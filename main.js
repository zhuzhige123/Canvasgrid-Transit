/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/managers/AnkiConnectManager.ts
var AnkiConnectManager_exports = {};
__export(AnkiConnectManager_exports, {
  AnkiConnectManager: () => AnkiConnectManager
});
var AnkiConnectManager;
var init_AnkiConnectManager = __esm({
  "src/managers/AnkiConnectManager.ts"() {
    "use strict";
    AnkiConnectManager = class {
      constructor(app, config) {
        this.app = app;
        this.config = config;
      }
      /**
       * 测试与Anki Connect的连接
       */
      async testConnection() {
        try {
          console.log(`AnkiConnect: \u6D4B\u8BD5\u8FDE\u63A5\u5230 ${this.config.apiUrl}`);
          const response = await this.invoke("version");
          console.log(`AnkiConnect: \u8FDE\u63A5\u6210\u529F\uFF0C\u7248\u672C:`, response);
          return response !== null;
        } catch (error) {
          console.error("Anki Connect\u8FDE\u63A5\u6D4B\u8BD5\u5931\u8D25:", error);
          if (error instanceof Error) {
            if (error.message.includes("fetch")) {
              console.error("AnkiConnect: \u7F51\u7EDC\u8FDE\u63A5\u5931\u8D25\uFF0C\u8BF7\u68C0\u67E5Anki\u662F\u5426\u8FD0\u884C");
            } else if (error.message.includes("timeout")) {
              console.error("AnkiConnect: \u8FDE\u63A5\u8D85\u65F6\uFF0C\u8BF7\u68C0\u67E5\u7F51\u7EDC\u6216\u589E\u52A0\u8D85\u65F6\u65F6\u95F4");
            }
          }
          return false;
        }
      }
      /**
       * 获取所有牌组名称
       */
      async getDeckNames() {
        try {
          const result = await this.invoke("deckNames");
          return result || [];
        } catch (error) {
          console.error("\u83B7\u53D6\u724C\u7EC4\u5217\u8868\u5931\u8D25:", error);
          return [];
        }
      }
      /**
       * 获取所有模板名称
       */
      async getModelNames() {
        try {
          const result = await this.invoke("modelNames");
          return result || [];
        } catch (error) {
          console.error("\u83B7\u53D6\u6A21\u677F\u5217\u8868\u5931\u8D25:", error);
          return [];
        }
      }
      /**
       * 获取指定模板的字段名称
       */
      async getModelFields(modelName) {
        try {
          const result = await this.invoke("modelFieldNames", { modelName });
          return result || [];
        } catch (error) {
          console.error("\u83B7\u53D6\u6A21\u677F\u5B57\u6BB5\u5931\u8D25:", error);
          return [];
        }
      }
      /**
       * 检查牌组是否存在
       */
      async deckExists(deckName) {
        try {
          const deckNames = await this.getDeckNames();
          return deckNames.includes(deckName);
        } catch (error) {
          console.error("\u68C0\u67E5\u724C\u7EC4\u5B58\u5728\u6027\u5931\u8D25:", error);
          return false;
        }
      }
      /**
       * 创建牌组
       */
      async createDeck(deckName) {
        try {
          console.log(`AnkiConnect: \u521B\u5EFA\u724C\u7EC4 "${deckName}"`);
          const result = await this.invoke("createDeck", { deck: deckName });
          console.log(`AnkiConnect: \u724C\u7EC4\u521B\u5EFA\u7ED3\u679C:`, result);
          return result !== null;
        } catch (error) {
          console.error(`AnkiConnect: \u521B\u5EFA\u724C\u7EC4 "${deckName}" \u5931\u8D25:`, error);
          return false;
        }
      }
      /**
       * 确保牌组存在，如果不存在则创建
       */
      async ensureDeckExists(deckName) {
        try {
          const exists = await this.deckExists(deckName);
          if (exists) {
            console.log(`AnkiConnect: \u724C\u7EC4 "${deckName}" \u5DF2\u5B58\u5728`);
            return true;
          }
          console.log(`AnkiConnect: \u724C\u7EC4 "${deckName}" \u4E0D\u5B58\u5728\uFF0C\u5C1D\u8BD5\u521B\u5EFA`);
          const created = await this.createDeck(deckName);
          if (created) {
            console.log(`AnkiConnect: \u6210\u529F\u521B\u5EFA\u724C\u7EC4 "${deckName}"`);
            return true;
          } else {
            console.error(`AnkiConnect: \u521B\u5EFA\u724C\u7EC4 "${deckName}" \u5931\u8D25`);
            return false;
          }
        } catch (error) {
          console.error(`AnkiConnect: \u786E\u4FDD\u724C\u7EC4\u5B58\u5728\u65F6\u51FA\u9519:`, error);
          return false;
        }
      }
      /**
       * 添加单个卡片
       */
      async addNote(note) {
        try {
          console.log("AnkiConnect: \u51C6\u5907\u6DFB\u52A0\u5361\u7247:", {
            deck: note.deckName,
            model: note.modelName,
            fields: Object.keys(note.fields),
            tags: note.tags
          });
          const result = await this.invoke("addNote", { note });
          if (result) {
            console.log(`AnkiConnect: \u6210\u529F\u6DFB\u52A0\u5361\u7247\uFF0CID: ${result}`);
          } else {
            console.warn("AnkiConnect: \u6DFB\u52A0\u5361\u7247\u8FD4\u56DE\u7A7A\u7ED3\u679C");
          }
          return result;
        } catch (error) {
          console.error("AnkiConnect: \u6DFB\u52A0\u5361\u7247\u5931\u8D25:", error);
          console.error("AnkiConnect: \u5931\u8D25\u7684\u5361\u7247\u6570\u636E:", note);
          return null;
        }
      }
      /**
       * 批量添加卡片
       */
      async addNotes(notes) {
        try {
          const result = await this.invoke("addNotes", { notes });
          return result || [];
        } catch (error) {
          console.error("\u6279\u91CF\u6DFB\u52A0\u5361\u7247\u5931\u8D25:", error);
          return [];
        }
      }
      /**
       * 查找卡片
       */
      async findNotes(query) {
        try {
          const result = await this.invoke("findNotes", { query });
          return result || [];
        } catch (error) {
          console.error("\u67E5\u627E\u5361\u7247\u5931\u8D25:", error);
          return [];
        }
      }
      /**
       * 检查模型是否存在
       */
      async modelExists(modelName) {
        try {
          const modelNames = await this.getModelNames();
          return modelNames.includes(modelName);
        } catch (error) {
          console.error("\u68C0\u67E5\u6A21\u578B\u5B58\u5728\u6027\u5931\u8D25:", error);
          return false;
        }
      }
      /**
       * 获取模型详细信息
       */
      async getModelInfo(modelName) {
        try {
          const result = await this.invoke("modelNamesAndIds");
          const modelData = result ? Object.entries(result).find(([name2]) => name2 === modelName) : null;
          if (!modelData) {
            return null;
          }
          const [name, id] = modelData;
          const fields = await this.getModelFields(modelName);
          const templates = await this.invoke("modelTemplates", { modelName });
          const styling = await this.invoke("modelStyling", { modelName });
          return {
            name,
            id,
            fields,
            templates: templates || {},
            css: styling?.css || ""
          };
        } catch (error) {
          console.error("\u83B7\u53D6\u6A21\u578B\u4FE1\u606F\u5931\u8D25:", error);
          return null;
        }
      }
      /**
       * 创建新的Anki模型
       */
      async createModel(modelName, inOrderFields, css, cardTemplates) {
        try {
          console.log(`AnkiConnect: \u521B\u5EFA\u6A21\u578B "${modelName}"`);
          console.log("AnkiConnect: \u5B57\u6BB5\u5217\u8868:", inOrderFields);
          console.log("AnkiConnect: \u5361\u7247\u6A21\u677F\u6570\u91CF:", cardTemplates.length);
          const result = await this.invoke("createModel", {
            modelName,
            inOrderFields,
            css,
            cardTemplates
          });
          if (result) {
            console.log(`AnkiConnect: \u6210\u529F\u521B\u5EFA\u6A21\u578B "${modelName}"`);
            return true;
          } else {
            console.error(`AnkiConnect: \u521B\u5EFA\u6A21\u578B "${modelName}" \u8FD4\u56DE\u7A7A\u7ED3\u679C`);
            return false;
          }
        } catch (error) {
          console.error(`AnkiConnect: \u521B\u5EFA\u6A21\u578B "${modelName}" \u5931\u8D25:`, error);
          return false;
        }
      }
      /**
       * 更新模型字段
       */
      async updateModelFields(modelName, targetFields) {
        try {
          console.log(`AnkiConnect: \u66F4\u65B0\u6A21\u578B "${modelName}" \u5B57\u6BB5`);
          const currentFields = await this.getModelFields(modelName);
          console.log("AnkiConnect: \u5F53\u524D\u5B57\u6BB5:", currentFields);
          console.log("AnkiConnect: \u76EE\u6807\u5B57\u6BB5:", targetFields);
          for (const field of targetFields) {
            if (!currentFields.includes(field)) {
              console.log(`AnkiConnect: \u6DFB\u52A0\u5B57\u6BB5 "${field}"`);
              const addResult = await this.invoke("modelFieldAdd", {
                modelName,
                fieldName: field,
                index: currentFields.length
              });
              if (!addResult) {
                console.error(`AnkiConnect: \u6DFB\u52A0\u5B57\u6BB5 "${field}" \u5931\u8D25`);
                return false;
              }
            }
          }
          const fieldsToRemove = currentFields.filter((field) => !targetFields.includes(field));
          for (const field of fieldsToRemove.reverse()) {
            console.log(`AnkiConnect: \u79FB\u9664\u5B57\u6BB5 "${field}"`);
            const removeResult = await this.invoke("modelFieldRemove", {
              modelName,
              fieldName: field
            });
            if (!removeResult) {
              console.error(`AnkiConnect: \u79FB\u9664\u5B57\u6BB5 "${field}" \u5931\u8D25`);
              return false;
            }
          }
          console.log(`AnkiConnect: \u6A21\u578B "${modelName}" \u5B57\u6BB5\u66F4\u65B0\u5B8C\u6210`);
          return true;
        } catch (error) {
          console.error(`AnkiConnect: \u66F4\u65B0\u6A21\u578B\u5B57\u6BB5\u5931\u8D25:`, error);
          return false;
        }
      }
      /**
       * 更新模型模板
       */
      async updateModelTemplates(modelName, templates) {
        try {
          console.log(`AnkiConnect: \u66F4\u65B0\u6A21\u578B "${modelName}" \u6A21\u677F`);
          const result = await this.invoke("updateModelTemplates", {
            model: {
              name: modelName,
              templates
            }
          });
          if (result) {
            console.log(`AnkiConnect: \u6210\u529F\u66F4\u65B0\u6A21\u578B "${modelName}" \u6A21\u677F`);
            return true;
          } else {
            console.error(`AnkiConnect: \u66F4\u65B0\u6A21\u578B\u6A21\u677F\u8FD4\u56DE\u7A7A\u7ED3\u679C`);
            return false;
          }
        } catch (error) {
          console.error(`AnkiConnect: \u66F4\u65B0\u6A21\u578B\u6A21\u677F\u5931\u8D25:`, error);
          return false;
        }
      }
      /**
       * 更新模型样式
       */
      async updateModelStyling(modelName, css) {
        try {
          console.log(`AnkiConnect: \u66F4\u65B0\u6A21\u578B "${modelName}" \u6837\u5F0F`);
          const result = await this.invoke("updateModelStyling", {
            model: {
              name: modelName,
              css
            }
          });
          if (result) {
            console.log(`AnkiConnect: \u6210\u529F\u66F4\u65B0\u6A21\u578B "${modelName}" \u6837\u5F0F`);
            return true;
          } else {
            console.error(`AnkiConnect: \u66F4\u65B0\u6A21\u578B\u6837\u5F0F\u8FD4\u56DE\u7A7A\u7ED3\u679C`);
            return false;
          }
        } catch (error) {
          console.error(`AnkiConnect: \u66F4\u65B0\u6A21\u578B\u6837\u5F0F\u5931\u8D25:`, error);
          return false;
        }
      }
      /**
       * 核心API调用方法
       */
      async invoke(action, params = {}) {
        const requestBody = {
          action,
          version: 6,
          params,
          ...this.config.apiKey && { key: this.config.apiKey }
        };
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);
        try {
          const response = await fetch(this.config.apiUrl, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify(requestBody),
            signal: controller.signal
          });
          clearTimeout(timeoutId);
          if (!response.ok) {
            throw new Error(`HTTP\u9519\u8BEF: ${response.status}`);
          }
          const data = await response.json();
          if (data.error) {
            throw new Error(data.error);
          }
          return data.result;
        } catch (error) {
          clearTimeout(timeoutId);
          if (error instanceof Error) {
            throw error;
          }
          throw new Error("\u672A\u77E5\u9519\u8BEF");
        }
      }
      /**
       * 更新配置
       */
      updateConfig(config) {
        this.config = config;
      }
      /**
       * 检查卡片是否存在
       */
      async noteExists(noteId) {
        try {
          const response = await this.invoke("notesInfo", {
            notes: [noteId]
          });
          if (response && Array.isArray(response)) {
            return response.length > 0 && response[0] !== null;
          }
          return false;
        } catch (error) {
          console.error("AnkiConnect: \u68C0\u67E5\u5361\u7247\u5B58\u5728\u6027\u5931\u8D25:", error);
          return false;
        }
      }
      /**
       * 更新现有卡片
       */
      async updateNote(noteId, ankiNote) {
        try {
          const updateData = {
            id: noteId,
            fields: ankiNote.fields,
            tags: ankiNote.tags
          };
          if (ankiNote.deckName) {
            updateData.deckName = ankiNote.deckName;
          }
          const response = await this.invoke("updateNoteFields", updateData);
          if (response !== null) {
            console.log(`AnkiConnect: \u6210\u529F\u66F4\u65B0\u5361\u7247 ${noteId}`);
            if (ankiNote.tags && ankiNote.tags.length > 0) {
              await this.updateNoteTags(noteId, ankiNote.tags);
            }
            return true;
          } else {
            console.error("AnkiConnect: \u66F4\u65B0\u5361\u7247\u5931\u8D25");
            return false;
          }
        } catch (error) {
          console.error("AnkiConnect: \u66F4\u65B0\u5361\u7247\u5F02\u5E38:", error);
          return false;
        }
      }
      /**
       * 更新卡片标签
       */
      async updateNoteTags(noteId, tags) {
        try {
          await this.invoke("removeTags", {
            notes: [noteId],
            tags: " "
            // 清除所有标签
          });
          if (tags.length > 0) {
            await this.invoke("addTags", {
              notes: [noteId],
              tags: tags.join(" ")
            });
          }
          return true;
        } catch (error) {
          console.error("AnkiConnect: \u66F4\u65B0\u6807\u7B7E\u5931\u8D25:", error);
          return false;
        }
      }
    };
  }
});

// src/types/LinkTypes.ts
var PREDEFINED_LINK_STYLES, LINK_ICONS;
var init_LinkTypes = __esm({
  "src/types/LinkTypes.ts"() {
    "use strict";
    PREDEFINED_LINK_STYLES = {
      simple: {
        name: "\u7B80\u5355\u6837\u5F0F",
        template: '<a href="{url}" style="color: #0066cc; text-decoration: none;">{text}</a>'
      },
      enhanced: {
        name: "\u589E\u5F3A\u6837\u5F0F",
        template: `<div style="margin-top: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px; border-left: 3px solid #6f42c1;">
            <a href="{url}" style="color: #6f42c1; text-decoration: none; font-weight: 500;">{icon} {text}</a>
            <div style="font-size: 10px; color: #6c757d; margin-top: 2px;">{metadata}</div>
        </div>`
      },
      minimal: {
        name: "\u6781\u7B80\u6837\u5F0F",
        template: '<a href="{url}" style="color: inherit; text-decoration: underline;">{text}</a>'
      },
      detailed: {
        name: "\u8BE6\u7EC6\u6837\u5F0F",
        template: `<div style="margin: 12px 0; padding: 12px; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 8px; border: 1px solid #dee2e6;">
            <div style="display: flex; align-items: center; margin-bottom: 6px;">
                <span style="font-size: 16px; margin-right: 8px;">{icon}</span>
                <a href="{url}" style="color: #495057; text-decoration: none; font-weight: 600; flex: 1;">{text}</a>
            </div>
            <div style="font-size: 11px; color: #6c757d; line-height: 1.4;">
                {metadata}
            </div>
        </div>`
      }
    };
    LINK_ICONS = {
      canvas: "\u{1F3A8}",
      node: "\u{1F3AF}",
      file: "\u{1F4C4}",
      grid: "\u{1F532}",
      settings: "\u2699\uFE0F",
      external: "\u{1F517}",
      location: "\u{1F4CD}",
      time: "\u23F0"
    };
  }
});

// src/managers/ObsidianLinkManager.ts
var ObsidianLinkManager;
var init_ObsidianLinkManager = __esm({
  "src/managers/ObsidianLinkManager.ts"() {
    "use strict";
    init_LinkTypes();
    ObsidianLinkManager = class {
      constructor(app) {
        this.linkTemplates = /* @__PURE__ */ new Map();
        this.app = app;
        this.initializeLinkTemplates();
      }
      /**
       * 生成HTML格式的Obsidian链接
       */
      generateHtmlLink(canvasFile, node, options) {
        const defaultOptions = {
          style: "enhanced",
          includeMetadata: true,
          multiLevel: false,
          includeCoordinates: true,
          includeTimestamp: false,
          target: "_blank",
          cssClass: "obsidian-link"
        };
        const finalOptions = { ...defaultOptions, ...options };
        try {
          const context = this.createLinkContext(canvasFile, node);
          if (finalOptions.multiLevel) {
            return this.generateMultiLevelLinks(context, finalOptions);
          } else {
            return this.generateSingleLink(context, finalOptions);
          }
        } catch (error) {
          console.error("ObsidianLink: \u751F\u6210\u94FE\u63A5\u65F6\u53D1\u751F\u9519\u8BEF:", error);
          return this.generateFallbackLink(canvasFile, node);
        }
      }
      /**
       * 生成多层次链接
       */
      generateMultiLevelLinks(context, options) {
        const links = [];
        const nodeLink = this.generateNodeLink(context, options);
        links.push(nodeLink);
        const fileLink = this.generateFileLink(context, options);
        links.push(fileLink);
        const gridLink = this.generateGridViewLink(context, options);
        links.push(gridLink);
        return this.wrapMultiLevelLinks(links, options);
      }
      /**
       * 生成单个链接
       */
      generateSingleLink(context, options) {
        const url = this.buildObsidianUrl(context, "node");
        const text = this.generateLinkText(context, options);
        const metadata = options.includeMetadata ? this.generateMetadata(context, options) : "";
        return this.applyLinkTemplate(url, text, metadata, options);
      }
      /**
       * 生成节点链接
       */
      generateNodeLink(context, options) {
        const url = this.buildObsidianUrl(context, "node");
        const text = `${LINK_ICONS.node} \u5728Obsidian\u4E2D\u67E5\u770B`;
        const metadata = `\u8282\u70B9ID: ${context.nodeId.substring(0, 8)}... (\u5750\u6807: ${context.nodeCoordinates.x}, ${context.nodeCoordinates.y})`;
        return this.applyLinkTemplate(url, text, metadata, options);
      }
      /**
       * 生成文件链接
       */
      generateFileLink(context, options) {
        const url = this.buildObsidianUrl(context, "file");
        const text = `${LINK_ICONS.canvas} \u6253\u5F00Canvas\u6587\u4EF6`;
        const metadata = `\u6587\u4EF6: ${context.canvasFilePath}`;
        return this.applyLinkTemplate(url, text, metadata, options);
      }
      /**
       * 生成网格视图链接
       */
      generateGridViewLink(context, options) {
        const url = this.buildObsidianUrl(context, "grid");
        const text = `${LINK_ICONS.grid} \u7F51\u683C\u89C6\u56FE`;
        const metadata = `\u5750\u6807: (${context.nodeCoordinates.x}, ${context.nodeCoordinates.y})`;
        return this.applyLinkTemplate(url, text, metadata, options);
      }
      /**
       * 构建Obsidian URL
       */
      buildObsidianUrl(context, type) {
        const encodedVault = encodeURIComponent(context.vaultName);
        const encodedPath = encodeURIComponent(context.canvasFilePath);
        let baseUrl = `obsidian://open?vault=${encodedVault}&file=${encodedPath}`;
        switch (type) {
          case "node":
            baseUrl += `#node-${encodeURIComponent(context.nodeId)}`;
            break;
          case "file":
            break;
          case "grid":
            baseUrl += `#grid-view`;
            break;
        }
        return baseUrl;
      }
      /**
       * 生成链接文本
       */
      generateLinkText(context, options) {
        if (options.customText) {
          return options.customText;
        }
        const nodeTypeText = this.getNodeTypeText(context.nodeType);
        const colorText = context.nodeColor ? this.getColorName(context.nodeColor) : "";
        const locationText = options.includeCoordinates ? ` (${context.nodeCoordinates.x}, ${context.nodeCoordinates.y})` : "";
        return `${LINK_ICONS.location} \u5728Obsidian\u4E2D\u67E5\u770B${nodeTypeText}${colorText}${locationText} (\u624B\u52A8\u5B9A\u4F4D\u5230\u8282\u70B9)`;
      }
      /**
       * 生成元数据
       */
      generateMetadata(context, options) {
        const metadata = [];
        metadata.push(`\u6587\u4EF6: ${context.canvasFilePath}`);
        metadata.push(`\u8282\u70B9: ${context.nodeId.substring(0, 12)}...`);
        if (options.includeCoordinates) {
          metadata.push(`\u5750\u6807: (${context.nodeCoordinates.x}, ${context.nodeCoordinates.y})`);
        }
        if (options.includeTimestamp) {
          const timestamp = new Date(context.timestamp).toLocaleString();
          metadata.push(`\u751F\u6210\u65F6\u95F4: ${timestamp}`);
        }
        if (context.pluginVersion) {
          metadata.push(`\u63D2\u4EF6\u7248\u672C: ${context.pluginVersion}`);
        }
        return metadata.join(" | ");
      }
      /**
       * 应用链接模板
       */
      applyLinkTemplate(url, text, metadata, options) {
        const style = PREDEFINED_LINK_STYLES[options.style];
        if (!style) {
          return this.generateSimpleLink(url, text, options);
        }
        let template = style.template;
        let processedTemplate = template.replace(/{url}/g, url);
        processedTemplate = processedTemplate.replace(/{text}/g, text);
        processedTemplate = processedTemplate.replace(/{metadata}/g, metadata);
        processedTemplate = processedTemplate.replace(/{icon}/g, LINK_ICONS.location);
        if (options.target) {
          processedTemplate = processedTemplate.replace(/<a /g, `<a target="${options.target}" `);
        }
        if (options.cssClass) {
          processedTemplate = processedTemplate.replace(/<a /g, `<a class="${options.cssClass}" `);
        }
        if (options.customStyle) {
          processedTemplate = processedTemplate.replace(/style="([^"]*)"/, `style="$1; ${options.customStyle}"`);
        }
        return processedTemplate;
      }
      /**
       * 生成简单链接
       */
      generateSimpleLink(url, text, options) {
        const attributes = [`href="${url}"`];
        if (options.target) {
          attributes.push(`target="${options.target}"`);
        }
        if (options.cssClass) {
          attributes.push(`class="${options.cssClass}"`);
        }
        const style = "color: #0066cc; text-decoration: none;";
        attributes.push(`style="${style}${options.customStyle ? "; " + options.customStyle : ""}"`);
        return `<a ${attributes.join(" ")}>${text}</a>`;
      }
      /**
       * 包装多层次链接
       */
      wrapMultiLevelLinks(links, options) {
        const containerStyle = `
            margin: 10px 0;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 4px solid #6f42c1;
        `;
        const linksHtml = links.join('<br style="margin: 4px 0;">');
        return `<div style="${containerStyle}">${linksHtml}</div>`;
      }
      /**
       * 创建链接上下文
       */
      createLinkContext(canvasFile, node) {
        const vaultName = this.getVaultName();
        return {
          vaultName,
          canvasFilePath: canvasFile.path,
          nodeId: node.id,
          nodeCoordinates: {
            x: node.x,
            y: node.y
          },
          nodeType: node.type,
          nodeColor: node.color,
          timestamp: Date.now(),
          pluginVersion: this.getPluginVersion()
        };
      }
      /**
       * 获取Vault名称
       */
      getVaultName() {
        try {
          const adapterName = this.app.vault.adapter?.name;
          if (adapterName && adapterName !== "vault") {
            console.log(`ObsidianLink: \u4ECEadapter\u83B7\u53D6vault\u540D\u79F0: ${adapterName}`);
            return adapterName;
          }
          const vaultConfig = this.app.vault.config;
          if (vaultConfig?.name) {
            console.log(`ObsidianLink: \u4ECEconfig\u83B7\u53D6vault\u540D\u79F0: ${vaultConfig.name}`);
            return vaultConfig.name;
          }
          const appVault = this.app.vault;
          if (appVault?.name) {
            console.log(`ObsidianLink: \u4ECEapp.vault\u83B7\u53D6vault\u540D\u79F0: ${appVault.name}`);
            return appVault.name;
          }
          const basePath = this.app.vault.adapter?.basePath;
          if (basePath) {
            const vaultName = basePath.split(/[/\\]/).pop();
            if (vaultName && vaultName !== ".") {
              console.log(`ObsidianLink: \u4ECE\u8DEF\u5F84\u63A8\u65ADvault\u540D\u79F0: ${vaultName}`);
              return vaultName;
            }
          }
          console.warn("ObsidianLink: \u65E0\u6CD5\u83B7\u53D6vault\u540D\u79F0\uFF0C\u4F7F\u7528\u9ED8\u8BA4\u503C");
          return "vault";
        } catch (error) {
          console.error("ObsidianLink: \u83B7\u53D6vault\u540D\u79F0\u65F6\u53D1\u751F\u9519\u8BEF:", error);
          return "vault";
        }
      }
      /**
       * 获取插件版本
       */
      getPluginVersion() {
        return "1.3.0";
      }
      /**
       * 获取节点类型文本
       */
      getNodeTypeText(nodeType) {
        const typeMap = {
          "text": "\u6587\u672C\u5361\u7247",
          "file": "\u6587\u4EF6\u5361\u7247",
          "link": "\u94FE\u63A5\u5361\u7247",
          "group": "\u5206\u7EC4"
        };
        return typeMap[nodeType] || "\u5361\u7247";
      }
      /**
       * 获取颜色名称
       */
      getColorName(color) {
        const colorMap = {
          "1": "\u7EA2\u8272",
          "2": "\u6A59\u8272",
          "3": "\u9EC4\u8272",
          "4": "\u7EFF\u8272",
          "5": "\u9752\u8272",
          "6": "\u84DD\u8272"
        };
        return colorMap[color] ? ` (${colorMap[color]})` : "";
      }
      /**
       * 生成后备链接
       */
      generateFallbackLink(canvasFile, node) {
        const vaultName = this.getVaultName();
        const encodedVault = encodeURIComponent(vaultName);
        const encodedPath = encodeURIComponent(canvasFile.path);
        const url = `obsidian://open?vault=${encodedVault}&file=${encodedPath}`;
        return `<a href="${url}" target="_blank" style="color: #0066cc; text-decoration: none;">${LINK_ICONS.location} \u5728Obsidian\u4E2D\u67E5\u770B</a>`;
      }
      /**
       * 初始化链接模板
       */
      initializeLinkTemplates() {
        for (const [key, style] of Object.entries(PREDEFINED_LINK_STYLES)) {
          const template = {
            name: style.name,
            description: `${style.name}\u94FE\u63A5\u6A21\u677F`,
            htmlTemplate: style.template,
            supportedVariables: ["url", "text", "metadata", "icon"],
            defaultStyle: "",
            builtin: true
          };
          this.linkTemplates.set(key, template);
        }
      }
      /**
       * 验证链接有效性
       */
      async validateLink(link) {
        try {
          const url = new URL(link);
          return {
            valid: true,
            protocol: url.protocol,
            accessible: true,
            // 简化实现，实际应该检查Obsidian是否安装
            warnings: []
          };
        } catch (error) {
          return {
            valid: false,
            protocol: "",
            accessible: false,
            error: `\u65E0\u6548\u7684\u94FE\u63A5\u683C\u5F0F: ${error instanceof Error ? error.message : String(error)}`,
            warnings: []
          };
        }
      }
      /**
       * 生成跨平台兼容链接
       */
      generateCrossPlatformLink(canvasFile, node) {
        return this.generateHtmlLink(canvasFile, node, {
          style: "enhanced",
          includeMetadata: true,
          multiLevel: false,
          includeCoordinates: true,
          includeTimestamp: false
        });
      }
      /**
       * 生成智能链接文本
       */
      generateSmartLinkText(node, canvasFile) {
        const nodeType = this.getNodeTypeText(node.type);
        const fileName = canvasFile.basename;
        const colorText = node.color ? this.getColorName(node.color) : "";
        return `${LINK_ICONS.location} \u67E5\u770B${fileName}\u4E2D\u7684${nodeType}${colorText}`;
      }
    };
  }
});

// src/managers/AnkiModelManager.ts
var PLUGIN_MODEL_DEFINITION, AnkiModelManager;
var init_AnkiModelManager = __esm({
  "src/managers/AnkiModelManager.ts"() {
    "use strict";
    PLUGIN_MODEL_DEFINITION = {
      name: "Canvasgrid_Transit_Basic",
      fields: ["Front", "Back", "NodeId", "Source", "Color"],
      templates: [{
        Name: "Card 1",
        Front: "{{Front}}",
        Back: `{{FrontSide}}

<hr id="answer">

{{Back}}

<div class="source-info">
	<small>{{Source}}</small>
</div>`
      }],
      css: `
.card {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
	font-size: 16px;
	line-height: 1.6;
	color: var(--text-normal);
	background: var(--background-primary);
	padding: 20px;
	white-space: pre-wrap;
	word-break: break-word;
}

.card p {
	margin: 0.8em 0;
}

.card ul, .card ol {
	margin: 0.5em 0;
	padding-left: 1.5em;
}

.card li {
	margin: 0.3em 0;
}

.source-info {
	margin-top: 20px;
	padding-top: 10px;
	border-top: 1px solid var(--background-modifier-border);
	font-size: 12px;
	color: var(--text-muted);
}

.obsidian-link {
	color: var(--text-accent);
	text-decoration: none;
	font-weight: 500;
}

.obsidian-link:hover {
	text-decoration: underline;
}

/* \u9002\u914D\u6DF1\u8272\u6A21\u5F0F */
.night_mode .card {
	background: #1e1e1e;
	color: #e0e0e0;
}

.night_mode .source-info {
	border-top-color: #404040;
	color: #a0a0a0;
}

.night_mode .obsidian-link {
	color: #7c3aed;
}
`
    };
    AnkiModelManager = class {
      constructor(app, ankiConnectManager, config) {
        this.app = app;
        this.ankiConnectManager = ankiConnectManager;
        this.config = config;
      }
      /**
       * 确保插件模型存在且字段正确
       */
      async ensurePluginModelExists() {
        try {
          console.log("AnkiModel: \u5F00\u59CB\u68C0\u67E5\u63D2\u4EF6\u4E13\u5C5E\u6A21\u578B");
          const validation = await this.validatePluginModel();
          console.log("AnkiModel: \u6A21\u578B\u9A8C\u8BC1\u7ED3\u679C:", validation);
          if (!validation.exists) {
            console.log("AnkiModel: \u6A21\u578B\u4E0D\u5B58\u5728\uFF0C\u5F00\u59CB\u521B\u5EFA");
            return await this.createPluginModel();
          }
          if (validation.needsUpdate) {
            console.log("AnkiModel: \u6A21\u578B\u9700\u8981\u66F4\u65B0\uFF0C\u5F00\u59CB\u8986\u76D6");
            return await this.updatePluginModel();
          }
          console.log("AnkiModel: \u6A21\u578B\u5DF2\u5B58\u5728\u4E14\u5B57\u6BB5\u6B63\u786E");
          return true;
        } catch (error) {
          console.error("AnkiModel: \u786E\u4FDD\u6A21\u578B\u5B58\u5728\u65F6\u51FA\u9519:", error);
          return false;
        }
      }
      /**
       * 验证插件模型状态
       */
      async validatePluginModel() {
        const modelName = PLUGIN_MODEL_DEFINITION.name;
        const targetFields = PLUGIN_MODEL_DEFINITION.fields;
        try {
          const exists = await this.ankiConnectManager.modelExists(modelName);
          if (!exists) {
            return {
              exists: false,
              fieldsMatch: false,
              needsUpdate: false,
              missingFields: targetFields,
              extraFields: [],
              currentFields: []
            };
          }
          const currentFields = await this.ankiConnectManager.getModelFields(modelName);
          const missingFields = targetFields.filter((field) => !currentFields.includes(field));
          const extraFields = currentFields.filter((field) => !targetFields.includes(field));
          const fieldsMatch = missingFields.length === 0 && extraFields.length === 0;
          return {
            exists: true,
            fieldsMatch,
            needsUpdate: !fieldsMatch,
            missingFields,
            extraFields,
            currentFields
          };
        } catch (error) {
          console.error("AnkiModel: \u9A8C\u8BC1\u6A21\u578B\u65F6\u51FA\u9519:", error);
          throw error;
        }
      }
      /**
       * 创建插件专属模型
       */
      async createPluginModel() {
        const { name, fields, templates, css } = PLUGIN_MODEL_DEFINITION;
        try {
          console.log(`AnkiModel: \u521B\u5EFA\u6A21\u578B "${name}"`);
          console.log("AnkiModel: \u5B57\u6BB5:", fields);
          console.log("AnkiModel: \u6A21\u677F\u6570\u91CF:", templates.length);
          const success = await this.ankiConnectManager.createModel(name, fields, css, templates);
          if (success) {
            console.log(`AnkiModel: \u6210\u529F\u521B\u5EFA\u6A21\u578B "${name}"`);
            return true;
          } else {
            console.error(`AnkiModel: \u521B\u5EFA\u6A21\u578B "${name}" \u5931\u8D25`);
            return false;
          }
        } catch (error) {
          console.error("AnkiModel: \u521B\u5EFA\u6A21\u578B\u65F6\u51FA\u9519:", error);
          return false;
        }
      }
      /**
       * 更新插件模型（覆盖策略）
       */
      async updatePluginModel() {
        const { name, fields, templates, css } = PLUGIN_MODEL_DEFINITION;
        try {
          console.log(`AnkiModel: \u66F4\u65B0\u6A21\u578B "${name}"`);
          const fieldsUpdated = await this.ankiConnectManager.updateModelFields(name, fields);
          if (!fieldsUpdated) {
            console.error("AnkiModel: \u66F4\u65B0\u5B57\u6BB5\u5931\u8D25");
            return false;
          }
          const templatesUpdated = await this.ankiConnectManager.updateModelTemplates(name, templates);
          if (!templatesUpdated) {
            console.error("AnkiModel: \u66F4\u65B0\u6A21\u677F\u5931\u8D25");
            return false;
          }
          const stylingUpdated = await this.ankiConnectManager.updateModelStyling(name, css);
          if (!stylingUpdated) {
            console.error("AnkiModel: \u66F4\u65B0\u6837\u5F0F\u5931\u8D25");
            return false;
          }
          console.log(`AnkiModel: \u6210\u529F\u66F4\u65B0\u6A21\u578B "${name}"`);
          return true;
        } catch (error) {
          console.error("AnkiModel: \u66F4\u65B0\u6A21\u578B\u65F6\u51FA\u9519:", error);
          return false;
        }
      }
      /**
       * 获取插件模型名称
       */
      getPluginModelName() {
        return PLUGIN_MODEL_DEFINITION.name;
      }
      /**
       * 获取插件模型字段列表
       */
      getPluginModelFields() {
        return [...PLUGIN_MODEL_DEFINITION.fields];
      }
      /**
       * 检查字段是否为插件模型的必需字段
       */
      isRequiredField(fieldName) {
        return PLUGIN_MODEL_DEFINITION.fields.includes(fieldName);
      }
      /**
       * 更新配置
       */
      updateConfig(config) {
        this.config = config;
      }
    };
  }
});

// src/managers/AnkiFieldMapper.ts
var AnkiFieldMapper;
var init_AnkiFieldMapper = __esm({
  "src/managers/AnkiFieldMapper.ts"() {
    "use strict";
    init_ObsidianLinkManager();
    init_AnkiModelManager();
    AnkiFieldMapper = class {
      constructor(app, config, mediaSyncConfig) {
        this.fieldMappings = [];
        this.mediaSyncManager = null;
        this.app = app;
        this.config = config;
        this.obsidianLinkManager = new ObsidianLinkManager(app);
        if (mediaSyncConfig && mediaSyncConfig.enabled) {
          this.mediaSyncManager = null;
        }
        this.initializeDefaultFieldMappings();
      }
      /**
       * 将Canvas节点转换为Anki卡片
       */
      mapNodeToAnkiNote(node, canvasFile, contentDivider = "---div---") {
        const warnings = [];
        try {
          if (node.type === "group") {
            return {
              success: false,
              error: "\u5206\u7EC4\u8282\u70B9\u4E0D\u652F\u6301\u540C\u6B65",
              warnings: []
            };
          }
          const validationResult = this.validateNode(node);
          if (!validationResult.valid) {
            return {
              success: false,
              error: `\u8282\u70B9\u9A8C\u8BC1\u5931\u8D25: ${validationResult.errors.join(", ")}`,
              warnings: validationResult.warnings
            };
          }
          const textContent = this.extractTextContent(node);
          if (!textContent) {
            return {
              success: false,
              error: "\u65E0\u6CD5\u63D0\u53D6\u8282\u70B9\u6587\u672C\u5185\u5BB9",
              warnings
            };
          }
          const fields = this.generatePluginModelFields(node, textContent, canvasFile, contentDivider);
          const tags = this.generateTags(node);
          const ankiNote = {
            deckName: this.config.defaultDeck,
            modelName: PLUGIN_MODEL_DEFINITION.name,
            fields,
            tags,
            options: {
              allowDuplicate: false,
              duplicateScope: "deck"
            }
          };
          console.log("AnkiFieldMapper: \u751F\u6210\u7684\u5361\u7247\u6570\u636E:", {
            modelName: ankiNote.modelName,
            deckName: ankiNote.deckName,
            fields: Object.entries(ankiNote.fields).map(([key, value]) => ({
              field: key,
              value: value.substring(0, 100) + (value.length > 100 ? "..." : ""),
              length: value.length
            })),
            tags: ankiNote.tags
          });
          return {
            success: true,
            ankiNote,
            warnings
          };
        } catch (error) {
          return {
            success: false,
            error: error instanceof Error ? error.message : "\u8F6C\u6362\u8FC7\u7A0B\u4E2D\u53D1\u751F\u672A\u77E5\u9519\u8BEF",
            warnings
          };
        }
      }
      /**
       * 提取节点文本内容
       */
      extractTextContent(node) {
        console.log(`AnkiFieldMapper: \u63D0\u53D6\u8282\u70B9\u5185\u5BB9 - ID: ${node.id}, \u7C7B\u578B: ${node.type}`);
        let content = "";
        switch (node.type) {
          case "text":
            content = node.text || "";
            console.log(`AnkiFieldMapper: \u6587\u672C\u8282\u70B9\u5185\u5BB9\u957F\u5EA6: ${content.length}`);
            break;
          case "file":
            content = node.file ? `\u6587\u4EF6: ${node.file}` : "";
            console.log(`AnkiFieldMapper: \u6587\u4EF6\u8282\u70B9\u8DEF\u5F84: ${node.file || "(\u7A7A)"}`);
            break;
          case "link":
            content = node.url || "";
            console.log(`AnkiFieldMapper: \u94FE\u63A5\u8282\u70B9URL: ${node.url || "(\u7A7A)"}`);
            break;
          case "group":
            content = node.label || "\u5206\u7EC4";
            console.log(`AnkiFieldMapper: \u5206\u7EC4\u8282\u70B9\u6807\u7B7E: ${node.label || "(\u7A7A)"}`);
            break;
          default:
            content = "";
            console.warn(`AnkiFieldMapper: \u672A\u77E5\u8282\u70B9\u7C7B\u578B: ${node.type}`);
        }
        console.log(`AnkiFieldMapper: \u6700\u7EC8\u63D0\u53D6\u5185\u5BB9: "${content.substring(0, 100)}${content.length > 100 ? "..." : ""}"`);
        return content.trim();
      }
      /**
       * 生成插件专属模型的字段映射
       */
      generatePluginModelFields(node, textContent, canvasFile, contentDivider = "---div---") {
        console.log(`AnkiFieldMapper: \u5F00\u59CB\u751F\u6210\u5B57\u6BB5\u6620\u5C04 - \u8282\u70B9: ${node.id}`);
        console.log(`AnkiFieldMapper: \u8F93\u5165\u6587\u672C\u5185\u5BB9: "${textContent}"`);
        console.log(`AnkiFieldMapper: \u4F7F\u7528\u5206\u9694\u7B26: "${contentDivider}"`);
        const fields = {};
        const parsedContent = this.parseContentWithDivider(textContent, contentDivider);
        console.log(`AnkiFieldMapper: \u89E3\u6790\u7ED3\u679C - \u6B63\u9762: "${parsedContent.front}", \u80CC\u9762: "${parsedContent.back}", \u6709\u80CC\u9762: ${parsedContent.hasBack}`);
        const obsidianHtmlLink = this.generateEnhancedObsidianLink(canvasFile, node);
        console.log(`AnkiFieldMapper: \u751F\u6210HTML\u94FE\u63A5: "${obsidianHtmlLink}"`);
        let frontContent = parsedContent.front;
        if (!frontContent || frontContent.trim() === "") {
          frontContent = this.generateFallbackFrontContent(node);
          console.log(`AnkiFieldMapper: \u4F7F\u7528\u515C\u5E95\u5185\u5BB9: "${frontContent}"`);
        }
        if (node.color) {
          const colorTag = this.formatColorTag(node.color);
          frontContent += ` ${colorTag}`;
          console.log(`AnkiFieldMapper: \u6DFB\u52A0\u989C\u8272\u6807\u7B7E: "${colorTag}"`);
        }
        if (obsidianHtmlLink) {
          frontContent += `

${obsidianHtmlLink}`;
        }
        fields["Front"] = this.formatContentForAnki(frontContent);
        fields["Back"] = parsedContent.hasBack ? this.formatContentForAnki(parsedContent.back) : "";
        fields["NodeId"] = node.id;
        fields["Source"] = canvasFile ? canvasFile.basename : "\u672A\u77E5\u6765\u6E90";
        fields["Color"] = node.color ? this.getColorName(node.color) : "";
        for (const [fieldName, fieldValue] of Object.entries(fields)) {
          if (fieldValue === void 0 || fieldValue === null) {
            console.warn(`AnkiFieldMapper: \u5B57\u6BB5 "${fieldName}" \u4E3A\u7A7A\uFF0C\u4F7F\u7528\u9ED8\u8BA4\u503C`);
            fields[fieldName] = "";
          }
        }
        if (!fields["Front"] || fields["Front"].trim() === "") {
          const emergencyContent = `${node.type}\u8282\u70B9 (${node.id})`;
          fields["Front"] = this.formatContentForAnki(emergencyContent);
          console.error(`AnkiFieldMapper: Front\u5B57\u6BB5\u4E3A\u7A7A\uFF0C\u4F7F\u7528\u7D27\u6025\u5185\u5BB9: "${emergencyContent}"`);
        }
        console.log(`AnkiFieldMapper: \u751F\u6210\u5B57\u6BB5\u6620\u5C04 ${node.id}:`, {
          Front: fields["Front"]?.substring(0, 100) + "...",
          Back: fields["Back"]?.substring(0, 50) + "...",
          NodeId: fields["NodeId"],
          Source: fields["Source"],
          Color: fields["Color"],
          HasObsidianLink: obsidianHtmlLink ? "\u662F" : "\u5426"
        });
        return fields;
      }
      /**
       * 生成兜底的Front内容（确保永不为空）
       */
      generateFallbackFrontContent(node) {
        switch (node.type) {
          case "text":
            return "\u7A7A\u6587\u672C\u8282\u70B9";
          case "file":
            return node.file ? `\u6587\u4EF6: ${node.file}` : "\u7A7A\u6587\u4EF6\u8282\u70B9";
          case "link":
            return node.url ? `\u94FE\u63A5: ${node.url}` : "\u7A7A\u94FE\u63A5\u8282\u70B9";
          case "group":
            return node.label ? `\u5206\u7EC4: ${node.label}` : "\u7A7A\u5206\u7EC4\u8282\u70B9";
          default:
            return `${node.type}\u8282\u70B9`;
        }
      }
      /**
       * 生成正面内容
       */
      generateFrontContent(node, textContent) {
        let frontContent = textContent;
        switch (node.type) {
          case "file":
            frontContent = `\u6587\u4EF6: ${textContent}`;
            break;
          case "link":
            frontContent = `\u94FE\u63A5: ${textContent}`;
            break;
          case "group":
            frontContent = `\u5206\u7EC4: ${textContent}`;
            break;
        }
        if (node.color) {
          const colorName = this.getColorName(node.color);
          frontContent += `

<small style="color: ${this.getColorValue(node.color)};">\u6807\u7B7E: ${colorName}</small>`;
        }
        return this.formatContentForAnki(frontContent);
      }
      /**
       * 生成背面内容
       */
      generateBackContent(node, textContent) {
        let backContent = "";
        switch (node.type) {
          case "text":
            backContent = this.extractKeyInformation(textContent);
            break;
          case "file":
            backContent = `\u6587\u4EF6\u8DEF\u5F84: ${node.file}

\u70B9\u51FB\u67E5\u770B\u6587\u4EF6\u5185\u5BB9`;
            break;
          case "link":
            backContent = `URL: ${node.url}

\u70B9\u51FB\u8BBF\u95EE\u94FE\u63A5`;
            break;
          case "group":
            backContent = `\u5206\u7EC4\u4FE1\u606F
\u4F4D\u7F6E: (${node.x}, ${node.y})
\u5927\u5C0F: ${node.width} \xD7 ${node.height}`;
            break;
        }
        const sourceInfo = this.generateSourceInfo(node);
        if (sourceInfo) {
          backContent += `

---
${sourceInfo}`;
        }
        const finalContent = backContent || textContent;
        return this.formatContentForAnki(finalContent);
      }
      /**
       * 生成填空题内容
       */
      generateClozeContent(node, textContent) {
        let clozeContent = textContent;
        const keywords = this.extractKeywords(textContent);
        keywords.forEach((keyword, index) => {
          const clozeNumber = index + 1;
          clozeContent = clozeContent.replace(
            new RegExp(`\\b${keyword}\\b`, "gi"),
            `{{c${clozeNumber}::${keyword}}}`
          );
        });
        return clozeContent;
      }
      /**
       * 生成额外内容
       */
      generateExtraContent(node) {
        const extras = [];
        extras.push(`\u7C7B\u578B: ${node.type}`);
        extras.push(`\u4F4D\u7F6E: (${node.x}, ${node.y})`);
        if (node.color) {
          extras.push(`\u989C\u8272: ${this.getColorName(node.color)}`);
        }
        extras.push(`\u521B\u5EFA\u65F6\u95F4: ${(/* @__PURE__ */ new Date()).toLocaleString()}`);
        return extras.join("\n");
      }
      /**
       * 生成元数据
       */
      generateMetadata(node) {
        const metadata = {
          nodeId: node.id,
          nodeType: node.type,
          position: { x: node.x, y: node.y },
          size: { width: node.width, height: node.height },
          color: node.color,
          createdAt: (/* @__PURE__ */ new Date()).toISOString()
        };
        return JSON.stringify(metadata, null, 2);
      }
      /**
       * 生成标签
       */
      generateTags(node) {
        const tags = [];
        tags.push("canvasgrid-transit");
        tags.push(`type-${node.type}`);
        if (node.color) {
          tags.push(`color-${this.getColorName(node.color).toLowerCase()}`);
        }
        const textTags = this.extractTagsFromText(this.extractTextContent(node));
        tags.push(...textTags);
        return [...new Set(tags)].filter((tag) => tag && tag.trim().length > 0);
      }
      /**
       * 处理特殊内容（如图片、链接等）
       */
      handleSpecialContent(node) {
        const specialFields = {};
        if (node.type === "file" && node.file) {
          specialFields["File"] = node.file;
          if (this.isImageFile(node.file)) {
            specialFields["Image"] = `<img src="${node.file}" alt="Canvas Image">`;
          }
        }
        if (node.type === "link" && node.url) {
          specialFields["URL"] = node.url;
          specialFields["Link"] = `<a href="${node.url}" target="_blank">${node.url}</a>`;
        }
        return specialFields;
      }
      /**
       * 验证节点数据
       */
      validateNode(node) {
        const errors = [];
        const warnings = [];
        if (!node.id)
          errors.push("\u8282\u70B9ID\u7F3A\u5931");
        if (!node.type)
          errors.push("\u8282\u70B9\u7C7B\u578B\u7F3A\u5931");
        if (typeof node.x !== "number")
          errors.push("\u8282\u70B9X\u5750\u6807\u65E0\u6548");
        if (typeof node.y !== "number")
          errors.push("\u8282\u70B9Y\u5750\u6807\u65E0\u6548");
        const hasContent = node.text || node.file || node.url || node.label;
        if (!hasContent) {
          errors.push("\u8282\u70B9\u5185\u5BB9\u4E3A\u7A7A");
        }
        if (node.color && !this.config.syncColors.includes(node.color)) {
          warnings.push("\u8282\u70B9\u989C\u8272\u4E0D\u5728\u540C\u6B65\u8303\u56F4\u5185");
        }
        return {
          valid: errors.length === 0,
          errors,
          warnings
        };
      }
      /**
       * 从文本中提取关键词
       */
      extractKeywords(text) {
        const words = text.split(/\s+/);
        return words.filter((word) => word.length > 3).filter((word) => !/^[0-9]+$/.test(word)).slice(0, 3);
      }
      /**
       * 提取关键信息
       */
      extractKeyInformation(text) {
        const sentences = text.split(/[.!?。！？]/);
        return sentences[0] || text.substring(0, 100) + "...";
      }
      /**
       * 生成源信息
       */
      generateSourceInfo(node) {
        return `\u6765\u6E90: Canvasgrid Transit
\u8282\u70B9ID: ${node.id}
\u521B\u5EFA\u65F6\u95F4: ${(/* @__PURE__ */ new Date()).toLocaleString()}`;
      }
      /**
       * 从文本中提取标签
       */
      extractTagsFromText(text) {
        const tagRegex = /#[\w\u4e00-\u9fa5]+/g;
        const matches = text.match(tagRegex);
        return matches ? matches.map((tag) => tag.substring(1)) : [];
      }
      /**
       * 判断是否为图片文件
       */
      isImageFile(filename) {
        const imageExtensions = [".jpg", ".jpeg", ".png", ".gif", ".bmp", ".svg", ".webp"];
        return imageExtensions.some((ext) => filename.toLowerCase().endsWith(ext));
      }
      /**
       * 获取颜色名称
       */
      getColorName(colorId) {
        const colorNames = {
          "1": "\u7EA2\u8272",
          "2": "\u6A59\u8272",
          "3": "\u9EC4\u8272",
          "4": "\u7EFF\u8272",
          "5": "\u9752\u8272",
          "6": "\u84DD\u8272",
          "7": "\u7D2B\u8272"
        };
        return colorNames[colorId] || colorId;
      }
      /**
       * 获取颜色值
       */
      getColorValue(colorId) {
        const colorValues = {
          "1": "#ff6b6b",
          "2": "#ffa726",
          "3": "#ffeb3b",
          "4": "#66bb6a",
          "5": "#26c6da",
          "6": "#42a5f5",
          "7": "#ab47bc"
        };
        return colorValues[colorId] || "#999999";
      }
      /**
       * 初始化默认字段映射
       */
      initializeDefaultFieldMappings() {
        this.fieldMappings = [
          {
            ankiField: "Front",
            canvasProperty: "text"
          },
          {
            ankiField: "Back",
            canvasProperty: "text"
          }
        ];
      }
      /**
       * 更新配置
       */
      updateConfig(config) {
        this.config = config;
      }
      /**
       * 设置自定义字段映射
       */
      setFieldMappings(mappings) {
        this.fieldMappings = mappings;
      }
      /**
       * 获取当前字段映射
       */
      getFieldMappings() {
        return [...this.fieldMappings];
      }
      /**
       * 解析内容分隔符
       */
      parseContentWithDivider(content, divider) {
        if (!divider || !content.includes(divider)) {
          return { front: content, back: "", hasBack: false };
        }
        const parts = content.split(divider);
        return {
          front: parts[0]?.trim() || "",
          back: parts.slice(1).join(divider).trim(),
          hasBack: true
        };
      }
      /**
       * 格式化颜色标签
       */
      formatColorTag(colorValue) {
        const colorNames = {
          "1": "\u7EA2\u8272",
          "2": "\u6A59\u8272",
          "3": "\u9EC4\u8272",
          "4": "\u7EFF\u8272",
          "5": "\u9752\u8272",
          "6": "\u84DD\u8272",
          "7": "\u7D2B\u8272",
          "8": "\u7C89\u8272"
        };
        const colorName = colorNames[colorValue] || `\u989C\u8272${colorValue}`;
        return `#${colorName}`;
      }
      /**
       * 生成增强的 HTML Obsidian 链接
       */
      generateEnhancedObsidianLink(canvasFile, node) {
        if (!canvasFile || !node) {
          return "";
        }
        try {
          const linkOptions = {
            style: "enhanced",
            includeMetadata: true,
            multiLevel: false,
            includeCoordinates: true,
            includeTimestamp: false,
            target: "_blank",
            cssClass: "obsidian-canvas-link"
          };
          const htmlLink = this.obsidianLinkManager.generateHtmlLink(canvasFile, node, linkOptions);
          console.log(`AnkiFieldMapper: \u751F\u6210HTML\u94FE\u63A5 - ${htmlLink}`);
          return htmlLink;
        } catch (error) {
          console.error("AnkiFieldMapper: \u751F\u6210HTML\u94FE\u63A5\u5931\u8D25:", error);
          return this.generateFallbackLink(canvasFile, node);
        }
      }
      /**
       * 生成后备链接（当增强链接失败时使用）
       */
      generateFallbackLink(canvasFile, node) {
        try {
          const vaultName = this.app.vault.adapter?.name || "vault";
          const encodedVault = encodeURIComponent(vaultName);
          const encodedPath = encodeURIComponent(canvasFile.path);
          const baseLink = `obsidian://open?vault=${encodedVault}&file=${encodedPath}`;
          const nodeParams = `&nodeId=${node.id}&x=${node.x}&y=${node.y}`;
          const fullLink = baseLink + nodeParams;
          return `<a href="${fullLink}" target="_blank" style="color: #0066cc; text-decoration: none;">\u{1F4CD} \u5728Obsidian\u4E2D\u67E5\u770B</a>`;
        } catch (error) {
          console.error("AnkiFieldMapper: \u751F\u6210\u540E\u5907\u94FE\u63A5\u5931\u8D25:", error);
          return "";
        }
      }
      /**
       * 生成官方 Obsidian Canvas 链接
       */
      generateOfficialCanvasLink(canvasFile, node) {
        if (!canvasFile || !node) {
          return "";
        }
        try {
          const vaultName = this.app.vault.adapter?.name || "vault";
          const encodedVault = encodeURIComponent(vaultName);
          const encodedPath = encodeURIComponent(canvasFile.path);
          const baseLink = `obsidian://open?vault=${encodedVault}&file=${encodedPath}`;
          const nodeParams = `&nodeId=${node.id}&x=${node.x}&y=${node.y}`;
          return baseLink + nodeParams;
        } catch (error) {
          console.warn("\u751F\u6210 Obsidian \u94FE\u63A5\u5931\u8D25:", error);
          return "";
        }
      }
      /**
       * 格式化内容用于Anki显示
       */
      formatContentForAnki(content) {
        if (!content || !content.trim()) {
          return content;
        }
        return content.replace(/\n{2,}/g, "<br><br>").replace(/\n/g, "<br>").replace(/\s+/g, " ").trim();
      }
    };
  }
});

// src/types/GroupTypes.ts
var init_GroupTypes = __esm({
  "src/types/GroupTypes.ts"() {
    "use strict";
  }
});

// src/managers/GroupAnalysisManager.ts
var GroupAnalysisManager;
var init_GroupAnalysisManager = __esm({
  "src/managers/GroupAnalysisManager.ts"() {
    "use strict";
    init_GroupTypes();
    GroupAnalysisManager = class {
      constructor(app) {
        this.app = app;
      }
      /**
       * 分析Canvas中的分组结构
       */
      analyzeGroupStructure(canvasNodes) {
        console.log(`GroupAnalysis: \u5F00\u59CB\u5206\u6790\u5206\u7EC4\u7ED3\u6784\uFF0C\u603B\u8282\u70B9\u6570: ${canvasNodes.length}`);
        const groupNodes = canvasNodes.filter((node) => node.type === "group");
        const nonGroupNodes = canvasNodes.filter((node) => node.type !== "group");
        console.log(`GroupAnalysis: \u5206\u7EC4\u8282\u70B9\u6570: ${groupNodes.length}, \u975E\u5206\u7EC4\u8282\u70B9\u6570: ${nonGroupNodes.length}`);
        const groups = [];
        const allMemberNodes = [];
        for (const groupNode of groupNodes) {
          const groupInfo = this.analyzeGroup(groupNode, nonGroupNodes, groupNodes);
          groups.push(groupInfo);
          allMemberNodes.push(...groupInfo.memberNodes);
        }
        const memberNodeIds = new Set(allMemberNodes.map((node) => node.id));
        const orphanNodes = nonGroupNodes.filter((node) => !memberNodeIds.has(node.id));
        const stats = this.generateStats(groups, allMemberNodes, orphanNodes);
        console.log(`GroupAnalysis: \u5206\u6790\u5B8C\u6210 - \u5206\u7EC4: ${groups.length}, \u6210\u5458\u8282\u70B9: ${allMemberNodes.length}, \u5B64\u7ACB\u8282\u70B9: ${orphanNodes.length}`);
        return {
          groups,
          memberNodes: allMemberNodes,
          orphanNodes,
          stats
        };
      }
      /**
       * 分析单个分组
       */
      analyzeGroup(groupNode, candidateNodes, allGroups) {
        const bounds = this.calculateGroupBounds(groupNode);
        const memberNodes = [];
        for (const node of candidateNodes) {
          if (this.isNodeInsideGroup(node, groupNode)) {
            memberNodes.push(node);
          }
        }
        let level = 0;
        let parentGroupId;
        for (const otherGroup of allGroups) {
          if (otherGroup.id !== groupNode.id && this.isNodeInsideGroup(groupNode, otherGroup)) {
            level++;
            parentGroupId = otherGroup.id;
          }
        }
        console.log(`GroupAnalysis: \u5206\u7EC4 ${groupNode.id} \u5305\u542B ${memberNodes.length} \u4E2A\u6210\u5458\u8282\u70B9\uFF0C\u5C42\u7EA7: ${level}`);
        return {
          groupNode,
          memberNodes,
          bounds,
          level,
          parentGroupId
        };
      }
      /**
       * 计算分组边界
       */
      calculateGroupBounds(groupNode) {
        const x = groupNode.x;
        const y = groupNode.y;
        const width = groupNode.width;
        const height = groupNode.height;
        return {
          x,
          y,
          width,
          height,
          right: x + width,
          bottom: y + height
        };
      }
      /**
       * 检查节点是否在分组内
       */
      isNodeInsideGroup(node, group) {
        const groupBounds = this.calculateGroupBounds(group);
        const nodeBounds = {
          x: node.x,
          y: node.y,
          right: node.x + node.width,
          bottom: node.y + node.height
        };
        const isInside = nodeBounds.x >= groupBounds.x && nodeBounds.y >= groupBounds.y && nodeBounds.right <= groupBounds.right && nodeBounds.bottom <= groupBounds.bottom;
        return isInside;
      }
      /**
       * 获取分组内的成员节点
       */
      getGroupMemberNodes(canvasNodes, groupId) {
        const groupNode = canvasNodes.find((node) => node.id === groupId && node.type === "group");
        if (!groupNode) {
          return [];
        }
        const nonGroupNodes = canvasNodes.filter((node) => node.type !== "group");
        return nonGroupNodes.filter((node) => this.isNodeInsideGroup(node, groupNode));
      }
      /**
       * 获取所有分组内的成员节点
       */
      getAllGroupMemberNodes(canvasNodes, options) {
        const analysisResult = this.analyzeGroupStructure(canvasNodes);
        let memberNodes = analysisResult.memberNodes;
        if (options) {
          memberNodes = this.applyMemberFilter(memberNodes, options);
        }
        return memberNodes;
      }
      /**
       * 应用成员节点筛选
       */
      applyMemberFilter(nodes, options) {
        let filteredNodes = nodes;
        if (options.includeColors && options.includeColors.length > 0) {
          filteredNodes = filteredNodes.filter(
            (node) => node.color && options.includeColors.includes(node.color)
          );
        }
        if (options.excludeColors && options.excludeColors.length > 0) {
          filteredNodes = filteredNodes.filter(
            (node) => !node.color || !options.excludeColors.includes(node.color)
          );
        }
        if (options.includeTypes && options.includeTypes.length > 0) {
          filteredNodes = filteredNodes.filter(
            (node) => options.includeTypes.includes(node.type)
          );
        }
        if (options.excludeTypes && options.excludeTypes.length > 0) {
          filteredNodes = filteredNodes.filter(
            (node) => !options.excludeTypes.includes(node.type)
          );
        }
        if (options.minNodeArea && options.minNodeArea > 0) {
          filteredNodes = filteredNodes.filter(
            (node) => node.width * node.height >= options.minNodeArea
          );
        }
        return filteredNodes;
      }
      /**
       * 生成统计信息
       */
      generateStats(groups, memberNodes, orphanNodes) {
        const nestedGroups = groups.filter((group) => group.level > 0);
        const maxNestingLevel = groups.length > 0 ? Math.max(...groups.map((group) => group.level)) : 0;
        return {
          totalGroups: groups.length,
          totalMemberNodes: memberNodes.length,
          orphanNodesCount: orphanNodes.length,
          nestedGroupsCount: nestedGroups.length,
          maxNestingLevel
        };
      }
      /**
       * 获取节点间的位置关系
       */
      getNodeRelation(node1, node2) {
        const bounds1 = {
          x: node1.x,
          y: node1.y,
          right: node1.x + node1.width,
          bottom: node1.y + node1.height
        };
        const bounds2 = {
          x: node2.x,
          y: node2.y,
          right: node2.x + node2.width,
          bottom: node2.y + node2.height
        };
        if (bounds1.right < bounds2.x || bounds2.right < bounds1.x || bounds1.bottom < bounds2.y || bounds2.bottom < bounds1.y) {
          return "separate" /* SEPARATE */;
        }
        if (bounds1.x >= bounds2.x && bounds1.y >= bounds2.y && bounds1.right <= bounds2.right && bounds1.bottom <= bounds2.bottom) {
          return "contained" /* CONTAINED */;
        }
        if (bounds2.x >= bounds1.x && bounds2.y >= bounds1.y && bounds2.right <= bounds1.right && bounds2.bottom <= bounds1.bottom) {
          return "contained" /* CONTAINED */;
        }
        if ((bounds1.right === bounds2.x || bounds2.right === bounds1.x || bounds1.bottom === bounds2.y || bounds2.bottom === bounds1.y) && !(bounds1.right < bounds2.x || bounds2.right < bounds1.x || bounds1.bottom < bounds2.y || bounds2.bottom < bounds1.y)) {
          return "touching" /* TOUCHING */;
        }
        return "overlapping" /* OVERLAPPING */;
      }
    };
  }
});

// src/types/AnkiTypes.ts
var init_AnkiTypes = __esm({
  "src/types/AnkiTypes.ts"() {
    "use strict";
  }
});

// src/managers/AnkiSyncManager.ts
var AnkiSyncManager_exports = {};
__export(AnkiSyncManager_exports, {
  AnkiSyncManager: () => AnkiSyncManager
});
var AnkiSyncManager;
var init_AnkiSyncManager = __esm({
  "src/managers/AnkiSyncManager.ts"() {
    "use strict";
    init_AnkiConnectManager();
    init_AnkiFieldMapper();
    init_AnkiModelManager();
    init_GroupAnalysisManager();
    init_AnkiTypes();
    AnkiSyncManager = class {
      constructor(app, config, syncHistory, callbacks) {
        this.currentSyncProgress = null;
        this.syncInProgress = false;
        this.abortController = null;
        this.app = app;
        this.config = config;
        this.syncHistory = syncHistory;
        this.ankiConnectManager = new AnkiConnectManager(app, config);
        this.ankiModelManager = new AnkiModelManager(app, this.ankiConnectManager, config);
        this.ankiFieldMapper = new AnkiFieldMapper(app, config);
        this.groupAnalysisManager = new GroupAnalysisManager(app);
        if (callbacks) {
          this.onProgressUpdate = callbacks.onProgressUpdate;
          this.onSyncComplete = callbacks.onSyncComplete;
          this.onSyncError = callbacks.onSyncError;
        }
      }
      /**
       * 同步选中的卡片
       */
      async syncSelectedCards(nodeIds, canvasNodes, canvasFile) {
        const selectedNodes = canvasNodes.filter((node) => nodeIds.includes(node.id));
        return this.performSync(selectedNodes, { nodeIds }, canvasFile);
      }
      /**
       * 同步特定颜色的卡片
       */
      async syncColorFilteredCards(colors, canvasNodes, canvasFile) {
        console.log(`AnkiSync: \u5F00\u59CB\u989C\u8272\u7B5B\u9009\u540C\u6B65\uFF0C\u76EE\u6807\u989C\u8272: [${colors.join(", ")}]`);
        console.log(`AnkiSync: \u603B\u8282\u70B9\u6570: ${canvasNodes.length}`);
        const directNodes = canvasNodes.filter(
          (node) => node.color && colors.includes(node.color) && node.type !== "group"
        );
        const groupMemberNodes = this.getGroupMemberNodesWithColors(canvasNodes, colors);
        const allEligibleNodes = this.deduplicateNodes([...directNodes, ...groupMemberNodes]);
        console.log(`AnkiSync: \u76F4\u63A5\u8282\u70B9: ${directNodes.length}, \u5206\u7EC4\u6210\u5458\u8282\u70B9: ${groupMemberNodes.length}, \u603B\u8BA1: ${allEligibleNodes.length}`);
        const nodeTypeStats = allEligibleNodes.reduce((stats, node) => {
          stats[node.type] = (stats[node.type] || 0) + 1;
          return stats;
        }, {});
        console.log("AnkiSync: \u8282\u70B9\u7C7B\u578B\u7EDF\u8BA1:", nodeTypeStats);
        return this.performSync(allEligibleNodes, { colors }, canvasFile);
      }
      /**
       * 执行增量同步
       */
      async performIncrementalSync(canvasNodes, canvasFile) {
        if (!this.config.enableIncrementalSync) {
          return this.syncColorFilteredCards(this.config.syncColors, canvasNodes, canvasFile);
        }
        const nodesToSync = this.filterNodesForIncrementalSync(canvasNodes);
        return this.performSync(nodesToSync, { forceUpdate: false }, canvasFile);
      }
      /**
       * 验证同步数据
       */
      validateSyncData(nodes) {
        if (!nodes || nodes.length === 0) {
          console.warn("AnkiSync: \u6CA1\u6709\u8282\u70B9\u6570\u636E\u9700\u8981\u540C\u6B65");
          return false;
        }
        const validNodes = nodes.filter((node) => this.isValidNode(node));
        if (validNodes.length === 0) {
          console.warn("AnkiSync: \u6CA1\u6709\u6709\u6548\u7684\u8282\u70B9\u53EF\u4EE5\u540C\u6B65");
          console.log("AnkiSync: \u8282\u70B9\u9A8C\u8BC1\u8BE6\u60C5:", nodes.map((node) => ({
            id: node.id,
            type: node.type,
            hasContent: this.hasNodeContent(node),
            hasPosition: typeof node.x === "number" && typeof node.y === "number"
          })));
          return false;
        }
        if (validNodes.length < nodes.length) {
          console.warn(`AnkiSync: ${nodes.length - validNodes.length} \u4E2A\u8282\u70B9\u9A8C\u8BC1\u5931\u8D25\uFF0C\u5C06\u540C\u6B65 ${validNodes.length} \u4E2A\u6709\u6548\u8282\u70B9`);
        }
        return true;
      }
      /**
       * 验证单个节点是否有效
       */
      isValidNode(node) {
        if (node.type === "group") {
          return false;
        }
        if (!node.id || !node.type) {
          return false;
        }
        if (typeof node.x !== "number" || typeof node.y !== "number") {
          return false;
        }
        return this.hasNodeContent(node);
      }
      /**
       * 检查节点是否有内容
       */
      hasNodeContent(node) {
        switch (node.type) {
          case "text":
            return !!(node.text && node.text.trim());
          case "file":
            return !!(node.file && node.file.trim());
          case "link":
            return !!(node.url && node.url.trim());
          case "group":
            return !!(node.label && node.label.trim());
          default:
            return !!(node.text || node.file || node.url || node.label);
        }
      }
      /**
       * 取消当前同步操作
       */
      cancelSync() {
        if (this.syncInProgress && this.abortController) {
          this.abortController.abort();
          this.updateSyncProgress({
            status: "cancelled" /* CANCELLED */,
            current: 0,
            total: 0,
            message: "\u540C\u6B65\u5DF2\u53D6\u6D88",
            errors: []
          });
          this.syncInProgress = false;
        }
      }
      /**
       * 获取当前同步进度
       */
      getCurrentProgress() {
        return this.currentSyncProgress;
      }
      /**
       * 检查是否正在同步
       */
      isSyncInProgress() {
        return this.syncInProgress;
      }
      /**
       * 更新配置
       */
      updateConfig(config) {
        this.config = config;
        this.ankiConnectManager.updateConfig(config);
      }
      /**
       * 更新同步历史
       */
      updateSyncHistory(syncHistory) {
        this.syncHistory = syncHistory;
      }
      /**
       * 执行同步的核心方法
       */
      async performSync(nodes, options = {}, canvasFile) {
        if (this.syncInProgress) {
          throw new Error("\u540C\u6B65\u6B63\u5728\u8FDB\u884C\u4E2D\uFF0C\u8BF7\u7B49\u5F85\u5B8C\u6210");
        }
        if (!this.validateSyncData(nodes)) {
          throw new Error("\u540C\u6B65\u6570\u636E\u9A8C\u8BC1\u5931\u8D25\uFF1A\u6CA1\u6709\u6709\u6548\u7684\u8282\u70B9\u53EF\u4EE5\u540C\u6B65");
        }
        const validNodes = nodes.filter((node) => this.isValidNode(node));
        console.log(`AnkiSync: \u539F\u59CB\u8282\u70B9\u6570\u91CF: ${nodes.length}, \u6709\u6548\u8282\u70B9\u6570\u91CF: ${validNodes.length}`);
        if (validNodes.length === 0) {
          throw new Error("\u540C\u6B65\u6570\u636E\u9A8C\u8BC1\u5931\u8D25\uFF1A\u6240\u6709\u8282\u70B9\u90FD\u65E0\u6548");
        }
        const isConnected = await this.ankiConnectManager.testConnection();
        if (!isConnected) {
          throw new Error("\u65E0\u6CD5\u8FDE\u63A5\u5230Anki Connect\uFF0C\u8BF7\u68C0\u67E5Anki\u662F\u5426\u8FD0\u884C");
        }
        console.log("AnkiSync: \u68C0\u67E5\u63D2\u4EF6\u4E13\u5C5E\u6A21\u578B");
        const modelReady = await this.ankiModelManager.ensurePluginModelExists();
        if (!modelReady) {
          throw new Error("\u65E0\u6CD5\u521B\u5EFA\u6216\u66F4\u65B0\u63D2\u4EF6\u4E13\u5C5E\u6A21\u578B");
        }
        console.log(`AnkiSync: \u68C0\u67E5\u724C\u7EC4 "${this.config.defaultDeck}" \u662F\u5426\u5B58\u5728`);
        const deckExists = await this.ankiConnectManager.ensureDeckExists(this.config.defaultDeck);
        if (!deckExists) {
          throw new Error(`\u65E0\u6CD5\u521B\u5EFA\u6216\u8BBF\u95EE\u724C\u7EC4 "${this.config.defaultDeck}"`);
        }
        this.syncInProgress = true;
        this.abortController = new AbortController();
        const startTime = Date.now();
        const result = {
          success: false,
          created: 0,
          updated: 0,
          skipped: 0,
          errors: [],
          totalProcessed: 0,
          duration: 0
        };
        try {
          this.updateSyncProgress({
            status: "connecting" /* CONNECTING */,
            current: 0,
            total: validNodes.length,
            message: "\u8FDE\u63A5\u5230Anki...",
            errors: []
          });
          this.updateSyncProgress({
            status: "syncing" /* SYNCING */,
            current: 0,
            total: validNodes.length,
            message: `\u5F00\u59CB\u540C\u6B65 ${validNodes.length} \u4E2A\u5361\u7247...`,
            errors: []
          });
          const batchSize = options.batchSize || this.config.batchSize;
          const batches = this.createBatches(validNodes, batchSize);
          for (let i = 0; i < batches.length; i++) {
            if (this.abortController.signal.aborted) {
              throw new Error("\u540C\u6B65\u88AB\u7528\u6237\u53D6\u6D88");
            }
            const batch = batches[i];
            const batchResult = await this.processBatch(batch, i + 1, batches.length, canvasFile);
            result.created += batchResult.created;
            result.updated += batchResult.updated;
            result.skipped += batchResult.skipped;
            result.errors.push(...batchResult.errors);
            result.totalProcessed += batchResult.totalProcessed;
            const processedCount = (i + 1) * batchSize;
            this.updateSyncProgress({
              status: "syncing" /* SYNCING */,
              current: Math.min(processedCount, nodes.length),
              total: nodes.length,
              message: `\u6B63\u5728\u540C\u6B65\u7B2C ${i + 1}/${batches.length} \u6279...`,
              errors: result.errors
            });
          }
          result.success = result.errors.length === 0 || result.created > 0 || result.updated > 0;
          result.duration = Date.now() - startTime;
          this.updateSyncHistoryAfterSync(nodes, result);
          this.updateSyncProgress({
            status: "completed" /* COMPLETED */,
            current: nodes.length,
            total: nodes.length,
            message: `\u540C\u6B65\u5B8C\u6210\uFF01\u521B\u5EFA ${result.created} \u4E2A\uFF0C\u66F4\u65B0 ${result.updated} \u4E2A\uFF0C\u8DF3\u8FC7 ${result.skipped} \u4E2A`,
            errors: result.errors
          });
          if (this.onSyncComplete) {
            this.onSyncComplete(result);
          }
          return result;
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : "\u672A\u77E5\u9519\u8BEF";
          result.errors.push(errorMessage);
          result.duration = Date.now() - startTime;
          this.updateSyncProgress({
            status: "error" /* ERROR */,
            current: 0,
            total: nodes.length,
            message: `\u540C\u6B65\u5931\u8D25: ${errorMessage}`,
            errors: result.errors
          });
          if (this.onSyncError) {
            this.onSyncError(errorMessage);
          }
          throw error;
        } finally {
          this.syncInProgress = false;
          this.abortController = null;
        }
      }
      /**
       * 筛选需要增量同步的节点
       */
      filterNodesForIncrementalSync(nodes) {
        return nodes.filter((node) => {
          if (node.type === "group") {
            return false;
          }
          if (!node.color || !this.config.syncColors.includes(node.color)) {
            return false;
          }
          const syncedInfo = this.syncHistory.syncedNodes[node.id];
          if (!syncedInfo) {
            return true;
          }
          const nodeModified = this.getNodeLastModified(node);
          return nodeModified > syncedInfo.lastModified;
        });
      }
      /**
       * 获取节点最后修改时间
       */
      getNodeLastModified(node) {
        return Date.now();
      }
      /**
       * 创建批次
       */
      createBatches(items, batchSize) {
        const batches = [];
        for (let i = 0; i < items.length; i += batchSize) {
          batches.push(items.slice(i, i + batchSize));
        }
        return batches;
      }
      /**
       * 处理单个批次
       */
      async processBatch(nodes, batchIndex, totalBatches, canvasFile) {
        const startTime = Date.now();
        const result = {
          success: true,
          created: 0,
          updated: 0,
          skipped: 0,
          errors: [],
          totalProcessed: 0,
          duration: 0
        };
        console.log(`AnkiSync: \u5904\u7406\u7B2C ${batchIndex}/${totalBatches} \u6279\uFF0C\u8282\u70B9\u6570\u91CF: ${nodes.length}`);
        for (const node of nodes) {
          try {
            if (this.abortController && this.abortController.signal.aborted) {
              throw new Error("\u540C\u6B65\u88AB\u7528\u6237\u53D6\u6D88");
            }
            const conversionResult = this.ankiFieldMapper.mapNodeToAnkiNote(node, canvasFile, this.config.contentDivider);
            if (!conversionResult.success) {
              console.warn(`AnkiSync: \u8282\u70B9\u8F6C\u6362\u5931\u8D25 ${node.id}:`, conversionResult.error);
              result.errors.push(`\u8282\u70B9 ${node.id} \u8F6C\u6362\u5931\u8D25: ${conversionResult.error}`);
              result.skipped++;
              continue;
            }
            const ankiNote = conversionResult.ankiNote;
            console.log(`AnkiSync: \u51C6\u5907\u540C\u6B65\u8282\u70B9 ${node.id}, \u7C7B\u578B: ${node.type}`);
            console.log(`AnkiSync: ObsidianLink\u5B57\u6BB5\u503C:`, ankiNote.fields["ObsidianLink"] || "(\u7A7A)");
            if (this.config.enableIncrementalSync && !this.config.forceSync) {
              const existingSync2 = this.syncHistory.syncedNodes[node.id];
              if (existingSync2) {
                const currentHash = this.generateContentHash(node);
                console.log(`AnkiSync: \u8282\u70B9 ${node.id} \u5185\u5BB9\u54C8\u5E0C\u5BF9\u6BD4 - \u5F53\u524D: ${currentHash}, \u5386\u53F2: ${existingSync2.contentHash}`);
                if (currentHash === existingSync2.contentHash) {
                  console.log(`AnkiSync: \u8282\u70B9 ${node.id} \u5185\u5BB9\u672A\u53D8\u5316\uFF0C\u8DF3\u8FC7\u540C\u6B65`);
                  result.skipped++;
                  continue;
                } else {
                  console.log(`AnkiSync: \u8282\u70B9 ${node.id} \u5185\u5BB9\u5DF2\u53D8\u5316\uFF0C\u9700\u8981\u66F4\u65B0`);
                }
              } else {
                console.log(`AnkiSync: \u8282\u70B9 ${node.id} \u662F\u65B0\u8282\u70B9\uFF0C\u9700\u8981\u521B\u5EFA`);
              }
            } else if (this.config.forceSync) {
              console.log(`AnkiSync: \u5F3A\u5236\u540C\u6B65\u6A21\u5F0F\uFF0C\u8282\u70B9 ${node.id} \u5C06\u88AB\u5F3A\u5236\u540C\u6B65`);
            }
            const existingSync = this.syncHistory.syncedNodes[node.id];
            let noteId = null;
            let isUpdate = false;
            if (existingSync && existingSync.ankiNoteId) {
              console.log(`AnkiSync: \u5C1D\u8BD5\u66F4\u65B0\u73B0\u6709\u5361\u7247 ${existingSync.ankiNoteId} for \u8282\u70B9 ${node.id}`);
              const noteExists = await this.ankiConnectManager.noteExists(existingSync.ankiNoteId);
              if (noteExists) {
                const updateSuccess = await this.ankiConnectManager.updateNote(existingSync.ankiNoteId, ankiNote);
                if (updateSuccess) {
                  noteId = existingSync.ankiNoteId;
                  isUpdate = true;
                  console.log(`AnkiSync: \u6210\u529F\u66F4\u65B0\u5361\u7247 ${noteId} for \u8282\u70B9 ${node.id}`);
                  result.updated++;
                } else {
                  console.warn(`AnkiSync: \u66F4\u65B0\u5361\u7247\u5931\u8D25\uFF0C\u5C1D\u8BD5\u521B\u5EFA\u65B0\u5361\u7247 for \u8282\u70B9 ${node.id}`);
                  noteId = await this.ankiConnectManager.addNote(ankiNote);
                  if (noteId) {
                    console.log(`AnkiSync: \u6210\u529F\u521B\u5EFA\u65B0\u5361\u7247 ${noteId} for \u8282\u70B9 ${node.id}`);
                    result.created++;
                  }
                }
              } else {
                console.log(`AnkiSync: \u539F\u5361\u7247\u4E0D\u5B58\u5728\uFF0C\u521B\u5EFA\u65B0\u5361\u7247 for \u8282\u70B9 ${node.id}`);
                noteId = await this.ankiConnectManager.addNote(ankiNote);
                if (noteId) {
                  console.log(`AnkiSync: \u6210\u529F\u521B\u5EFA\u65B0\u5361\u7247 ${noteId} for \u8282\u70B9 ${node.id}`);
                  result.created++;
                }
              }
            } else {
              console.log(`AnkiSync: \u521B\u5EFA\u65B0\u5361\u7247 for \u8282\u70B9 ${node.id}`);
              noteId = await this.ankiConnectManager.addNote(ankiNote);
              if (noteId) {
                console.log(`AnkiSync: \u6210\u529F\u521B\u5EFA\u5361\u7247 ${noteId} for \u8282\u70B9 ${node.id}`);
                result.created++;
              }
            }
            if (noteId) {
              this.syncHistory.syncedNodes[node.id] = {
                nodeId: node.id,
                ankiNoteId: noteId,
                lastModified: this.getNodeLastModified(node),
                contentHash: this.generateContentHash(node),
                syncTime: Date.now()
              };
            } else {
              console.warn(`AnkiSync: ${isUpdate ? "\u66F4\u65B0" : "\u521B\u5EFA"}\u5361\u7247\u5931\u8D25 for \u8282\u70B9 ${node.id}`);
              result.errors.push(`\u8282\u70B9 ${node.id} ${isUpdate ? "\u66F4\u65B0" : "\u521B\u5EFA"}\u5361\u7247\u5931\u8D25`);
              result.skipped++;
            }
            result.totalProcessed++;
          } catch (error) {
            console.error(`AnkiSync: \u5904\u7406\u8282\u70B9 ${node.id} \u65F6\u51FA\u9519:`, error);
            result.errors.push(`\u8282\u70B9 ${node.id} \u5904\u7406\u5931\u8D25: ${error instanceof Error ? error.message : "\u672A\u77E5\u9519\u8BEF"}`);
            result.skipped++;
          }
        }
        result.duration = Date.now() - startTime;
        result.success = result.errors.length === 0 || result.created > 0;
        console.log(`AnkiSync: \u6279\u6B21 ${batchIndex} \u5B8C\u6210 - \u521B\u5EFA: ${result.created}, \u8DF3\u8FC7: ${result.skipped}, \u9519\u8BEF: ${result.errors.length}`);
        return result;
      }
      /**
       * 更新同步进度
       */
      updateSyncProgress(progress) {
        this.currentSyncProgress = progress;
        if (this.onProgressUpdate) {
          this.onProgressUpdate(progress);
        }
      }
      /**
       * 同步完成后更新历史记录
       */
      updateSyncHistoryAfterSync(nodes, result) {
        const now = Date.now();
        this.syncHistory.lastSyncTime = now;
        this.syncHistory.lastSyncResult = result;
        nodes.forEach((node) => {
          if (!result.errors.some((error) => error.includes(node.id))) {
            this.syncHistory.syncedNodes[node.id] = {
              nodeId: node.id,
              ankiNoteId: 0,
              // 这里需要从实际同步结果中获取
              lastModified: this.getNodeLastModified(node),
              contentHash: this.generateContentHash(node),
              syncTime: now
            };
          }
        });
        this.syncHistory.failedNodes = this.syncHistory.failedNodes.filter(
          (nodeId) => !nodes.some((node) => node.id === nodeId) || result.errors.some((error) => error.includes(nodeId))
        );
      }
      /**
       * 获取分组成员节点（按颜色筛选）
       */
      getGroupMemberNodesWithColors(canvasNodes, colors) {
        const filterOptions = {
          includeColors: colors,
          excludeTypes: ["group"],
          // 确保不包含分组节点本身
          includeNestedMembers: true
          // 包含嵌套分组的成员
        };
        const groupMemberNodes = this.groupAnalysisManager.getAllGroupMemberNodes(canvasNodes, filterOptions);
        console.log(`AnkiSync: \u5206\u7EC4\u5206\u6790\u5B8C\u6210\uFF0C\u627E\u5230 ${groupMemberNodes.length} \u4E2A\u7B26\u5408\u989C\u8272\u6761\u4EF6\u7684\u5206\u7EC4\u6210\u5458\u8282\u70B9`);
        return groupMemberNodes;
      }
      /**
       * 去重节点数组（基于节点ID）
       */
      deduplicateNodes(nodes) {
        const seen = /* @__PURE__ */ new Set();
        const uniqueNodes = [];
        for (const node of nodes) {
          if (!seen.has(node.id)) {
            seen.add(node.id);
            uniqueNodes.push(node);
          }
        }
        if (nodes.length !== uniqueNodes.length) {
          console.log(`AnkiSync: \u53BB\u91CD\u5B8C\u6210\uFF0C\u539F\u59CB: ${nodes.length}, \u53BB\u91CD\u540E: ${uniqueNodes.length}`);
        }
        return uniqueNodes;
      }
      /**
       * 生成节点内容哈希
       */
      generateContentHash(node) {
        const content = JSON.stringify({
          type: node.type,
          text: node.text,
          file: node.file,
          url: node.url,
          color: node.color
        });
        let hash = 0;
        for (let i = 0; i < content.length; i++) {
          const char = content.charCodeAt(i);
          hash = (hash << 5) - hash + char;
          hash = hash & hash;
        }
        return hash.toString();
      }
    };
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  CANVAS_GRID_VIEW_TYPE: () => CANVAS_GRID_VIEW_TYPE,
  CANVAS_TIMELINE_VIEW_TYPE: () => CANVAS_TIMELINE_VIEW_TYPE,
  CanvasGridView: () => CanvasGridView,
  default: () => CanvasGridPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian12 = require("obsidian");

// src/managers/UIComponentManager.ts
var import_obsidian2 = require("obsidian");

// src/utils/SafeDOMUtils.ts
var import_obsidian = require("obsidian");
var SafeDOMUtils = class {
  /**
   * 安全地设置元素的文本内容
   */
  static setTextContent(element, content) {
    element.textContent = content;
  }
  /**
   * 安全地设置HTML内容，仅允许特定的安全标签
   */
  static setSafeHTML(element, content, allowedTags = ["strong", "em", "code", "br"]) {
    element.empty();
    if (!content.includes("<")) {
      element.textContent = content;
      return;
    }
    const cleanContent = this.sanitizeHTML(content, allowedTags);
    this.appendSafeHTML(element, cleanContent);
  }
  /**
   * 创建安全的SVG图标元素
   */
  static createSVGIcon(iconName, size = 16) {
    const container = document.createElement("span");
    container.className = "svg-icon";
    try {
      (0, import_obsidian.setIcon)(container, iconName);
    } catch (error) {
      container.textContent = "\u{1F4C4}";
    }
    return container;
  }
  /**
   * 创建带有图标的元素
   */
  static createIconElement(iconName, text, className) {
    const container = document.createElement("span");
    if (className) {
      container.className = className;
    }
    const iconEl = this.createSVGIcon(iconName);
    container.appendChild(iconEl);
    if (text) {
      const textEl = document.createElement("span");
      textEl.textContent = text;
      container.appendChild(textEl);
    }
    return container;
  }
  /**
   * 安全地添加CSS类
   */
  static addClasses(element, ...classNames) {
    classNames.forEach((className) => {
      if (className && typeof className === "string") {
        element.addClass(className);
      }
    });
  }
  /**
   * 安全地移除CSS类
   */
  static removeClasses(element, ...classNames) {
    classNames.forEach((className) => {
      if (className && typeof className === "string") {
        element.removeClass(className);
      }
    });
  }
  /**
   * 安全地切换CSS类
   */
  static toggleClass(element, className, force) {
    if (className && typeof className === "string") {
      if (force !== void 0) {
        element.toggleClass(className, force);
      } else {
        const hasClass = element.hasClass(className);
        element.toggleClass(className, !hasClass);
      }
    }
  }
  /**
   * 创建安全的链接元素
   */
  static createSafeLink(href, text, target) {
    const link = document.createElement("a");
    if (this.isValidURL(href)) {
      link.href = href;
    } else {
      link.textContent = `[Invalid URL: ${text}]`;
      return link;
    }
    link.textContent = text;
    if (target) {
      link.target = target;
      if (target === "_blank") {
        link.rel = "noopener noreferrer";
      }
    }
    return link;
  }
  /**
   * 验证URL是否安全
   */
  static isValidURL(url) {
    try {
      const urlObj = new URL(url);
      const allowedProtocols = ["http:", "https:", "obsidian:", "file:"];
      return allowedProtocols.includes(urlObj.protocol);
    } catch {
      return false;
    }
  }
  /**
   * 清理HTML内容，移除不安全的标签和属性
   */
  static sanitizeHTML(html, allowedTags) {
    const tempDiv = document.createElement("div");
    tempDiv.textContent = html;
    const parser = new DOMParser();
    const doc = parser.parseFromString(tempDiv.textContent || "", "text/html");
    this.cleanElement(doc.body, allowedTags);
    return doc.body.innerHTML;
  }
  /**
   * 递归清理DOM元素
   */
  static cleanElement(element, allowedTags) {
    const children = Array.from(element.children);
    children.forEach((child) => {
      const tagName = child.tagName.toLowerCase();
      if (!allowedTags.includes(tagName)) {
        const textNode = document.createTextNode(child.textContent || "");
        child.parentNode?.replaceChild(textNode, child);
      } else {
        this.cleanAttributes(child);
        this.cleanElement(child, allowedTags);
      }
    });
  }
  /**
   * 清理元素属性，只保留安全的属性
   */
  static cleanAttributes(element) {
    const allowedAttributes = ["class", "id", "title", "alt"];
    const attributes = Array.from(element.attributes);
    attributes.forEach((attr) => {
      if (!allowedAttributes.includes(attr.name.toLowerCase())) {
        element.removeAttribute(attr.name);
      }
    });
  }
  /**
   * 安全地添加HTML内容到元素
   */
  static appendSafeHTML(element, html) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, "text/html");
    Array.from(doc.body.childNodes).forEach((node) => {
      element.appendChild(node.cloneNode(true));
    });
  }
  /**
   * 创建安全的代码块元素
   */
  static createCodeBlock(code, language) {
    const pre = document.createElement("pre");
    const codeEl = document.createElement("code");
    if (language) {
      codeEl.className = `language-${language}`;
    }
    codeEl.textContent = code;
    pre.appendChild(codeEl);
    return pre;
  }
  /**
   * 创建安全的列表元素
   */
  static createList(items, ordered = false) {
    const list = document.createElement(ordered ? "ol" : "ul");
    items.forEach((item) => {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
    });
    return list;
  }
  /**
   * 安全地设置元素属性
   */
  static setSafeAttribute(element, name, value) {
    const allowedAttributes = [
      "class",
      "id",
      "title",
      "alt",
      "data-*",
      "aria-*",
      "role",
      "href",
      "target",
      "rel",
      "type",
      "value",
      "placeholder"
    ];
    const isAllowed = allowedAttributes.some((allowed) => {
      if (allowed.endsWith("*")) {
        return name.startsWith(allowed.slice(0, -1));
      }
      return name === allowed;
    });
    if (isAllowed) {
      element.setAttribute(name, value);
    }
  }
  /**
   * 创建安全的表格元素
   */
  static createTable(headers, rows) {
    const table = document.createElement("table");
    if (headers.length > 0) {
      const thead = document.createElement("thead");
      const headerRow = document.createElement("tr");
      headers.forEach((header) => {
        const th = document.createElement("th");
        th.textContent = header;
        headerRow.appendChild(th);
      });
      thead.appendChild(headerRow);
      table.appendChild(thead);
    }
    if (rows.length > 0) {
      const tbody = document.createElement("tbody");
      rows.forEach((row) => {
        const tr = document.createElement("tr");
        row.forEach((cell) => {
          const td = document.createElement("td");
          td.textContent = cell;
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
    }
    return table;
  }
};

// src/managers/UIComponentManager.ts
var ToolbarManager = class {
  constructor(app, config) {
    this.container = null;
    this.app = app;
    this.config = config;
  }
  /**
   * 创建工具栏
   */
  createToolbar(container) {
    this.container = container;
    const toolbar = container.createDiv("canvas-grid-toolbar");
    toolbar.addClass("canvas-grid-toolbar-container");
    const leftGroup = toolbar.createDiv("toolbar-group toolbar-left");
    if (this.config.showMainMenu) {
      this.createMainMenuButton(leftGroup);
    }
    if (this.config.showTimeCapsule) {
      this.createTimeCapsuleButton(leftGroup);
    }
    const centerGroup = toolbar.createDiv("toolbar-group toolbar-center");
    if (this.config.showSearch) {
      this.createSearchBox(centerGroup);
    }
    const rightGroup = toolbar.createDiv("toolbar-group toolbar-right");
    if (this.config.showColorFilter) {
      this.createColorFilter(rightGroup);
    }
    if (this.config.showSortOptions) {
      this.createSortOptions(rightGroup);
    }
    this.createAnkiSyncButton(rightGroup);
    return toolbar;
  }
  /**
   * 创建主菜单按钮
   */
  createMainMenuButton(container) {
    const button = container.createEl("button", {
      cls: "canvas-grid-button main-menu-button",
      attr: { "aria-label": "\u4E3B\u83DC\u5355" }
    });
    (0, import_obsidian2.setIcon)(button, "menu");
    button.addEventListener("click", (e) => {
      this.showMainMenu(e);
    });
    return button;
  }
  /**
   * 创建时间胶囊按钮
   */
  createTimeCapsuleButton(container) {
    const button = container.createEl("button", {
      cls: "canvas-grid-button time-capsule-button",
      attr: { "aria-label": "\u65F6\u95F4\u80F6\u56CA" }
    });
    (0, import_obsidian2.setIcon)(button, "clock");
    button.addEventListener("click", () => {
      this.toggleTimeCapsule();
    });
    return button;
  }
  /**
   * 创建搜索框
   */
  createSearchBox(container) {
    const searchContainer = container.createDiv("search-container");
    const searchInput = searchContainer.createEl("input", {
      type: "text",
      cls: "canvas-grid-search-input",
      attr: {
        placeholder: "\u641C\u7D22\u5361\u7247\u5185\u5BB9...",
        "aria-label": "\u641C\u7D22"
      }
    });
    const searchIcon = searchContainer.createEl("div", {
      cls: "search-icon"
    });
    (0, import_obsidian2.setIcon)(searchIcon, "search");
    let searchTimeout;
    searchInput.addEventListener("input", (e) => {
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => {
        const query = e.target.value;
        this.performSearch(query);
      }, 300);
    });
    return searchContainer;
  }
  /**
   * 创建颜色筛选器
   */
  createColorFilter(container) {
    const filterContainer = container.createDiv("color-filter-container");
    const filterButton = filterContainer.createEl("button", {
      cls: "canvas-grid-button color-filter-button",
      attr: { "aria-label": "\u989C\u8272\u7B5B\u9009" }
    });
    (0, import_obsidian2.setIcon)(filterButton, "filter");
    filterButton.addEventListener("click", () => {
      this.showColorFilterMenu(filterButton);
    });
    return filterContainer;
  }
  /**
   * 创建排序选项
   */
  createSortOptions(container) {
    const sortContainer = container.createDiv("sort-options-container");
    const sortButton = sortContainer.createEl("button", {
      cls: "canvas-grid-button sort-button",
      attr: { "aria-label": "\u6392\u5E8F\u9009\u9879" }
    });
    (0, import_obsidian2.setIcon)(sortButton, "arrow-up-down");
    sortButton.addEventListener("click", () => {
      this.showSortMenu(sortButton);
    });
    return sortContainer;
  }
  /**
   * 创建Anki同步按钮
   */
  createAnkiSyncButton(container) {
    const syncContainer = container.createDiv("sync-button-container");
    const syncButton = syncContainer.createEl("button", {
      cls: "toolbar-button mod-cta anki-sync-btn",
      attr: { "aria-label": "Anki\u540C\u6B65" }
    });
    (0, import_obsidian2.setIcon)(syncButton, "refresh-cw");
    const textSpan = syncButton.createSpan();
    SafeDOMUtils.setTextContent(textSpan, "Anki\u540C\u6B65");
    SafeDOMUtils.addClasses(textSpan, "anki-sync-text");
    syncButton.addEventListener("click", async () => {
      await this.handleAnkiSync();
    });
    return syncContainer;
  }
  /**
   * 显示主菜单
   */
  showMainMenu(event) {
    const button = event.target;
    const existingMenu = document.querySelector(".canvas-grid-main-dropdown");
    if (existingMenu) {
      existingMenu.remove();
      return;
    }
    const dropdown = document.createElement("div");
    dropdown.className = "canvas-grid-main-dropdown";
    const basicSection = dropdown.createDiv("canvas-grid-menu-section");
    const infoItem = this.createMenuItem("\u7F51\u683C\u89C6\u56FE", "grid", () => {
      console.log("\u7F51\u683C\u89C6\u56FE\u4FE1\u606F");
      dropdown.remove();
    });
    basicSection.appendChild(infoItem);
    const buttonRect = button.getBoundingClientRect();
    dropdown.style.position = "absolute";
    dropdown.style.top = `${buttonRect.bottom + 4}px`;
    dropdown.style.left = `${buttonRect.left}px`;
    dropdown.style.zIndex = "1000";
    document.body.appendChild(dropdown);
    const closeMenu = (e) => {
      if (!dropdown.contains(e.target)) {
        dropdown.remove();
        document.removeEventListener("click", closeMenu);
      }
    };
    setTimeout(() => document.addEventListener("click", closeMenu), 0);
  }
  /**
   * 创建菜单项
   */
  createMenuItem(text, iconName, onClick) {
    const item = document.createElement("div");
    item.className = "canvas-grid-menu-item";
    const icon = document.createElement("span");
    icon.className = "menu-icon";
    (0, import_obsidian2.setIcon)(icon, iconName);
    item.appendChild(icon);
    const label = document.createElement("span");
    label.className = "menu-label";
    label.textContent = text;
    item.appendChild(label);
    item.addEventListener("click", onClick);
    return item;
  }
  /**
   * 处理Anki同步
   */
  async handleAnkiSync() {
    try {
      console.log("Anki\u540C\u6B65\u529F\u80FD - \u57FA\u7840\u5B9E\u73B0");
    } catch (error) {
      console.error("Anki\u540C\u6B65\u5931\u8D25:", error);
      new import_obsidian2.Notice("Anki\u540C\u6B65\u5931\u8D25: " + (error instanceof Error ? error.message : "\u672A\u77E5\u9519\u8BEF"));
    }
  }
  /**
   * 切换时间胶囊
   */
  toggleTimeCapsule() {
    console.log("\u5207\u6362\u65F6\u95F4\u80F6\u56CA");
  }
  /**
   * 执行搜索
   */
  performSearch(query) {
    console.log("\u6267\u884C\u641C\u7D22:", query);
  }
  /**
   * 显示颜色筛选菜单
   */
  showColorFilterMenu(button) {
    console.log("\u663E\u793A\u989C\u8272\u7B5B\u9009\u83DC\u5355", button);
  }
  /**
   * 显示排序菜单
   */
  showSortMenu(button) {
    console.log("\u663E\u793A\u6392\u5E8F\u83DC\u5355", button);
  }
  /**
   * 更新配置
   */
  updateConfig(config) {
    this.config = { ...this.config, ...config };
    if (this.container) {
      this.container.empty();
      this.createToolbar(this.container);
    }
  }
  /**
   * 销毁工具栏
   */
  destroy() {
    if (this.container) {
      this.container.empty();
      this.container = null;
    }
  }
};
var CardRendererManager = class {
  constructor(app, config) {
    this.app = app;
    this.config = config;
  }
  /**
   * 渲染文本卡片
   */
  renderTextCard(node, container) {
    const card = container.createDiv("canvas-card text-card");
    const header = card.createDiv("card-header");
    const typeIcon = header.createSpan("card-type-icon");
    SafeDOMUtils.setTextContent(typeIcon, "\u{1F4DD}");
    const title = header.createSpan("card-title");
    SafeDOMUtils.setTextContent(title, "\u6587\u672C\u5361\u7247");
    const content = card.createDiv("card-content");
    const text = node.text || "";
    const preview = text.length > this.config.maxPreviewLength ? text.substring(0, this.config.maxPreviewLength) + "..." : text;
    content.createDiv("card-text").textContent = preview;
    if (this.config.showMetadata) {
      this.addCardToolbar(card, node);
    }
    if (this.config.enableHover) {
      this.addHoverEffects(card);
    }
    return card;
  }
  /**
   * 渲染文件卡片
   */
  renderFileCard(node, container) {
    const card = container.createDiv("canvas-card file-card");
    const header = card.createDiv("card-header");
    const typeIcon = header.createSpan("card-type-icon");
    SafeDOMUtils.setTextContent(typeIcon, "\u{1F4C4}");
    const fileName = node.file || "Unknown File";
    const title = header.createSpan("card-title");
    SafeDOMUtils.setTextContent(title, fileName);
    const content = card.createDiv("card-content");
    content.createDiv("file-info").textContent = `\u6587\u4EF6: ${fileName}`;
    if (this.config.showMetadata) {
      this.addCardToolbar(card, node);
    }
    if (this.config.enableHover) {
      this.addHoverEffects(card);
    }
    return card;
  }
  /**
   * 渲染链接卡片
   */
  renderLinkCard(node, container) {
    const card = container.createDiv("canvas-card link-card");
    const header = card.createDiv("card-header");
    const typeIcon = header.createSpan("card-type-icon");
    SafeDOMUtils.setTextContent(typeIcon, "\u{1F517}");
    const title = header.createSpan("card-title");
    SafeDOMUtils.setTextContent(title, "\u94FE\u63A5\u5361\u7247");
    const content = card.createDiv("card-content");
    const url = node.url || "";
    content.createDiv("link-url").textContent = url;
    if (this.config.showMetadata) {
      this.addCardToolbar(card, node);
    }
    if (this.config.enableHover) {
      this.addHoverEffects(card);
    }
    return card;
  }
  /**
   * 添加卡片工具栏
   */
  addCardToolbar(card, node) {
    const toolbar = card.createDiv("card-toolbar");
    const editBtn = toolbar.createEl("button", {
      cls: "card-action-btn edit-btn",
      attr: { "aria-label": "\u7F16\u8F91" }
    });
    (0, import_obsidian2.setIcon)(editBtn, "edit");
    editBtn.addEventListener("click", () => this.editCard(node));
    const deleteBtn = toolbar.createEl("button", {
      cls: "card-action-btn delete-btn",
      attr: { "aria-label": "\u5220\u9664" }
    });
    (0, import_obsidian2.setIcon)(deleteBtn, "trash");
    deleteBtn.addEventListener("click", () => this.deleteCard(node));
    const copyBtn = toolbar.createEl("button", {
      cls: "card-action-btn copy-btn",
      attr: { "aria-label": "\u590D\u5236" }
    });
    (0, import_obsidian2.setIcon)(copyBtn, "copy");
    copyBtn.addEventListener("click", () => this.copyCard(node));
  }
  /**
   * 添加悬停效果
   */
  addHoverEffects(card) {
    card.addEventListener("mouseenter", () => {
      card.addClass("card-hover");
    });
    card.addEventListener("mouseleave", () => {
      card.removeClass("card-hover");
    });
  }
  /**
   * 编辑卡片
   */
  editCard(node) {
    console.log("\u7F16\u8F91\u5361\u7247:", node);
  }
  /**
   * 删除卡片
   */
  deleteCard(node) {
    console.log("\u5220\u9664\u5361\u7247:", node);
  }
  /**
   * 复制卡片
   */
  copyCard(node) {
    console.log("\u590D\u5236\u5361\u7247:", node);
  }
  /**
   * 更新配置
   */
  updateConfig(config) {
    this.config = { ...this.config, ...config };
  }
};
var ModalManager = class {
  constructor(app, config) {
    this.activeModals = /* @__PURE__ */ new Map();
    this.app = app;
    this.config = config;
  }
  /**
   * 显示模态窗
   */
  async showModal(type, options = {}) {
    return new Promise((resolve, reject) => {
      let modal;
      switch (type) {
        case "new-card" /* NEW_CARD */:
          modal = this.createNewCardModal(options, resolve, reject);
          break;
        case "edit-card" /* EDIT_CARD */:
          modal = this.createEditCardModal(options, resolve, reject);
          break;
        case "confirm-dialog" /* CONFIRM_DIALOG */:
          modal = this.createConfirmDialog(options, resolve, reject);
          break;
        case "settings" /* SETTINGS */:
          modal = this.createSettingsModal(options, resolve, reject);
          break;
        case "help" /* HELP */:
          modal = this.createHelpModal(options, resolve, reject);
          break;
        case "anki-sync" /* ANKI_SYNC */:
          modal = this.createAnkiSyncModal(options, resolve, reject);
          break;
        case "anki-settings" /* ANKI_SETTINGS */:
          modal = this.createAnkiSettingsModal(options, resolve, reject);
          break;
        case "anki-progress" /* ANKI_PROGRESS */:
          modal = this.createAnkiProgressModal(options, resolve, reject);
          break;
        default:
          reject(new Error(`\u4E0D\u652F\u6301\u7684\u6A21\u6001\u7A97\u7C7B\u578B: ${type}`));
          return;
      }
      const modalId = `${type}-${Date.now()}`;
      this.activeModals.set(modalId, modal);
      const originalClose = modal.close.bind(modal);
      modal.close = () => {
        this.activeModals.delete(modalId);
        originalClose();
      };
      modal.open();
    });
  }
  /**
   * 创建新建卡片模态窗
   */
  createNewCardModal(options, resolve, reject) {
    return new class extends import_obsidian2.Modal {
      constructor(app) {
        super(app);
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: options.title || "\u65B0\u5EFA\u5361\u7247" });
        const typeContainer = contentEl.createDiv("card-type-selection");
        typeContainer.createEl("label", { text: "\u5361\u7247\u7C7B\u578B:" });
        const typeSelect = typeContainer.createEl("select");
        typeSelect.createEl("option", { value: "text", text: "\u6587\u672C\u5361\u7247" });
        typeSelect.createEl("option", { value: "file", text: "\u6587\u4EF6\u5361\u7247" });
        typeSelect.createEl("option", { value: "link", text: "\u94FE\u63A5\u5361\u7247" });
        const contentContainer = contentEl.createDiv("card-content-input");
        contentContainer.createEl("label", { text: "\u5185\u5BB9:" });
        const contentInput = contentContainer.createEl("textarea", {
          attr: {
            placeholder: "\u8BF7\u8F93\u5165\u5361\u7247\u5185\u5BB9...",
            rows: "6"
          }
        });
        const buttonContainer = contentEl.createDiv("modal-buttons");
        const confirmBtn = buttonContainer.createEl("button", {
          cls: "mod-cta",
          text: "\u521B\u5EFA"
        });
        const cancelBtn = buttonContainer.createEl("button", {
          text: "\u53D6\u6D88"
        });
        confirmBtn.addEventListener("click", () => {
          const result = {
            type: typeSelect.value,
            content: contentInput.value.trim()
          };
          if (!result.content) {
            new import_obsidian2.Notice("\u8BF7\u8F93\u5165\u5361\u7247\u5185\u5BB9");
            return;
          }
          resolve(result);
          this.close();
        });
        cancelBtn.addEventListener("click", () => {
          reject(new Error("\u7528\u6237\u53D6\u6D88"));
          this.close();
        });
        contentInput.focus();
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    }(this.app);
  }
  /**
   * 创建编辑卡片模态窗
   */
  createEditCardModal(options, resolve, reject) {
    return new class extends import_obsidian2.Modal {
      constructor(app) {
        super(app);
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: options.title || "\u7F16\u8F91\u5361\u7247" });
        const cardData = options.data || {};
        const contentContainer = contentEl.createDiv("card-content-input");
        contentContainer.createEl("label", { text: "\u5185\u5BB9:" });
        const contentInput = contentContainer.createEl("textarea", {
          attr: {
            rows: "6"
          }
        });
        contentInput.value = cardData.content || "";
        const buttonContainer = contentEl.createDiv("modal-buttons");
        const saveBtn = buttonContainer.createEl("button", {
          cls: "mod-cta",
          text: "\u4FDD\u5B58"
        });
        const cancelBtn = buttonContainer.createEl("button", {
          text: "\u53D6\u6D88"
        });
        saveBtn.addEventListener("click", () => {
          const result = {
            ...cardData,
            content: contentInput.value.trim()
          };
          if (!result.content) {
            new import_obsidian2.Notice("\u8BF7\u8F93\u5165\u5361\u7247\u5185\u5BB9");
            return;
          }
          resolve(result);
          this.close();
        });
        cancelBtn.addEventListener("click", () => {
          reject(new Error("\u7528\u6237\u53D6\u6D88"));
          this.close();
        });
        contentInput.focus();
        contentInput.select();
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    }(this.app);
  }
  /**
   * 创建确认对话框
   */
  createConfirmDialog(options, resolve, reject) {
    return new class extends import_obsidian2.Modal {
      constructor(app) {
        super(app);
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: options.title || "\u786E\u8BA4\u64CD\u4F5C" });
        const messageEl = contentEl.createDiv("confirm-message");
        messageEl.textContent = options.content || "\u786E\u5B9A\u8981\u6267\u884C\u6B64\u64CD\u4F5C\u5417\uFF1F";
        const buttonContainer = contentEl.createDiv("modal-buttons");
        const confirmBtn = buttonContainer.createEl("button", {
          cls: "mod-warning",
          text: "\u786E\u8BA4"
        });
        const cancelBtn = buttonContainer.createEl("button", {
          text: "\u53D6\u6D88"
        });
        confirmBtn.addEventListener("click", () => {
          resolve(true);
          this.close();
        });
        cancelBtn.addEventListener("click", () => {
          resolve(false);
          this.close();
        });
        cancelBtn.focus();
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    }(this.app);
  }
  /**
   * 创建设置模态窗
   */
  createSettingsModal(options, resolve, reject) {
    return new class extends import_obsidian2.Modal {
      constructor(app) {
        super(app);
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: options.title || "\u8BBE\u7F6E" });
        const placeholder = contentEl.createDiv("settings-placeholder");
        placeholder.textContent = "\u8BBE\u7F6E\u754C\u9762 - \u57FA\u7840\u5B9E\u73B0";
        const buttonContainer = contentEl.createDiv("modal-buttons");
        const closeBtn = buttonContainer.createEl("button", {
          cls: "mod-cta",
          text: "\u5173\u95ED"
        });
        closeBtn.addEventListener("click", () => {
          resolve(null);
          this.close();
        });
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    }(this.app);
  }
  /**
   * 创建帮助模态窗
   */
  createHelpModal(options, resolve, reject) {
    return new class extends import_obsidian2.Modal {
      constructor(app) {
        super(app);
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: options.title || "\u5E2E\u52A9" });
        const helpContent = contentEl.createDiv("help-content");
        const title = helpContent.createEl("h3");
        SafeDOMUtils.setTextContent(title, "Canvasgrid Transit \u4F7F\u7528\u6307\u5357");
        const guideItems = [
          "\u62D6\u62FD\u6587\u672C\u5230\u754C\u9762\u521B\u5EFA\u5361\u7247",
          "\u4F7F\u7528\u641C\u7D22\u6846\u67E5\u627E\u5361\u7247",
          "\u70B9\u51FB\u989C\u8272\u7B5B\u9009\u5668\u6309\u989C\u8272\u8FC7\u6EE4",
          "\u4F7F\u7528\u6392\u5E8F\u9009\u9879\u91CD\u65B0\u6392\u5217\u5361\u7247"
        ];
        const guideList = SafeDOMUtils.createList(guideItems, false);
        helpContent.appendChild(guideList);
        const buttonContainer = contentEl.createDiv("modal-buttons");
        const closeBtn = buttonContainer.createEl("button", {
          cls: "mod-cta",
          text: "\u5173\u95ED"
        });
        closeBtn.addEventListener("click", () => {
          resolve(null);
          this.close();
        });
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    }(this.app);
  }
  /**
   * 创建Anki同步模态窗
   */
  createAnkiSyncModal(options, resolve, reject) {
    return new class extends import_obsidian2.Modal {
      constructor(app) {
        super(app);
        this.colorFilterEnabled = true;
        this.selectedColors = options.data?.selectedColors || ["1", "2", "4"];
        this.colorGrid = null;
        this.statsSection = null;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: options.title || "Anki\u540C\u6B65" });
        const syncOptions = contentEl.createDiv("anki-sync-options");
        syncOptions.style.cssText = `
					display: flex;
					flex-direction: column;
					gap: 20px;
					margin: 20px 0;
				`;
        const modeDescription = syncOptions.createDiv("sync-mode-description");
        modeDescription.style.cssText = `
					padding: 12px;
					background: var(--background-secondary);
					border-radius: 6px;
					border: 1px solid var(--background-modifier-border);
					margin-bottom: 16px;
				`;
        const modeTitle = modeDescription.createEl("h4", {
          text: "\u540C\u6B65\u6A21\u5F0F",
          cls: "anki-section-title"
        });
        modeTitle.style.cssText = `
					margin: 0 0 8px 0;
					font-size: 14px;
					font-weight: 600;
					color: var(--text-normal);
				`;
        const modeText = modeDescription.createEl("div", {
          text: this.colorFilterEnabled ? "\u5F53\u524D\u6A21\u5F0F\uFF1A\u989C\u8272\u7B5B\u9009\u540C\u6B65 - \u53EA\u540C\u6B65\u9009\u5B9A\u989C\u8272\u7684\u5361\u7247" : "\u5F53\u524D\u6A21\u5F0F\uFF1A\u5168\u91CF\u540C\u6B65 - \u540C\u6B65Canvas\u4E2D\u7684\u6240\u6709\u5361\u7247",
          cls: "mode-description-text"
        });
        modeText.style.cssText = `
					font-size: 13px;
					color: var(--text-muted);
					line-height: 1.4;
				`;
        const colorSection = syncOptions.createDiv("color-selection");
        colorSection.createEl("h4", {
          text: "\u9009\u62E9\u8981\u540C\u6B65\u7684\u989C\u8272:",
          cls: "anki-section-title"
        });
        this.colorGrid = colorSection.createDiv("anki-color-sync-grid-simplified");
        this.renderColorOptions();
        this.statsSection = syncOptions.createDiv("sync-stats");
        this.updateStats();
        console.log("\u989C\u8272\u7B5B\u9009\u529F\u80FD\u9700\u8981\u5B8C\u6574\u5B9E\u73B0");
        if (!this.colorFilterEnabled) {
          colorSection.style.display = "none";
        }
        const buttonContainer = contentEl.createDiv("modal-buttons");
        buttonContainer.style.cssText = `
					display: flex;
					justify-content: space-between;
					align-items: center;
					gap: 12px;
					margin-top: 20px;
					padding-top: 16px;
					border-top: 1px solid var(--background-modifier-border);
				`;
        const configBtn = buttonContainer.createEl("button", {
          cls: "toolbar-button",
          text: "\u2699\uFE0F \u914D\u7F6E"
        });
        configBtn.onclick = () => {
          new import_obsidian2.Notice("Anki\u914D\u7F6E\u529F\u80FD - \u57FA\u7840\u5B9E\u73B0");
        };
        const filterSwitchContainer = buttonContainer.createDiv("filter-switch-container");
        filterSwitchContainer.style.cssText = `
					display: flex;
					align-items: center;
					gap: 8px;
					padding: 8px 12px;
					background: var(--background-secondary);
					border-radius: 6px;
					border: 1px solid var(--background-modifier-border);
				`;
        const filterSwitchCheckbox = filterSwitchContainer.createEl("input", {
          type: "checkbox",
          cls: "filter-switch-checkbox"
        });
        filterSwitchCheckbox.checked = this.colorFilterEnabled;
        filterSwitchCheckbox.style.cssText = `
					width: 16px;
					height: 16px;
					accent-color: var(--interactive-accent);
					cursor: pointer;
				`;
        const filterSwitchLabel = filterSwitchContainer.createEl("span", {
          text: "\u542F\u7528\u989C\u8272\u7B5B\u9009",
          cls: "filter-switch-label"
        });
        filterSwitchLabel.style.cssText = `
					font-size: 13px;
					color: var(--text-normal);
					cursor: pointer;
					user-select: none;
				`;
        const toggleFilter = () => {
          this.colorFilterEnabled = filterSwitchCheckbox.checked;
          filterSwitchLabel.textContent = this.colorFilterEnabled ? "\u542F\u7528\u989C\u8272\u7B5B\u9009" : "\u540C\u6B65\u6240\u6709\u5361\u7247";
          modeText.textContent = this.colorFilterEnabled ? "\u5F53\u524D\u6A21\u5F0F\uFF1A\u989C\u8272\u7B5B\u9009\u540C\u6B65 - \u53EA\u540C\u6B65\u9009\u5B9A\u989C\u8272\u7684\u5361\u7247" : "\u5F53\u524D\u6A21\u5F0F\uFF1A\u5168\u91CF\u540C\u6B65 - \u540C\u6B65Canvas\u4E2D\u7684\u6240\u6709\u5361\u7247";
          if (this.colorFilterEnabled) {
            colorSection.style.display = "block";
          } else {
            colorSection.style.display = "none";
          }
          this.updateStats();
        };
        filterSwitchCheckbox.addEventListener("change", toggleFilter);
        filterSwitchLabel.addEventListener("click", () => {
          filterSwitchCheckbox.checked = !filterSwitchCheckbox.checked;
          toggleFilter();
        });
        const actionButtons = buttonContainer.createDiv("action-buttons");
        actionButtons.style.cssText = `
					display: flex;
					gap: 12px;
				`;
        const cancelBtn = actionButtons.createEl("button", {
          cls: "mod-cancel",
          text: "\u53D6\u6D88"
        });
        cancelBtn.onclick = () => {
          this.close();
          resolve({ action: "cancel" });
        };
        const syncBtn = actionButtons.createEl("button", {
          cls: "mod-cta",
          text: "\u5F00\u59CB\u540C\u6B65"
        });
        syncBtn.onclick = () => {
          this.close();
          resolve({
            action: "sync",
            data: {
              ...options.data,
              colorFilterEnabled: this.colorFilterEnabled,
              selectedColors: this.colorFilterEnabled ? this.selectedColors : []
            }
          });
        };
      }
      renderColorOptions() {
        if (!this.colorGrid)
          return;
        this.colorGrid.empty();
        const colors = [
          { id: "1", name: "\u7EA2\u8272", desc: "\u91CD\u8981\u5185\u5BB9", color: "#ff6b6b" },
          { id: "2", name: "\u6A59\u8272", desc: "\u5F85\u529E\u4E8B\u9879", color: "#ffa726" },
          { id: "3", name: "\u9EC4\u8272", desc: "\u63D0\u9192\u4E8B\u9879", color: "#ffeb3b" },
          { id: "4", name: "\u7EFF\u8272", desc: "\u5DF2\u5B8C\u6210", color: "#66bb6a" },
          { id: "5", name: "\u9752\u8272", desc: "\u8FDB\u884C\u4E2D", color: "#26c6da" },
          { id: "6", name: "\u84DD\u8272", desc: "\u4FE1\u606F\u8D44\u6599", color: "#42a5f5" },
          { id: "7", name: "\u7D2B\u8272", desc: "\u521B\u610F\u60F3\u6CD5", color: "#ab47bc" }
        ];
        colors.forEach((color) => {
          const colorItem = this.colorGrid.createDiv("anki-color-item-simplified");
          const isSelected = this.selectedColors.includes(color.id);
          if (isSelected) {
            colorItem.classList.add("selected");
          }
          const colorDot = colorItem.createDiv("anki-color-dot");
          colorDot.style.backgroundColor = color.color;
          if (isSelected) {
            colorDot.style.borderColor = "var(--interactive-accent)";
            colorDot.style.borderWidth = "3px";
          }
          const colorInfo = colorItem.createDiv("anki-color-info");
          colorInfo.createEl("div", {
            text: color.name,
            cls: "anki-color-name"
          });
          colorInfo.createEl("div", {
            text: color.desc,
            cls: "anki-color-desc"
          });
          const colorCheck = colorItem.createDiv("anki-color-check");
          colorCheck.textContent = isSelected ? "\u2713" : "";
          colorCheck.style.color = isSelected ? "var(--interactive-accent)" : "transparent";
          colorItem.addEventListener("click", () => {
            const index = this.selectedColors.indexOf(color.id);
            if (index > -1) {
              this.selectedColors.splice(index, 1);
            } else {
              this.selectedColors.push(color.id);
            }
            this.renderColorOptions();
            this.updateStats();
          });
        });
      }
      updateStats() {
        if (!this.statsSection)
          return;
        const totalCards = options.data?.totalCards || 0;
        const selectedColorsCount = this.colorFilterEnabled ? this.selectedColors.length : 0;
        const estimatedCards = this.colorFilterEnabled ? Math.floor(totalCards * (selectedColorsCount / 7)) : totalCards;
        this.statsSection.empty();
        const title = this.statsSection.createEl("h4");
        SafeDOMUtils.setTextContent(title, "\u540C\u6B65\u7EDF\u8BA1:");
        SafeDOMUtils.addClasses(title, "anki-stats-title");
        const statsContainer = this.statsSection.createDiv("anki-stats-container");
        const modeRow = statsContainer.createDiv("anki-stats-row");
        const modeLabel = modeRow.createSpan("anki-stats-label");
        SafeDOMUtils.setTextContent(modeLabel, "\u540C\u6B65\u6A21\u5F0F:");
        const modeValue = modeRow.createSpan("anki-stats-value");
        SafeDOMUtils.setTextContent(modeValue, this.colorFilterEnabled ? "\u989C\u8272\u7B5B\u9009" : "\u5168\u91CF\u540C\u6B65");
        const totalRow = statsContainer.createDiv("anki-stats-row");
        const totalLabel = totalRow.createSpan("anki-stats-label");
        SafeDOMUtils.setTextContent(totalLabel, "\u603B\u5361\u7247\u6570:");
        const totalValue = totalRow.createSpan("anki-stats-value");
        SafeDOMUtils.setTextContent(totalValue, totalCards.toString());
        if (this.colorFilterEnabled) {
          const colorRow = statsContainer.createDiv("anki-stats-row");
          const colorLabel = colorRow.createSpan("anki-stats-label");
          SafeDOMUtils.setTextContent(colorLabel, "\u5DF2\u9009\u989C\u8272:");
          const colorValue = colorRow.createSpan("anki-stats-value anki-stats-accent");
          SafeDOMUtils.setTextContent(colorValue, `${selectedColorsCount}/7`);
          const estimateRow = statsContainer.createDiv("anki-stats-row");
          const estimateLabel = estimateRow.createSpan("anki-stats-label");
          SafeDOMUtils.setTextContent(estimateLabel, "\u9884\u8BA1\u540C\u6B65:");
          const estimateValue = estimateRow.createSpan("anki-stats-value anki-stats-success");
          SafeDOMUtils.setTextContent(estimateValue, `${estimatedCards} \u5F20\u5361\u7247`);
        } else {
          const syncRow = statsContainer.createDiv("anki-stats-row");
          const syncLabel = syncRow.createSpan("anki-stats-label");
          SafeDOMUtils.setTextContent(syncLabel, "\u5C06\u540C\u6B65:");
          const syncValue = syncRow.createSpan("anki-stats-value anki-stats-success");
          SafeDOMUtils.setTextContent(syncValue, `\u6240\u6709 ${totalCards} \u5F20\u5361\u7247`);
        }
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    }(this.app);
  }
  /**
   * 创建Anki设置模态窗
   */
  createAnkiSettingsModal(options, resolve, reject) {
    return new class extends import_obsidian2.Modal {
      constructor(app) {
        super(app);
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: options.title || "Anki Connect\u8BBE\u7F6E" });
        const settingsForm = contentEl.createDiv("anki-settings-form");
        settingsForm.style.cssText = `
					display: flex;
					flex-direction: column;
					gap: 16px;
					margin: 20px 0;
				`;
        const urlSection = settingsForm.createDiv("setting-item");
        urlSection.createEl("label", { text: "Anki Connect URL:" });
        const urlInput = urlSection.createEl("input", {
          type: "text",
          value: options.data?.apiUrl || "http://localhost:8765",
          placeholder: "http://localhost:8765"
        });
        const deckSection = settingsForm.createDiv("setting-item");
        deckSection.createEl("label", { text: "\u9ED8\u8BA4\u724C\u7EC4:" });
        const deckInput = deckSection.createEl("input", {
          type: "text",
          value: options.data?.defaultDeck || "Default",
          placeholder: "Default"
        });
        const testSection = settingsForm.createDiv("test-section");
        const testBtn = testSection.createEl("button", {
          cls: "mod-secondary",
          text: "\u6D4B\u8BD5\u8FDE\u63A5"
        });
        const testResult = testSection.createDiv("test-result");
        testBtn.onclick = async () => {
          testResult.textContent = "\u6D4B\u8BD5\u4E2D...";
          setTimeout(() => {
            testResult.textContent = "\u8FDE\u63A5\u6210\u529F\uFF01";
            testResult.style.color = "var(--text-success)";
          }, 1e3);
        };
        const buttonContainer = contentEl.createDiv("modal-buttons");
        buttonContainer.style.cssText = `
					display: flex;
					justify-content: flex-end;
					gap: 12px;
					margin-top: 20px;
				`;
        const cancelBtn = buttonContainer.createEl("button", {
          cls: "mod-cancel",
          text: "\u53D6\u6D88"
        });
        cancelBtn.onclick = () => {
          this.close();
          resolve({ action: "cancel" });
        };
        const saveBtn = buttonContainer.createEl("button", {
          cls: "mod-cta",
          text: "\u4FDD\u5B58"
        });
        saveBtn.onclick = () => {
          const settings = {
            apiUrl: urlInput.value,
            defaultDeck: deckInput.value
          };
          this.close();
          resolve({ action: "save", data: settings });
        };
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    }(this.app);
  }
  /**
   * 创建Anki同步进度模态窗
   */
  createAnkiProgressModal(options, resolve, reject) {
    return new class extends import_obsidian2.Modal {
      constructor(app) {
        super(app);
        this.progressBar = null;
        this.statusText = null;
        this.progressPercent = null;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: options.title || "Anki\u540C\u6B65\u8FDB\u5EA6" });
        const progressContainer = contentEl.createDiv("progress-container");
        progressContainer.style.cssText = `
					margin: 20px 0;
					text-align: center;
				`;
        const progressWrapper = progressContainer.createDiv("progress-wrapper");
        progressWrapper.style.cssText = `
					background: var(--background-secondary);
					border-radius: 10px;
					height: 20px;
					margin: 16px 0;
					overflow: hidden;
				`;
        this.progressBar = progressWrapper.createDiv("progress-bar");
        this.progressBar.style.cssText = `
					background: var(--interactive-accent);
					height: 100%;
					width: 0%;
					transition: width 0.3s ease;
				`;
        this.progressPercent = progressContainer.createDiv("progress-percent");
        this.progressPercent.textContent = "0%";
        this.progressPercent.style.cssText = `
					font-size: 18px;
					font-weight: 600;
					margin-bottom: 8px;
				`;
        this.statusText = progressContainer.createDiv("status-text");
        this.statusText.textContent = "\u51C6\u5907\u5F00\u59CB\u540C\u6B65...";
        this.statusText.style.cssText = `
					color: var(--text-muted);
					font-size: 14px;
				`;
        const detailsContainer = contentEl.createDiv("sync-details");
        detailsContainer.style.cssText = `
					background: var(--background-secondary);
					border-radius: 8px;
					padding: 16px;
					margin: 16px 0;
					font-family: monospace;
					font-size: 12px;
					max-height: 200px;
					overflow-y: auto;
				`;
        const buttonContainer = contentEl.createDiv("modal-buttons");
        buttonContainer.style.cssText = `
					display: flex;
					justify-content: flex-end;
					gap: 12px;
					margin-top: 20px;
				`;
        const cancelBtn = buttonContainer.createEl("button", {
          cls: "mod-cancel",
          text: "\u53D6\u6D88"
        });
        cancelBtn.onclick = () => {
          this.close();
          resolve({ action: "cancel" });
        };
        if (options.data?.completed) {
          const doneBtn = buttonContainer.createEl("button", {
            cls: "mod-cta",
            text: "\u5B8C\u6210"
          });
          doneBtn.onclick = () => {
            this.close();
            resolve({ action: "done" });
          };
        }
      }
      // 更新进度的方法
      updateProgress(percent, status) {
        if (this.progressBar) {
          this.progressBar.style.width = `${percent}%`;
        }
        if (this.progressPercent) {
          this.progressPercent.textContent = `${percent}%`;
        }
        if (this.statusText) {
          this.statusText.textContent = status;
        }
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    }(this.app);
  }
  /**
   * 关闭所有模态窗
   */
  closeAllModals() {
    this.activeModals.forEach((modal) => modal.close());
    this.activeModals.clear();
  }
  /**
   * 更新配置
   */
  updateConfig(config) {
    this.config = { ...this.config, ...config };
  }
};
var UIComponentManager = class {
  constructor(app, config) {
    this.app = app;
    this.config = config;
    this.toolbarManager = new ToolbarManager(app, {
      showMainMenu: true,
      showSearch: true,
      showTimeCapsule: true,
      showColorFilter: true,
      showSortOptions: true
    });
    this.cardRenderer = new CardRendererManager(app, {
      maxPreviewLength: 200,
      showMetadata: true,
      enableHover: true,
      cardSpacing: 16,
      borderRadius: 8
    });
    this.modalManager = new ModalManager(app, {
      width: "600px",
      height: "400px",
      backdrop: true,
      closeOnEscape: true,
      animation: true
    });
  }
  /**
   * 创建工具栏
   */
  createToolbar(container) {
    return this.toolbarManager.createToolbar(container);
  }
  /**
   * 渲染卡片
   */
  renderCard(node, container) {
    const nodeType = this.detectNodeType(node);
    switch (nodeType) {
      case "text":
        return this.cardRenderer.renderTextCard(node, container);
      case "file":
        return this.cardRenderer.renderFileCard(node, container);
      case "link":
        return this.cardRenderer.renderLinkCard(node, container);
      default:
        return this.cardRenderer.renderTextCard(node, container);
    }
  }
  /**
   * 显示模态窗
   */
  async showModal(type, options = {}) {
    return this.modalManager.showModal(type, options);
  }
  /**
   * 检测节点类型
   */
  detectNodeType(node) {
    if (node.file) {
      return "file";
    } else if (node.url) {
      return "link";
    } else {
      return "text";
    }
  }
  /**
   * 更新工具栏配置
   */
  updateToolbarConfig(config) {
    this.toolbarManager.updateConfig(config);
  }
  /**
   * 更新卡片渲染配置
   */
  updateCardRenderConfig(config) {
    this.cardRenderer.updateConfig(config);
  }
  /**
   * 更新模态窗配置
   */
  updateModalConfig(config) {
    this.modalManager.updateConfig(config);
  }
  /**
   * 更新主配置
   */
  updateConfig(config) {
    this.config = { ...this.config, ...config };
    if (config.theme) {
      this.applyTheme(config.theme);
    }
    if (config.language) {
      this.applyLanguage(config.language);
    }
  }
  /**
   * 应用主题
   */
  applyTheme(theme) {
    const body = document.body;
    body.removeClass("canvas-grid-theme-light", "canvas-grid-theme-dark");
    if (theme === "light") {
      body.addClass("canvas-grid-theme-light");
    } else if (theme === "dark") {
      body.addClass("canvas-grid-theme-dark");
    }
  }
  /**
   * 应用语言设置
   */
  applyLanguage(language) {
    console.log("\u5207\u6362\u8BED\u8A00\u5230:", language);
  }
  /**
   * 获取工具栏管理器
   */
  getToolbarManager() {
    return this.toolbarManager;
  }
  /**
   * 获取卡片渲染管理器
   */
  getCardRenderer() {
    return this.cardRenderer;
  }
  /**
   * 获取模态窗管理器
   */
  getModalManager() {
    return this.modalManager;
  }
  /**
   * 销毁所有组件
   */
  destroy() {
    this.toolbarManager.destroy();
    this.modalManager.closeAllModals();
    document.body.removeClass("canvas-grid-theme-light", "canvas-grid-theme-dark");
  }
  /**
   * 验证配置
   */
  validateConfig(config) {
    const errors = [];
    if (!["auto", "light", "dark"].includes(config.theme)) {
      errors.push(`\u65E0\u6548\u7684\u4E3B\u9898\u8BBE\u7F6E: ${config.theme}`);
    }
    if (!["zh", "en"].includes(config.language)) {
      errors.push(`\u65E0\u6548\u7684\u8BED\u8A00\u8BBE\u7F6E: ${config.language}`);
    }
    return {
      valid: errors.length === 0,
      errors
    };
  }
};

// src/utils/DebugManager.ts
var import_obsidian3 = require("obsidian");
var DebugManager = class {
  // 可通过配置控制
  /**
   * 调试日志输出
   */
  static log(message, ...args) {
    if (this.isDebugMode) {
      console.log(`[CanvasGrid] ${message}`, ...args);
    }
  }
  /**
   * 警告日志输出
   */
  static warn(message, ...args) {
    if (this.isDebugMode) {
      console.warn(`[CanvasGrid] ${message}`, ...args);
    }
  }
  /**
   * 错误日志输出（生产环境也会输出）
   */
  static error(message, ...args) {
    console.error(`[CanvasGrid] ${message}`, ...args);
  }
  /**
   * 详细调试信息（仅在verbose模式下输出）
   */
  static verbose(message, ...args) {
    if (this.isDebugMode && this.isVerboseMode) {
      console.log(`[CanvasGrid:Verbose] ${message}`, ...args);
    }
  }
  /**
   * 性能计时开始
   */
  static timeStart(label) {
    if (this.isDebugMode) {
      console.time(`[CanvasGrid:Timer] ${label}`);
    }
  }
  /**
   * 性能计时结束
   */
  static timeEnd(label) {
    if (this.isDebugMode) {
      console.timeEnd(`[CanvasGrid:Timer] ${label}`);
    }
  }
  /**
   * 用户通知（开发环境显示详细信息）
   */
  static notify(message, duration = 3e3, debugInfo) {
    if (this.isDebugMode && debugInfo) {
      new import_obsidian3.Notice(`${message} (Debug: ${JSON.stringify(debugInfo)})`, duration);
      this.log("User notification with debug info:", { message, debugInfo });
    } else {
      new import_obsidian3.Notice(message, duration);
    }
  }
  /**
   * 条件调试输出
   */
  static logIf(condition, message, ...args) {
    if (condition && this.isDebugMode) {
      this.log(message, ...args);
    }
  }
  /**
   * 对象深度检查（开发环境）
   */
  static inspect(obj, label) {
    if (this.isDebugMode) {
      const prefix = label ? `[${label}] ` : "";
      console.log(`${prefix}Object inspection:`, {
        type: typeof obj,
        constructor: obj?.constructor?.name,
        keys: obj && typeof obj === "object" ? Object.keys(obj) : "N/A",
        value: obj
      });
    }
  }
  /**
   * 函数执行追踪
   */
  static trace(functionName, args) {
    if (this.isDebugMode) {
      console.trace(`[CanvasGrid:Trace] ${functionName}`, args);
    }
  }
  /**
   * 断言检查（开发环境）
   */
  static assert(condition, message) {
    if (this.isDebugMode && !condition) {
      console.assert(condition, `[CanvasGrid:Assert] ${message}`);
      throw new Error(`Assertion failed: ${message}`);
    }
  }
};
DebugManager.isDebugMode = true;
DebugManager.isVerboseMode = false;

// src/managers/SearchAndFilterManager.ts
var BasicSearchStrategy = class {
  constructor() {
    this.name = "basic";
  }
  search(nodes, query, config) {
    if (!query.trim()) {
      return nodes;
    }
    const searchTerm = config.caseSensitive ? query : query.toLowerCase();
    return nodes.filter((node) => {
      return this.matchesNode(node, searchTerm, config);
    });
  }
  validate(query) {
    return query.length <= 1e3;
  }
  matchesNode(node, searchTerm, config) {
    if (config.searchInContent && node.text) {
      const content = config.caseSensitive ? node.text : node.text.toLowerCase();
      if (this.matchesText(content, searchTerm, config)) {
        return true;
      }
    }
    if (config.searchInFilenames && node.file) {
      const filename = config.caseSensitive ? node.file : node.file.toLowerCase();
      if (this.matchesText(filename, searchTerm, config)) {
        return true;
      }
    }
    if (node.url) {
      const url = config.caseSensitive ? node.url : node.url.toLowerCase();
      if (this.matchesText(url, searchTerm, config)) {
        return true;
      }
    }
    return false;
  }
  matchesText(text, searchTerm, config) {
    if (config.wholeWord) {
      const regex = new RegExp(`\\b${this.escapeRegex(searchTerm)}\\b`, config.caseSensitive ? "g" : "gi");
      return regex.test(text);
    } else {
      return text.includes(searchTerm);
    }
  }
  escapeRegex(text) {
    return text.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
};
var RegexSearchStrategy = class {
  constructor() {
    this.name = "regex";
  }
  search(nodes, query, config) {
    if (!query.trim()) {
      return nodes;
    }
    try {
      const flags = config.caseSensitive ? "g" : "gi";
      const regex = new RegExp(query, flags);
      return nodes.filter((node) => {
        return this.matchesNodeRegex(node, regex, config);
      });
    } catch (error) {
      console.warn("Invalid regex pattern:", query, error);
      return [];
    }
  }
  validate(query) {
    try {
      new RegExp(query);
      return true;
    } catch {
      return false;
    }
  }
  matchesNodeRegex(node, regex, config) {
    regex.lastIndex = 0;
    if (config.searchInContent && node.text && regex.test(node.text)) {
      return true;
    }
    regex.lastIndex = 0;
    if (config.searchInFilenames && node.file && regex.test(node.file)) {
      return true;
    }
    regex.lastIndex = 0;
    if (node.url && regex.test(node.url)) {
      return true;
    }
    return false;
  }
};
var FuzzySearchStrategy = class {
  constructor() {
    this.name = "fuzzy";
  }
  search(nodes, query, config) {
    if (!query.trim()) {
      return nodes;
    }
    const searchTerm = config.caseSensitive ? query : query.toLowerCase();
    const results = nodes.map((node) => ({
      node,
      score: this.calculateFuzzyScore(node, searchTerm, config)
    })).filter((result) => result.score > 0);
    results.sort((a, b) => b.score - a.score);
    return results.map((result) => result.node);
  }
  validate(query) {
    return query.length <= 100;
  }
  calculateFuzzyScore(node, searchTerm, config) {
    let maxScore = 0;
    if (config.searchInContent && node.text) {
      const content = config.caseSensitive ? node.text : node.text.toLowerCase();
      maxScore = Math.max(maxScore, this.fuzzyMatch(content, searchTerm));
    }
    if (config.searchInFilenames && node.file) {
      const filename = config.caseSensitive ? node.file : node.file.toLowerCase();
      maxScore = Math.max(maxScore, this.fuzzyMatch(filename, searchTerm));
    }
    if (node.url) {
      const url = config.caseSensitive ? node.url : node.url.toLowerCase();
      maxScore = Math.max(maxScore, this.fuzzyMatch(url, searchTerm));
    }
    return maxScore;
  }
  fuzzyMatch(text, pattern) {
    if (pattern.length === 0)
      return 0;
    if (text.length === 0)
      return 0;
    let score = 0;
    let patternIndex = 0;
    let previousMatchIndex = -1;
    for (let i = 0; i < text.length && patternIndex < pattern.length; i++) {
      if (text[i] === pattern[patternIndex]) {
        score += 1;
        if (i === previousMatchIndex + 1) {
          score += 0.5;
        }
        previousMatchIndex = i;
        patternIndex++;
      }
    }
    if (patternIndex === pattern.length) {
      score += pattern.length;
    }
    return score / (text.length + pattern.length);
  }
};
var FilterManager = class {
  constructor(config) {
    this.config = config;
  }
  /**
   * 应用过滤条件
   */
  applyFilters(nodes, criteria) {
    let filteredNodes = [...nodes];
    if (this.config.enableColorFilter && criteria.colors && criteria.colors.length > 0) {
      filteredNodes = filteredNodes.filter(
        (node) => criteria.colors.includes(node.color || "default")
      );
    }
    if (this.config.enableTypeFilter && criteria.types && criteria.types.length > 0) {
      filteredNodes = filteredNodes.filter((node) => {
        const nodeType = this.getNodeType(node);
        return criteria.types.includes(nodeType);
      });
    }
    if (this.config.enableDateFilter && criteria.dateRange) {
      filteredNodes = filteredNodes.filter((node) => {
        const nodeDate = this.getNodeDate(node);
        if (!nodeDate)
          return false;
        return nodeDate >= criteria.dateRange.start && nodeDate <= criteria.dateRange.end;
      });
    }
    if (this.config.enableSizeFilter && criteria.sizeRange) {
      filteredNodes = filteredNodes.filter((node) => {
        const nodeSize = this.getNodeSize(node);
        return nodeSize >= criteria.sizeRange.min && nodeSize <= criteria.sizeRange.max;
      });
    }
    return filteredNodes;
  }
  getNodeType(node) {
    if (node.file)
      return "file";
    if (node.url)
      return "link";
    if (node.text)
      return "text";
    return "unknown";
  }
  getNodeDate(node) {
    if (node.createdAt) {
      return new Date(node.createdAt);
    }
    if (node.updatedAt) {
      return new Date(node.updatedAt);
    }
    return null;
  }
  getNodeSize(node) {
    let size = 0;
    if (node.text)
      size += node.text.length;
    if (node.file)
      size += node.file.length;
    if (node.url)
      size += node.url.length;
    return size;
  }
  /**
   * 更新配置
   */
  updateConfig(config) {
    this.config = { ...this.config, ...config };
  }
};
var SortManager = class {
  constructor(config) {
    this.config = config;
  }
  /**
   * 排序节点
   */
  sortNodes(nodes) {
    const sortedNodes = [...nodes];
    sortedNodes.sort((a, b) => {
      let comparison = 0;
      switch (this.config.sortBy) {
        case "name":
          comparison = this.compareByName(a, b);
          break;
        case "date":
          comparison = this.compareByDate(a, b);
          break;
        case "size":
          comparison = this.compareBySize(a, b);
          break;
        case "type":
          comparison = this.compareByType(a, b);
          break;
        case "color":
          comparison = this.compareByColor(a, b);
          break;
        default:
          comparison = 0;
      }
      return this.config.sortOrder === "desc" ? -comparison : comparison;
    });
    return sortedNodes;
  }
  compareByName(a, b) {
    const nameA = this.getNodeName(a).toLowerCase();
    const nameB = this.getNodeName(b).toLowerCase();
    return nameA.localeCompare(nameB);
  }
  compareByDate(a, b) {
    const dateA = this.getNodeDate(a);
    const dateB = this.getNodeDate(b);
    if (!dateA && !dateB)
      return 0;
    if (!dateA)
      return 1;
    if (!dateB)
      return -1;
    return dateA.getTime() - dateB.getTime();
  }
  compareBySize(a, b) {
    const sizeA = this.getNodeSize(a);
    const sizeB = this.getNodeSize(b);
    return sizeA - sizeB;
  }
  compareByType(a, b) {
    const typeA = this.getNodeType(a);
    const typeB = this.getNodeType(b);
    return typeA.localeCompare(typeB);
  }
  compareByColor(a, b) {
    const colorA = a.color || "default";
    const colorB = b.color || "default";
    return colorA.localeCompare(colorB);
  }
  getNodeName(node) {
    if (node.file)
      return node.file;
    if (node.text)
      return node.text.substring(0, 50);
    if (node.url)
      return node.url;
    return "Untitled";
  }
  getNodeDate(node) {
    if (node.createdAt)
      return new Date(node.createdAt);
    if (node.updatedAt)
      return new Date(node.updatedAt);
    return null;
  }
  getNodeSize(node) {
    let size = 0;
    if (node.text)
      size += node.text.length;
    if (node.file)
      size += node.file.length;
    if (node.url)
      size += node.url.length;
    return size;
  }
  getNodeType(node) {
    if (node.file)
      return "file";
    if (node.url)
      return "link";
    if (node.text)
      return "text";
    return "unknown";
  }
  /**
   * 更新配置
   */
  updateConfig(config) {
    this.config = { ...this.config, ...config };
  }
};
var SearchAndFilterManager = class {
  constructor(app, searchConfig, filterConfig, sortConfig) {
    this.searchStrategies = /* @__PURE__ */ new Map();
    this.searchTimeout = null;
    this.lastSearchQuery = "";
    this.lastSearchResults = null;
    this.app = app;
    this.searchConfig = searchConfig;
    this.filterConfig = filterConfig;
    this.sortConfig = sortConfig;
    this.initializeSearchStrategies();
    this.currentStrategy = this.searchStrategies.get("basic");
    this.filterManager = new FilterManager(filterConfig);
    this.sortManager = new SortManager(sortConfig);
  }
  /**
   * 初始化搜索策略
   */
  initializeSearchStrategies() {
    this.searchStrategies.set("basic", new BasicSearchStrategy());
    this.searchStrategies.set("regex", new RegexSearchStrategy());
    this.searchStrategies.set("fuzzy", new FuzzySearchStrategy());
  }
  /**
   * 执行搜索
   */
  async search(nodes, query) {
    const startTime = performance.now();
    if (this.searchTimeout) {
      clearTimeout(this.searchTimeout);
    }
    if (query === this.lastSearchQuery && this.lastSearchResults) {
      return this.lastSearchResults;
    }
    return new Promise((resolve) => {
      this.searchTimeout = setTimeout(() => {
        const searchResults = this.performSearch(nodes, query, startTime);
        this.lastSearchQuery = query;
        this.lastSearchResults = searchResults;
        resolve(searchResults);
      }, this.searchConfig.debounceDelay);
    });
  }
  /**
   * 执行实际搜索
   */
  performSearch(nodes, query, startTime) {
    try {
      if (!this.currentStrategy.validate(query)) {
        return {
          nodes: [],
          totalCount: nodes.length,
          filteredCount: 0,
          searchTime: performance.now() - startTime,
          query
        };
      }
      const searchedNodes = this.currentStrategy.search(nodes, query, this.searchConfig);
      const endTime = performance.now();
      return {
        nodes: searchedNodes,
        totalCount: nodes.length,
        filteredCount: searchedNodes.length,
        searchTime: endTime - startTime,
        query
      };
    } catch (error) {
      DebugManager.error("Search error:", error);
      return {
        nodes: [],
        totalCount: nodes.length,
        filteredCount: 0,
        searchTime: performance.now() - startTime,
        query
      };
    }
  }
  /**
   * 应用过滤器
   */
  applyFilters(nodes, criteria) {
    return this.filterManager.applyFilters(nodes, criteria);
  }
  /**
   * 排序节点
   */
  sortNodes(nodes) {
    return this.sortManager.sortNodes(nodes);
  }
  /**
   * 执行完整的搜索、过滤和排序流程
   */
  async searchFilterAndSort(nodes, query, filterCriteria = {}) {
    const searchResult = await this.search(nodes, query);
    const filteredNodes = this.applyFilters(searchResult.nodes, filterCriteria);
    const sortedNodes = this.sortNodes(filteredNodes);
    return {
      ...searchResult,
      nodes: sortedNodes,
      filteredCount: sortedNodes.length
    };
  }
  /**
   * 切换搜索策略
   */
  setSearchStrategy(strategyName) {
    const strategy = this.searchStrategies.get(strategyName);
    if (strategy) {
      this.currentStrategy = strategy;
      this.clearSearchCache();
      return true;
    }
    return false;
  }
  /**
   * 获取当前搜索策略
   */
  getCurrentStrategy() {
    return this.currentStrategy.name;
  }
  /**
   * 获取可用的搜索策略
   */
  getAvailableStrategies() {
    return Array.from(this.searchStrategies.keys());
  }
  /**
   * 清除搜索缓存
   */
  clearSearchCache() {
    this.lastSearchQuery = "";
    this.lastSearchResults = null;
    if (this.searchTimeout) {
      clearTimeout(this.searchTimeout);
      this.searchTimeout = null;
    }
  }
  /**
   * 更新搜索配置
   */
  updateSearchConfig(config) {
    this.searchConfig = { ...this.searchConfig, ...config };
    this.clearSearchCache();
  }
  /**
   * 更新过滤配置
   */
  updateFilterConfig(config) {
    this.filterConfig = { ...this.filterConfig, ...config };
    this.filterManager.updateConfig(config);
  }
  /**
   * 更新排序配置
   */
  updateSortConfig(config) {
    this.sortConfig = { ...this.sortConfig, ...config };
    this.sortManager.updateConfig(config);
  }
  /**
   * 获取搜索统计信息
   */
  getSearchStats() {
    return {
      lastQuery: this.lastSearchQuery,
      lastResultCount: this.lastSearchResults?.filteredCount || 0,
      lastSearchTime: this.lastSearchResults?.searchTime || 0,
      currentStrategy: this.currentStrategy.name
    };
  }
  /**
   * 验证配置
   */
  validateConfigs() {
    const errors = [];
    if (this.searchConfig.debounceDelay < 0) {
      errors.push("\u641C\u7D22\u9632\u6296\u5EF6\u8FDF\u4E0D\u80FD\u4E3A\u8D1F\u6570");
    }
    const validSortFields = ["name", "date", "size", "type", "color", "custom"];
    if (!validSortFields.includes(this.sortConfig.sortBy)) {
      errors.push(`\u65E0\u6548\u7684\u6392\u5E8F\u5B57\u6BB5: ${this.sortConfig.sortBy}`);
    }
    const validSortOrders = ["asc", "desc"];
    if (!validSortOrders.includes(this.sortConfig.sortOrder)) {
      errors.push(`\u65E0\u6548\u7684\u6392\u5E8F\u987A\u5E8F: ${this.sortConfig.sortOrder}`);
    }
    return {
      valid: errors.length === 0,
      errors
    };
  }
  /**
   * 销毁管理器
   */
  destroy() {
    this.clearSearchCache();
    this.searchStrategies.clear();
  }
};

// src/managers/DragDropManager.ts
var import_obsidian4 = require("obsidian");
var TextDragStrategy = class {
  constructor(app, onCreateCard) {
    this.name = "text";
    this.app = app;
    this.onCreateCard = onCreateCard;
  }
  canHandle(dragData) {
    return dragData.type === "text" && dragData.content.trim().length > 0;
  }
  async handleDrop(dragData, dropTarget, position) {
    try {
      const cardData = {
        type: "text",
        content: dragData.content.trim(),
        position,
        sourceFile: dragData.sourceFile,
        sourcePosition: dragData.sourcePosition,
        metadata: dragData.metadata
      };
      if (this.onCreateCard) {
        await this.onCreateCard(cardData);
      }
      return {
        success: true,
        action: "create",
        data: cardData
      };
    } catch (error) {
      return {
        success: false,
        action: "create",
        error: error instanceof Error ? error.message : "\u521B\u5EFA\u6587\u672C\u5361\u7247\u5931\u8D25"
      };
    }
  }
  createPreview(dragData) {
    const preview = document.createElement("div");
    preview.className = "drag-preview text-preview";
    const content = dragData.content.length > 100 ? dragData.content.substring(0, 100) + "..." : dragData.content;
    preview.innerHTML = `
			<div class="preview-header">
				<span class="preview-icon">\u{1F4DD}</span>
				<span class="preview-title">\u6587\u672C\u5361\u7247</span>
			</div>
			<div class="preview-content">${content}</div>
		`;
    return preview;
  }
};
var FileDragStrategy = class {
  constructor(app, onCreateCard) {
    this.name = "file";
    this.app = app;
    this.onCreateCard = onCreateCard;
  }
  canHandle(dragData) {
    return dragData.type === "file" && dragData.sourceFile != null;
  }
  async handleDrop(dragData, dropTarget, position) {
    try {
      const cardData = {
        type: "file",
        file: dragData.sourceFile?.path || dragData.content,
        position,
        metadata: dragData.metadata
      };
      if (this.onCreateCard) {
        await this.onCreateCard(cardData);
      }
      return {
        success: true,
        action: "create",
        data: cardData
      };
    } catch (error) {
      return {
        success: false,
        action: "create",
        error: error instanceof Error ? error.message : "\u521B\u5EFA\u6587\u4EF6\u5361\u7247\u5931\u8D25"
      };
    }
  }
  createPreview(dragData) {
    const preview = document.createElement("div");
    preview.className = "drag-preview file-preview";
    const fileName = dragData.sourceFile?.name || dragData.content;
    preview.innerHTML = `
			<div class="preview-header">
				<span class="preview-icon">\u{1F4C4}</span>
				<span class="preview-title">\u6587\u4EF6\u5361\u7247</span>
			</div>
			<div class="preview-content">${fileName}</div>
		`;
    return preview;
  }
};
var URLDragStrategy = class {
  constructor(app, onCreateCard) {
    this.name = "url";
    this.app = app;
    this.onCreateCard = onCreateCard;
  }
  canHandle(dragData) {
    return dragData.type === "url" || this.isValidURL(dragData.content);
  }
  async handleDrop(dragData, dropTarget, position) {
    try {
      const cardData = {
        type: "link",
        url: dragData.content,
        position,
        metadata: dragData.metadata
      };
      if (this.onCreateCard) {
        await this.onCreateCard(cardData);
      }
      return {
        success: true,
        action: "create",
        data: cardData
      };
    } catch (error) {
      return {
        success: false,
        action: "create",
        error: error instanceof Error ? error.message : "\u521B\u5EFA\u94FE\u63A5\u5361\u7247\u5931\u8D25"
      };
    }
  }
  createPreview(dragData) {
    const preview = document.createElement("div");
    preview.className = "drag-preview url-preview";
    preview.innerHTML = `
			<div class="preview-header">
				<span class="preview-icon">\u{1F517}</span>
				<span class="preview-title">\u94FE\u63A5\u5361\u7247</span>
			</div>
			<div class="preview-content">${dragData.content}</div>
		`;
    return preview;
  }
  isValidURL(text) {
    try {
      new URL(text);
      return true;
    } catch {
      return false;
    }
  }
};
var BrowserDragStrategy = class {
  constructor(app, onCreateCard) {
    this.name = "browser";
    this.app = app;
    this.onCreateCard = onCreateCard;
  }
  canHandle(dragData) {
    return !!(dragData.metadata?.source === "html-link" || dragData.metadata?.originalHTML || dragData.type === "url" && dragData.metadata?.originalText);
  }
  async handleDrop(dragData, dropTarget, position) {
    try {
      let content = "";
      let sourceUrl = "";
      if (dragData.type === "url") {
        sourceUrl = dragData.content;
        if (dragData.metadata?.originalText) {
          content = dragData.metadata.originalText.trim();
          if (content !== sourceUrl) {
            content += `

\u{1F4CD} \u6765\u6E90: ${sourceUrl}`;
          }
        } else {
          content = sourceUrl;
        }
      } else {
        content = dragData.content;
        if (dragData.metadata?.source === "html-link") {
          const originalHTML = dragData.metadata.originalHTML;
          if (originalHTML) {
            const urlMatch = originalHTML.match(/href=["']([^"']+)["']/);
            if (urlMatch) {
              sourceUrl = urlMatch[1];
              content += `

\u{1F4CD} \u6765\u6E90: ${sourceUrl}`;
            }
          }
        }
      }
      const cardData = {
        type: sourceUrl ? "link" : "text",
        content,
        url: sourceUrl || void 0,
        position,
        metadata: {
          ...dragData.metadata,
          source: "browser-drag",
          hasSourceLink: !!sourceUrl,
          timestamp: Date.now()
        }
      };
      if (this.onCreateCard) {
        await this.onCreateCard(cardData);
      }
      return {
        success: true,
        action: "create",
        data: cardData
      };
    } catch (error) {
      return {
        success: false,
        action: "create",
        error: error instanceof Error ? error.message : "\u521B\u5EFA\u6D4F\u89C8\u5668\u62D6\u62FD\u5361\u7247\u5931\u8D25"
      };
    }
  }
  createPreview(dragData) {
    const preview = document.createElement("div");
    preview.className = "drag-preview browser-preview";
    const isLink = dragData.type === "url" || dragData.metadata?.source === "html-link";
    const content = dragData.metadata?.originalText || dragData.content;
    const sourceUrl = dragData.type === "url" ? dragData.content : (dragData.metadata?.originalHTML?.match(/href=["']([^"']+)["']/) || [])[1];
    preview.innerHTML = `
			<div class="preview-header">
				<span class="preview-icon">${isLink ? "\u{1F310}" : "\u{1F4DD}"}</span>
				<span class="preview-title">${isLink ? "\u6D4F\u89C8\u5668\u94FE\u63A5" : "\u6D4F\u89C8\u5668\u5185\u5BB9"}</span>
			</div>
			<div class="preview-content">${content.length > 100 ? content.substring(0, 100) + "..." : content}</div>
			${sourceUrl ? `<div class="preview-source">\u6765\u6E90: ${sourceUrl}</div>` : ""}
		`;
    return preview;
  }
};
var DragDropManager = class {
  constructor(app, config) {
    this.strategies = /* @__PURE__ */ new Map();
    this.currentDragData = null;
    this.dragPreview = null;
    this.dropZones = /* @__PURE__ */ new Set();
    this.isDragging = false;
    // 事件监听器
    this.dragStartHandler = this.handleDragStart.bind(this);
    this.dragOverHandler = this.handleDragOver.bind(this);
    this.dragEnterHandler = this.handleDragEnter.bind(this);
    this.dragLeaveHandler = this.handleDragLeave.bind(this);
    this.dropHandler = this.handleDrop.bind(this);
    this.dragEndHandler = this.handleDragEnd.bind(this);
    this.app = app;
    this.config = config;
    this.initializeStrategies();
    this.setupEventListeners();
  }
  /**
   * 初始化拖拽策略
   */
  initializeStrategies() {
    this.strategies.set("text", new TextDragStrategy(this.app));
    this.strategies.set("file", new FileDragStrategy(this.app));
    this.strategies.set("url", new URLDragStrategy(this.app));
    this.strategies.set("browser", new BrowserDragStrategy(this.app));
  }
  /**
   * 设置事件监听器
   */
  setupEventListeners() {
    if (this.config.enableDragToCreate || this.config.enableDropFromExternal) {
      document.addEventListener("dragstart", this.dragStartHandler);
      document.addEventListener("dragover", this.dragOverHandler);
      document.addEventListener("dragenter", this.dragEnterHandler);
      document.addEventListener("dragleave", this.dragLeaveHandler);
      document.addEventListener("drop", this.dropHandler);
      document.addEventListener("dragend", this.dragEndHandler);
    }
  }
  /**
   * 注册拖拽策略
   */
  registerStrategy(strategy) {
    this.strategies.set(strategy.name, strategy);
  }
  /**
   * 注册放置区域
   */
  registerDropZone(element, type = "grid") {
    this.dropZones.add(element);
    element.classList.add("canvas-grid-drop-zone");
    element.dataset.dropZoneType = type;
  }
  /**
   * 取消注册放置区域
   */
  unregisterDropZone(element) {
    this.dropZones.delete(element);
    element.classList.remove("canvas-grid-drop-zone", "drop-zone-active");
    delete element.dataset.dropZoneType;
  }
  /**
   * 处理拖拽开始
   */
  handleDragStart(event) {
    const dragEvent = event;
    if (!this.config.enableDragToCreate)
      return;
    this.currentDragData = this.extractDragData(dragEvent);
    if (this.currentDragData) {
      this.isDragging = true;
      if (this.config.dragPreview) {
        this.createDragPreview(this.currentDragData);
      }
      if (this.config.dropZoneHighlight) {
        this.highlightDropZones(true);
      }
    }
  }
  /**
   * 处理拖拽悬停
   */
  handleDragOver(event) {
    const dragEvent = event;
    if (!this.isDragging)
      return;
    event.preventDefault();
    if (this.dragPreview) {
      this.updateDragPreviewPosition(dragEvent.clientX, dragEvent.clientY);
    }
    if (this.config.autoScroll) {
      this.handleAutoScroll(dragEvent.clientX, dragEvent.clientY);
    }
  }
  /**
   * 处理拖拽进入
   */
  handleDragEnter(event) {
    const target = event.target;
    if (this.isValidDropTarget(target)) {
      target.classList.add("drop-zone-active");
    }
  }
  /**
   * 处理拖拽离开
   */
  handleDragLeave(event) {
    const target = event.target;
    target.classList.remove("drop-zone-active");
  }
  /**
   * 处理放置
   */
  async handleDrop(event) {
    const dragEvent = event;
    event.preventDefault();
    if (!this.isDragging || !this.currentDragData)
      return;
    const target = event.target;
    if (!this.isValidDropTarget(target)) {
      new import_obsidian4.Notice("\u65E0\u6548\u7684\u653E\u7F6E\u76EE\u6807");
      return;
    }
    const position = {
      x: dragEvent.clientX,
      y: dragEvent.clientY
    };
    const strategy = this.findStrategy(this.currentDragData);
    if (strategy) {
      try {
        const result = await strategy.handleDrop(this.currentDragData, target, position);
        if (result.success) {
          new import_obsidian4.Notice("\u6210\u529F\u521B\u5EFA\u5361\u7247");
        } else {
          new import_obsidian4.Notice(`\u521B\u5EFA\u5931\u8D25: ${result.error}`);
        }
      } catch (error) {
        console.error("Drop handling error:", error);
        new import_obsidian4.Notice("\u5904\u7406\u62D6\u62FD\u5931\u8D25");
      }
    } else {
      new import_obsidian4.Notice("\u4E0D\u652F\u6301\u7684\u62D6\u62FD\u7C7B\u578B");
    }
  }
  /**
   * 处理拖拽结束
   */
  handleDragEnd(event) {
    this.isDragging = false;
    this.currentDragData = null;
    if (this.dragPreview) {
      this.dragPreview.remove();
      this.dragPreview = null;
    }
    this.highlightDropZones(false);
    this.dropZones.forEach((zone) => {
      zone.classList.remove("drop-zone-active");
    });
  }
  /**
   * 提取拖拽数据
   */
  extractDragData(event) {
    const dataTransfer = event.dataTransfer;
    if (!dataTransfer)
      return null;
    const obsidianText = dataTransfer.getData("application/obsidian-text");
    if (obsidianText) {
      return {
        type: "text",
        content: obsidianText,
        metadata: {
          source: "obsidian-editor",
          timestamp: Date.now()
        }
      };
    }
    const obsidianFile = dataTransfer.getData("application/obsidian-file");
    if (obsidianFile) {
      try {
        const fileData = JSON.parse(obsidianFile);
        return {
          type: "file",
          content: fileData.path || fileData.name || obsidianFile,
          metadata: {
            source: "obsidian-file",
            fileData,
            timestamp: Date.now()
          }
        };
      } catch (error) {
        return {
          type: "text",
          content: obsidianFile
        };
      }
    }
    const url = dataTransfer.getData("text/uri-list");
    if (url && this.isValidURL(url.trim())) {
      return {
        type: "url",
        content: url.trim(),
        metadata: {
          source: "external-url",
          timestamp: Date.now()
        }
      };
    }
    const html = dataTransfer.getData("text/html");
    if (html) {
      const urlMatch = html.match(/href=["']([^"']+)["']/);
      if (urlMatch && this.isValidURL(urlMatch[1])) {
        const textContent = this.extractTextFromHTML(html);
        return {
          type: "url",
          content: urlMatch[1],
          metadata: {
            source: "html-link",
            originalText: textContent,
            originalHTML: html,
            timestamp: Date.now()
          }
        };
      }
    }
    const text = dataTransfer.getData("text/plain");
    if (text && text.trim()) {
      if (this.isValidURL(text.trim())) {
        return {
          type: "url",
          content: text.trim(),
          metadata: {
            source: "text-url",
            timestamp: Date.now()
          }
        };
      }
      return {
        type: "text",
        content: text.trim(),
        metadata: {
          source: "external-text",
          timestamp: Date.now()
        }
      };
    }
    return null;
  }
  /**
   * 🔧 新增：验证URL有效性
   */
  isValidURL(text) {
    try {
      const url = new URL(text);
      return url.protocol === "http:" || url.protocol === "https:" || url.protocol === "file:";
    } catch {
      return false;
    }
  }
  /**
   * 🔧 新增：从HTML中提取文本内容
   */
  extractTextFromHTML(html) {
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = html;
    return tempDiv.textContent || tempDiv.innerText || "";
  }
  /**
   * 查找合适的策略
   */
  findStrategy(dragData) {
    for (const strategy of this.strategies.values()) {
      if (strategy.canHandle(dragData)) {
        return strategy;
      }
    }
    return null;
  }
  /**
   * 创建拖拽预览
   */
  createDragPreview(dragData) {
    const strategy = this.findStrategy(dragData);
    if (strategy && strategy.createPreview) {
      this.dragPreview = strategy.createPreview(dragData);
      this.dragPreview.style.position = "fixed";
      this.dragPreview.style.pointerEvents = "none";
      this.dragPreview.style.zIndex = "10000";
      document.body.appendChild(this.dragPreview);
    }
  }
  /**
   * 更新拖拽预览位置
   */
  updateDragPreviewPosition(x, y) {
    if (this.dragPreview) {
      this.dragPreview.style.left = `${x + 10}px`;
      this.dragPreview.style.top = `${y + 10}px`;
    }
  }
  /**
   * 高亮放置区域
   */
  highlightDropZones(highlight) {
    this.dropZones.forEach((zone) => {
      if (highlight) {
        zone.classList.add("drop-zone-highlighted");
      } else {
        zone.classList.remove("drop-zone-highlighted");
      }
    });
  }
  /**
   * 检查是否为有效的放置目标
   */
  isValidDropTarget(target) {
    for (const zone of this.dropZones) {
      if (zone.contains(target) || zone === target) {
        return true;
      }
    }
    const gridContainer = target.closest(".canvas-grid-container");
    if (gridContainer) {
      for (const zone of this.dropZones) {
        if (zone.contains(gridContainer) || zone === gridContainer) {
          return true;
        }
      }
    }
    const canvasGridView = target.closest(".canvas-grid-view");
    if (canvasGridView) {
      return true;
    }
    const droppableElements = [
      ".canvas-grid-card",
      ".canvas-grid-empty-state",
      ".canvas-grid-main-content"
    ];
    for (const selector of droppableElements) {
      if (target.matches(selector) || target.closest(selector)) {
        return true;
      }
    }
    return false;
  }
  /**
   * 处理自动滚动
   */
  handleAutoScroll(x, y) {
    const scrollThreshold = 50;
    const scrollSpeed = 10;
    if (y < scrollThreshold) {
      window.scrollBy(0, -scrollSpeed);
    } else if (y > window.innerHeight - scrollThreshold) {
      window.scrollBy(0, scrollSpeed);
    }
    if (x < scrollThreshold) {
      window.scrollBy(-scrollSpeed, 0);
    } else if (x > window.innerWidth - scrollThreshold) {
      window.scrollBy(scrollSpeed, 0);
    }
  }
  /**
   * 更新配置
   */
  updateConfig(config) {
    this.config = { ...this.config, ...config };
    this.removeEventListeners();
    this.setupEventListeners();
  }
  /**
   * 移除事件监听器
   */
  removeEventListeners() {
    document.removeEventListener("dragstart", this.dragStartHandler);
    document.removeEventListener("dragover", this.dragOverHandler);
    document.removeEventListener("dragenter", this.dragEnterHandler);
    document.removeEventListener("dragleave", this.dragLeaveHandler);
    document.removeEventListener("drop", this.dropHandler);
    document.removeEventListener("dragend", this.dragEndHandler);
  }
  /**
   * 销毁管理器
   */
  destroy() {
    this.removeEventListeners();
    if (this.dragPreview) {
      this.dragPreview.remove();
      this.dragPreview = null;
    }
    this.dropZones.forEach((zone) => {
      zone.classList.remove("canvas-grid-drop-zone", "drop-zone-active", "drop-zone-highlighted");
    });
    this.dropZones.clear();
    this.strategies.clear();
    this.isDragging = false;
    this.currentDragData = null;
  }
};

// src/managers/CanvasAPIManager.ts
var StandardCanvasAPIStrategy = class {
  constructor(app) {
    this.name = "standard";
    this.app = app;
  }
  async loadCanvas(file) {
    try {
      const content = await this.app.vault.read(file);
      const rawData = JSON.parse(content);
      if (!this.validateCanvas(rawData)) {
        throw new Error("Invalid canvas format");
      }
      return this.normalizeCanvasData(rawData);
    } catch (error) {
      throw new Error(`Failed to load canvas: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  async saveCanvas(file, data) {
    try {
      const dataWithMetadata = {
        ...data,
        metadata: {
          ...data.metadata,
          modified: (/* @__PURE__ */ new Date()).toISOString(),
          version: "1.0"
        }
      };
      const content = JSON.stringify(dataWithMetadata, null, 2);
      await this.app.vault.modify(file, content);
      return true;
    } catch (error) {
      console.error("Failed to save canvas:", error);
      return false;
    }
  }
  validateCanvas(data) {
    if (!data || typeof data !== "object") {
      return false;
    }
    if (!Array.isArray(data.nodes)) {
      return false;
    }
    if (!Array.isArray(data.edges)) {
      return false;
    }
    for (const node of data.nodes) {
      if (!this.validateNode(node)) {
        return false;
      }
    }
    for (const edge of data.edges) {
      if (!this.validateEdge(edge)) {
        return false;
      }
    }
    return true;
  }
  validateNode(node) {
    return typeof node.id === "string" && typeof node.type === "string" && typeof node.x === "number" && typeof node.y === "number" && typeof node.width === "number" && typeof node.height === "number";
  }
  validateEdge(edge) {
    return typeof edge.id === "string" && typeof edge.fromNode === "string" && typeof edge.toNode === "string" && typeof edge.fromSide === "string" && typeof edge.toSide === "string";
  }
  normalizeCanvasData(rawData) {
    return {
      nodes: rawData.nodes || [],
      edges: rawData.edges || [],
      metadata: {
        version: rawData.metadata?.version || "1.0",
        created: rawData.metadata?.created || (/* @__PURE__ */ new Date()).toISOString(),
        modified: rawData.metadata?.modified || (/* @__PURE__ */ new Date()).toISOString(),
        ...rawData.metadata
      }
    };
  }
};
var EnhancedCanvasAPIStrategy = class {
  constructor(app) {
    this.name = "enhanced";
    this.app = app;
  }
  async loadCanvas(file) {
    try {
      const content = await this.app.vault.read(file);
      const rawData = JSON.parse(content);
      if (!this.validateCanvas(rawData)) {
        throw new Error("Invalid canvas format");
      }
      return this.enhanceCanvasData(rawData);
    } catch (error) {
      throw new Error(`Failed to load canvas: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  async saveCanvas(file, data) {
    try {
      const optimizedData = this.optimizeCanvasData(data);
      const dataWithMetadata = {
        ...optimizedData,
        metadata: {
          ...optimizedData.metadata,
          modified: (/* @__PURE__ */ new Date()).toISOString(),
          version: "2.0",
          optimized: true
        }
      };
      const content = JSON.stringify(dataWithMetadata, null, 2);
      await this.app.vault.modify(file, content);
      return true;
    } catch (error) {
      console.error("Failed to save canvas:", error);
      return false;
    }
  }
  validateCanvas(data) {
    const standardStrategy = new StandardCanvasAPIStrategy(this.app);
    return standardStrategy.validateCanvas(data);
  }
  migrateCanvas(data, fromVersion, toVersion) {
    let migratedData = { ...data };
    if (fromVersion === "1.0" && toVersion === "2.0") {
      migratedData.metadata = {
        ...migratedData.metadata,
        migrated: true,
        migratedFrom: fromVersion,
        migratedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      migratedData.nodes = migratedData.nodes.map((node) => ({
        ...node,
        optimized: true
      }));
    }
    return migratedData;
  }
  enhanceCanvasData(rawData) {
    const nodes = rawData.nodes.map((node) => ({
      ...node,
      id: node.id || this.generateId()
    }));
    const edges = rawData.edges.map((edge) => ({
      ...edge,
      id: edge.id || this.generateId()
    }));
    return {
      nodes,
      edges,
      metadata: {
        version: rawData.metadata?.version || "2.0",
        created: rawData.metadata?.created || (/* @__PURE__ */ new Date()).toISOString(),
        modified: rawData.metadata?.modified || (/* @__PURE__ */ new Date()).toISOString(),
        enhanced: true,
        ...rawData.metadata
      }
    };
  }
  optimizeCanvasData(data) {
    const uniqueNodes = data.nodes.filter(
      (node, index, array) => array.findIndex((n) => n.id === node.id) === index
    );
    const nodeIds = new Set(uniqueNodes.map((node) => node.id));
    const validEdges = data.edges.filter(
      (edge) => nodeIds.has(edge.fromNode) && nodeIds.has(edge.toNode)
    );
    return {
      nodes: uniqueNodes,
      edges: validEdges,
      metadata: {
        version: data.metadata?.version || "2.0",
        created: data.metadata?.created || (/* @__PURE__ */ new Date()).toISOString(),
        modified: data.metadata?.modified || (/* @__PURE__ */ new Date()).toISOString(),
        ...data.metadata,
        optimized: true,
        optimizedAt: (/* @__PURE__ */ new Date()).toISOString()
      }
    };
  }
  generateId() {
    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
  }
};
var CanvasAPIManager = class {
  constructor(app, config) {
    this.strategies = /* @__PURE__ */ new Map();
    this.versionHistory = /* @__PURE__ */ new Map();
    this.autoSaveTimer = null;
    this.app = app;
    this.config = config;
    this.initializeStrategies();
    this.currentStrategy = this.strategies.get("enhanced");
    if (config.enableAutoSave) {
      this.setupAutoSave();
    }
  }
  /**
   * 初始化Canvas API策略
   */
  initializeStrategies() {
    this.strategies.set("standard", new StandardCanvasAPIStrategy(this.app));
    this.strategies.set("enhanced", new EnhancedCanvasAPIStrategy(this.app));
  }
  /**
   * 加载Canvas文件
   */
  async loadCanvas(file) {
    const startTime = Date.now();
    try {
      const data = await this.currentStrategy.loadCanvas(file);
      if (this.config.enableVersionControl) {
        this.saveVersion(file.path, data);
      }
      return {
        success: true,
        data,
        timestamp: startTime
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
        timestamp: startTime
      };
    }
  }
  /**
   * 保存Canvas文件
   */
  async saveCanvas(file, data) {
    const startTime = Date.now();
    try {
      const success = await this.currentStrategy.saveCanvas(file, data);
      if (success && this.config.enableVersionControl) {
        this.saveVersion(file.path, data);
      }
      return {
        success,
        data: success ? data : void 0,
        timestamp: startTime
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
        timestamp: startTime
      };
    }
  }
  /**
   * 验证Canvas数据
   */
  validateCanvas(data) {
    return this.currentStrategy.validateCanvas(data);
  }
  /**
   * 切换API策略
   */
  setStrategy(strategyName) {
    const strategy = this.strategies.get(strategyName);
    if (strategy) {
      this.currentStrategy = strategy;
      return true;
    }
    return false;
  }
  /**
   * 获取当前策略名称
   */
  getCurrentStrategy() {
    return this.currentStrategy.name;
  }
  /**
   * 获取可用策略
   */
  getAvailableStrategies() {
    return Array.from(this.strategies.keys());
  }
  /**
   * 保存版本历史
   */
  saveVersion(filePath, data) {
    if (!this.versionHistory.has(filePath)) {
      this.versionHistory.set(filePath, []);
    }
    const versions = this.versionHistory.get(filePath);
    const version = {
      version: `v${versions.length + 1}`,
      timestamp: Date.now(),
      changes: ["Auto-saved version"],
      data: JSON.parse(JSON.stringify(data))
      // 深拷贝
    };
    versions.push(version);
    if (versions.length > this.config.maxBackupVersions) {
      versions.shift();
    }
  }
  /**
   * 获取版本历史
   */
  getVersionHistory(filePath) {
    return this.versionHistory.get(filePath) || [];
  }
  /**
   * 恢复到指定版本
   */
  async restoreVersion(file, version) {
    const versions = this.versionHistory.get(file.path);
    if (!versions) {
      return {
        success: false,
        error: "No version history found",
        timestamp: Date.now()
      };
    }
    const targetVersion = versions.find((v) => v.version === version);
    if (!targetVersion) {
      return {
        success: false,
        error: `Version ${version} not found`,
        timestamp: Date.now()
      };
    }
    return this.saveCanvas(file, targetVersion.data);
  }
  /**
   * 设置自动保存
   */
  setupAutoSave() {
    if (this.autoSaveTimer) {
      clearInterval(this.autoSaveTimer);
    }
    this.autoSaveTimer = setInterval(() => {
      console.log("Auto-save triggered");
    }, this.config.autoSaveInterval);
  }
  /**
   * 更新配置
   */
  updateConfig(config) {
    this.config = { ...this.config, ...config };
    if (config.enableAutoSave !== void 0) {
      if (config.enableAutoSave) {
        this.setupAutoSave();
      } else if (this.autoSaveTimer) {
        clearInterval(this.autoSaveTimer);
        this.autoSaveTimer = null;
      }
    }
  }
  /**
   * 销毁管理器
   */
  destroy() {
    if (this.autoSaveTimer) {
      clearInterval(this.autoSaveTimer);
      this.autoSaveTimer = null;
    }
    this.versionHistory.clear();
    this.strategies.clear();
  }
};

// src/managers/FileSystemManager.ts
var import_obsidian5 = require("obsidian");
var TextFileStrategy = class {
  constructor(app) {
    this.name = "text";
    this.app = app;
  }
  canHandle(file) {
    const textExtensions = [".md", ".txt", ".json", ".canvas", ".css", ".js", ".ts"];
    return textExtensions.some((ext) => file.path.endsWith(ext));
  }
  async read(file) {
    try {
      return await this.app.vault.read(file);
    } catch (error) {
      throw new Error(`Failed to read text file: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  async write(file, content) {
    try {
      await this.app.vault.modify(file, content);
      return true;
    } catch (error) {
      DebugManager.error("Failed to write text file:", error);
      return false;
    }
  }
  validate(content) {
    return typeof content === "string" && content.length < 10 * 1024 * 1024;
  }
};
var JSONFileStrategy = class {
  constructor(app) {
    this.name = "json";
    this.app = app;
  }
  canHandle(file) {
    return file.path.endsWith(".json") || file.path.endsWith(".canvas");
  }
  async read(file) {
    try {
      const content = await this.app.vault.read(file);
      JSON.parse(content);
      return content;
    } catch (error) {
      throw new Error(`Failed to read JSON file: ${error instanceof Error ? error.message : "Invalid JSON format"}`);
    }
  }
  async write(file, content) {
    try {
      JSON.parse(content);
      await this.app.vault.modify(file, content);
      return true;
    } catch (error) {
      console.error("Failed to write JSON file:", error);
      return false;
    }
  }
  validate(content) {
    try {
      JSON.parse(content);
      return true;
    } catch {
      return false;
    }
  }
};
var BinaryFileStrategy = class {
  constructor(app) {
    this.name = "binary";
    this.app = app;
  }
  canHandle(file) {
    const binaryExtensions = [".png", ".jpg", ".jpeg", ".gif", ".pdf", ".zip"];
    return binaryExtensions.some((ext) => file.path.endsWith(ext));
  }
  async read(file) {
    try {
      const buffer = await this.app.vault.readBinary(file);
      return this.bufferToBase64(buffer);
    } catch (error) {
      throw new Error(`Failed to read binary file: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  async write(file, content) {
    try {
      const buffer = this.base64ToBuffer(content);
      await this.app.vault.modifyBinary(file, buffer);
      return true;
    } catch (error) {
      console.error("Failed to write binary file:", error);
      return false;
    }
  }
  validate(content) {
    try {
      return btoa(atob(content)) === content;
    } catch {
      return false;
    }
  }
  bufferToBase64(buffer) {
    const bytes = new Uint8Array(buffer);
    let binary = "";
    for (let i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  }
  base64ToBuffer(base64) {
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
      bytes[i] = binary.charCodeAt(i);
    }
    return bytes.buffer;
  }
};
var FileSystemManager = class {
  constructor(app, config) {
    this.strategies = /* @__PURE__ */ new Map();
    this.fileWatchers = /* @__PURE__ */ new Map();
    this.backupTimer = null;
    this.fileHistory = /* @__PURE__ */ new Map();
    this.app = app;
    this.config = config;
    this.initializeStrategies();
    this.setupFileWatcher();
    this.setupAutoBackup();
  }
  /**
   * 初始化文件操作策略
   */
  initializeStrategies() {
    this.strategies.set("text", new TextFileStrategy(this.app));
    this.strategies.set("json", new JSONFileStrategy(this.app));
    this.strategies.set("binary", new BinaryFileStrategy(this.app));
  }
  /**
   * 读取文件
   */
  async readFile(file) {
    const startTime = Date.now();
    try {
      if (!this.isAllowedFileType(file)) {
        return {
          success: false,
          error: `File type not allowed: ${file.extension}`,
          timestamp: startTime
        };
      }
      const strategy = this.findStrategy(file);
      if (!strategy) {
        return {
          success: false,
          error: `No strategy found for file: ${file.path}`,
          timestamp: startTime
        };
      }
      const content = await strategy.read(file);
      return {
        success: true,
        file,
        data: content,
        timestamp: startTime
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
        timestamp: startTime
      };
    }
  }
  /**
   * 写入文件
   */
  async writeFile(file, content) {
    const startTime = Date.now();
    try {
      if (!this.isAllowedFileType(file)) {
        return {
          success: false,
          error: `File type not allowed: ${file.extension}`,
          timestamp: startTime
        };
      }
      const strategy = this.findStrategy(file);
      if (!strategy) {
        return {
          success: false,
          error: `No strategy found for file: ${file.path}`,
          timestamp: startTime
        };
      }
      if (this.config.enableFileValidation && strategy.validate && !strategy.validate(content)) {
        return {
          success: false,
          error: "File content validation failed",
          timestamp: startTime
        };
      }
      const success = await strategy.write(file, content);
      if (success) {
        this.recordFileChange({
          type: "modified",
          file,
          timestamp: Date.now()
        });
      }
      return {
        success,
        file: success ? file : void 0,
        timestamp: startTime
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
        timestamp: startTime
      };
    }
  }
  /**
   * 创建文件
   */
  async createFile(path, content = "") {
    const startTime = Date.now();
    try {
      const existingFile = this.app.vault.getAbstractFileByPath(path);
      if (existingFile) {
        return {
          success: false,
          error: `File already exists: ${path}`,
          timestamp: startTime
        };
      }
      const file = await this.app.vault.create(path, content);
      this.recordFileChange({
        type: "created",
        file,
        timestamp: Date.now()
      });
      return {
        success: true,
        file,
        timestamp: startTime
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
        timestamp: startTime
      };
    }
  }
  /**
   * 删除文件
   */
  async deleteFile(file) {
    const startTime = Date.now();
    try {
      if (this.config.enableTrash) {
        await this.app.fileManager.trashFile(file);
      } else {
        await this.app.vault.delete(file);
      }
      this.recordFileChange({
        type: "deleted",
        file,
        timestamp: Date.now()
      });
      return {
        success: true,
        file,
        timestamp: startTime
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
        timestamp: startTime
      };
    }
  }
  /**
   * 重命名文件
   */
  async renameFile(file, newPath) {
    const startTime = Date.now();
    const oldPath = file.path;
    try {
      await this.app.vault.rename(file, newPath);
      this.recordFileChange({
        type: "renamed",
        file,
        oldPath,
        newPath,
        timestamp: Date.now()
      });
      return {
        success: true,
        file,
        timestamp: startTime
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
        timestamp: startTime
      };
    }
  }
  /**
   * 获取文件信息
   */
  getFileInfo(file) {
    return {
      path: file.path,
      name: file.name,
      extension: file.extension,
      size: file.stat.size,
      created: file.stat.ctime,
      modified: file.stat.mtime,
      type: "file",
      exists: true
    };
  }
  /**
   * 搜索文件
   */
  searchFiles(query, folder) {
    const allFiles = this.app.vault.getMarkdownFiles();
    const searchFolder = folder || this.app.vault.getRoot();
    return allFiles.filter((file) => {
      if (!file.path.startsWith(searchFolder.path)) {
        return false;
      }
      return file.name.toLowerCase().includes(query.toLowerCase()) || file.path.toLowerCase().includes(query.toLowerCase());
    });
  }
  /**
   * 获取文件变更历史
   */
  getFileHistory(filePath) {
    return this.fileHistory.get(filePath) || [];
  }
  /**
   * 清理文件历史
   */
  clearFileHistory(filePath) {
    if (filePath) {
      this.fileHistory.delete(filePath);
    } else {
      this.fileHistory.clear();
    }
  }
  /**
   * 查找文件操作策略
   */
  findStrategy(file) {
    for (const strategy of this.strategies.values()) {
      if (strategy.canHandle(file)) {
        return strategy;
      }
    }
    return null;
  }
  /**
   * 检查文件类型是否允许
   */
  isAllowedFileType(file) {
    if (this.config.allowedFileTypes.length === 0) {
      return true;
    }
    return this.config.allowedFileTypes.some(
      (type) => file.path.endsWith(type) || file.extension === type.replace(".", "")
    );
  }
  /**
   * 记录文件变更
   */
  recordFileChange(event) {
    if (!this.config.enableFileHistory) {
      return;
    }
    const filePath = event.file.path;
    if (!this.fileHistory.has(filePath)) {
      this.fileHistory.set(filePath, []);
    }
    const history = this.fileHistory.get(filePath);
    history.push(event);
    if (history.length > 100) {
      history.shift();
    }
  }
  /**
   * 设置文件监听器
   */
  setupFileWatcher() {
    if (!this.config.enableFileWatcher) {
      return;
    }
    this.app.vault.on("create", (file) => {
      if (file instanceof import_obsidian5.TFile) {
        this.recordFileChange({
          type: "created",
          file,
          timestamp: Date.now()
        });
      }
    });
    this.app.vault.on("modify", (file) => {
      if (file instanceof import_obsidian5.TFile) {
        this.recordFileChange({
          type: "modified",
          file,
          timestamp: Date.now()
        });
      }
    });
    this.app.vault.on("delete", (file) => {
      if (file instanceof import_obsidian5.TFile) {
        this.recordFileChange({
          type: "deleted",
          file,
          timestamp: Date.now()
        });
      }
    });
    this.app.vault.on("rename", (file, oldPath) => {
      if (file instanceof import_obsidian5.TFile) {
        this.recordFileChange({
          type: "renamed",
          file,
          oldPath,
          newPath: file.path,
          timestamp: Date.now()
        });
      }
    });
  }
  /**
   * 设置自动备份
   */
  setupAutoBackup() {
    if (!this.config.enableAutoBackup) {
      return;
    }
    this.backupTimer = setInterval(() => {
      this.performAutoBackup();
    }, this.config.backupInterval);
  }
  /**
   * 执行自动备份
   */
  async performAutoBackup() {
    try {
      console.log("Auto backup triggered");
    } catch (error) {
      console.error("Auto backup failed:", error);
    }
  }
  /**
   * 注册文件操作策略
   */
  registerStrategy(strategy) {
    this.strategies.set(strategy.name, strategy);
  }
  /**
   * 更新配置
   */
  updateConfig(config) {
    this.config = { ...this.config, ...config };
    if (config.enableFileWatcher !== void 0) {
    }
    if (config.enableAutoBackup !== void 0) {
      if (this.backupTimer) {
        clearInterval(this.backupTimer);
        this.backupTimer = null;
      }
      if (config.enableAutoBackup) {
        this.setupAutoBackup();
      }
    }
  }
  /**
   * 销毁管理器
   */
  destroy() {
    if (this.backupTimer) {
      clearInterval(this.backupTimer);
      this.backupTimer = null;
    }
    this.fileWatchers.clear();
    this.fileHistory.clear();
    this.strategies.clear();
  }
};

// src/managers/ThemeManager.ts
var AutoThemeStrategy = class {
  constructor() {
    this.name = "auto";
    this.mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
    this.changeHandler = this.handleSystemThemeChange.bind(this);
  }
  apply(config) {
    this.mediaQuery.addEventListener("change", this.changeHandler);
    this.applySystemTheme();
  }
  remove() {
    this.mediaQuery.removeEventListener("change", this.changeHandler);
    this.removeThemeClasses();
  }
  getVariables() {
    const isDark = this.mediaQuery.matches;
    return {
      "--theme-mode": isDark ? "dark" : "light",
      "--is-auto-theme": "1"
    };
  }
  handleSystemThemeChange(e) {
    this.applySystemTheme();
  }
  applySystemTheme() {
    const isDark = this.mediaQuery.matches;
    const body = document.body;
    body.removeClass("canvas-grid-theme-light", "canvas-grid-theme-dark");
    body.addClass(isDark ? "canvas-grid-theme-dark" : "canvas-grid-theme-light");
    body.addClass("canvas-grid-theme-auto");
  }
  removeThemeClasses() {
    const body = document.body;
    body.removeClass("canvas-grid-theme-light", "canvas-grid-theme-dark", "canvas-grid-theme-auto");
  }
};
var LightThemeStrategy = class {
  constructor() {
    this.name = "light";
  }
  apply(config) {
    const body = document.body;
    body.removeClass("canvas-grid-theme-dark", "canvas-grid-theme-auto");
    body.addClass("canvas-grid-theme-light");
    this.applyColorScheme(config.colorScheme);
  }
  remove() {
    const body = document.body;
    body.removeClass("canvas-grid-theme-light");
    this.removeColorScheme();
  }
  getVariables() {
    return {
      "--theme-mode": "light",
      "--is-light-theme": "1"
    };
  }
  applyColorScheme(colorScheme) {
    const root = document.documentElement;
    root.style.setProperty("--canvas-grid-primary", colorScheme.primary);
    root.style.setProperty("--canvas-grid-secondary", colorScheme.secondary);
    root.style.setProperty("--canvas-grid-accent", colorScheme.accent);
    root.style.setProperty("--canvas-grid-background", colorScheme.background);
    root.style.setProperty("--canvas-grid-surface", colorScheme.surface);
    root.style.setProperty("--canvas-grid-text", colorScheme.text);
    root.style.setProperty("--canvas-grid-text-secondary", colorScheme.textSecondary);
    root.style.setProperty("--canvas-grid-border", colorScheme.border);
    root.style.setProperty("--canvas-grid-shadow", colorScheme.shadow);
    root.style.setProperty("--canvas-grid-success", colorScheme.success);
    root.style.setProperty("--canvas-grid-warning", colorScheme.warning);
    root.style.setProperty("--canvas-grid-error", colorScheme.error);
  }
  removeColorScheme() {
    const root = document.documentElement;
    const properties = [
      "--canvas-grid-primary",
      "--canvas-grid-secondary",
      "--canvas-grid-accent",
      "--canvas-grid-background",
      "--canvas-grid-surface",
      "--canvas-grid-text",
      "--canvas-grid-text-secondary",
      "--canvas-grid-border",
      "--canvas-grid-shadow",
      "--canvas-grid-success",
      "--canvas-grid-warning",
      "--canvas-grid-error"
    ];
    properties.forEach((prop) => root.style.removeProperty(prop));
  }
};
var DarkThemeStrategy = class {
  constructor() {
    this.name = "dark";
  }
  apply(config) {
    const body = document.body;
    body.removeClass("canvas-grid-theme-light", "canvas-grid-theme-auto");
    body.addClass("canvas-grid-theme-dark");
    this.applyColorScheme(config.colorScheme);
  }
  remove() {
    const body = document.body;
    body.removeClass("canvas-grid-theme-dark");
    this.removeColorScheme();
  }
  getVariables() {
    return {
      "--theme-mode": "dark",
      "--is-dark-theme": "1"
    };
  }
  applyColorScheme(colorScheme) {
    const root = document.documentElement;
    const darkColorScheme = this.adjustForDarkTheme(colorScheme);
    root.style.setProperty("--canvas-grid-primary", darkColorScheme.primary);
    root.style.setProperty("--canvas-grid-secondary", darkColorScheme.secondary);
    root.style.setProperty("--canvas-grid-accent", darkColorScheme.accent);
    root.style.setProperty("--canvas-grid-background", darkColorScheme.background);
    root.style.setProperty("--canvas-grid-surface", darkColorScheme.surface);
    root.style.setProperty("--canvas-grid-text", darkColorScheme.text);
    root.style.setProperty("--canvas-grid-text-secondary", darkColorScheme.textSecondary);
    root.style.setProperty("--canvas-grid-border", darkColorScheme.border);
    root.style.setProperty("--canvas-grid-shadow", darkColorScheme.shadow);
    root.style.setProperty("--canvas-grid-success", darkColorScheme.success);
    root.style.setProperty("--canvas-grid-warning", darkColorScheme.warning);
    root.style.setProperty("--canvas-grid-error", darkColorScheme.error);
  }
  adjustForDarkTheme(colorScheme) {
    return {
      ...colorScheme,
      background: this.darkenColor(colorScheme.background),
      surface: this.darkenColor(colorScheme.surface),
      text: this.lightenColor(colorScheme.text),
      textSecondary: this.lightenColor(colorScheme.textSecondary),
      border: this.adjustBorderForDark(colorScheme.border)
    };
  }
  darkenColor(color) {
    if (color.startsWith("#")) {
      const hex = color.slice(1);
      const num = parseInt(hex, 16);
      const r = Math.max(0, (num >> 16) - 40);
      const g = Math.max(0, (num >> 8 & 255) - 40);
      const b = Math.max(0, (num & 255) - 40);
      return `#${(r << 16 | g << 8 | b).toString(16).padStart(6, "0")}`;
    }
    return color;
  }
  lightenColor(color) {
    if (color.startsWith("#")) {
      const hex = color.slice(1);
      const num = parseInt(hex, 16);
      const r = Math.min(255, (num >> 16) + 40);
      const g = Math.min(255, (num >> 8 & 255) + 40);
      const b = Math.min(255, (num & 255) + 40);
      return `#${(r << 16 | g << 8 | b).toString(16).padStart(6, "0")}`;
    }
    return color;
  }
  adjustBorderForDark(color) {
    return this.lightenColor(color);
  }
  removeColorScheme() {
    const root = document.documentElement;
    const properties = [
      "--canvas-grid-primary",
      "--canvas-grid-secondary",
      "--canvas-grid-accent",
      "--canvas-grid-background",
      "--canvas-grid-surface",
      "--canvas-grid-text",
      "--canvas-grid-text-secondary",
      "--canvas-grid-border",
      "--canvas-grid-shadow",
      "--canvas-grid-success",
      "--canvas-grid-warning",
      "--canvas-grid-error"
    ];
    properties.forEach((prop) => root.style.removeProperty(prop));
  }
};
var CustomThemeStrategy = class {
  constructor() {
    this.name = "custom";
    this.customStyleElement = null;
  }
  apply(config) {
    const body = document.body;
    body.removeClass("canvas-grid-theme-light", "canvas-grid-theme-dark", "canvas-grid-theme-auto");
    body.addClass("canvas-grid-theme-custom");
    if (config.enableCustomCSS && config.customCSS) {
      this.applyCustomCSS(config.customCSS);
    }
    this.applyColorScheme(config.colorScheme);
  }
  remove() {
    const body = document.body;
    body.removeClass("canvas-grid-theme-custom");
    if (this.customStyleElement) {
      this.customStyleElement.remove();
      this.customStyleElement = null;
    }
    this.removeColorScheme();
  }
  getVariables() {
    return {
      "--theme-mode": "custom",
      "--is-custom-theme": "1"
    };
  }
  applyCustomCSS(css) {
    if (this.customStyleElement) {
      this.customStyleElement.remove();
    }
    this.customStyleElement = document.createElement("style");
    this.customStyleElement.id = "canvas-grid-custom-theme";
    this.customStyleElement.textContent = css;
    document.head.appendChild(this.customStyleElement);
  }
  applyColorScheme(colorScheme) {
    const root = document.documentElement;
    Object.entries(colorScheme).forEach(([key, value]) => {
      const cssVar = `--canvas-grid-${key.replace(/([A-Z])/g, "-$1").toLowerCase()}`;
      root.style.setProperty(cssVar, value);
    });
  }
  removeColorScheme() {
    const root = document.documentElement;
    const properties = [
      "--canvas-grid-primary",
      "--canvas-grid-secondary",
      "--canvas-grid-accent",
      "--canvas-grid-background",
      "--canvas-grid-surface",
      "--canvas-grid-text",
      "--canvas-grid-text-secondary",
      "--canvas-grid-border",
      "--canvas-grid-shadow",
      "--canvas-grid-success",
      "--canvas-grid-warning",
      "--canvas-grid-error"
    ];
    properties.forEach((prop) => root.style.removeProperty(prop));
  }
};
var DEFAULT_COLOR_SCHEMES = {
  default: {
    primary: "#007acc",
    secondary: "#6c757d",
    accent: "#17a2b8",
    background: "#ffffff",
    surface: "#f8f9fa",
    text: "#212529",
    textSecondary: "#6c757d",
    border: "#dee2e6",
    shadow: "rgba(0, 0, 0, 0.1)",
    success: "#28a745",
    warning: "#ffc107",
    error: "#dc3545"
  },
  obsidian: {
    primary: "var(--interactive-accent)",
    secondary: "var(--text-muted)",
    accent: "var(--interactive-accent-hover)",
    background: "var(--background-primary)",
    surface: "var(--background-secondary)",
    text: "var(--text-normal)",
    textSecondary: "var(--text-muted)",
    border: "var(--background-modifier-border)",
    shadow: "var(--background-modifier-box-shadow)",
    success: "var(--text-success)",
    warning: "var(--text-warning)",
    error: "var(--text-error)"
  }
};
var ThemeManager = class {
  constructor(app, config) {
    this.strategies = /* @__PURE__ */ new Map();
    this.currentStrategy = null;
    this.transitionStyleElement = null;
    this.app = app;
    this.config = config;
    this.initializeStrategies();
    this.applyTheme();
  }
  /**
   * 初始化主题策略
   */
  initializeStrategies() {
    this.strategies.set("auto", new AutoThemeStrategy());
    this.strategies.set("light", new LightThemeStrategy());
    this.strategies.set("dark", new DarkThemeStrategy());
    this.strategies.set("custom", new CustomThemeStrategy());
  }
  /**
   * 应用主题
   */
  applyTheme() {
    if (this.currentStrategy) {
      this.currentStrategy.remove();
    }
    if (this.config.enableTransitions) {
      this.applyTransitions();
    }
    const strategy = this.strategies.get(this.config.mode);
    if (!strategy) {
      console.error(`Theme strategy not found: ${this.config.mode}`);
      return;
    }
    this.currentStrategy = strategy;
    strategy.apply(this.config);
    this.applyThemeVariables();
  }
  /**
   * 切换主题模式
   */
  setThemeMode(mode) {
    this.config.mode = mode;
    this.applyTheme();
  }
  /**
   * 更新颜色方案
   */
  updateColorScheme(colorScheme) {
    this.config.colorScheme = { ...this.config.colorScheme, ...colorScheme };
    this.applyTheme();
  }
  /**
   * 设置自定义CSS
   */
  setCustomCSS(css) {
    this.config.customCSS = css;
    this.config.enableCustomCSS = true;
    if (this.config.mode === "custom") {
      this.applyTheme();
    }
  }
  /**
   * 获取当前主题状态
   */
  getThemeState() {
    const currentMode = this.getCurrentMode();
    const variables = this.currentStrategy?.getVariables() || {};
    return {
      currentMode,
      isCustomTheme: this.config.mode === "custom",
      activeColorScheme: this.config.colorScheme,
      cssVariables: variables
    };
  }
  /**
   * 获取当前模式
   */
  getCurrentMode() {
    if (this.config.mode === "auto") {
      return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
    return this.config.mode === "dark" ? "dark" : "light";
  }
  /**
   * 应用过渡效果
   */
  applyTransitions() {
    if (this.transitionStyleElement) {
      this.transitionStyleElement.remove();
    }
    const css = `
			.canvas-grid-container,
			.canvas-grid-toolbar,
			.canvas-card,
			.canvas-grid-button {
				transition: all ${this.config.transitionDuration}ms ease-in-out;
			}
		`;
    this.transitionStyleElement = document.createElement("style");
    this.transitionStyleElement.id = "canvas-grid-transitions";
    this.transitionStyleElement.textContent = css;
    document.head.appendChild(this.transitionStyleElement);
  }
  /**
   * 应用主题变量
   */
  applyThemeVariables() {
    if (!this.currentStrategy)
      return;
    const variables = this.currentStrategy.getVariables();
    const root = document.documentElement;
    Object.entries(variables).forEach(([key, value]) => {
      root.style.setProperty(key, String(value));
    });
  }
  /**
   * 注册主题策略
   */
  registerStrategy(strategy) {
    this.strategies.set(strategy.name, strategy);
  }
  /**
   * 获取可用主题
   */
  getAvailableThemes() {
    return Array.from(this.strategies.keys());
  }
  /**
   * 重置为默认主题
   */
  resetToDefault() {
    this.config = {
      mode: "auto",
      enableTransitions: true,
      transitionDuration: 200,
      enableColorScheme: true,
      colorScheme: DEFAULT_COLOR_SCHEMES.obsidian,
      enableCustomCSS: false,
      customCSS: ""
    };
    this.applyTheme();
  }
  /**
   * 更新配置
   */
  updateConfig(config) {
    this.config = { ...this.config, ...config };
    this.applyTheme();
  }
  /**
   * 销毁主题管理器
   */
  destroy() {
    if (this.currentStrategy) {
      this.currentStrategy.remove();
      this.currentStrategy = null;
    }
    if (this.transitionStyleElement) {
      this.transitionStyleElement.remove();
      this.transitionStyleElement = null;
    }
    this.strategies.clear();
    const root = document.documentElement;
    const properties = [
      "--theme-mode",
      "--is-auto-theme",
      "--is-light-theme",
      "--is-dark-theme",
      "--is-custom-theme"
    ];
    properties.forEach((prop) => root.style.removeProperty(prop));
  }
};

// src/managers/TimeCapsuleManager.ts
var import_obsidian6 = require("obsidian");
var TextTimeCapsuleStrategy = class {
  constructor(app) {
    this.name = "text";
    this.app = app;
  }
  canHandle(type) {
    return type === "text" || type === "clipboard" || type === "selection";
  }
  createCapsule(data) {
    const now = Date.now();
    const duration = data.metadata?.duration || 60;
    return {
      id: this.generateId(),
      title: data.title || "\u6587\u672C\u65F6\u95F4\u80F6\u56CA",
      content: data.content || "",
      type: data.type || "text",
      createdAt: now,
      expiresAt: now + duration * 60 * 1e3,
      isExpired: false,
      isOpened: false,
      metadata: {
        ...data.metadata,
        wordCount: data.content?.length || 0,
        createdBy: "TextTimeCapsuleStrategy"
      }
    };
  }
  async openCapsule(capsule) {
    const tempFileName = `\u65F6\u95F4\u80F6\u56CA-${capsule.title}-${(/* @__PURE__ */ new Date()).toISOString().slice(0, 10)}.md`;
    const tempContent = `# ${capsule.title}

\u521B\u5EFA\u65F6\u95F4: ${new Date(capsule.createdAt).toLocaleString()}
\u5230\u671F\u65F6\u95F4: ${new Date(capsule.expiresAt).toLocaleString()}

---

${capsule.content}`;
    try {
      const tempFile = await this.app.vault.create(tempFileName, tempContent);
      const leaf = this.app.workspace.getUnpinnedLeaf();
      await leaf.openFile(tempFile);
      new import_obsidian6.Notice(`\u65F6\u95F4\u80F6\u56CA"${capsule.title}"\u5DF2\u6253\u5F00`);
    } catch (error) {
      console.error("Failed to open text capsule:", error);
      new import_obsidian6.Notice("\u6253\u5F00\u65F6\u95F4\u80F6\u56CA\u5931\u8D25");
    }
  }
  validateCapsule(capsule) {
    return typeof capsule.content === "string" && capsule.content.length > 0 && capsule.content.length < 1e6;
  }
  generateId() {
    return `text-${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;
  }
};
var FileTimeCapsuleStrategy = class {
  constructor(app) {
    this.name = "file";
    this.app = app;
  }
  canHandle(type) {
    return type === "file";
  }
  createCapsule(data) {
    const now = Date.now();
    const duration = data.metadata?.duration || 60;
    return {
      id: this.generateId(),
      title: data.title || "\u6587\u4EF6\u65F6\u95F4\u80F6\u56CA",
      content: data.content || "",
      type: "file",
      createdAt: now,
      expiresAt: now + duration * 60 * 1e3,
      isExpired: false,
      isOpened: false,
      metadata: {
        ...data.metadata,
        fileSize: data.content?.length || 0,
        createdBy: "FileTimeCapsuleStrategy"
      }
    };
  }
  async openCapsule(capsule) {
    try {
      if (capsule.metadata?.sourceFile) {
        const file = this.app.vault.getAbstractFileByPath(capsule.metadata.sourceFile);
        if (file instanceof import_obsidian6.TFile) {
          const leaf2 = this.app.workspace.getUnpinnedLeaf();
          await leaf2.openFile(file);
          new import_obsidian6.Notice(`\u65F6\u95F4\u80F6\u56CA"${capsule.title}"\u5DF2\u6253\u5F00\u539F\u6587\u4EF6`);
          return;
        }
      }
      const tempFileName = `\u65F6\u95F4\u80F6\u56CA-${capsule.title}-${(/* @__PURE__ */ new Date()).toISOString().slice(0, 10)}.md`;
      const tempFile = await this.app.vault.create(tempFileName, capsule.content);
      const leaf = this.app.workspace.getUnpinnedLeaf();
      await leaf.openFile(tempFile);
      new import_obsidian6.Notice(`\u65F6\u95F4\u80F6\u56CA"${capsule.title}"\u5DF2\u6253\u5F00`);
    } catch (error) {
      console.error("Failed to open file capsule:", error);
      new import_obsidian6.Notice("\u6253\u5F00\u65F6\u95F4\u80F6\u56CA\u5931\u8D25");
    }
  }
  validateCapsule(capsule) {
    return typeof capsule.content === "string" && capsule.content.length > 0;
  }
  generateId() {
    return `file-${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;
  }
};
var TimeCapsuleManager = class {
  constructor(app, config) {
    this.strategies = /* @__PURE__ */ new Map();
    this.capsules = /* @__PURE__ */ new Map();
    this.cleanupTimer = null;
    this.clipboardWatcher = null;
    this.eventListeners = [];
    this.app = app;
    this.config = config;
    this.initializeStrategies();
    this.setupCleanupTimer();
    this.setupClipboardWatcher();
    this.loadCapsules();
  }
  /**
   * 初始化时间胶囊策略
   */
  initializeStrategies() {
    this.strategies.set("text", new TextTimeCapsuleStrategy(this.app));
    this.strategies.set("file", new FileTimeCapsuleStrategy(this.app));
  }
  /**
   * 创建时间胶囊
   */
  async createCapsule(data) {
    const startTime = Date.now();
    try {
      if (!this.config.enabled) {
        return {
          success: false,
          error: "\u65F6\u95F4\u80F6\u56CA\u529F\u80FD\u672A\u542F\u7528",
          timestamp: startTime
        };
      }
      if (this.capsules.size >= this.config.maxCapsules) {
        return {
          success: false,
          error: `\u65F6\u95F4\u80F6\u56CA\u6570\u91CF\u5DF2\u8FBE\u4E0A\u9650 (${this.config.maxCapsules})`,
          timestamp: startTime
        };
      }
      const strategy = this.findStrategy(data.type || "text");
      if (!strategy) {
        return {
          success: false,
          error: `\u4E0D\u652F\u6301\u7684\u65F6\u95F4\u80F6\u56CA\u7C7B\u578B: ${data.type}`,
          timestamp: startTime
        };
      }
      const capsule = strategy.createCapsule(data);
      if (!strategy.validateCapsule(capsule)) {
        return {
          success: false,
          error: "\u65F6\u95F4\u80F6\u56CA\u6570\u636E\u9A8C\u8BC1\u5931\u8D25",
          timestamp: startTime
        };
      }
      this.capsules.set(capsule.id, capsule);
      await this.saveCapsules();
      this.emitEvent({
        type: "created",
        capsule,
        timestamp: Date.now()
      });
      if (this.config.showNotifications) {
        new import_obsidian6.Notice(`\u65F6\u95F4\u80F6\u56CA"${capsule.title}"\u5DF2\u521B\u5EFA\uFF0C\u5C06\u5728${Math.round((capsule.expiresAt - capsule.createdAt) / 6e4)}\u5206\u949F\u540E\u5230\u671F`);
      }
      return {
        success: true,
        capsule,
        timestamp: startTime
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
        timestamp: startTime
      };
    }
  }
  /**
   * 打开时间胶囊
   */
  async openCapsule(capsuleId) {
    const startTime = Date.now();
    try {
      const capsule = this.capsules.get(capsuleId);
      if (!capsule) {
        return {
          success: false,
          error: "\u65F6\u95F4\u80F6\u56CA\u4E0D\u5B58\u5728",
          timestamp: startTime
        };
      }
      if (!capsule.isExpired && Date.now() < capsule.expiresAt) {
        return {
          success: false,
          error: "\u65F6\u95F4\u80F6\u56CA\u5C1A\u672A\u5230\u671F",
          timestamp: startTime
        };
      }
      const strategy = this.findStrategy(capsule.type);
      if (!strategy) {
        return {
          success: false,
          error: `\u4E0D\u652F\u6301\u7684\u65F6\u95F4\u80F6\u56CA\u7C7B\u578B: ${capsule.type}`,
          timestamp: startTime
        };
      }
      await strategy.openCapsule(capsule);
      capsule.isOpened = true;
      capsule.openedAt = Date.now();
      await this.saveCapsules();
      this.emitEvent({
        type: "opened",
        capsule,
        timestamp: Date.now()
      });
      return {
        success: true,
        capsule,
        timestamp: startTime
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
        timestamp: startTime
      };
    }
  }
  /**
   * 删除时间胶囊
   */
  async deleteCapsule(capsuleId) {
    const startTime = Date.now();
    try {
      const capsule = this.capsules.get(capsuleId);
      if (!capsule) {
        return {
          success: false,
          error: "\u65F6\u95F4\u80F6\u56CA\u4E0D\u5B58\u5728",
          timestamp: startTime
        };
      }
      this.capsules.delete(capsuleId);
      await this.saveCapsules();
      this.emitEvent({
        type: "deleted",
        capsule,
        timestamp: Date.now()
      });
      if (this.config.showNotifications) {
        new import_obsidian6.Notice(`\u65F6\u95F4\u80F6\u56CA"${capsule.title}"\u5DF2\u5220\u9664`);
      }
      return {
        success: true,
        capsule,
        timestamp: startTime
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
        timestamp: startTime
      };
    }
  }
  /**
   * 获取所有时间胶囊
   */
  getAllCapsules() {
    return Array.from(this.capsules.values());
  }
  /**
   * 获取已过期的时间胶囊
   */
  getExpiredCapsules() {
    const now = Date.now();
    return this.getAllCapsules().filter(
      (capsule) => !capsule.isOpened && (capsule.isExpired || now >= capsule.expiresAt)
    );
  }
  /**
   * 获取活跃的时间胶囊
   */
  getActiveCapsules() {
    const now = Date.now();
    return this.getAllCapsules().filter(
      (capsule) => !capsule.isOpened && !capsule.isExpired && now < capsule.expiresAt
    );
  }
  /**
   * 查找时间胶囊策略
   */
  findStrategy(type) {
    for (const strategy of this.strategies.values()) {
      if (strategy.canHandle(type)) {
        return strategy;
      }
    }
    return null;
  }
  /**
   * 设置清理定时器
   */
  setupCleanupTimer() {
    if (!this.config.enableAutoCleanup) {
      return;
    }
    this.cleanupTimer = setInterval(() => {
      this.performCleanup();
    }, this.config.cleanupInterval);
  }
  /**
   * 执行清理
   */
  async performCleanup() {
    const now = Date.now();
    let cleanedCount = 0;
    for (const [id, capsule] of this.capsules.entries()) {
      if (!capsule.isExpired && now >= capsule.expiresAt) {
        capsule.isExpired = true;
        this.emitEvent({
          type: "expired",
          capsule,
          timestamp: now
        });
        if (this.config.showNotifications) {
          new import_obsidian6.Notice(`\u65F6\u95F4\u80F6\u56CA"${capsule.title}"\u5DF2\u5230\u671F`);
        }
      }
      if (capsule.isOpened && capsule.openedAt && now - capsule.openedAt > 7 * 24 * 60 * 60 * 1e3) {
        this.capsules.delete(id);
        cleanedCount++;
      }
    }
    if (cleanedCount > 0) {
      await this.saveCapsules();
      console.log(`Cleaned up ${cleanedCount} old time capsules`);
    }
  }
  /**
   * 设置剪贴板监听器
   */
  setupClipboardWatcher() {
    if (!this.config.autoCollectClipboard) {
      return;
    }
    this.clipboardWatcher = setInterval(async () => {
      try {
        const clipboardText = await navigator.clipboard.readText();
        if (clipboardText && clipboardText.length > 10) {
          const lastClipboard = localStorage.getItem("canvas-grid-last-clipboard");
          if (clipboardText !== lastClipboard) {
            localStorage.setItem("canvas-grid-last-clipboard", clipboardText);
            await this.createCapsule({
              title: "\u81EA\u52A8\u6536\u96C6\u7684\u526A\u8D34\u677F\u5185\u5BB9",
              content: clipboardText,
              type: "clipboard",
              metadata: {
                duration: this.config.defaultDuration,
                autoCollected: true
              }
            });
          }
        }
      } catch (error) {
      }
    }, 5e3);
  }
  /**
   * 保存时间胶囊数据
   */
  async saveCapsules() {
    try {
      const data = Array.from(this.capsules.values());
      const content = JSON.stringify(data, null, 2);
      const storageFile = this.config.storageLocation || "time-capsules.json";
      const file = this.app.vault.getAbstractFileByPath(storageFile);
      if (file instanceof import_obsidian6.TFile) {
        await this.app.vault.modify(file, content);
      } else {
        await this.app.vault.create(storageFile, content);
      }
    } catch (error) {
      console.error("Failed to save time capsules:", error);
    }
  }
  /**
   * 加载时间胶囊数据
   */
  async loadCapsules() {
    try {
      const storageFile = this.config.storageLocation || "time-capsules.json";
      const file = this.app.vault.getAbstractFileByPath(storageFile);
      if (file instanceof import_obsidian6.TFile) {
        const content = await this.app.vault.read(file);
        const data = JSON.parse(content);
        this.capsules.clear();
        data.forEach((capsule) => {
          this.capsules.set(capsule.id, capsule);
        });
      }
    } catch (error) {
      console.log("No existing time capsules found or failed to load");
    }
  }
  /**
   * 添加事件监听器
   */
  addEventListener(listener) {
    this.eventListeners.push(listener);
  }
  /**
   * 移除事件监听器
   */
  removeEventListener(listener) {
    const index = this.eventListeners.indexOf(listener);
    if (index > -1) {
      this.eventListeners.splice(index, 1);
    }
  }
  /**
   * 触发事件
   */
  emitEvent(event) {
    this.eventListeners.forEach((listener) => {
      try {
        listener(event);
      } catch (error) {
        console.error("Error in time capsule event listener:", error);
      }
    });
  }
  /**
   * 注册时间胶囊策略
   */
  registerStrategy(strategy) {
    this.strategies.set(strategy.name, strategy);
  }
  /**
   * 更新配置
   */
  updateConfig(config) {
    this.config = { ...this.config, ...config };
    if (this.cleanupTimer) {
      clearInterval(this.cleanupTimer);
      this.cleanupTimer = null;
    }
    if (this.clipboardWatcher) {
      clearInterval(this.clipboardWatcher);
      this.clipboardWatcher = null;
    }
    this.setupCleanupTimer();
    this.setupClipboardWatcher();
  }
  /**
   * 销毁管理器
   */
  destroy() {
    if (this.cleanupTimer) {
      clearInterval(this.cleanupTimer);
      this.cleanupTimer = null;
    }
    if (this.clipboardWatcher) {
      clearInterval(this.clipboardWatcher);
      this.clipboardWatcher = null;
    }
    this.capsules.clear();
    this.strategies.clear();
    this.eventListeners.length = 0;
  }
};

// src/managers/NavigationManager.ts
var import_obsidian7 = require("obsidian");
var FileNavigationStrategy = class {
  constructor(app) {
    this.name = "file";
    this.app = app;
  }
  canHandle(destination) {
    return destination.endsWith(".md") || destination.endsWith(".canvas") || this.app.vault.getAbstractFileByPath(destination) !== null;
  }
  async navigate(destination, options = {}) {
    const startTime = Date.now();
    try {
      const file = this.app.vault.getAbstractFileByPath(destination);
      if (!file || !(file instanceof import_obsidian7.TFile)) {
        return {
          success: false,
          error: `\u6587\u4EF6\u4E0D\u5B58\u5728: ${destination}`,
          timestamp: startTime
        };
      }
      let leaf;
      if (options.newTab) {
        leaf = this.app.workspace.getLeaf("tab");
      } else if (options.split) {
        leaf = this.app.workspace.getLeaf("split", options.split === "horizontal" ? "horizontal" : "vertical");
      } else {
        leaf = this.app.workspace.getUnpinnedLeaf();
      }
      await leaf.openFile(file);
      if (options.position && leaf.view instanceof import_obsidian7.MarkdownView) {
        const editor = leaf.view.editor;
        editor.setCursor(options.position);
        editor.scrollIntoView({
          from: options.position,
          to: options.position
        }, true);
      }
      if (options.focus !== false) {
        this.app.workspace.setActiveLeaf(leaf);
      }
      return {
        success: true,
        destination: file.path,
        timestamp: startTime
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
        timestamp: startTime
      };
    }
  }
  getDisplayName(destination) {
    const file = this.app.vault.getAbstractFileByPath(destination);
    return file ? file.name.replace(/\.[^/.]+$/, "") : destination;
  }
};
var URLNavigationStrategy = class {
  constructor(app) {
    this.name = "url";
    this.app = app;
  }
  canHandle(destination) {
    return destination.startsWith("http://") || destination.startsWith("https://") || destination.startsWith("obsidian://");
  }
  async navigate(destination, options = {}) {
    const startTime = Date.now();
    try {
      if (destination.startsWith("obsidian://")) {
        window.open(destination);
      } else {
        window.open(destination, options.newTab ? "_blank" : "_self");
      }
      return {
        success: true,
        destination,
        timestamp: startTime
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
        timestamp: startTime
      };
    }
  }
  getDisplayName(destination) {
    try {
      const url = new URL(destination);
      return url.hostname;
    } catch {
      return destination;
    }
  }
};
var BlockReferenceNavigationStrategy = class {
  constructor(app) {
    this.name = "block";
    this.app = app;
  }
  canHandle(destination) {
    return destination.includes("#^") || Boolean(destination.match(/\[\[.*#\^.*\]\]/));
  }
  async navigate(destination, options = {}) {
    const startTime = Date.now();
    try {
      const match = destination.match(/\[\[(.*?)#\^(.*?)\]\]/) || destination.match(/(.*?)#\^(.*)/);
      if (!match) {
        return {
          success: false,
          error: "\u65E0\u6548\u7684\u5757\u5F15\u7528\u683C\u5F0F",
          timestamp: startTime
        };
      }
      const [, filePath, blockId] = match;
      const file = this.app.vault.getAbstractFileByPath(filePath + ".md") || this.app.vault.getAbstractFileByPath(filePath);
      if (!file || !(file instanceof import_obsidian7.TFile)) {
        return {
          success: false,
          error: `\u6587\u4EF6\u4E0D\u5B58\u5728: ${filePath}`,
          timestamp: startTime
        };
      }
      const leaf = options.newTab ? this.app.workspace.getLeaf("tab") : this.app.workspace.getUnpinnedLeaf();
      await leaf.openFile(file);
      if (leaf.view instanceof import_obsidian7.MarkdownView) {
        const content = await this.app.vault.read(file);
        const lines = content.split("\n");
        for (let i = 0; i < lines.length; i++) {
          if (lines[i].includes(`^${blockId}`)) {
            const editor = leaf.view.editor;
            const position = { line: i, ch: 0 };
            editor.setCursor(position);
            editor.scrollIntoView({
              from: position,
              to: position
            }, true);
            break;
          }
        }
      }
      if (options.focus !== false) {
        this.app.workspace.setActiveLeaf(leaf);
      }
      return {
        success: true,
        destination: `${file.path}#^${blockId}`,
        timestamp: startTime
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
        timestamp: startTime
      };
    }
  }
  getDisplayName(destination) {
    const match = destination.match(/\[\[(.*?)#\^(.*?)\]\]/) || destination.match(/(.*?)#\^(.*)/);
    if (match) {
      const [, filePath, blockId] = match;
      return `${filePath}#^${blockId.substring(0, 8)}...`;
    }
    return destination;
  }
};
var NavigationManager = class {
  constructor(app, config) {
    this.strategies = /* @__PURE__ */ new Map();
    this.history = [];
    this.currentIndex = -1;
    this.breadcrumbs = [];
    this.app = app;
    this.config = config;
    this.initializeStrategies();
    this.setupKeyboardShortcuts();
    this.loadHistory();
  }
  /**
   * 初始化导航策略
   */
  initializeStrategies() {
    this.strategies.set("file", new FileNavigationStrategy(this.app));
    this.strategies.set("url", new URLNavigationStrategy(this.app));
    this.strategies.set("block", new BlockReferenceNavigationStrategy(this.app));
  }
  /**
   * 导航到指定目标
   */
  async navigateTo(destination, options = {}) {
    const strategy = this.findStrategy(destination);
    if (!strategy) {
      return {
        success: false,
        error: `\u4E0D\u652F\u6301\u7684\u5BFC\u822A\u76EE\u6807: ${destination}`,
        timestamp: Date.now()
      };
    }
    const result = await strategy.navigate(destination, options);
    if (result.success) {
      this.addToHistory({
        id: this.generateId(),
        file: destination,
        position: options.position,
        timestamp: result.timestamp,
        title: strategy.getDisplayName(destination),
        type: this.getNavigationType(destination)
      });
    }
    return result;
  }
  /**
   * 后退导航
   */
  async goBack() {
    if (!this.canGoBack()) {
      return {
        success: false,
        error: "\u6CA1\u6709\u53EF\u540E\u9000\u7684\u5386\u53F2\u8BB0\u5F55",
        timestamp: Date.now()
      };
    }
    this.currentIndex--;
    const item = this.history[this.currentIndex];
    return await this.navigateTo(item.file, { position: item.position });
  }
  /**
   * 前进导航
   */
  async goForward() {
    if (!this.canGoForward()) {
      return {
        success: false,
        error: "\u6CA1\u6709\u53EF\u524D\u8FDB\u7684\u5386\u53F2\u8BB0\u5F55",
        timestamp: Date.now()
      };
    }
    this.currentIndex++;
    const item = this.history[this.currentIndex];
    return await this.navigateTo(item.file, { position: item.position });
  }
  /**
   * 检查是否可以后退
   */
  canGoBack() {
    return this.currentIndex > 0;
  }
  /**
   * 检查是否可以前进
   */
  canGoForward() {
    return this.currentIndex < this.history.length - 1;
  }
  /**
   * 获取导航历史
   */
  getHistory() {
    return [...this.history];
  }
  /**
   * 获取面包屑导航
   */
  getBreadcrumbs() {
    return [...this.breadcrumbs];
  }
  /**
   * 清空导航历史
   */
  clearHistory() {
    this.history = [];
    this.currentIndex = -1;
    this.breadcrumbs = [];
    this.saveHistory();
  }
  /**
   * 查找导航策略
   */
  findStrategy(destination) {
    for (const strategy of this.strategies.values()) {
      if (strategy.canHandle(destination)) {
        return strategy;
      }
    }
    return null;
  }
  /**
   * 添加到历史记录
   */
  addToHistory(item) {
    this.history = this.history.slice(0, this.currentIndex + 1);
    this.history.push(item);
    this.currentIndex = this.history.length - 1;
    if (this.history.length > this.config.maxHistorySize) {
      this.history = this.history.slice(-this.config.maxHistorySize);
      this.currentIndex = this.history.length - 1;
    }
    this.updateBreadcrumbs(item);
    this.saveHistory();
  }
  /**
   * 更新面包屑导航
   */
  updateBreadcrumbs(item) {
    if (!this.config.enableBreadcrumbs) {
      return;
    }
    this.breadcrumbs = this.breadcrumbs.filter((b) => b.file !== item.file);
    this.breadcrumbs.push(item);
    const maxBreadcrumbs = 5;
    if (this.breadcrumbs.length > maxBreadcrumbs) {
      this.breadcrumbs = this.breadcrumbs.slice(-maxBreadcrumbs);
    }
  }
  /**
   * 获取导航类型
   */
  getNavigationType(destination) {
    if (destination.endsWith(".canvas")) {
      return "canvas";
    } else if (destination.endsWith(".md")) {
      return "markdown";
    } else {
      return "grid";
    }
  }
  /**
   * 生成唯一ID
   */
  generateId() {
    return `nav-${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;
  }
  /**
   * 设置键盘快捷键
   */
  setupKeyboardShortcuts() {
    if (!this.config.enableKeyboardShortcuts) {
      return;
    }
  }
  /**
   * 保存历史记录
   */
  async saveHistory() {
    try {
      const data = {
        history: this.history,
        currentIndex: this.currentIndex,
        breadcrumbs: this.breadcrumbs
      };
      localStorage.setItem("canvas-grid-navigation-history", JSON.stringify(data));
    } catch (error) {
      console.error("Failed to save navigation history:", error);
    }
  }
  /**
   * 加载历史记录
   */
  loadHistory() {
    try {
      const data = localStorage.getItem("canvas-grid-navigation-history");
      if (data) {
        const parsed = JSON.parse(data);
        this.history = parsed.history || [];
        this.currentIndex = parsed.currentIndex || -1;
        this.breadcrumbs = parsed.breadcrumbs || [];
      }
    } catch (error) {
      console.error("Failed to load navigation history:", error);
    }
  }
  /**
   * 注册导航策略
   */
  registerStrategy(strategy) {
    this.strategies.set(strategy.name, strategy);
  }
  /**
   * 更新配置
   */
  updateConfig(config) {
    this.config = { ...this.config, ...config };
  }
  /**
   * 销毁管理器
   */
  destroy() {
    this.saveHistory();
    this.strategies.clear();
    this.history = [];
    this.breadcrumbs = [];
    this.currentIndex = -1;
  }
};

// src/managers/EditorStateManager.ts
var EditorStateManager = class {
  constructor() {
    this.editorStates = /* @__PURE__ */ new Map();
    this.documentState = null;
    this.changeOperations = [];
    this.stateChangeListeners = [];
    DebugManager.log("EditorStateManager initialized");
  }
  /**
   * 初始化文档状态
   */
  initializeDocument(filePath, initialData) {
    this.documentState = {
      filePath,
      memoryVersion: JSON.parse(JSON.stringify(initialData)),
      fileVersion: JSON.parse(JSON.stringify(initialData)),
      lastSyncTime: Date.now(),
      hasUnsavedChanges: false,
      conflictDetected: false,
      activeEditors: /* @__PURE__ */ new Set()
    };
    DebugManager.log("Document state initialized:", filePath);
  }
  /**
   * 开始编辑节点
   */
  startEditing(nodeId, content, cardElement, editorElement) {
    if (this.editorStates.has(nodeId)) {
      return this.editorStates.get(nodeId);
    }
    const editorState = {
      nodeId,
      originalContent: JSON.parse(JSON.stringify(content)),
      currentContent: JSON.parse(JSON.stringify(content)),
      isDirty: false,
      lastModified: Date.now(),
      editingMode: this.detectEditingMode(content),
      cardElement,
      editorElement
    };
    this.editorStates.set(nodeId, editorState);
    if (this.documentState) {
      this.documentState.activeEditors.add(nodeId);
    }
    this.notifyStateChange(nodeId, editorState);
    DebugManager.log("Started editing node:", nodeId);
    return editorState;
  }
  /**
   * 更新编辑内容（仅更新内存状态）
   */
  updateContent(nodeId, newContent) {
    const state = this.editorStates.get(nodeId);
    if (!state) {
      DebugManager.warn("Attempted to update non-existent editor state:", nodeId);
      return false;
    }
    if (JSON.stringify(state.currentContent) === JSON.stringify(newContent)) {
      return false;
    }
    const changeOp = {
      id: `${nodeId}-${Date.now()}`,
      nodeId,
      type: "update",
      oldValue: state.currentContent,
      newValue: newContent,
      timestamp: Date.now(),
      applied: false
    };
    state.currentContent = JSON.parse(JSON.stringify(newContent));
    state.isDirty = true;
    state.lastModified = Date.now();
    this.changeOperations = [changeOp];
    if (this.documentState) {
      this.documentState.hasUnsavedChanges = true;
    }
    this.notifyStateChange(nodeId, state);
    DebugManager.log("Updated content for node:", nodeId);
    return true;
  }
  /**
   * 停止编辑节点（Canvas兼容模式 - 简化版本）
   */
  stopEditing(nodeId, saveChanges = true) {
    const state = this.editorStates.get(nodeId);
    if (!state) {
      return false;
    }
    if (saveChanges) {
      this.applyChangesToMemoryVersion(nodeId);
    } else {
      this.discardChanges(nodeId);
    }
    this.editorStates.delete(nodeId);
    if (this.documentState) {
      this.documentState.activeEditors.delete(nodeId);
    }
    DebugManager.log("Stopped editing node (Canvas-compatible mode):", nodeId, "saved:", saveChanges);
    return true;
  }
  /**
   * 获取编辑器状态
   */
  getEditorState(nodeId) {
    return this.editorStates.get(nodeId) || null;
  }
  /**
   * 获取文档状态
   */
  getDocumentState() {
    return this.documentState;
  }
  /**
   * 检查是否有未保存的变更
   */
  hasUnsavedChanges() {
    return this.documentState?.hasUnsavedChanges || false;
  }
  /**
   * 检查是否有活跃的编辑器
   */
  hasActiveEditors() {
    return this.editorStates.size > 0;
  }
  /**
   * 获取所有活跃编辑器的节点ID
   */
  getActiveEditorIds() {
    return Array.from(this.editorStates.keys());
  }
  /**
   * 获取待应用的变更操作
   */
  getPendingChanges() {
    return this.changeOperations.filter((op) => !op.applied);
  }
  /**
   * 检测编辑模式
   */
  detectEditingMode(content) {
    if (content && typeof content === "object") {
      if (content.type === "text")
        return "text";
      if (content.type === "link")
        return "link";
    }
    return "none";
  }
  /**
   * 应用变更到内存版本
   */
  applyChangesToMemoryVersion(nodeId) {
    if (!this.documentState)
      return;
    const relevantChanges = this.changeOperations.filter(
      (op) => op.nodeId === nodeId && !op.applied
    );
    for (const change of relevantChanges) {
      this.applyChangeToMemoryVersion(change);
      change.applied = true;
    }
  }
  /**
   * 应用单个变更到内存版本
   */
  applyChangeToMemoryVersion(change) {
    if (!this.documentState)
      return;
    const memoryVersion = this.documentState.memoryVersion;
    if (!memoryVersion.nodes)
      return;
    const nodeIndex = memoryVersion.nodes.findIndex((node) => node.id === change.nodeId);
    if (nodeIndex === -1)
      return;
    switch (change.type) {
      case "update":
        memoryVersion.nodes[nodeIndex] = { ...memoryVersion.nodes[nodeIndex], ...change.newValue };
        break;
      case "delete":
        memoryVersion.nodes.splice(nodeIndex, 1);
        break;
    }
    DebugManager.log("Applied change to memory version:", change.id);
  }
  /**
   * 丢弃变更
   */
  discardChanges(nodeId) {
    this.changeOperations = this.changeOperations.filter((op) => op.nodeId !== nodeId);
    const hasOtherChanges = this.changeOperations.some((op) => !op.applied);
    if (this.documentState && !hasOtherChanges) {
      this.documentState.hasUnsavedChanges = false;
    }
  }
  /**
   * 通知状态变化
   */
  notifyStateChange(nodeId, state) {
    for (const listener of this.stateChangeListeners) {
      try {
        listener(nodeId, state);
      } catch (error) {
        DebugManager.error("Error in state change listener:", error);
      }
    }
  }
  /**
   * 添加状态变化监听器
   */
  addStateChangeListener(listener) {
    this.stateChangeListeners.push(listener);
  }
  /**
   * 移除状态变化监听器
   */
  removeStateChangeListener(listener) {
    const index = this.stateChangeListeners.indexOf(listener);
    if (index > -1) {
      this.stateChangeListeners.splice(index, 1);
    }
  }
  /**
   * 清理所有状态
   */
  cleanup() {
    this.editorStates.clear();
    this.changeOperations = [];
    this.stateChangeListeners = [];
    this.documentState = null;
    DebugManager.log("EditorStateManager cleaned up");
  }
};

// src/managers/MemoryBufferManager.ts
var MemoryBufferManager = class {
  constructor(config) {
    this.memoryBuffer = null;
    this.autoSaveTimer = null;
    this.saveCallbacks = [];
    this.changeListeners = [];
    this.saveConfig = {
      autoSaveDelay: 0,
      // 立即保存，移除延迟
      maxPendingChanges: 100,
      enableAutoSave: false,
      // 禁用自动保存，采用立即保存策略
      saveOnBlur: false,
      // 禁用失焦保存，避免与官方Canvas冲突
      saveOnViewSwitch: false,
      // 禁用视图切换保存
      ...config
    };
    DebugManager.log("MemoryBufferManager initialized with Canvas-compatible config:", this.saveConfig);
  }
  /**
   * 初始化内存缓冲区
   */
  initializeBuffer(documentState) {
    this.memoryBuffer = {
      documentState: JSON.parse(JSON.stringify(documentState)),
      pendingChanges: [],
      autoSaveScheduled: false,
      lastAutoSaveTime: Date.now()
    };
    DebugManager.log("Memory buffer initialized for:", documentState.filePath);
  }
  /**
   * 应用变更到内存缓冲区
   */
  applyChange(operation) {
    if (!this.memoryBuffer) {
      DebugManager.warn("Cannot apply change: memory buffer not initialized");
      return;
    }
    this.memoryBuffer.pendingChanges.push(operation);
    this.applyToMemoryVersion(operation);
    this.markAsUnsaved();
    DebugManager.log("Applied change to memory buffer:", operation.id);
  }
  /**
   * 立即保存（移除延迟调度机制）
   */
  async triggerImmediateSave() {
    if (!this.memoryBuffer) {
      DebugManager.warn("Cannot trigger immediate save: memory buffer not initialized");
      return;
    }
    await this.triggerSave("manual");
    DebugManager.log("Immediate save triggered (Canvas-compatible mode)");
  }
  /**
   * 清理定时器（保留方法以维持接口兼容性）
   */
  cancelAutoSave() {
    if (this.autoSaveTimer) {
      clearTimeout(this.autoSaveTimer);
      this.autoSaveTimer = null;
    }
    if (this.memoryBuffer) {
      this.memoryBuffer.autoSaveScheduled = false;
    }
    DebugManager.log("Timer cleanup completed (Canvas-compatible mode)");
  }
  /**
   * 手动触发保存
   */
  async triggerSave(trigger) {
    if (!this.memoryBuffer) {
      DebugManager.warn("Cannot trigger save: memory buffer not initialized");
      return;
    }
    DebugManager.log("Triggering save with trigger:", trigger);
    for (const callback of this.saveCallbacks) {
      try {
        await callback(trigger);
      } catch (error) {
        DebugManager.error("Error in save callback:", error);
      }
    }
    this.memoryBuffer.lastAutoSaveTime = Date.now();
  }
  /**
   * 标记变更已保存
   */
  markChangesSaved() {
    if (!this.memoryBuffer)
      return;
    this.memoryBuffer.pendingChanges = [];
    this.memoryBuffer.documentState.hasUnsavedChanges = false;
    this.memoryBuffer.documentState.fileVersion = JSON.parse(
      JSON.stringify(this.memoryBuffer.documentState.memoryVersion)
    );
    this.memoryBuffer.documentState.lastSyncTime = Date.now();
    this.notifyChangeListeners();
    DebugManager.log("Changes marked as saved");
  }
  /**
   * 检查是否应该自动保存
   */
  shouldAutoSave() {
    if (!this.memoryBuffer || !this.saveConfig.enableAutoSave) {
      return false;
    }
    if (!this.memoryBuffer.documentState.hasUnsavedChanges) {
      return false;
    }
    if (this.memoryBuffer.documentState.activeEditors.size > 0) {
      const timeSinceLastSave = Date.now() - this.memoryBuffer.lastAutoSaveTime;
      return timeSinceLastSave > this.saveConfig.autoSaveDelay * 3;
    }
    return true;
  }
  /**
   * 获取内存缓冲区状态
   */
  getBufferState() {
    return this.memoryBuffer;
  }
  /**
   * 获取待处理变更数量
   */
  getPendingChangesCount() {
    return this.memoryBuffer?.pendingChanges.length || 0;
  }
  /**
   * 检查是否有未保存变更
   */
  hasUnsavedChanges() {
    return this.memoryBuffer?.documentState.hasUnsavedChanges || false;
  }
  /**
   * 获取内存版本数据
   */
  getMemoryVersion() {
    return this.memoryBuffer?.documentState.memoryVersion;
  }
  /**
   * 获取文件版本数据
   */
  getFileVersion() {
    return this.memoryBuffer?.documentState.fileVersion;
  }
  /**
   * 更新文件版本（用于外部文件变更）
   */
  updateFileVersion(newFileData) {
    if (!this.memoryBuffer)
      return;
    this.memoryBuffer.documentState.fileVersion = JSON.parse(JSON.stringify(newFileData));
    this.memoryBuffer.documentState.lastSyncTime = Date.now();
    DebugManager.log("File version updated");
  }
  /**
   * 检测冲突
   */
  detectConflict() {
    if (!this.memoryBuffer)
      return false;
    const memoryVersion = this.memoryBuffer.documentState.memoryVersion;
    const fileVersion = this.memoryBuffer.documentState.fileVersion;
    const memoryHash = JSON.stringify(memoryVersion);
    const fileHash = JSON.stringify(fileVersion);
    return memoryHash !== fileHash;
  }
  /**
   * 应用变更到内存版本
   */
  applyToMemoryVersion(operation) {
    if (!this.memoryBuffer)
      return;
    const memoryVersion = this.memoryBuffer.documentState.memoryVersion;
    if (!memoryVersion.nodes)
      return;
    const nodeIndex = memoryVersion.nodes.findIndex((node) => node.id === operation.nodeId);
    switch (operation.type) {
      case "update":
        if (nodeIndex !== -1) {
          memoryVersion.nodes[nodeIndex] = {
            ...memoryVersion.nodes[nodeIndex],
            ...operation.newValue
          };
        }
        break;
      case "create":
        memoryVersion.nodes.push(operation.newValue);
        break;
      case "delete":
        if (nodeIndex !== -1) {
          memoryVersion.nodes.splice(nodeIndex, 1);
        }
        break;
    }
  }
  /**
   * 标记为未保存
   */
  markAsUnsaved() {
    if (this.memoryBuffer) {
      this.memoryBuffer.documentState.hasUnsavedChanges = true;
      this.notifyChangeListeners();
    }
  }
  /**
   * 添加保存回调
   */
  addSaveCallback(callback) {
    this.saveCallbacks.push(callback);
  }
  /**
   * 移除保存回调
   */
  removeSaveCallback(callback) {
    const index = this.saveCallbacks.indexOf(callback);
    if (index > -1) {
      this.saveCallbacks.splice(index, 1);
    }
  }
  /**
   * 添加变更监听器
   */
  addChangeListener(listener) {
    this.changeListeners.push(listener);
  }
  /**
   * 移除变更监听器
   */
  removeChangeListener(listener) {
    const index = this.changeListeners.indexOf(listener);
    if (index > -1) {
      this.changeListeners.splice(index, 1);
    }
  }
  /**
   * 通知变更监听器
   */
  notifyChangeListeners() {
    const hasChanges = this.hasUnsavedChanges();
    this.changeListeners.forEach((listener) => {
      try {
        listener(hasChanges);
      } catch (error) {
        DebugManager.error("Error in change listener:", error);
      }
    });
  }
  /**
   * 清理内存缓冲区
   */
  cleanup() {
    this.cancelAutoSave();
    this.memoryBuffer = null;
    this.saveCallbacks = [];
    this.changeListeners = [];
    DebugManager.log("MemoryBufferManager cleaned up");
  }
};

// src/managers/ConflictResolver.ts
var import_obsidian8 = require("obsidian");
var ConflictResolver = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * 检测冲突
   */
  async detectConflict(filePath, localVersion, remoteVersion) {
    try {
      const localHash = this.generateContentHash(localVersion);
      const remoteHash = this.generateContentHash(remoteVersion);
      const hasConflict = localHash !== remoteHash;
      if (hasConflict) {
        DebugManager.log("Conflict detected for file:", filePath);
      }
      return hasConflict;
    } catch (error) {
      DebugManager.error("Error detecting conflict:", error);
      return false;
    }
  }
  /**
   * 解决冲突
   */
  async resolveConflict(conflictInfo) {
    try {
      if (!conflictInfo.hasActiveEditors) {
        DebugManager.log("No active editors, using remote version");
        return {
          strategy: "use-remote",
          userChoice: false
        };
      }
      const mergeResult = this.attemptAutoMerge(
        conflictInfo.localVersion,
        conflictInfo.remoteVersion
      );
      if (mergeResult.success) {
        DebugManager.log("Auto-merge successful");
        return {
          strategy: "merge",
          mergedContent: mergeResult.mergedContent
        };
      }
      DebugManager.log("Conflict requires user intervention");
      return await this.showConflictDialog(conflictInfo);
    } catch (error) {
      DebugManager.error("Error resolving conflict:", error);
      return {
        strategy: "keep-local",
        cancelled: true
      };
    }
  }
  /**
   * 尝试自动合并
   */
  attemptAutoMerge(localVersion, remoteVersion) {
    try {
      if (this.canAutoMerge(localVersion, remoteVersion)) {
        const merged = this.performAutoMerge(localVersion, remoteVersion);
        return {
          success: true,
          mergedContent: merged
        };
      }
      return { success: false };
    } catch (error) {
      DebugManager.error("Auto-merge failed:", error);
      return { success: false };
    }
  }
  /**
   * 检查是否可以自动合并
   */
  canAutoMerge(localVersion, remoteVersion) {
    if (!localVersion.nodes || !remoteVersion.nodes) {
      return false;
    }
    const localIds = new Set(localVersion.nodes.map((n) => n.id));
    const remoteIds = new Set(remoteVersion.nodes.map((n) => n.id));
    for (const id of localIds) {
      if (remoteIds.has(id)) {
        const localNode = localVersion.nodes.find((n) => n.id === id);
        const remoteNode = remoteVersion.nodes.find((n) => n.id === id);
        if (JSON.stringify(localNode) !== JSON.stringify(remoteNode)) {
          return false;
        }
      }
    }
    return true;
  }
  /**
   * 执行自动合并
   */
  performAutoMerge(localVersion, remoteVersion) {
    const merged = JSON.parse(JSON.stringify(localVersion));
    const localIds = new Set(localVersion.nodes.map((n) => n.id));
    for (const remoteNode of remoteVersion.nodes) {
      if (!localIds.has(remoteNode.id)) {
        merged.nodes.push(remoteNode);
      }
    }
    if (remoteVersion.edges && localVersion.edges) {
      const localEdgeIds = new Set(localVersion.edges.map((e) => e.id));
      for (const remoteEdge of remoteVersion.edges) {
        if (!localEdgeIds.has(remoteEdge.id)) {
          merged.edges.push(remoteEdge);
        }
      }
    }
    return merged;
  }
  /**
   * 显示冲突解决对话框
   */
  async showConflictDialog(conflictInfo) {
    return new Promise((resolve) => {
      const modal = new ConflictResolutionModal(
        this.app,
        conflictInfo,
        (resolution) => resolve(resolution)
      );
      modal.open();
    });
  }
  /**
   * 生成内容哈希
   */
  generateContentHash(content) {
    try {
      return JSON.stringify(content);
    } catch (error) {
      return String(content);
    }
  }
};
var ConflictResolutionModal = class extends import_obsidian8.Modal {
  constructor(app, conflictInfo, onResolve) {
    super(app);
    this.conflictInfo = conflictInfo;
    this.onResolve = onResolve;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "\u68C0\u6D4B\u5230\u7F16\u8F91\u51B2\u7A81" });
    contentEl.createEl("p", {
      text: `\u6587\u4EF6 "${this.conflictInfo.filePath}" \u5728\u5916\u90E8\u88AB\u4FEE\u6539\uFF0C\u4F46\u60A8\u6709\u672A\u4FDD\u5B58\u7684\u672C\u5730\u66F4\u6539\u3002`
    });
    contentEl.createEl("p", {
      text: "\u8BF7\u9009\u62E9\u5982\u4F55\u5904\u7406\u8FD9\u4E2A\u51B2\u7A81\uFF1A"
    });
    const optionsContainer = contentEl.createDiv("conflict-resolution-options");
    new import_obsidian8.Setting(optionsContainer).setName("\u4FDD\u7559\u6211\u7684\u66F4\u6539").setDesc("\u5FFD\u7565\u5916\u90E8\u66F4\u6539\uFF0C\u4FDD\u5B58\u60A8\u7684\u672C\u5730\u4FEE\u6539").addButton(
      (btn) => btn.setButtonText("\u4FDD\u7559\u672C\u5730").setCta().onClick(() => {
        this.resolve({
          strategy: "keep-local",
          userChoice: true
        });
      })
    );
    new import_obsidian8.Setting(optionsContainer).setName("\u4F7F\u7528\u5916\u90E8\u66F4\u6539").setDesc("\u4E22\u5F03\u60A8\u7684\u672C\u5730\u4FEE\u6539\uFF0C\u4F7F\u7528\u5916\u90E8\u7248\u672C").addButton(
      (btn) => btn.setButtonText("\u4F7F\u7528\u5916\u90E8").setWarning().onClick(() => {
        this.resolve({
          strategy: "use-remote",
          userChoice: true
        });
      })
    );
    new import_obsidian8.Setting(optionsContainer).addButton(
      (btn) => btn.setButtonText("\u53D6\u6D88").onClick(() => {
        this.resolve({
          strategy: "keep-local",
          cancelled: true
        });
      })
    );
  }
  resolve(resolution) {
    this.close();
    this.onResolve(resolution);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/managers/SaveTriggerManager.ts
var SaveTriggerManager = class {
  constructor(app, conditions) {
    this.saveCallbacks = [];
    this.hasUnsavedChangesCallback = null;
    this.getMemoryVersionCallback = null;
    this.getFileVersionCallback = null;
    this.hasActiveEditorsCallback = null;
    this.app = app;
    this.conflictResolver = new ConflictResolver(app);
    this.saveConditions = {
      onBlur: false,
      // 禁用失焦保存，避免与官方Canvas冲突
      onManualSave: true,
      // 保留手动保存（Ctrl+S）
      onAppClose: true,
      // 保留应用关闭保存
      onViewSwitch: false,
      // 禁用视图切换保存
      onFileClose: false,
      // 禁用文件关闭保存
      onAutoSave: false,
      // 禁用自动保存
      ...conditions
    };
    this.setupEventListeners();
    DebugManager.log("SaveTriggerManager initialized with Canvas-compatible conditions:", this.saveConditions);
  }
  /**
   * 设置回调函数
   */
  setCallbacks(callbacks) {
    this.hasUnsavedChangesCallback = callbacks.hasUnsavedChanges;
    this.getMemoryVersionCallback = callbacks.getMemoryVersion;
    this.getFileVersionCallback = callbacks.getFileVersion;
    this.hasActiveEditorsCallback = callbacks.hasActiveEditors;
  }
  /**
   * 检查是否应该触发保存
   */
  shouldTriggerSave(trigger) {
    if (!this.hasUnsavedChangesCallback?.()) {
      return false;
    }
    switch (trigger) {
      case "blur":
        return this.saveConditions.onBlur;
      case "manual":
        return this.saveConditions.onManualSave;
      case "app-close":
        return this.saveConditions.onAppClose;
      case "view-switch":
        return this.saveConditions.onViewSwitch;
      case "file-close":
        return this.saveConditions.onFileClose;
      case "auto":
        return this.saveConditions.onAutoSave;
      default:
        return false;
    }
  }
  /**
   * 执行保存操作
   */
  async performSave(trigger, filePath) {
    if (!this.shouldTriggerSave(trigger)) {
      DebugManager.log("Save not triggered for:", trigger);
      return false;
    }
    DebugManager.log("Performing save with trigger:", trigger);
    try {
      const hasConflict = await this.checkForConflicts(filePath);
      if (hasConflict) {
        const resolution = await this.resolveConflict(filePath);
        if (resolution.cancelled) {
          DebugManager.log("Save cancelled due to conflict resolution");
          return false;
        }
        await this.applySaveWithResolution(trigger, resolution);
      } else {
        await this.performNormalSave(trigger);
      }
      DebugManager.log("Save completed successfully for trigger:", trigger);
      return true;
    } catch (error) {
      DebugManager.error("Save failed for trigger:", trigger, error);
      return false;
    }
  }
  /**
   * 手动触发保存
   */
  async triggerManualSave(filePath) {
    return await this.performSave("manual", filePath);
  }
  /**
   * 检查冲突
   */
  async checkForConflicts(filePath) {
    if (!filePath || !this.getMemoryVersionCallback || !this.getFileVersionCallback) {
      return false;
    }
    try {
      const memoryVersion = this.getMemoryVersionCallback();
      const fileVersion = this.getFileVersionCallback();
      return await this.conflictResolver.detectConflict(filePath, memoryVersion, fileVersion);
    } catch (error) {
      DebugManager.error("Error checking for conflicts:", error);
      return false;
    }
  }
  /**
   * 解决冲突
   */
  async resolveConflict(filePath) {
    if (!filePath || !this.getMemoryVersionCallback || !this.getFileVersionCallback) {
      return { strategy: "keep-local" };
    }
    const conflictInfo = {
      filePath,
      localVersion: this.getMemoryVersionCallback(),
      remoteVersion: this.getFileVersionCallback(),
      hasActiveEditors: this.hasActiveEditorsCallback?.() || false,
      lastModified: Date.now()
    };
    return await this.conflictResolver.resolveConflict(conflictInfo);
  }
  /**
   * 应用带冲突解决的保存
   */
  async applySaveWithResolution(trigger, resolution) {
    switch (resolution.strategy) {
      case "keep-local":
        await this.performNormalSave(trigger);
        break;
      case "use-remote":
        await this.notifyUseRemoteVersion();
        break;
      case "merge":
        if (resolution.mergedContent) {
          await this.notifyUseMergedContent(resolution.mergedContent);
        }
        break;
    }
  }
  /**
   * 执行正常保存
   */
  async performNormalSave(trigger) {
    for (const callback of this.saveCallbacks) {
      try {
        await callback(trigger);
      } catch (error) {
        DebugManager.error("Error in save callback:", error);
        throw error;
      }
    }
  }
  /**
   * 通知使用远程版本
   */
  async notifyUseRemoteVersion() {
    DebugManager.log("Using remote version to resolve conflict");
  }
  /**
   * 通知使用合并内容
   */
  async notifyUseMergedContent(mergedContent) {
    DebugManager.log("Using merged content to resolve conflict");
  }
  /**
   * 设置事件监听器（Canvas兼容模式 - 仅保留必要监听器）
   */
  setupEventListeners() {
    document.addEventListener("keydown", this.handleKeyDown.bind(this));
    window.addEventListener("beforeunload", this.handleBeforeUnload.bind(this));
    DebugManager.log("Event listeners setup completed (Canvas-compatible mode)");
  }
  /**
   * 处理窗口失焦（已禁用，保留方法以维持兼容性）
   */
  async handleWindowBlur() {
    DebugManager.log("Window blur detected, but blur save is disabled (Canvas-compatible mode)");
  }
  /**
   * 处理键盘事件
   */
  async handleKeyDown(event) {
    if ((event.ctrlKey || event.metaKey) && event.key === "s") {
      event.preventDefault();
      await this.performSave("manual");
    }
  }
  /**
   * 处理应用关闭前事件
   */
  handleBeforeUnload(event) {
    if (this.hasUnsavedChangesCallback?.()) {
      event.preventDefault();
      event.returnValue = "\u60A8\u6709\u672A\u4FDD\u5B58\u7684\u66F4\u6539\uFF0C\u786E\u5B9A\u8981\u79BB\u5F00\u5417\uFF1F";
    }
  }
  /**
   * 添加保存回调
   */
  addSaveCallback(callback) {
    this.saveCallbacks.push(callback);
  }
  /**
   * 移除保存回调
   */
  removeSaveCallback(callback) {
    const index = this.saveCallbacks.indexOf(callback);
    if (index > -1) {
      this.saveCallbacks.splice(index, 1);
    }
  }
  /**
   * 更新保存条件
   */
  updateSaveConditions(conditions) {
    this.saveConditions = { ...this.saveConditions, ...conditions };
    DebugManager.log("Save conditions updated:", this.saveConditions);
  }
  /**
   * 清理资源（Canvas兼容模式）
   */
  cleanup() {
    document.removeEventListener("keydown", this.handleKeyDown.bind(this));
    window.removeEventListener("beforeunload", this.handleBeforeUnload.bind(this));
    this.saveCallbacks = [];
    this.hasUnsavedChangesCallback = null;
    this.getMemoryVersionCallback = null;
    this.getFileVersionCallback = null;
    this.hasActiveEditorsCallback = null;
    DebugManager.log("SaveTriggerManager cleaned up (Canvas-compatible mode)");
  }
};

// src/managers/TempFileManager.ts
var _TempFileManager = class _TempFileManager {
  constructor(app, config) {
    this.currentTempFile = null;
    this.cleanupInterval = null;
    this.isCleaningUp = false;
    /**
     * 编辑器变化处理器
     */
    this.handleEditorChange = () => {
      if (this.currentTempFile) {
        this.currentTempFile.lastAccessed = Date.now();
      }
    };
    this.app = app;
    this.config = {
      maxAge: 3e5,
      // 5分钟
      cleanupInterval: 6e4,
      // 1分钟检查一次
      filePrefix: "canvasgrid-temp-editor",
      enablePeriodicCleanup: true,
      ...config
    };
    DebugManager.log("TempFileManager initialized with config:", this.config);
  }
  /**
   * 获取单例实例
   */
  static getInstance(app, config) {
    if (!_TempFileManager.instance) {
      _TempFileManager.instance = new _TempFileManager(app, config);
    }
    return _TempFileManager.instance;
  }
  /**
   * 创建临时文件（确保单一文件策略）
   */
  async createTempFile(content) {
    try {
      if (this.currentTempFile) {
        await this.cleanupCurrentTempFile();
      }
      const tempFileName = `${this.config.filePrefix}-${Date.now()}.md`;
      const tempFile = await this.app.vault.create(tempFileName, content);
      const leaf = await this.createHiddenLeaf(tempFile);
      this.currentTempFile = {
        file: tempFile,
        leaf,
        createdAt: Date.now(),
        lastAccessed: Date.now()
      };
      DebugManager.log("Created temp file:", tempFileName);
      return tempFile;
    } catch (error) {
      DebugManager.error("Failed to create temp file:", error);
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`\u4E34\u65F6\u6587\u4EF6\u521B\u5EFA\u5931\u8D25: ${errorMessage}`);
    }
  }
  /**
   * 更新临时文件内容
   */
  async updateTempFile(content) {
    if (!this.currentTempFile) {
      throw new Error("\u6CA1\u6709\u6D3B\u8DC3\u7684\u4E34\u65F6\u6587\u4EF6\u53EF\u4EE5\u66F4\u65B0");
    }
    try {
      await this.app.vault.modify(this.currentTempFile.file, content);
      this.currentTempFile.lastAccessed = Date.now();
      DebugManager.log("Updated temp file content");
    } catch (error) {
      DebugManager.error("Failed to update temp file:", error);
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`\u4E34\u65F6\u6587\u4EF6\u66F4\u65B0\u5931\u8D25: ${errorMessage}`);
    }
  }
  /**
   * 获取当前临时文件
   */
  getCurrentTempFile() {
    if (this.currentTempFile) {
      this.currentTempFile.lastAccessed = Date.now();
      return this.currentTempFile.file;
    }
    return null;
  }
  /**
   * 获取当前临时文件的leaf
   */
  getCurrentLeaf() {
    return this.currentTempFile?.leaf || null;
  }
  /**
   * 清理当前临时文件
   */
  async cleanupCurrentTempFile() {
    if (!this.currentTempFile || this.isCleaningUp) {
      return;
    }
    this.isCleaningUp = true;
    try {
      const { file, leaf } = this.currentTempFile;
      this.app.workspace.off("editor-change", this.handleEditorChange);
      if (leaf && !leaf.isDeferred) {
        leaf.detach();
      }
      if (await this.app.vault.adapter.exists(file.path)) {
        await this.app.fileManager.trashFile(file);
      }
      this.currentTempFile = null;
      DebugManager.log("Cleaned up temp file:", file.path);
    } catch (error) {
      DebugManager.error("Failed to cleanup temp file:", error);
    } finally {
      this.isCleaningUp = false;
    }
  }
  /**
   * 创建隐藏的leaf（不在主工作区显示）
   */
  async createHiddenLeaf(tempFile) {
    const hiddenContainer = document.createElement("div");
    hiddenContainer.style.display = "none";
    hiddenContainer.style.position = "absolute";
    hiddenContainer.style.top = "-9999px";
    hiddenContainer.style.left = "-9999px";
    document.body.appendChild(hiddenContainer);
    const leaf = this.app.workspace.createLeafInParent(
      this.app.workspace.rootSplit,
      0
    );
    if (leaf.containerEl) {
      hiddenContainer.appendChild(leaf.containerEl);
    }
    await leaf.openFile(tempFile);
    return leaf;
  }
  /**
   * 异常恢复机制
   */
  async recoverFromException() {
    try {
      DebugManager.log("Starting exception recovery...");
      const allFiles = this.app.vault.getFiles();
      const tempFiles = allFiles.filter(
        (file) => file.name.startsWith(this.config.filePrefix)
      );
      for (const file of tempFiles) {
        try {
          await this.app.fileManager.trashFile(file);
          DebugManager.log("Recovered temp file:", file.path);
        } catch (error) {
          DebugManager.error("Failed to recover temp file:", file.path, error);
        }
      }
      this.currentTempFile = null;
      this.isCleaningUp = false;
      DebugManager.log("Exception recovery completed");
    } catch (error) {
      DebugManager.error("Exception recovery failed:", error);
    }
  }
  /**
   * 启动定期清理
   */
  startPeriodicCleanup() {
    if (!this.config.enablePeriodicCleanup || this.cleanupInterval) {
      return;
    }
    this.cleanupInterval = setInterval(async () => {
      await this.performPeriodicCleanup();
    }, this.config.cleanupInterval);
    DebugManager.log("Started periodic cleanup");
  }
  /**
   * 停止定期清理
   */
  stopPeriodicCleanup() {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
      DebugManager.log("Stopped periodic cleanup");
    }
  }
  /**
   * 执行定期清理
   */
  async performPeriodicCleanup() {
    if (!this.currentTempFile) {
      return;
    }
    const now = Date.now();
    const age = now - this.currentTempFile.lastAccessed;
    if (age > this.config.maxAge) {
      DebugManager.log("Temp file expired, cleaning up...");
      await this.cleanupCurrentTempFile();
    }
  }
  /**
   * 检查是否有活跃的临时文件
   */
  hasActiveTempFile() {
    return this.currentTempFile !== null;
  }
  /**
   * 获取临时文件状态信息
   */
  getTempFileStatus() {
    if (!this.currentTempFile) {
      return { hasActive: false };
    }
    const now = Date.now();
    return {
      hasActive: true,
      fileName: this.currentTempFile.file.name,
      age: now - this.currentTempFile.createdAt,
      lastAccessed: now - this.currentTempFile.lastAccessed
    };
  }
  /**
   * 强制清理所有资源
   */
  async forceCleanup() {
    try {
      this.stopPeriodicCleanup();
      await this.cleanupCurrentTempFile();
      await this.recoverFromException();
      DebugManager.log("Force cleanup completed");
    } catch (error) {
      DebugManager.error("Force cleanup failed:", error);
    }
  }
  /**
   * 销毁管理器实例
   */
  static destroy() {
    if (_TempFileManager.instance) {
      _TempFileManager.instance.forceCleanup();
      _TempFileManager.instance = null;
    }
  }
};
_TempFileManager.instance = null;
var TempFileManager = _TempFileManager;

// src/managers/PersistentFileManager.ts
var _PersistentFileManager = class _PersistentFileManager {
  constructor(app, config) {
    this.persistentFile = null;
    this.isInitialized = false;
    this.app = app;
    this.config = {
      fileName: ".canvasgrid-editor-workspace.md",
      defaultContent: this.generateDefaultContent(),
      hiddenDirectory: ".obsidian/plugins/canvasgrid-transit",
      enableFileHiding: true,
      ...config
    };
    DebugManager.log("PersistentFileManager initialized with config:", this.config);
  }
  /**
   * 获取单例实例
   */
  static getInstance(app, config) {
    if (!_PersistentFileManager.instance) {
      _PersistentFileManager.instance = new _PersistentFileManager(app, config);
    }
    return _PersistentFileManager.instance;
  }
  /**
   * 初始化持久化文件
   */
  async initialize() {
    if (this.isInitialized) {
      return;
    }
    try {
      await this.ensurePersistentFile();
      this.isInitialized = true;
      DebugManager.log("PersistentFileManager initialized successfully");
    } catch (error) {
      DebugManager.error("Failed to initialize PersistentFileManager:", error);
      throw new Error(`\u6301\u4E45\u5316\u6587\u4EF6\u7BA1\u7406\u5668\u521D\u59CB\u5316\u5931\u8D25: ${error}`);
    }
  }
  /**
   * 准备编辑器文件（清空内容并填充卡片数据）
   */
  async prepareEditorFile(content) {
    try {
      await this.ensureInitialized();
      if (!this.persistentFile) {
        throw new Error("\u6301\u4E45\u5316\u6587\u4EF6\u672A\u6B63\u786E\u521D\u59CB\u5316");
      }
      await this.app.vault.modify(this.persistentFile.file, content);
      this.persistentFile.isInUse = true;
      this.persistentFile.lastAccessed = Date.now();
      DebugManager.log("Prepared editor file with content length:", content.length);
      return this.persistentFile.file;
    } catch (error) {
      DebugManager.error("Failed to prepare editor file:", error);
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`\u7F16\u8F91\u5668\u6587\u4EF6\u51C6\u5907\u5931\u8D25: ${errorMessage}`);
    }
  }
  /**
   * 更新编辑器文件内容
   */
  async updateEditorFile(content) {
    if (!this.persistentFile || !this.persistentFile.isInUse) {
      throw new Error("\u6CA1\u6709\u6D3B\u8DC3\u7684\u7F16\u8F91\u5668\u6587\u4EF6\u53EF\u4EE5\u66F4\u65B0");
    }
    try {
      await this.app.vault.modify(this.persistentFile.file, content);
      this.persistentFile.lastAccessed = Date.now();
      DebugManager.log("Updated editor file content");
    } catch (error) {
      DebugManager.error("Failed to update editor file:", error);
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`\u7F16\u8F91\u5668\u6587\u4EF6\u66F4\u65B0\u5931\u8D25: ${errorMessage}`);
    }
  }
  /**
   * 恢复文件到默认状态（结束编辑时调用）
   */
  async restoreDefaultContent() {
    if (!this.persistentFile) {
      return;
    }
    try {
      await this.app.vault.modify(this.persistentFile.file, this.config.defaultContent);
      this.persistentFile.isInUse = false;
      this.persistentFile.lastAccessed = Date.now();
      DebugManager.log("Restored file to default content");
    } catch (error) {
      DebugManager.error("Failed to restore default content:", error);
    }
  }
  /**
   * 获取当前的leaf实例
   */
  getCurrentLeaf() {
    return this.persistentFile?.leaf || null;
  }
  /**
   * 检查是否有活跃的编辑器文件
   */
  hasActiveEditorFile() {
    return this.persistentFile?.isInUse || false;
  }
  /**
   * 获取文件状态信息
   */
  getFileStatus() {
    if (!this.persistentFile) {
      return { hasFile: false, isInUse: false };
    }
    const now = Date.now();
    return {
      hasFile: true,
      isInUse: this.persistentFile.isInUse,
      fileName: this.persistentFile.file.name,
      age: now - this.persistentFile.createdAt,
      lastAccessed: now - this.persistentFile.lastAccessed
    };
  }
  /**
   * 确保持久化文件存在
   */
  async ensurePersistentFile() {
    const filePath = this.getFilePath();
    let existingFile = this.app.vault.getAbstractFileByPath(filePath);
    if (!existingFile) {
      await this.ensureDirectory();
      existingFile = await this.app.vault.create(filePath, this.config.defaultContent);
      DebugManager.log("Created persistent file:", filePath);
    }
    const leaf = await this.createHiddenLeaf(existingFile);
    this.persistentFile = {
      file: existingFile,
      leaf,
      createdAt: Date.now(),
      lastAccessed: Date.now(),
      isInUse: false
    };
    if (this.config.enableFileHiding) {
      this.hideFileFromExplorer();
    }
  }
  /**
   * 确保目录存在
   */
  async ensureDirectory() {
    const dirPath = this.config.hiddenDirectory;
    try {
      const dirExists = await this.app.vault.adapter.exists(dirPath);
      if (!dirExists) {
        await this.app.vault.createFolder(dirPath);
        DebugManager.log("Created directory:", dirPath);
      }
    } catch (error) {
      DebugManager.warn("Failed to create directory, using root:", error);
      this.config.hiddenDirectory = "";
    }
  }
  /**
   * 获取完整文件路径
   */
  getFilePath() {
    if (this.config.hiddenDirectory) {
      return `${this.config.hiddenDirectory}/${this.config.fileName}`;
    }
    return this.config.fileName;
  }
  /**
   * 生成默认文件内容
   */
  generateDefaultContent() {
    return `<!-- 
Canvasgrid Transit \u7F16\u8F91\u5668\u5DE5\u4F5C\u6587\u4EF6
\u6B64\u6587\u4EF6\u7531\u63D2\u4EF6\u81EA\u52A8\u7BA1\u7406\uFF0C\u8BF7\u52FF\u624B\u52A8\u7F16\u8F91

Editor Workspace File for Canvasgrid Transit Plugin
This file is automatically managed by the plugin, please do not edit manually

\u521B\u5EFA\u65F6\u95F4 / Created: ${(/* @__PURE__ */ new Date()).toISOString()}
-->

<!-- \u63D2\u4EF6\u5DE5\u4F5C\u533A\u57DF - Plugin Workspace -->
`;
  }
  /**
   * 创建隐藏的leaf
   */
  async createHiddenLeaf(file) {
    const hiddenContainer = document.createElement("div");
    hiddenContainer.style.display = "none";
    hiddenContainer.style.position = "absolute";
    hiddenContainer.style.top = "-9999px";
    hiddenContainer.style.left = "-9999px";
    document.body.appendChild(hiddenContainer);
    const leaf = this.app.workspace.createLeafInParent(
      this.app.workspace.rootSplit,
      0
    );
    if (leaf.containerEl) {
      hiddenContainer.appendChild(leaf.containerEl);
    }
    await leaf.openFile(file);
    return leaf;
  }
  /**
   * 从文件浏览器隐藏文件
   */
  hideFileFromExplorer() {
    if (!this.persistentFile)
      return;
    const fileName = this.persistentFile.file.name;
    const filePath = this.persistentFile.file.path;
    const style = document.createElement("style");
    style.id = "canvasgrid-hide-workspace-file";
    style.textContent = `
            .nav-file-title[data-path="${filePath}"] {
                display: none !important;
            }
            .nav-file-title[data-path*="${fileName}"] {
                display: none !important;
            }
        `;
    const existingStyle = document.getElementById("canvasgrid-hide-workspace-file");
    if (existingStyle) {
      existingStyle.remove();
    }
    document.head.appendChild(style);
    DebugManager.log("Hidden file from explorer:", fileName);
  }
  /**
   * 确保已初始化
   */
  async ensureInitialized() {
    if (!this.isInitialized) {
      await this.initialize();
    }
  }
  /**
   * 清理资源
   */
  async cleanup() {
    try {
      await this.restoreDefaultContent();
      if (this.persistentFile?.leaf && !this.persistentFile.leaf.isDeferred) {
        this.persistentFile.leaf.detach();
      }
      const style = document.getElementById("canvasgrid-hide-workspace-file");
      if (style) {
        style.remove();
      }
      DebugManager.log("PersistentFileManager cleanup completed");
    } catch (error) {
      DebugManager.error("Failed to cleanup PersistentFileManager:", error);
    }
  }
  /**
   * 销毁管理器实例
   */
  static async destroy() {
    if (_PersistentFileManager.instance) {
      await _PersistentFileManager.instance.cleanup();
      _PersistentFileManager.instance = null;
    }
  }
};
_PersistentFileManager.instance = null;
var PersistentFileManager = _PersistentFileManager;

// src/managers/HiddenEditorManager.ts
var HiddenEditorManager = class {
  // 默认使用持久化文件
  constructor(app, config) {
    this.currentEditor = null;
    this.hiddenContainer = null;
    this.usePersistentFile = true;
    this.app = app;
    this.tempFileManager = TempFileManager.getInstance(app);
    this.persistentFileManager = PersistentFileManager.getInstance(app);
    this.config = {
      enableSyntaxHighlight: true,
      enableAutoComplete: true,
      enableVimMode: false,
      theme: "auto",
      ...config
    };
    this.initializeHiddenContainer();
    this.initializePersistentFileManager();
    DebugManager.log("HiddenEditorManager initialized with persistent file support");
  }
  /**
   * 初始化持久化文件管理器
   */
  async initializePersistentFileManager() {
    try {
      await this.persistentFileManager.initialize();
      DebugManager.log("Persistent file manager initialized successfully");
    } catch (error) {
      DebugManager.error("Failed to initialize persistent file manager, falling back to temp files:", error);
      this.usePersistentFile = false;
    }
  }
  /**
   * 创建隐藏编辑器
   */
  async createHiddenEditor(content) {
    try {
      if (this.currentEditor) {
        await this.cleanupCurrentEditor();
      }
      let workspaceFile;
      let leaf;
      if (this.usePersistentFile) {
        workspaceFile = await this.persistentFileManager.prepareEditorFile(content);
        leaf = this.persistentFileManager.getCurrentLeaf();
        DebugManager.log("Using persistent file for editor");
      } else {
        workspaceFile = await this.tempFileManager.createTempFile(content);
        leaf = this.tempFileManager.getCurrentLeaf();
        DebugManager.log("Using temporary file for editor (fallback)");
      }
      if (!leaf) {
        throw new Error("\u65E0\u6CD5\u83B7\u53D6\u5DE5\u4F5C\u6587\u4EF6\u7684leaf");
      }
      const markdownView = leaf.view;
      if (!markdownView || !markdownView.editor) {
        throw new Error("\u65E0\u6CD5\u83B7\u53D6MarkdownView\u6216Editor\u5B9E\u4F8B");
      }
      const editor = markdownView.editor;
      const container = this.createEditorContainer();
      await this.extractEditorElement(markdownView, container);
      this.setupEditorStyles(container);
      this.configureEditor(editor);
      this.currentEditor = {
        editor,
        markdownView,
        leaf,
        workspaceFile,
        container,
        createdAt: Date.now()
      };
      DebugManager.log(
        "Created hidden editor successfully using",
        this.usePersistentFile ? "persistent file" : "temporary file"
      );
      return container;
    } catch (error) {
      DebugManager.error("Failed to create hidden editor:", error);
      if (this.usePersistentFile && !this.currentEditor) {
        DebugManager.warn("Persistent file failed, falling back to temporary file");
        this.usePersistentFile = false;
        return this.createHiddenEditor(content);
      }
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`\u9690\u85CF\u7F16\u8F91\u5668\u521B\u5EFA\u5931\u8D25: ${errorMessage}`);
    }
  }
  /**
   * 获取当前编辑器实例
   */
  getCurrentEditor() {
    return this.currentEditor?.editor || null;
  }
  /**
   * 获取编辑器内容
   */
  getEditorContent() {
    if (!this.currentEditor) {
      return "";
    }
    try {
      return this.currentEditor.editor.getValue();
    } catch (error) {
      DebugManager.error("Failed to get editor content:", error);
      return "";
    }
  }
  /**
   * 设置编辑器内容
   */
  setEditorContent(content) {
    if (!this.currentEditor) {
      DebugManager.warn("No active editor to set content");
      return;
    }
    try {
      this.currentEditor.editor.setValue(content);
      DebugManager.log("Editor content updated");
    } catch (error) {
      DebugManager.error("Failed to set editor content:", error);
    }
  }
  /**
   * 聚焦编辑器
   */
  focusEditor() {
    if (!this.currentEditor) {
      return;
    }
    try {
      this.currentEditor.editor.focus();
      const lastLine = this.currentEditor.editor.lastLine();
      const lastLineLength = this.currentEditor.editor.getLine(lastLine).length;
      this.currentEditor.editor.setCursor({ line: lastLine, ch: lastLineLength });
      DebugManager.log("Editor focused");
    } catch (error) {
      DebugManager.error("Failed to focus editor:", error);
    }
  }
  /**
   * 添加编辑器事件监听器
   */
  addEditorEventListeners(onChange, onSave, onCancel) {
    if (!this.currentEditor) {
      return;
    }
    const { editor, container } = this.currentEditor;
    if (onChange) {
      const changeHandler = () => {
        const content = editor.getValue();
        onChange(content);
      };
      this.app.workspace.on("editor-change", changeHandler);
      container.changeHandler = changeHandler;
    }
    const keyHandler = (evt) => {
      if (evt.key === "Escape" && onCancel) {
        evt.preventDefault();
        onCancel();
      } else if (evt.key === "Enter" && (evt.ctrlKey || evt.metaKey) && onSave) {
        evt.preventDefault();
        onSave(editor.getValue());
      }
    };
    container.addEventListener("keydown", keyHandler);
    container.keyHandler = keyHandler;
    DebugManager.log("Editor event listeners added");
  }
  /**
   * 清理当前编辑器
   */
  async cleanupCurrentEditor() {
    if (!this.currentEditor) {
      return;
    }
    try {
      const { container } = this.currentEditor;
      const changeHandler = container.changeHandler;
      const keyHandler = container.keyHandler;
      if (changeHandler) {
        this.app.workspace.off("editor-change", changeHandler);
      }
      if (keyHandler) {
        container.removeEventListener("keydown", keyHandler);
      }
      if (this.usePersistentFile) {
        await this.persistentFileManager.restoreDefaultContent();
        DebugManager.log("Restored persistent file to default content");
      } else {
        await this.tempFileManager.cleanupCurrentTempFile();
        DebugManager.log("Cleaned up temporary file");
      }
      if (container.parentNode) {
        container.parentNode.removeChild(container);
      }
      this.currentEditor = null;
      DebugManager.log("Current editor cleaned up");
    } catch (error) {
      DebugManager.error("Failed to cleanup current editor:", error);
    }
  }
  /**
   * 初始化隐藏容器
   */
  initializeHiddenContainer() {
    this.hiddenContainer = document.createElement("div");
    this.hiddenContainer.className = "canvasgrid-hidden-editor-container";
    this.hiddenContainer.style.cssText = `
            position: absolute;
            top: -9999px;
            left: -9999px;
            width: 1px;
            height: 1px;
            overflow: hidden;
            visibility: hidden;
            pointer-events: none;
        `;
    document.body.appendChild(this.hiddenContainer);
  }
  /**
   * 创建编辑器容器
   */
  createEditorContainer() {
    const container = document.createElement("div");
    container.className = "card-editor-container obsidian-editor hidden-editor";
    container.style.cssText = `
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
        `;
    return container;
  }
  /**
   * 提取编辑器DOM元素
   */
  async extractEditorElement(markdownView, container) {
    await new Promise((resolve) => setTimeout(resolve, 100));
    const editorEl = markdownView.contentEl;
    if (!editorEl) {
      throw new Error("\u65E0\u6CD5\u83B7\u53D6\u7F16\u8F91\u5668DOM\u5143\u7D20");
    }
    container.appendChild(editorEl);
    editorEl.style.display = "";
    editorEl.style.visibility = "visible";
    editorEl.style.position = "relative";
  }
  /**
   * 设置编辑器样式
   */
  setupEditorStyles(container) {
    const editorEl = container.querySelector(".cm-editor");
    if (editorEl) {
      editorEl.style.cssText = `
                width: 100%;
                height: 100%;
                border: none;
                outline: none;
                background: var(--background-primary);
                color: var(--text-normal);
                font-family: var(--font-text);
                font-size: var(--font-text-size);
                line-height: var(--line-height-normal);
            `;
    }
  }
  /**
   * 配置编辑器
   */
  configureEditor(editor) {
    try {
      if (!this.config.enableVimMode) {
      }
      DebugManager.log("Editor configured");
    } catch (error) {
      DebugManager.error("Failed to configure editor:", error);
    }
  }
  /**
   * 检查是否有活跃编辑器
   */
  hasActiveEditor() {
    return this.currentEditor !== null;
  }
  /**
   * 获取编辑器状态信息
   */
  getEditorStatus() {
    if (!this.currentEditor) {
      return { hasActive: false };
    }
    const now = Date.now();
    const content = this.getEditorContent();
    return {
      hasActive: true,
      age: now - this.currentEditor.createdAt,
      contentLength: content.length
    };
  }
  /**
   * 更新编辑器内容（支持持久化文件）
   */
  async updateEditorContent(content) {
    if (!this.currentEditor) {
      throw new Error("\u6CA1\u6709\u6D3B\u8DC3\u7684\u7F16\u8F91\u5668\u53EF\u4EE5\u66F4\u65B0");
    }
    try {
      if (this.usePersistentFile) {
        await this.persistentFileManager.updateEditorFile(content);
      } else {
        await this.tempFileManager.updateTempFile(content);
      }
      DebugManager.log("Editor content updated");
    } catch (error) {
      DebugManager.error("Failed to update editor content:", error);
      throw error;
    }
  }
  /**
   * 切换文件管理模式
   */
  setPersistentFileMode(enabled) {
    this.usePersistentFile = enabled;
    DebugManager.log("Persistent file mode set to:", enabled);
  }
  /**
   * 获取当前文件管理模式
   */
  isPersistentFileMode() {
    return this.usePersistentFile;
  }
  /**
   * 获取文件状态信息
   */
  getFileStatus() {
    if (this.usePersistentFile) {
      return this.persistentFileManager.getFileStatus();
    } else {
      return this.tempFileManager.getTempFileStatus();
    }
  }
  /**
   * 强制清理所有资源
   */
  async forceCleanup() {
    try {
      await this.cleanupCurrentEditor();
      if (this.usePersistentFile) {
        await this.persistentFileManager.cleanup();
      }
      if (this.hiddenContainer && this.hiddenContainer.parentNode) {
        this.hiddenContainer.parentNode.removeChild(this.hiddenContainer);
        this.hiddenContainer = null;
      }
      DebugManager.log("HiddenEditorManager force cleanup completed");
    } catch (error) {
      DebugManager.error("HiddenEditorManager force cleanup failed:", error);
    }
  }
};

// src/managers/EditorStateCoordinator.ts
var EditorStateCoordinator = class {
  constructor(app, editorStateManager) {
    this.activeEditorNodeId = null;
    this.app = app;
    this.editorStateManager = editorStateManager;
    this.tempFileManager = TempFileManager.getInstance(app);
    this.persistentFileManager = PersistentFileManager.getInstance(app);
    this.hiddenEditorManager = new HiddenEditorManager(app);
    this.tempFileManager.startPeriodicCleanup();
    this.initializePersistentFileManager();
    DebugManager.log("EditorStateCoordinator initialized with persistent file support");
  }
  /**
   * 初始化持久化文件管理器
   */
  async initializePersistentFileManager() {
    try {
      await this.persistentFileManager.initialize();
      DebugManager.log("Persistent file manager initialized in coordinator");
    } catch (error) {
      DebugManager.error("Failed to initialize persistent file manager in coordinator:", error);
    }
  }
  /**
   * 创建简化的编辑器实例（官方Canvas风格）
   */
  async createEditor(options) {
    try {
      if (this.activeEditorNodeId && this.activeEditorNodeId !== options.nodeId) {
        await this.cleanupEditor(this.activeEditorNodeId);
      }
      const editorContainer = await this.hiddenEditorManager.createHiddenEditor(options.content);
      this.setupSimplifiedEventListeners(options);
      this.activeEditorNodeId = options.nodeId;
      editorContainer.cleanup = () => {
        this.cleanupEditor(options.nodeId);
      };
      setTimeout(() => {
        this.hiddenEditorManager.focusEditor();
      }, 50);
      DebugManager.log("Simplified editor created for node:", options.nodeId);
      return editorContainer;
    } catch (error) {
      DebugManager.error("Failed to create simplified editor:", error);
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`\u7F16\u8F91\u5668\u521B\u5EFA\u5931\u8D25: ${errorMessage}`);
    }
  }
  /**
   * 🎯 优化：同步编辑器状态 - 确保所有管理器及时更新
   */
  syncEditorState(nodeId, content) {
    if (this.activeEditorNodeId !== nodeId) {
      DebugManager.warn("Attempting to sync inactive editor:", nodeId);
      return;
    }
    try {
      DebugManager.log("\u{1F504} \u5F00\u59CB\u540C\u6B65\u7F16\u8F91\u5668\u72B6\u6001", {
        nodeId,
        contentLength: content.length,
        contentPreview: content.substring(0, 50) + (content.length > 50 ? "..." : "")
      });
      this.editorStateManager.updateContent(nodeId, {
        text: content,
        type: "text",
        id: nodeId,
        x: 0,
        y: 0,
        width: 200,
        height: 100
        // 提供默认值
      });
      DebugManager.log("\u2705 \u7F16\u8F91\u5668\u72B6\u6001\u7BA1\u7406\u5668\u5DF2\u540C\u6B65", { nodeId });
      const currentContent = this.hiddenEditorManager.getEditorContent();
      if (currentContent !== content) {
        this.hiddenEditorManager.setEditorContent(content);
        DebugManager.log("\u2705 \u9690\u85CF\u7F16\u8F91\u5668\u5185\u5BB9\u5DF2\u540C\u6B65", { nodeId });
      }
      this.notifyStateChange(nodeId, content);
      DebugManager.log("\u{1F389} \u7F16\u8F91\u5668\u72B6\u6001\u540C\u6B65\u5B8C\u6210", { nodeId });
    } catch (error) {
      DebugManager.error("\u274C \u7F16\u8F91\u5668\u72B6\u6001\u540C\u6B65\u5931\u8D25", { nodeId, error });
    }
  }
  /**
   * 🎯 新增：通知状态变化 - 让其他组件及时响应
   */
  notifyStateChange(nodeId, content) {
    try {
      DebugManager.log("\u{1F4E2} \u72B6\u6001\u53D8\u5316\u901A\u77E5\u5DF2\u53D1\u9001", { nodeId, contentLength: content.length });
    } catch (error) {
      DebugManager.error("\u274C \u72B6\u6001\u53D8\u5316\u901A\u77E5\u5931\u8D25", { nodeId, error });
    }
  }
  /**
   * 获取编辑器内容
   */
  getEditorContent(nodeId) {
    if (this.activeEditorNodeId !== nodeId) {
      DebugManager.warn("Attempting to get content from inactive editor:", nodeId);
      return "";
    }
    return this.hiddenEditorManager.getEditorContent();
  }
  /**
   * 检查编辑器是否活跃
   */
  isEditorActive(nodeId) {
    return this.activeEditorNodeId === nodeId && this.hiddenEditorManager.hasActiveEditor();
  }
  /**
   * 获取当前活跃编辑器的节点ID
   */
  getActiveEditorNodeId() {
    return this.activeEditorNodeId;
  }
  /**
   * 清理指定编辑器（简化版本，官方Canvas风格）
   * 🎯 修复：返回清理结果，包含编辑内容
   */
  async cleanupEditor(nodeId, saveChanges = false) {
    try {
      if (this.activeEditorNodeId !== nodeId) {
        DebugManager.log("Editor not active, skipping cleanup:", nodeId);
        return { success: true };
      }
      let editorContent;
      try {
        editorContent = this.hiddenEditorManager.getEditorContent();
        DebugManager.log("\u{1F4DD} \u83B7\u53D6\u7F16\u8F91\u5668\u5185\u5BB9\u6210\u529F", {
          nodeId,
          contentLength: editorContent?.length || 0,
          contentPreview: editorContent?.substring(0, 50) + (editorContent && editorContent.length > 50 ? "..." : "")
        });
      } catch (contentError) {
        DebugManager.warn("\u26A0\uFE0F \u83B7\u53D6\u7F16\u8F91\u5668\u5185\u5BB9\u5931\u8D25\uFF0C\u4F7F\u7528\u7A7A\u5185\u5BB9", { nodeId, error: contentError });
        editorContent = "";
      }
      await this.hiddenEditorManager.cleanupCurrentEditor();
      this.activeEditorNodeId = null;
      DebugManager.log("\u2705 \u7B80\u5316\u7F16\u8F91\u5668\u6E05\u7406\u5B8C\u6210", {
        nodeId,
        hasContent: !!editorContent,
        contentLength: editorContent?.length || 0
      });
      return { content: editorContent, success: true };
    } catch (error) {
      DebugManager.error("\u274C \u7F16\u8F91\u5668\u6E05\u7406\u5931\u8D25:", error);
      this.activeEditorNodeId = null;
      return { success: false };
    }
  }
  /**
   * 清理所有编辑器
   */
  async cleanupAllEditors() {
    try {
      if (this.activeEditorNodeId) {
        await this.cleanupEditor(this.activeEditorNodeId, false);
      }
      await this.hiddenEditorManager.forceCleanup();
      await this.tempFileManager.forceCleanup();
      DebugManager.log("All editors cleaned up");
    } catch (error) {
      DebugManager.error("Failed to cleanup all editors:", error);
    }
  }
  /**
   * 设置简化的编辑器事件监听器（官方Canvas风格）
   */
  setupSimplifiedEventListeners(options) {
    const { nodeId, onChange, onSave, onCancel } = options;
    this.hiddenEditorManager.addEditorEventListeners(
      // onChange 处理器 - 简化，直接调用
      (content) => {
        if (onChange) {
          onChange(content);
        }
      },
      // onSave 处理器 - 简化，减少异步复杂性
      (content) => {
        try {
          if (onSave) {
            onSave(content);
          }
        } catch (error) {
          DebugManager.error("Error in save handler:", error);
        }
      },
      // onCancel 处理器 - 简化，减少异步复杂性
      () => {
        try {
          if (onCancel) {
            onCancel();
          }
        } catch (error) {
          DebugManager.error("Error in cancel handler:", error);
        }
      }
    );
  }
  /**
   * 设置编辑器事件监听器（保留向后兼容）
   */
  setupEditorEventListeners(options, editorState) {
    this.setupSimplifiedEventListeners(options);
  }
  /**
   * 获取编辑器状态信息
   */
  getEditorStatusInfo() {
    const isPersistentMode = this.hiddenEditorManager.isPersistentFileMode();
    return {
      hasActiveEditor: this.activeEditorNodeId !== null,
      activeNodeId: this.activeEditorNodeId,
      editorStatus: this.hiddenEditorManager.getEditorStatus(),
      fileStatus: isPersistentMode ? this.persistentFileManager.getFileStatus() : this.tempFileManager.getTempFileStatus(),
      fileMode: isPersistentMode ? "persistent" : "temporary",
      stateManagerStatus: {
        hasActiveEditors: this.editorStateManager.hasActiveEditors(),
        hasUnsavedChanges: this.editorStateManager.hasUnsavedChanges(),
        activeEditorIds: this.editorStateManager.getActiveEditorIds()
      }
    };
  }
  /**
   * 异常恢复
   */
  async recoverFromException() {
    try {
      DebugManager.log("Starting editor coordinator exception recovery...");
      await this.cleanupAllEditors();
      if (this.hiddenEditorManager.isPersistentFileMode()) {
        await this.persistentFileManager.cleanup();
        DebugManager.log("Persistent file manager recovered");
      } else {
        await this.tempFileManager.recoverFromException();
        DebugManager.log("Temporary file manager recovered");
      }
      this.activeEditorNodeId = null;
      DebugManager.log("Editor coordinator exception recovery completed");
    } catch (error) {
      DebugManager.error("Editor coordinator exception recovery failed:", error);
    }
  }
  /**
   * 检查系统健康状态
   */
  checkSystemHealth() {
    const issues = [];
    const recommendations = [];
    const hasActiveEditor = this.hiddenEditorManager.hasActiveEditor();
    const hasActiveStateManager = this.editorStateManager.hasActiveEditors();
    let hasActiveFile = false;
    if (this.hiddenEditorManager.isPersistentFileMode()) {
      hasActiveFile = this.persistentFileManager.hasActiveEditorFile();
    } else {
      hasActiveFile = this.tempFileManager.hasActiveTempFile();
    }
    if (hasActiveEditor !== hasActiveFile) {
      const fileType = this.hiddenEditorManager.isPersistentFileMode() ? "\u6301\u4E45\u5316\u6587\u4EF6" : "\u4E34\u65F6\u6587\u4EF6";
      issues.push(`\u7F16\u8F91\u5668\u548C${fileType}\u72B6\u6001\u4E0D\u4E00\u81F4`);
      recommendations.push("\u6267\u884C\u5F02\u5E38\u6062\u590D");
    }
    if (hasActiveEditor !== hasActiveStateManager) {
      issues.push("\u7F16\u8F91\u5668\u548C\u72B6\u6001\u7BA1\u7406\u5668\u72B6\u6001\u4E0D\u4E00\u81F4");
      recommendations.push("\u540C\u6B65\u7F16\u8F91\u5668\u72B6\u6001");
    }
    if (this.activeEditorNodeId && !hasActiveEditor) {
      issues.push("\u8BB0\u5F55\u7684\u6D3B\u8DC3\u7F16\u8F91\u5668\u4E0E\u5B9E\u9645\u72B6\u6001\u4E0D\u7B26");
      recommendations.push("\u91CD\u7F6E\u7F16\u8F91\u5668\u72B6\u6001");
    }
    const isHealthy = issues.length === 0;
    return {
      isHealthy,
      issues,
      recommendations
    };
  }
  /**
   * 销毁协调器
   */
  async destroy() {
    try {
      await this.cleanupAllEditors();
      this.tempFileManager.stopPeriodicCleanup();
      DebugManager.log("EditorStateCoordinator destroyed");
    } catch (error) {
      DebugManager.error("Failed to destroy EditorStateCoordinator:", error);
    }
  }
};

// src/managers/ObsidianRenderManager.ts
var import_obsidian9 = require("obsidian");
var ObsidianRenderManager = class {
  constructor(app, config) {
    this.componentPool = [];
    this.activeComponents = /* @__PURE__ */ new Set();
    this.renderCache = /* @__PURE__ */ new Map();
    // 🎯 新增：容器→组件的弱引用映射，用于生命周期管理
    this.containerComponents = /* @__PURE__ */ new WeakMap();
    this.app = app;
    this.config = {
      enableCache: true,
      cacheTimeout: 2 * 60 * 1e3,
      // 🎯 优化：降低为2分钟
      maxCacheSize: 30,
      // 🎯 优化：降低缓存大小
      enableLazyLoading: true,
      performanceMonitoring: true,
      ...config
    };
    this.metrics = {
      renderTime: 0,
      cacheHits: 0,
      cacheMisses: 0,
      totalRenders: 0,
      averageRenderTime: 0
    };
    DebugManager.log("\u2705 ObsidianRenderManager initialized", this.config);
  }
  /**
   * 渲染Markdown内容到指定容器
   */
  async renderMarkdownContent(content, container, sourcePath = "", nodeId) {
    const startTime = performance.now();
    try {
      this.disposeContainer(container);
      DebugManager.log("\u{1F3A8} \u5F00\u59CB\u6E32\u67D3Markdown\u5185\u5BB9", {
        nodeId,
        contentLength: content.length,
        contentPreview: content.substring(0, 50) + (content.length > 50 ? "..." : "")
      });
      const complexity = this.analyzeContentComplexity(content);
      DebugManager.log("\u{1F4CA} \u5185\u5BB9\u590D\u6742\u5EA6\u5206\u6790", { nodeId, complexity });
      if (this.config.enableCache) {
        const cached = this.getCachedContent(content);
        if (cached) {
          container.empty();
          container.appendChild(cached.cloneNode(true));
          this.metrics.cacheHits++;
          DebugManager.log("\u26A1 \u4F7F\u7528\u7F13\u5B58\u5185\u5BB9", { nodeId, cacheHits: this.metrics.cacheHits });
          return;
        }
        this.metrics.cacheMisses++;
      }
      container.empty();
      if (complexity.hasMarkdownFeatures) {
        await this.renderWithObsidianEngine(content, container, sourcePath, nodeId);
      } else {
        this.renderSimpleText(content, container, nodeId);
      }
      if (this.config.enableCache && complexity.hasMarkdownFeatures) {
        this.cacheRenderedContent(content, container);
      }
    } catch (error) {
      DebugManager.error("\u274C Markdown\u6E32\u67D3\u5931\u8D25", { nodeId, error });
      this.renderErrorFallback(container, content, error);
    } finally {
      const renderTime = performance.now() - startTime;
      this.updateMetrics(renderTime);
      if (this.config.performanceMonitoring) {
        DebugManager.log("\u{1F4C8} \u6E32\u67D3\u6027\u80FD\u6307\u6807", {
          nodeId,
          renderTime: `${renderTime.toFixed(2)}ms`,
          metrics: this.metrics
        });
      }
    }
  }
  /**
   * 使用Obsidian渲染引擎渲染复杂内容
   */
  async renderWithObsidianEngine(content, container, sourcePath, nodeId) {
    const component = this.getOrCreateComponent();
    try {
      await import_obsidian9.MarkdownRenderer.renderMarkdown(
        content,
        container,
        sourcePath,
        component
      );
      this.containerComponents.set(container, component);
      container.addClass("canvas-card-markdown-content");
      this.setupLinkHandlers(container, nodeId);
      DebugManager.log("\u2705 Obsidian\u5F15\u64CE\u6E32\u67D3\u5B8C\u6210", { nodeId });
    } catch (error) {
      DebugManager.error("\u274C Obsidian\u5F15\u64CE\u6E32\u67D3\u5931\u8D25", { nodeId, error });
      this.releaseComponent(component);
      this.renderSimpleText(content, container, nodeId);
    }
  }
  /**
   * 渲染简单文本内容
   */
  renderSimpleText(content, container, nodeId) {
    container.textContent = content;
    container.addClass("canvas-card-simple-text");
    container.style.cssText = `
            color: var(--text-normal);
            line-height: 1.5;
            overflow-wrap: break-word;
            white-space: pre-wrap;
        `;
    DebugManager.log("\u2705 \u7B80\u5355\u6587\u672C\u6E32\u67D3\u5B8C\u6210", { nodeId });
  }
  /**
   * 渲染错误降级处理
   */
  renderErrorFallback(container, content, error) {
    container.empty();
    const errorDiv = container.createDiv("render-error-fallback");
    errorDiv.style.cssText = `
            color: var(--text-error);
            font-style: italic;
            padding: 8px;
            border: 1px solid var(--background-modifier-border);
            border-radius: 4px;
            background: var(--background-secondary);
        `;
    errorDiv.createDiv("error-message").textContent = "\u6E32\u67D3\u5931\u8D25\uFF0C\u663E\u793A\u539F\u59CB\u5185\u5BB9";
    errorDiv.createDiv("error-content").textContent = content;
    DebugManager.error("\u{1F6A8} \u6E32\u67D3\u9519\u8BEF\u964D\u7EA7", { error: error.message });
  }
  /**
   * 分析内容复杂度
   */
  analyzeContentComplexity(content) {
    const hasLinks = /\[\[.*?\]\]/.test(content);
    const hasTags = /#[\w-]+/.test(content);
    const hasEmbeds = /!\[\[.*?\]\]/.test(content);
    const hasMath = /\$.*?\$/.test(content);
    const hasCodeBlocks = /```[\s\S]*?```|`[^`]+`/.test(content);
    const hasMarkdown = /[*_~`#>-]/.test(content);
    const hasMarkdownFeatures = hasLinks || hasTags || hasEmbeds || hasMath || hasCodeBlocks || hasMarkdown;
    let complexity = "simple";
    if (hasMarkdownFeatures) {
      complexity = hasMath || hasEmbeds || hasCodeBlocks ? "complex" : "medium";
    }
    return {
      hasMarkdownFeatures,
      hasLinks,
      hasTags,
      hasEmbeds,
      hasMath,
      hasCodeBlocks,
      complexity
    };
  }
  /**
   * 获取或创建Component实例
   */
  getOrCreateComponent() {
    let component = this.componentPool.pop();
    if (!component) {
      component = new import_obsidian9.Component();
    }
    this.activeComponents.add(component);
    return component;
  }
  /**
   * 释放Component实例
   */
  releaseComponent(component) {
    this.activeComponents.delete(component);
    component.unload();
    component.load();
    if (this.componentPool.length < 10) {
      this.componentPool.push(component);
    }
  }
  /**
   * 设置链接处理器
   */
  setupLinkHandlers(container, nodeId) {
    const links = container.querySelectorAll("a.internal-link");
    links.forEach((link) => {
      link.addEventListener("click", (e) => {
        e.preventDefault();
        const href = link.getAttribute("href");
        if (href) {
          DebugManager.log("\u{1F517} \u5185\u90E8\u94FE\u63A5\u70B9\u51FB", { nodeId, href });
          this.app.workspace.openLinkText(href, "");
        }
      });
    });
  }
  /**
   * 缓存渲染内容
   */
  cacheRenderedContent(content, container) {
    const hash = this.generateContentHash(content);
    const clonedElement = container.cloneNode(true);
    this.renderCache.set(hash, {
      element: clonedElement,
      timestamp: Date.now(),
      hash
    });
    this.cleanupCache();
  }
  /**
   * 获取缓存内容
   */
  getCachedContent(content) {
    const hash = this.generateContentHash(content);
    const cached = this.renderCache.get(hash);
    if (cached && Date.now() - cached.timestamp < this.config.cacheTimeout) {
      return cached.element;
    }
    if (cached) {
      this.renderCache.delete(hash);
    }
    return null;
  }
  /**
   * 生成内容哈希
   */
  generateContentHash(content) {
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
      const char = content.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return hash.toString(36);
  }
  /**
   * 清理过期缓存
   */
  cleanupCache() {
    const now = Date.now();
    const toDelete = [];
    for (const [hash, item] of this.renderCache) {
      if (now - item.timestamp > this.config.cacheTimeout) {
        toDelete.push(hash);
      }
    }
    toDelete.forEach((hash) => this.renderCache.delete(hash));
    if (this.renderCache.size > this.config.maxCacheSize) {
      const entries = Array.from(this.renderCache.entries());
      entries.sort((a, b) => a[1].timestamp - b[1].timestamp);
      const toRemove = entries.slice(0, entries.length - this.config.maxCacheSize);
      toRemove.forEach(([hash]) => this.renderCache.delete(hash));
    }
  }
  /**
   * 更新性能指标
   */
  updateMetrics(renderTime) {
    this.metrics.totalRenders++;
    this.metrics.renderTime += renderTime;
    this.metrics.averageRenderTime = this.metrics.renderTime / this.metrics.totalRenders;
  }
  /**
   * 获取性能指标
   */
  getMetrics() {
    return { ...this.metrics };
  }
  /**
   * 🎯 新增：释放特定容器关联的组件
   */
  disposeContainer(container) {
    const component = this.containerComponents.get(container);
    if (component) {
      DebugManager.log("\u{1F9F9} \u91CA\u653E\u5BB9\u5668\u5173\u8054\u7684\u7EC4\u4EF6", {
        containerClass: container.className,
        activeComponentsCount: this.activeComponents.size
      });
      this.containerComponents.delete(container);
      this.releaseComponent(component);
    }
  }
  /**
   * 🎯 新增：获取统计信息
   */
  getStats() {
    return {
      activeComponents: this.activeComponents.size,
      poolSize: this.componentPool.length,
      cacheSize: this.renderCache.size,
      cacheHits: this.metrics.cacheHits,
      cacheMisses: this.metrics.cacheMisses,
      averageRenderTime: this.metrics.averageRenderTime
    };
  }
  /**
   * 🎯 新增：更新配置
   */
  updateConfig(newConfig) {
    this.config = { ...this.config, ...newConfig };
    DebugManager.log("\u{1F527} ObsidianRenderManager\u914D\u7F6E\u5DF2\u66F4\u65B0", this.config);
  }
  /**
   * 清理所有资源
   */
  cleanup() {
    this.activeComponents.forEach((component) => {
      component.unload();
    });
    this.activeComponents.clear();
    this.componentPool.forEach((component) => {
      component.unload();
    });
    this.componentPool.length = 0;
    this.renderCache.clear();
    DebugManager.log("\u{1F9F9} ObsidianRenderManager \u8D44\u6E90\u6E05\u7406\u5B8C\u6210");
  }
};

// src/managers/DiagnosticsManager.ts
var DiagnosticsManager = class {
  constructor(app, tempFileManager, editorStateCoordinator) {
    this.performanceMetrics = /* @__PURE__ */ new Map();
    this.errorCount = 0;
    this.totalOperations = 0;
    this.app = app;
    this.tempFileManager = tempFileManager;
    this.editorStateCoordinator = editorStateCoordinator;
  }
  /**
   * 执行系统健康检查
   */
  checkSystemHealth() {
    const issues = [];
    const recommendations = [];
    const tempFileIssues = this.checkTempFileHealth();
    issues.push(...tempFileIssues);
    const editorIssues = this.checkEditorHealth();
    issues.push(...editorIssues);
    const stateIssues = this.checkStateConsistency();
    issues.push(...stateIssues);
    const performanceIssues = this.checkPerformanceHealth();
    issues.push(...performanceIssues);
    if (issues.length > 0) {
      recommendations.push(...this.generateRecommendations(issues));
    }
    const isHealthy = issues.filter(
      (issue) => issue.severity === "high" || issue.severity === "critical"
    ).length === 0;
    return {
      isHealthy,
      timestamp: Date.now(),
      issues,
      recommendations,
      resourceUsage: this.getResourceUsage()
    };
  }
  /**
   * 检查临时文件健康状态
   */
  checkTempFileHealth() {
    const issues = [];
    const tempFileStatus = this.tempFileManager.getTempFileStatus();
    if (tempFileStatus.hasActive) {
      if (tempFileStatus.age && tempFileStatus.age > 6e5) {
        issues.push({
          severity: "medium",
          category: "files",
          description: "\u4E34\u65F6\u6587\u4EF6\u5B58\u5728\u65F6\u95F4\u8FC7\u957F",
          details: { age: tempFileStatus.age, fileName: tempFileStatus.fileName }
        });
      }
      if (tempFileStatus.lastAccessed && tempFileStatus.lastAccessed > 3e5) {
        issues.push({
          severity: "low",
          category: "files",
          description: "\u4E34\u65F6\u6587\u4EF6\u957F\u65F6\u95F4\u672A\u8BBF\u95EE",
          details: { lastAccessed: tempFileStatus.lastAccessed }
        });
      }
    }
    return issues;
  }
  /**
   * 检查编辑器健康状态
   */
  checkEditorHealth() {
    const issues = [];
    const editorStatus = this.editorStateCoordinator.getEditorStatusInfo();
    const fileHasActive = editorStatus.fileMode === "persistent" ? editorStatus.fileStatus.isInUse : editorStatus.fileStatus.hasActive;
    if (editorStatus.hasActiveEditor !== fileHasActive) {
      issues.push({
        severity: "high",
        category: "state",
        description: `\u7F16\u8F91\u5668\u548C${editorStatus.fileMode === "persistent" ? "\u6301\u4E45\u5316" : "\u4E34\u65F6"}\u6587\u4EF6\u72B6\u6001\u4E0D\u4E00\u81F4`,
        details: editorStatus
      });
    }
    if (editorStatus.editorStatus.hasActive && editorStatus.editorStatus.age > 9e5) {
      issues.push({
        severity: "medium",
        category: "editors",
        description: "\u7F16\u8F91\u5668\u4F1A\u8BDD\u65F6\u95F4\u8FC7\u957F",
        details: { age: editorStatus.editorStatus.age }
      });
    }
    return issues;
  }
  /**
   * 检查状态一致性
   */
  checkStateConsistency() {
    const issues = [];
    try {
      const coordinatorHealth = this.editorStateCoordinator.checkSystemHealth();
      if (!coordinatorHealth.isHealthy) {
        issues.push({
          severity: "high",
          category: "state",
          description: "\u7F16\u8F91\u5668\u72B6\u6001\u534F\u8C03\u5668\u68C0\u6D4B\u5230\u95EE\u9898",
          details: coordinatorHealth
        });
      }
    } catch (error) {
      issues.push({
        severity: "critical",
        category: "state",
        description: "\u72B6\u6001\u68C0\u67E5\u5931\u8D25",
        details: { error: error instanceof Error ? error.message : String(error) }
      });
    }
    return issues;
  }
  /**
   * 检查性能健康状态
   */
  checkPerformanceHealth() {
    const issues = [];
    const errorRate = this.totalOperations > 0 ? this.errorCount / this.totalOperations : 0;
    if (errorRate > 0.05) {
      issues.push({
        severity: "high",
        category: "performance",
        description: "\u9519\u8BEF\u7387\u8FC7\u9AD8",
        details: { errorRate, errorCount: this.errorCount, totalOperations: this.totalOperations }
      });
    }
    const avgResponseTime = this.getAverageResponseTime();
    if (avgResponseTime > 1e3) {
      issues.push({
        severity: "medium",
        category: "performance",
        description: "\u5E73\u5747\u54CD\u5E94\u65F6\u95F4\u8FC7\u957F",
        details: { averageResponseTime: avgResponseTime }
      });
    }
    return issues;
  }
  /**
   * 生成建议
   */
  generateRecommendations(issues) {
    const recommendations = [];
    const categories = new Set(issues.map((issue) => issue.category));
    if (categories.has("files")) {
      recommendations.push("\u6267\u884C\u4E34\u65F6\u6587\u4EF6\u6E05\u7406");
    }
    if (categories.has("editors")) {
      recommendations.push("\u91CD\u542F\u7F16\u8F91\u5668\u4F1A\u8BDD");
    }
    if (categories.has("state")) {
      recommendations.push("\u6267\u884C\u72B6\u6001\u540C\u6B65\u548C\u5F02\u5E38\u6062\u590D");
    }
    if (categories.has("performance")) {
      recommendations.push("\u4F18\u5316\u6027\u80FD\u6216\u91CD\u542F\u63D2\u4EF6");
    }
    const criticalIssues = issues.filter((issue) => issue.severity === "critical");
    if (criticalIssues.length > 0) {
      recommendations.push("\u7ACB\u5373\u6267\u884C\u5B8C\u6574\u7CFB\u7EDF\u91CD\u7F6E");
    }
    return recommendations;
  }
  /**
   * 获取资源使用情况
   */
  getResourceUsage() {
    const tempFileStatus = this.tempFileManager.getTempFileStatus();
    const editorStatus = this.editorStateCoordinator.getEditorStatusInfo();
    return {
      tempFiles: {
        count: tempFileStatus.hasActive ? 1 : 0,
        totalSize: 0,
        // 暂时无法获取文件大小
        oldestAge: tempFileStatus.age || 0
      },
      editors: {
        activeCount: editorStatus.hasActiveEditor ? 1 : 0,
        memoryUsage: 0
        // 暂时无法获取内存使用
      },
      performance: {
        averageResponseTime: this.getAverageResponseTime(),
        errorRate: this.totalOperations > 0 ? this.errorCount / this.totalOperations : 0
      }
    };
  }
  /**
   * 记录操作性能
   */
  recordOperation(operationType, duration, success) {
    if (!this.performanceMetrics.has(operationType)) {
      this.performanceMetrics.set(operationType, []);
    }
    const metrics = this.performanceMetrics.get(operationType);
    metrics.push(duration);
    if (metrics.length > 100) {
      metrics.shift();
    }
    this.totalOperations++;
    if (!success) {
      this.errorCount++;
    }
  }
  /**
   * 获取平均响应时间
   */
  getAverageResponseTime() {
    let totalTime = 0;
    let totalCount = 0;
    for (const metrics of this.performanceMetrics.values()) {
      totalTime += metrics.reduce((sum, time) => sum + time, 0);
      totalCount += metrics.length;
    }
    return totalCount > 0 ? totalTime / totalCount : 0;
  }
  /**
   * 执行自动修复
   */
  async performAutoFix(healthStatus) {
    try {
      const criticalIssues = healthStatus.issues.filter((issue) => issue.severity === "critical");
      const highIssues = healthStatus.issues.filter((issue) => issue.severity === "high");
      if (criticalIssues.length > 0) {
        DebugManager.log("Performing critical issue auto-fix...");
        await this.editorStateCoordinator.recoverFromException();
        await this.tempFileManager.recoverFromException();
        return true;
      }
      if (highIssues.length > 0) {
        DebugManager.log("Performing high priority issue auto-fix...");
        for (const issue of highIssues) {
          if (issue.category === "state") {
            await this.editorStateCoordinator.recoverFromException();
          } else if (issue.category === "files") {
            await this.tempFileManager.cleanupCurrentTempFile();
          }
        }
        return true;
      }
      return false;
    } catch (error) {
      DebugManager.error("Auto-fix failed:", error);
      return false;
    }
  }
  /**
   * 生成诊断报告
   */
  generateDiagnosticReport() {
    const healthStatus = this.checkSystemHealth();
    const resourceUsage = healthStatus.resourceUsage;
    let report = "=== Canvasgrid Transit \u8BCA\u65AD\u62A5\u544A ===\n\n";
    report += `\u65F6\u95F4: ${new Date(healthStatus.timestamp).toLocaleString()}
`;
    report += `\u7CFB\u7EDF\u72B6\u6001: ${healthStatus.isHealthy ? "\u5065\u5EB7" : "\u5B58\u5728\u95EE\u9898"}

`;
    report += "--- \u8D44\u6E90\u4F7F\u7528\u60C5\u51B5 ---\n";
    report += `\u4E34\u65F6\u6587\u4EF6: ${resourceUsage.tempFiles.count} \u4E2A
`;
    report += `\u6D3B\u8DC3\u7F16\u8F91\u5668: ${resourceUsage.editors.activeCount} \u4E2A
`;
    report += `\u5E73\u5747\u54CD\u5E94\u65F6\u95F4: ${resourceUsage.performance.averageResponseTime.toFixed(2)}ms
`;
    report += `\u9519\u8BEF\u7387: ${(resourceUsage.performance.errorRate * 100).toFixed(2)}%

`;
    if (healthStatus.issues.length > 0) {
      report += "--- \u53D1\u73B0\u7684\u95EE\u9898 ---\n";
      for (const issue of healthStatus.issues) {
        report += `[${issue.severity.toUpperCase()}] ${issue.category}: ${issue.description}
`;
      }
      report += "\n";
    }
    if (healthStatus.recommendations.length > 0) {
      report += "--- \u5EFA\u8BAE\u64CD\u4F5C ---\n";
      for (const recommendation of healthStatus.recommendations) {
        report += `- ${recommendation}
`;
      }
    }
    return report;
  }
  /**
   * 重置统计数据
   */
  resetMetrics() {
    this.performanceMetrics.clear();
    this.errorCount = 0;
    this.totalOperations = 0;
    DebugManager.log("Diagnostics metrics reset");
  }
};

// src/managers/ProtocolHandler.ts
var import_obsidian10 = require("obsidian");

// src/adapters/CanvasAPIAdapter.ts
var CanvasAPIAdapter = class {
  constructor(leaf) {
    this.debugMode = true;
    this.leaf = leaf;
    this.canvas = this.getCanvasAPI(leaf);
  }
  /**
   * 获取Canvas API实例
   */
  getCanvasAPI(leaf) {
    try {
      const view = leaf.view;
      if (view?.canvas) {
        this.log("Canvas API found via view.canvas");
        return view.canvas;
      }
      if (view?.canvasView?.canvas) {
        this.log("Canvas API found via view.canvasView.canvas");
        return view.canvasView.canvas;
      }
      if (view?.renderer?.canvas) {
        this.log("Canvas API found via view.renderer.canvas");
        return view.renderer.canvas;
      }
      this.log("Canvas API not found");
      return null;
    } catch (error) {
      this.log("Error getting Canvas API:", error);
      return null;
    }
  }
  /**
   * 检查Canvas API是否可用
   */
  isAvailable() {
    return !!(this.canvas && typeof this.canvas === "object");
  }
  /**
   * 获取Canvas版本信息
   */
  getVersion() {
    try {
      if (this.canvas?.version) {
        return this.canvas.version;
      }
      const methods = Object.getOwnPropertyNames(Object.getPrototypeOf(this.canvas) || {});
      if (methods.includes("zoomToBbox")) {
        return "modern";
      } else if (methods.includes("zoomToSelection")) {
        return "legacy";
      }
      return "unknown";
    } catch (error) {
      return "error";
    }
  }
  /**
   * 聚焦到指定节点
   */
  async focusNode(nodeId, options = {}) {
    const startTime = Date.now();
    const defaultOptions = {
      highlight: true,
      animation: true,
      padding: 100,
      retryAttempts: 3,
      retryDelay: 500,
      ...options
    };
    this.log(`Focusing node: ${nodeId}`, defaultOptions);
    if (!this.isAvailable()) {
      return {
        success: false,
        method: "fallback",
        error: "Canvas API not available",
        nodeFound: false,
        canvasLoaded: false,
        executionTime: Date.now() - startTime
      };
    }
    const strategies = [
      () => this.focusWithZoomToBbox(nodeId, defaultOptions),
      () => this.focusWithPanTo(nodeId, defaultOptions),
      () => this.focusWithZoomToSelection(nodeId, defaultOptions),
      () => this.focusWithViewport(nodeId, defaultOptions),
      () => this.focusWithScroll(nodeId, defaultOptions)
    ];
    for (let i = 0; i < strategies.length; i++) {
      try {
        const result = await strategies[i]();
        if (result.success) {
          if (defaultOptions.highlight) {
            await this.highlightNode(nodeId, 2e3);
          }
          result.executionTime = Date.now() - startTime;
          this.log(`Focus successful with strategy ${i + 1}: ${result.method}`);
          return result;
        }
      } catch (error) {
        this.log(`Strategy ${i + 1} failed:`, error);
        continue;
      }
    }
    return {
      success: false,
      method: "fallback",
      error: "All focus strategies failed",
      nodeFound: this.findCanvasNode(nodeId) !== null,
      canvasLoaded: true,
      executionTime: Date.now() - startTime
    };
  }
  /**
   * 策略1: 使用zoomToBbox方法 - 基于成功实现
   */
  async focusWithZoomToBbox(nodeId, options) {
    try {
      if (!this.canvas?.zoomToBbox) {
        throw new Error("zoomToBbox method not available");
      }
      const nodeData = await this.findCanvasNodeData(nodeId);
      if (!nodeData) {
        return {
          success: false,
          method: "zoomToBbox",
          error: "Node not found",
          nodeFound: false,
          canvasLoaded: true,
          executionTime: 0
        };
      }
      this.log("Found node data:", nodeData);
      if (this.canvas.deselectAll) {
        this.log("Clearing selection...");
        this.canvas.deselectAll();
      }
      if (this.canvas.selectNode) {
        this.log("Selecting node:", nodeId);
        try {
          this.canvas.selectNode(nodeId);
        } catch (error) {
          this.log("selectNode failed:", error);
        }
      }
      const bbox = this.calculateOptimalBbox(nodeData, options.padding);
      this.log("Calculated bbox:", bbox);
      this.log("Zooming to bbox...");
      this.canvas.zoomToBbox(bbox);
      return {
        success: true,
        method: "zoomToBbox",
        nodeFound: true,
        canvasLoaded: true,
        executionTime: 0
      };
    } catch (error) {
      this.log("zoomToBbox strategy failed:", error);
      throw error;
    }
  }
  /**
   * 策略2: 使用panTo方法 - 基于成功实现
   */
  async focusWithPanTo(nodeId, options) {
    try {
      if (!this.canvas?.panTo) {
        throw new Error("panTo method not available");
      }
      const nodeData = await this.findCanvasNodeData(nodeId);
      if (!nodeData) {
        return {
          success: false,
          method: "viewport",
          error: "Node not found",
          nodeFound: false,
          canvasLoaded: true,
          executionTime: 0
        };
      }
      this.log("Using panTo as fallback...");
      const centerX = nodeData.x + nodeData.width / 2;
      const centerY = nodeData.y + nodeData.height / 2;
      try {
        this.canvas.panTo(centerX, centerY);
        return {
          success: true,
          method: "viewport",
          nodeFound: true,
          canvasLoaded: true,
          executionTime: 0
        };
      } catch (error) {
        this.log("panTo failed:", error);
        throw error;
      }
    } catch (error) {
      throw error;
    }
  }
  /**
   * 策略3: 使用zoomToSelection方法
   */
  async focusWithZoomToSelection(nodeId, options) {
    try {
      if (!this.canvas.zoomToSelection) {
        throw new Error("zoomToSelection method not available");
      }
      const node = this.findCanvasNode(nodeId);
      if (!node) {
        return {
          success: false,
          method: "zoomToSelection",
          error: "Node not found",
          nodeFound: false,
          canvasLoaded: true,
          executionTime: 0
        };
      }
      if (this.canvas.deselectAll) {
        this.canvas.deselectAll();
      }
      if (this.canvas.addToSelection) {
        this.canvas.addToSelection(node);
      } else if (this.canvas.selectNode) {
        this.canvas.selectNode(nodeId);
      }
      this.canvas.zoomToSelection();
      return {
        success: true,
        method: "zoomToSelection",
        nodeFound: true,
        canvasLoaded: true,
        executionTime: 0
      };
    } catch (error) {
      throw error;
    }
  }
  /**
   * 策略3: 直接操作viewport
   */
  async focusWithViewport(nodeId, options) {
    try {
      const node = this.findCanvasNode(nodeId);
      if (!node) {
        return {
          success: false,
          method: "viewport",
          error: "Node not found",
          nodeFound: false,
          canvasLoaded: true,
          executionTime: 0
        };
      }
      const viewport = this.canvas.viewport || this.canvas.view;
      if (!viewport) {
        throw new Error("Viewport not available");
      }
      const centerX = node.x + node.width / 2;
      const centerY = node.y + node.height / 2;
      if (viewport.setCenter) {
        viewport.setCenter(centerX, centerY);
      } else if (viewport.panTo) {
        viewport.panTo(centerX, centerY);
      } else if (typeof viewport.x !== "undefined" && typeof viewport.y !== "undefined") {
        viewport.x = -centerX + (viewport.width || 800) / 2;
        viewport.y = -centerY + (viewport.height || 600) / 2;
      } else {
        throw new Error("No viewport manipulation method available");
      }
      return {
        success: true,
        method: "viewport",
        nodeFound: true,
        canvasLoaded: true,
        executionTime: 0
      };
    } catch (error) {
      throw error;
    }
  }
  /**
   * 策略4: DOM滚动方法
   */
  async focusWithScroll(nodeId, options) {
    try {
      const nodeElement = this.findNodeElement(nodeId);
      if (!nodeElement) {
        return {
          success: false,
          method: "scroll",
          error: "Node element not found",
          nodeFound: false,
          canvasLoaded: true,
          executionTime: 0
        };
      }
      nodeElement.scrollIntoView({
        behavior: options.animation ? "smooth" : "auto",
        block: "center",
        inline: "center"
      });
      nodeElement.click();
      return {
        success: true,
        method: "scroll",
        nodeFound: true,
        canvasLoaded: true,
        executionTime: 0
      };
    } catch (error) {
      throw error;
    }
  }
  /**
   * 选择节点
   */
  async selectNode(nodeId) {
    try {
      if (this.canvas.selectNode) {
        this.canvas.selectNode(nodeId);
        return true;
      }
      const node = this.findCanvasNode(nodeId);
      if (node && this.canvas.addToSelection) {
        this.canvas.addToSelection(node);
        return true;
      }
      return false;
    } catch (error) {
      this.log("Select node failed:", error);
      return false;
    }
  }
  /**
   * 缩放到节点
   */
  async zoomToNode(nodeId, padding = 100) {
    try {
      const node = this.findCanvasNode(nodeId);
      if (!node)
        return false;
      const bbox = this.calculateNodeBbox(node, padding);
      if (this.canvas.zoomToBbox) {
        this.canvas.zoomToBbox(bbox);
        return true;
      }
      return false;
    } catch (error) {
      this.log("Zoom to node failed:", error);
      return false;
    }
  }
  /**
   * 高亮节点
   */
  async highlightNode(nodeId, duration = 2e3) {
    try {
      const nodeElement = this.findNodeElement(nodeId);
      if (!nodeElement)
        return;
      const originalOutline = nodeElement.style.outline;
      const originalBoxShadow = nodeElement.style.boxShadow;
      nodeElement.style.outline = "3px solid var(--interactive-accent)";
      nodeElement.style.boxShadow = "0 0 20px var(--interactive-accent)";
      nodeElement.style.transition = "all 0.3s ease";
      setTimeout(() => {
        if (nodeElement) {
          nodeElement.style.outline = originalOutline;
          nodeElement.style.boxShadow = originalBoxShadow;
          nodeElement.style.transition = "";
        }
      }, duration);
    } catch (error) {
      this.log("Highlight node failed:", error);
    }
  }
  /**
   * 查找Canvas节点对象
   */
  findCanvasNode(nodeId) {
    try {
      if (this.canvas.nodes && this.canvas.nodes.get) {
        return this.canvas.nodes.get(nodeId);
      }
      if (this.canvas.nodes && Array.isArray(this.canvas.nodes)) {
        return this.canvas.nodes.find((node) => node.id === nodeId);
      }
      return null;
    } catch (error) {
      this.log("Find canvas node failed:", error);
      return null;
    }
  }
  /**
   * 查找节点DOM元素
   */
  findNodeElement(nodeId) {
    try {
      const container = this.leaf.containerEl || this.leaf.view?.containerEl;
      const selectors = [
        `[data-node-id="${nodeId}"]`,
        `[data-id="${nodeId}"]`,
        `.canvas-node[data-node-id="${nodeId}"]`,
        `.canvas-node[data-id="${nodeId}"]`
      ];
      for (const selector of selectors) {
        const element = container.querySelector(selector);
        if (element)
          return element;
      }
      return null;
    } catch (error) {
      this.log("Find node element failed:", error);
      return null;
    }
  }
  /**
   * 计算节点边界框
   */
  calculateNodeBbox(node, padding) {
    return {
      minX: node.x - padding,
      minY: node.y - padding,
      maxX: node.x + node.width + padding,
      maxY: node.y + node.height + padding
    };
  }
  /**
   * 计算最佳聚焦边界框 - 基于成功实现
   */
  calculateOptimalBbox(node, padding = 100) {
    return {
      minX: node.x - padding,
      minY: node.y - padding,
      maxX: node.x + node.width + padding,
      maxY: node.y + node.height + padding
    };
  }
  /**
   * 查找Canvas节点数据 - 增强版本
   */
  async findCanvasNodeData(nodeId) {
    try {
      const canvasNode = this.findCanvasNode(nodeId);
      if (canvasNode) {
        this.log("Found node via Canvas API");
        return canvasNode;
      }
      const canvasData = await this.getCanvasFileData();
      if (canvasData?.nodes) {
        for (const node of canvasData.nodes) {
          if (node.id === nodeId) {
            this.log("Found node via file data");
            return node;
          }
        }
      }
      this.log("Node not found:", nodeId);
      return null;
    } catch (error) {
      this.log("Error finding node data:", error);
      return null;
    }
  }
  /**
   * 获取Canvas文件数据
   */
  async getCanvasFileData() {
    try {
      const view = this.leaf.view;
      const file = view?.file;
      if (!file) {
        this.log("No file found in view");
        return null;
      }
      const content = await this.leaf.view.app.vault.read(file);
      const canvasData = JSON.parse(content);
      this.log("Canvas file data loaded");
      return canvasData;
    } catch (error) {
      this.log("Error loading canvas file data:", error);
      return null;
    }
  }
  /**
   * 调试日志
   */
  log(message, data) {
    if (this.debugMode) {
      console.log(`[CanvasAPIAdapter] ${message}`, data || "");
    }
  }
  /**
   * 设置调试模式
   */
  setDebugMode(enabled) {
    this.debugMode = enabled;
  }
};

// src/managers/ProtocolHandler.ts
var ProtocolHandler = class {
  constructor(app) {
    this.debugMode = true;
    this.app = app;
  }
  /**
   * 处理协议请求的主入口
   */
  async handleProtocolRequest(params) {
    const startTime = Date.now();
    try {
      this.log("=== Protocol Request Started ===", params);
      const validatedParams = this.validateAndParseParams(params);
      if (!validatedParams) {
        new import_obsidian10.Notice("\u534F\u8BAE\u53C2\u6570\u65E0\u6548");
        return;
      }
      switch (validatedParams.action) {
        case "focus-node":
          await this.handleFocusNode(validatedParams);
          break;
        case "open-canvas":
          await this.handleOpenCanvas(validatedParams);
          break;
        default:
          new import_obsidian10.Notice(`\u4E0D\u652F\u6301\u7684\u64CD\u4F5C: ${validatedParams.action}`);
      }
      this.log(`Protocol request completed in ${Date.now() - startTime}ms`);
    } catch (error) {
      console.error("Protocol handler error:", error);
      new import_obsidian10.Notice("\u534F\u8BAE\u5904\u7406\u5931\u8D25: " + (error instanceof Error ? error.message : "\u672A\u77E5\u9519\u8BEF"));
    }
  }
  /**
   * 验证和解析协议参数
   */
  validateAndParseParams(params) {
    try {
      const { file, nodeId, x, y, vault, fallback, highlight, animation } = params;
      if (!file) {
        this.log("Missing required parameter: file");
        return null;
      }
      const action = nodeId ? "focus-node" : "open-canvas";
      const validatedParams = {
        action,
        file: decodeURIComponent(file),
        nodeId: nodeId ? decodeURIComponent(nodeId) : void 0,
        x: x || void 0,
        y: y || void 0,
        vault: vault ? decodeURIComponent(vault) : void 0,
        fallback: fallback || "true",
        highlight: highlight || "true",
        animation: animation || "true"
      };
      this.log("Validated params:", validatedParams);
      return validatedParams;
    } catch (error) {
      this.log("Parameter validation failed:", error);
      return null;
    }
  }
  /**
   * 处理节点聚焦请求
   */
  async handleFocusNode(params) {
    if (!params.nodeId) {
      new import_obsidian10.Notice("\u7F3A\u5C11\u8282\u70B9ID\u53C2\u6570");
      return;
    }
    const startTime = Date.now();
    new import_obsidian10.Notice("\u6B63\u5728\u5B9A\u4F4D\u8282\u70B9...", 2e3);
    try {
      const canvasFile = this.findCanvasFile(params.file);
      if (!canvasFile) {
        new import_obsidian10.Notice(`\u627E\u4E0D\u5230Canvas\u6587\u4EF6: ${params.file}`);
        return;
      }
      const leaf = await this.openCanvasFile(canvasFile);
      if (!leaf) {
        new import_obsidian10.Notice("\u65E0\u6CD5\u6253\u5F00Canvas\u6587\u4EF6");
        return;
      }
      const canvasReady = await this.waitForCanvasReady(leaf);
      if (!canvasReady) {
        new import_obsidian10.Notice("Canvas\u52A0\u8F7D\u8D85\u65F6");
        return;
      }
      await new Promise((resolve) => setTimeout(resolve, 300));
      const focusOptions = {
        highlight: params.highlight === "true",
        animation: params.animation === "true",
        padding: 100,
        retryAttempts: 3,
        retryDelay: 500
      };
      const result = await this.focusCanvasNode(leaf, params.nodeId, focusOptions);
      if (result.success) {
        new import_obsidian10.Notice(`\u5DF2\u805A\u7126\u5230\u8282\u70B9 (${result.method})`, 3e3);
        this.log(`Focus successful: ${result.method} in ${result.executionTime}ms`);
      } else {
        if (params.fallback === "true") {
          new import_obsidian10.Notice("\u805A\u7126\u5931\u8D25\uFF0C\u5DF2\u6253\u5F00Canvas\u6587\u4EF6", 3e3);
        } else {
          new import_obsidian10.Notice("\u8282\u70B9\u805A\u7126\u5931\u8D25: " + (result.error || "\u672A\u77E5\u9519\u8BEF"));
        }
      }
    } catch (error) {
      console.error("Focus node failed:", error);
      new import_obsidian10.Notice("\u8282\u70B9\u805A\u7126\u5931\u8D25");
    }
  }
  /**
   * 处理打开Canvas请求
   */
  async handleOpenCanvas(params) {
    try {
      const canvasFile = this.findCanvasFile(params.file);
      if (!canvasFile) {
        new import_obsidian10.Notice(`\u627E\u4E0D\u5230Canvas\u6587\u4EF6: ${params.file}`);
        return;
      }
      await this.openCanvasFile(canvasFile);
      new import_obsidian10.Notice(`\u5DF2\u6253\u5F00Canvas\u6587\u4EF6: ${canvasFile.basename}`);
    } catch (error) {
      console.error("Open canvas failed:", error);
      new import_obsidian10.Notice("\u6253\u5F00Canvas\u6587\u4EF6\u5931\u8D25");
    }
  }
  /**
   * 查找Canvas文件
   */
  findCanvasFile(filePath) {
    try {
      let file = this.app.vault.getAbstractFileByPath(filePath);
      if (file && file instanceof import_obsidian10.TFile) {
        return file;
      }
      if (!filePath.endsWith(".canvas")) {
        file = this.app.vault.getAbstractFileByPath(filePath + ".canvas");
        if (file && file instanceof import_obsidian10.TFile) {
          return file;
        }
      }
      const canvasFiles = this.app.vault.getFiles().filter((f) => f.extension === "canvas");
      const matchingFile = canvasFiles.find(
        (f) => f.path === filePath || f.path.endsWith("/" + filePath) || f.basename === filePath.replace(".canvas", "")
      );
      return matchingFile || null;
    } catch (error) {
      this.log("Find canvas file failed:", error);
      return null;
    }
  }
  /**
   * 打开Canvas文件
   */
  async openCanvasFile(file) {
    try {
      const leaf = this.app.workspace.getLeaf(false);
      await leaf.openFile(file);
      return leaf;
    } catch (error) {
      this.log("Open canvas file failed:", error);
      return null;
    }
  }
  /**
   * 等待Canvas准备就绪
   */
  async waitForCanvasReady(leaf, timeout = 5e3) {
    const startTime = Date.now();
    while (Date.now() - startTime < timeout) {
      try {
        const view = leaf.view;
        if (view && view.canvas && view.canvas.nodes) {
          this.log("Canvas is ready");
          return true;
        }
      } catch (error) {
      }
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
    this.log("Canvas ready timeout");
    return false;
  }
  /**
   * 聚焦Canvas节点 - 使用CanvasAPIAdapter实现
   */
  async focusCanvasNode(leaf, nodeId, options) {
    try {
      const adapter = new CanvasAPIAdapter(leaf);
      if (!adapter.isAvailable()) {
        this.log("Canvas API not available");
        return {
          success: false,
          method: "fallback",
          error: "Canvas API not available",
          nodeFound: false,
          canvasLoaded: false,
          executionTime: 0
        };
      }
      this.log(`Using Canvas API version: ${adapter.getVersion()}`);
      const result = await adapter.focusNode(nodeId, options);
      this.log("Focus result:", result);
      return result;
    } catch (error) {
      this.log("Focus canvas node failed:", error);
      return {
        success: false,
        method: "fallback",
        error: error instanceof Error ? error.message : "Unknown error",
        nodeFound: false,
        canvasLoaded: true,
        executionTime: 0
      };
    }
  }
  /**
   * 调试日志
   */
  log(message, data) {
    if (this.debugMode) {
      DebugManager.log(`[ProtocolHandler] ${message}`, data || "");
    }
  }
  /**
   * 设置调试模式
   */
  setDebugMode(enabled) {
    this.debugMode = enabled;
  }
};

// src/utils/CanvasDebugger.ts
var CanvasDebugger = class {
  constructor(leaf) {
    this.leaf = leaf;
    this.canvas = this.getCanvasAPI(leaf);
  }
  /**
   * 获取Canvas API实例
   */
  getCanvasAPI(leaf) {
    try {
      const view = leaf.view;
      if (view && "canvas" in view) {
        return view.canvas;
      }
      if (view && "canvasView" in view && view.canvasView?.canvas) {
        return view.canvasView.canvas;
      }
      if (view && "renderer" in view && view.renderer?.canvas) {
        return view.renderer.canvas;
      }
      return null;
    } catch (error) {
      DebugManager.error("Error getting Canvas API:", error);
      return null;
    }
  }
  /**
   * 完整的Canvas诊断报告
   */
  async generateDiagnosticReport(nodeId) {
    const report = [];
    report.push("=== Canvas \u8BCA\u65AD\u62A5\u544A ===");
    report.push(`\u65F6\u95F4: ${(/* @__PURE__ */ new Date()).toLocaleString()}`);
    report.push("");
    report.push("1. \u57FA\u7840\u4FE1\u606F:");
    report.push(`   - Leaf\u7C7B\u578B: ${this.leaf.view?.getViewType() || "unknown"}`);
    report.push(`   - View\u7C7B\u578B: ${this.leaf.view?.constructor?.name || "Unknown"}`);
    report.push(`   - Canvas API\u53EF\u7528: ${this.canvas ? "\u662F" : "\u5426"}`);
    report.push("");
    if (this.canvas) {
      report.push("2. Canvas API\u5206\u6790:");
      const methods = this.analyzeCanvasAPI();
      methods.forEach((method) => {
        report.push(`   - ${method}`);
      });
      report.push("");
      const nodeInfo = await this.analyzeNodes();
      report.push("3. \u8282\u70B9\u4FE1\u606F:");
      report.push(`   - \u603B\u8282\u70B9\u6570: ${nodeInfo.totalNodes}`);
      report.push(`   - \u8282\u70B9\u83B7\u53D6\u65B9\u5F0F: ${nodeInfo.method}`);
      if (nodeId) {
        const specificNode = await this.analyzeSpecificNode(nodeId);
        report.push(`   - \u76EE\u6807\u8282\u70B9 ${nodeId}:`);
        if (specificNode) {
          report.push(`     * \u627E\u5230: \u662F`);
          report.push(`     * \u4F4D\u7F6E: (${specificNode.x}, ${specificNode.y})`);
          report.push(`     * \u5C3A\u5BF8: ${specificNode.width} x ${specificNode.height}`);
          report.push(`     * \u7C7B\u578B: ${specificNode.type}`);
        } else {
          report.push(`     * \u627E\u5230: \u5426`);
        }
      }
      report.push("");
      const viewportInfo = this.analyzeViewport();
      report.push("4. \u89C6\u53E3\u4FE1\u606F:");
      Object.entries(viewportInfo).forEach(([key, value]) => {
        report.push(`   - ${key}: ${value}`);
      });
      report.push("");
    }
    const fileInfo = await this.analyzeCanvasFile();
    report.push("5. Canvas\u6587\u4EF6\u4FE1\u606F:");
    Object.entries(fileInfo).forEach(([key, value]) => {
      report.push(`   - ${key}: ${value}`);
    });
    return report.join("\n");
  }
  /**
   * 分析Canvas API可用方法
   */
  analyzeCanvasAPI() {
    if (!this.canvas)
      return ["Canvas API\u4E0D\u53EF\u7528"];
    const methods = [];
    const apiMethods = [
      "zoomToBbox",
      "zoomToSelection",
      "panTo",
      "setViewport",
      "deselectAll",
      "selectNode",
      "addToSelection",
      "nodes",
      "viewport",
      "view"
    ];
    apiMethods.forEach((method) => {
      const available = typeof this.canvas[method] !== "undefined";
      const type = typeof this.canvas[method];
      methods.push(`${method}: ${available ? `\u53EF\u7528 (${type})` : "\u4E0D\u53EF\u7528"}`);
    });
    return methods;
  }
  /**
   * 分析节点信息
   */
  async analyzeNodes() {
    let totalNodes = 0;
    let method = "\u672A\u77E5";
    try {
      if (this.canvas?.nodes) {
        if (this.canvas.nodes.size !== void 0) {
          totalNodes = this.canvas.nodes.size;
          method = "Canvas API (Map)";
        } else if (Array.isArray(this.canvas.nodes)) {
          totalNodes = this.canvas.nodes.length;
          method = "Canvas API (Array)";
        } else if (typeof this.canvas.nodes.get === "function") {
          let count = 0;
          try {
            this.canvas.nodes.forEach(() => count++);
            totalNodes = count;
            method = "Canvas API (Map\u904D\u5386)";
          } catch (e) {
            method = "Canvas API (\u65E0\u6CD5\u904D\u5386)";
          }
        }
      }
      if (totalNodes === 0) {
        const fileData = await this.getCanvasFileData();
        if (fileData?.nodes) {
          totalNodes = fileData.nodes.length;
          method = "\u6587\u4EF6\u6570\u636E";
        }
      }
    } catch (error) {
      method = `\u9519\u8BEF: ${error instanceof Error ? error.message : String(error)}`;
    }
    return { totalNodes, method };
  }
  /**
   * 分析特定节点
   */
  async analyzeSpecificNode(nodeId) {
    try {
      if (this.canvas?.nodes?.get) {
        const node = this.canvas.nodes.get(nodeId);
        if (node)
          return node;
      }
      const fileData = await this.getCanvasFileData();
      if (fileData?.nodes) {
        return fileData.nodes.find((node) => node.id === nodeId);
      }
      return null;
    } catch (error) {
      DebugManager.error("Error analyzing specific node:", error);
      return null;
    }
  }
  /**
   * 分析视口信息
   */
  analyzeViewport() {
    const info = {};
    try {
      if (this.canvas?.viewport) {
        const viewport = this.canvas.viewport;
        info["viewport\u5BF9\u8C61"] = "\u5B58\u5728";
        info["viewport.x"] = viewport.x || "undefined";
        info["viewport.y"] = viewport.y || "undefined";
        info["viewport.zoom"] = viewport.zoom || "undefined";
        info["viewport.width"] = viewport.width || "undefined";
        info["viewport.height"] = viewport.height || "undefined";
      } else {
        info["viewport\u5BF9\u8C61"] = "\u4E0D\u5B58\u5728";
      }
      if (this.canvas?.view) {
        info["view\u5BF9\u8C61"] = "\u5B58\u5728";
      } else {
        info["view\u5BF9\u8C61"] = "\u4E0D\u5B58\u5728";
      }
    } catch (error) {
      info["\u9519\u8BEF"] = error instanceof Error ? error.message : String(error);
    }
    return info;
  }
  /**
   * 分析Canvas文件
   */
  async analyzeCanvasFile() {
    const info = {};
    try {
      const view = this.leaf.view;
      if (view && "file" in view) {
        const file = view.file;
        if (file) {
          info["\u6587\u4EF6\u540D"] = file.name;
          info["\u6587\u4EF6\u8DEF\u5F84"] = file.path;
          info["\u6587\u4EF6\u5927\u5C0F"] = file.stat.size + " bytes";
          const content = await this.leaf.view.app.vault.read(file);
          const data = JSON.parse(content);
          info["\u8282\u70B9\u6570\u91CF"] = data.nodes?.length || 0;
          info["\u8FB9\u6570\u91CF"] = data.edges?.length || 0;
          info["\u6570\u636E\u7ED3\u6784"] = Object.keys(data).join(", ");
        } else {
          info["\u6587\u4EF6"] = "\u672A\u627E\u5230";
        }
      } else {
        info["\u6587\u4EF6"] = "\u89C6\u56FE\u4E0D\u652F\u6301\u6587\u4EF6\u8BBF\u95EE";
      }
    } catch (error) {
      info["\u9519\u8BEF"] = error instanceof Error ? error.message : String(error);
    }
    return info;
  }
  /**
   * 获取Canvas文件数据
   */
  async getCanvasFileData() {
    try {
      const view = this.leaf.view;
      if (view && "file" in view) {
        const file = view.file;
        if (!file)
          return null;
        const content = await this.leaf.view.app.vault.read(file);
        return JSON.parse(content);
      }
      return null;
    } catch (error) {
      DebugManager.error("Error loading canvas file data:", error);
      return null;
    }
  }
  /**
   * 测试聚焦功能
   */
  async testFocusCapabilities(nodeId) {
    const results = [];
    if (!this.canvas) {
      results.push("\u274C Canvas API\u4E0D\u53EF\u7528");
      return results;
    }
    const node = await this.analyzeSpecificNode(nodeId);
    if (!node) {
      results.push("\u274C \u8282\u70B9\u672A\u627E\u5230");
      return results;
    }
    results.push("\u2705 \u8282\u70B9\u5DF2\u627E\u5230");
    const tests = [
      {
        name: "zoomToBbox",
        test: () => {
          if (this.canvas.zoomToBbox) {
            const bbox = {
              minX: node.x - 100,
              minY: node.y - 100,
              maxX: node.x + node.width + 100,
              maxY: node.y + node.height + 100
            };
            this.canvas.zoomToBbox(bbox);
            return true;
          }
          return false;
        }
      },
      {
        name: "panTo",
        test: () => {
          if (this.canvas.panTo) {
            const centerX = node.x + node.width / 2;
            const centerY = node.y + node.height / 2;
            this.canvas.panTo(centerX, centerY);
            return true;
          }
          return false;
        }
      },
      {
        name: "zoomToSelection",
        test: () => {
          if (this.canvas.zoomToSelection && this.canvas.addToSelection) {
            if (this.canvas.deselectAll)
              this.canvas.deselectAll();
            this.canvas.addToSelection(node);
            this.canvas.zoomToSelection();
            return true;
          }
          return false;
        }
      }
    ];
    for (const test of tests) {
      try {
        const success = test.test();
        results.push(success ? `\u2705 ${test.name} \u6210\u529F` : `\u274C ${test.name} \u4E0D\u53EF\u7528`);
        if (success) {
          await new Promise((resolve) => setTimeout(resolve, 1e3));
        }
      } catch (error) {
        results.push(`\u274C ${test.name} \u5931\u8D25: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
    return results;
  }
};
window.debugCanvas = async (nodeId) => {
  const activeLeaf = window.app?.workspace?.getMostRecentLeaf();
  if (!activeLeaf || activeLeaf.view.getViewType() !== "canvas") {
    DebugManager.log("\u8BF7\u5148\u6253\u5F00\u4E00\u4E2ACanvas\u6587\u4EF6");
    return;
  }
  const canvasDebugger = new CanvasDebugger(activeLeaf);
  const report = await canvasDebugger.generateDiagnosticReport(nodeId);
  DebugManager.log(report);
  if (nodeId) {
    DebugManager.log("\n=== \u805A\u7126\u6D4B\u8BD5 ===");
    const testResults = await canvasDebugger.testFocusCapabilities(nodeId);
    testResults.forEach((result) => DebugManager.log(result));
  }
};

// src/utils/DataValidator.ts
var import_obsidian11 = require("obsidian");
var DataValidator = class {
  constructor(options) {
    this.repairOptions = {
      autoFix: true,
      createBackup: true,
      preserveOriginal: false,
      fixMissingFields: true,
      fixInvalidValues: true,
      ...options
    };
  }
  /**
   * 验证Canvas数据结构
   */
  validateCanvasData(data) {
    const errors = [];
    const warnings = [];
    let fixedData = data;
    try {
      if (!data || typeof data !== "object") {
        errors.push({
          type: "structure",
          field: "root",
          message: "Canvas\u6570\u636E\u5FC5\u987B\u662F\u4E00\u4E2A\u5BF9\u8C61",
          severity: "critical",
          fixable: false
        });
        return { isValid: false, errors, warnings };
      }
      if (!Array.isArray(data.nodes)) {
        errors.push({
          type: "structure",
          field: "nodes",
          message: "nodes\u5B57\u6BB5\u5FC5\u987B\u662F\u6570\u7EC4",
          severity: "critical",
          fixable: true
        });
        if (this.repairOptions.autoFix) {
          fixedData = { ...data, nodes: [] };
        }
      } else {
        const nodeValidation = this.validateNodes(data.nodes);
        errors.push(...nodeValidation.errors);
        warnings.push(...nodeValidation.warnings);
        if (nodeValidation.fixedData) {
          fixedData = { ...fixedData, nodes: nodeValidation.fixedData };
        }
      }
      if (data.edges !== void 0 && !Array.isArray(data.edges)) {
        errors.push({
          type: "structure",
          field: "edges",
          message: "edges\u5B57\u6BB5\u5FC5\u987B\u662F\u6570\u7EC4",
          severity: "high",
          fixable: true
        });
        if (this.repairOptions.autoFix) {
          fixedData = { ...fixedData, edges: [] };
        }
      }
      if (data.nodes && data.nodes.length > 1e3) {
        warnings.push({
          type: "performance",
          field: "nodes",
          message: `\u8282\u70B9\u6570\u91CF\u8FC7\u591A (${data.nodes.length})\uFF0C\u53EF\u80FD\u5F71\u54CD\u6027\u80FD`,
          suggestion: "\u8003\u8651\u5206\u5272Canvas\u6216\u542F\u7528\u865A\u62DF\u5316\u6E32\u67D3"
        });
      }
    } catch (error) {
      errors.push({
        type: "structure",
        field: "unknown",
        message: `\u6570\u636E\u9A8C\u8BC1\u8FC7\u7A0B\u4E2D\u53D1\u751F\u9519\u8BEF: ${error instanceof Error ? error.message : String(error)}`,
        severity: "critical",
        fixable: false
      });
    }
    const isValid = errors.filter((e) => e.severity === "critical").length === 0;
    return {
      isValid,
      errors,
      warnings,
      fixedData: fixedData !== data ? fixedData : void 0
    };
  }
  /**
   * 验证节点数组
   */
  validateNodes(nodes) {
    const errors = [];
    const warnings = [];
    const fixedNodes = [];
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      const nodeValidation = this.validateSingleNode(node, i);
      errors.push(...nodeValidation.errors);
      warnings.push(...nodeValidation.warnings);
      fixedNodes.push(nodeValidation.fixedData || node);
    }
    return {
      isValid: errors.filter((e) => e.severity === "critical").length === 0,
      errors,
      warnings,
      fixedData: fixedNodes
    };
  }
  /**
   * 验证单个节点
   */
  validateSingleNode(node, index) {
    const errors = [];
    const warnings = [];
    let fixedNode = node;
    const fieldPrefix = `nodes[${index}]`;
    try {
      if (!node.id || typeof node.id !== "string") {
        errors.push({
          type: "data",
          field: `${fieldPrefix}.id`,
          message: "\u8282\u70B9\u5FC5\u987B\u6709\u6709\u6548\u7684ID",
          severity: "critical",
          fixable: true
        });
        if (this.repairOptions.fixMissingFields) {
          fixedNode = { ...fixedNode, id: `node-${Date.now()}-${index}` };
        }
      }
      if (!node.type || !["text", "file", "link", "group"].includes(node.type)) {
        errors.push({
          type: "data",
          field: `${fieldPrefix}.type`,
          message: "\u8282\u70B9\u7C7B\u578B\u65E0\u6548",
          severity: "high",
          fixable: true
        });
        if (this.repairOptions.fixInvalidValues) {
          fixedNode = { ...fixedNode, type: "text" };
        }
      }
      const positionFields = ["x", "y", "width", "height"];
      for (const field of positionFields) {
        if (typeof node[field] !== "number") {
          errors.push({
            type: "data",
            field: `${fieldPrefix}.${field}`,
            message: `${field}\u5B57\u6BB5\u5FC5\u987B\u662F\u6570\u5B57`,
            severity: "medium",
            fixable: true
          });
          if (this.repairOptions.fixInvalidValues) {
            const defaultValues = { x: 0, y: 0, width: 250, height: 60 };
            fixedNode = { ...fixedNode, [field]: defaultValues[field] };
          }
        }
      }
      if (node.timelineData) {
        const timelineValidation = this.validateTimelineData(node.timelineData, `${fieldPrefix}.timelineData`);
        errors.push(...timelineValidation.errors);
        warnings.push(...timelineValidation.warnings);
        if (timelineValidation.fixedData) {
          fixedNode = { ...fixedNode, timelineData: timelineValidation.fixedData };
        }
      }
    } catch (error) {
      errors.push({
        type: "structure",
        field: fieldPrefix,
        message: `\u8282\u70B9\u9A8C\u8BC1\u5931\u8D25: ${error instanceof Error ? error.message : String(error)}`,
        severity: "high",
        fixable: false
      });
    }
    return {
      isValid: errors.filter((e) => e.severity === "critical").length === 0,
      errors,
      warnings,
      fixedData: fixedNode !== node ? fixedNode : void 0
    };
  }
  /**
   * 验证时间线数据
   */
  validateTimelineData(timelineData, fieldPrefix) {
    const errors = [];
    const warnings = [];
    let fixedData = timelineData;
    try {
      if (typeof timelineData.createdAt !== "number" || timelineData.createdAt <= 0) {
        errors.push({
          type: "data",
          field: `${fieldPrefix}.createdAt`,
          message: "\u521B\u5EFA\u65F6\u95F4\u5FC5\u987B\u662F\u6709\u6548\u7684\u65F6\u95F4\u6233",
          severity: "high",
          fixable: true
        });
        if (this.repairOptions.fixInvalidValues) {
          fixedData = { ...fixedData, createdAt: Date.now() };
        }
      }
      if (timelineData.modifiedAt !== void 0) {
        if (typeof timelineData.modifiedAt !== "number" || timelineData.modifiedAt <= 0) {
          errors.push({
            type: "data",
            field: `${fieldPrefix}.modifiedAt`,
            message: "\u4FEE\u6539\u65F6\u95F4\u5FC5\u987B\u662F\u6709\u6548\u7684\u65F6\u95F4\u6233",
            severity: "medium",
            fixable: true
          });
          if (this.repairOptions.fixInvalidValues) {
            fixedData = { ...fixedData, modifiedAt: timelineData.createdAt };
          }
        }
      }
      if (timelineData.scheduledAt !== void 0 && timelineData.scheduledAt !== null) {
        if (typeof timelineData.scheduledAt !== "number" || timelineData.scheduledAt <= 0) {
          warnings.push({
            type: "data_quality",
            field: `${fieldPrefix}.scheduledAt`,
            message: "\u8BA1\u5212\u65F6\u95F4\u683C\u5F0F\u65E0\u6548",
            suggestion: "\u68C0\u67E5\u8BA1\u5212\u65F6\u95F4\u8BBE\u7F6E"
          });
          if (this.repairOptions.fixInvalidValues) {
            fixedData = { ...fixedData, scheduledAt: null };
          }
        }
      }
      const validCategories = ["event", "task", "note", "meeting", "default"];
      if (timelineData.category && !validCategories.includes(timelineData.category)) {
        warnings.push({
          type: "data_quality",
          field: `${fieldPrefix}.category`,
          message: "\u672A\u77E5\u7684\u7C7B\u522B\u7C7B\u578B",
          suggestion: `\u4F7F\u7528\u4EE5\u4E0B\u7C7B\u522B\u4E4B\u4E00: ${validCategories.join(", ")}`
        });
        if (this.repairOptions.fixInvalidValues) {
          fixedData = { ...fixedData, category: "default" };
        }
      }
      const validPriorities = ["low", "medium", "high"];
      if (timelineData.priority && !validPriorities.includes(timelineData.priority)) {
        warnings.push({
          type: "data_quality",
          field: `${fieldPrefix}.priority`,
          message: "\u672A\u77E5\u7684\u4F18\u5148\u7EA7",
          suggestion: `\u4F7F\u7528\u4EE5\u4E0B\u4F18\u5148\u7EA7\u4E4B\u4E00: ${validPriorities.join(", ")}`
        });
        if (this.repairOptions.fixInvalidValues) {
          fixedData = { ...fixedData, priority: "medium" };
        }
      }
    } catch (error) {
      errors.push({
        type: "structure",
        field: fieldPrefix,
        message: `\u65F6\u95F4\u7EBF\u6570\u636E\u9A8C\u8BC1\u5931\u8D25: ${error instanceof Error ? error.message : String(error)}`,
        severity: "medium",
        fixable: false
      });
    }
    return {
      isValid: errors.filter((e) => e.severity === "critical").length === 0,
      errors,
      warnings,
      fixedData: fixedData !== timelineData ? fixedData : void 0
    };
  }
  /**
   * 修复数据
   */
  repairData(data, validationResult) {
    if (validationResult.fixedData) {
      console.log("\u{1F527} Applying data repairs...");
      const fixableErrors = validationResult.errors.filter((e) => e.fixable);
      if (fixableErrors.length > 0) {
        console.log(`\u{1F527} Fixed ${fixableErrors.length} errors`);
      }
      return validationResult.fixedData;
    }
    return data;
  }
  /**
   * 显示验证结果
   */
  showValidationResults(result) {
    const criticalErrors = result.errors.filter((e) => e.severity === "critical");
    const highErrors = result.errors.filter((e) => e.severity === "high");
    const warnings = result.warnings;
    if (criticalErrors.length > 0) {
      new import_obsidian11.Notice(`\u53D1\u73B0 ${criticalErrors.length} \u4E2A\u4E25\u91CD\u9519\u8BEF\uFF0C\u6570\u636E\u53EF\u80FD\u65E0\u6CD5\u6B63\u5E38\u4F7F\u7528`, 5e3);
      DebugManager.error("\u274C Critical validation errors:", criticalErrors);
    }
    if (highErrors.length > 0) {
      new import_obsidian11.Notice(`\u53D1\u73B0 ${highErrors.length} \u4E2A\u91CD\u8981\u9519\u8BEF\uFF0C\u5DF2\u5C1D\u8BD5\u81EA\u52A8\u4FEE\u590D`, 3e3);
      DebugManager.warn("\u26A0\uFE0F High priority validation errors:", highErrors);
    }
    if (warnings.length > 0) {
      DebugManager.warn("\u26A0\uFE0F Validation warnings:", warnings);
    }
    if (result.isValid && criticalErrors.length === 0 && highErrors.length === 0) {
      console.log("\u2705 Data validation passed");
    }
  }
  /**
   * 更新修复选项
   */
  updateRepairOptions(options) {
    this.repairOptions = { ...this.repairOptions, ...options };
  }
  /**
   * 获取当前修复选项
   */
  getRepairOptions() {
    return { ...this.repairOptions };
  }
};

// src/utils/ColorUtils.ts
var CANVAS_COLOR_MAP = {
  "1": "red",
  "2": "orange",
  "3": "yellow",
  "4": "green",
  "5": "cyan",
  "6": "blue",
  "7": "purple"
};
var ColorUtils = class {
  /**
   * 检测当前主题是否为深色主题
   */
  static isDarkTheme() {
    return document.body.classList.contains("theme-dark");
  }
  /**
   * 获取官方Canvas颜色样式
   * 使用官方CSS变量确保与Canvas原生卡片完全一致
   */
  static getCanvasColorStyles(colorNumber) {
    const colorName = CANVAS_COLOR_MAP[colorNumber];
    if (!colorName) {
      return {
        backgroundColor: "var(--background-primary)",
        textColor: "var(--text-normal)",
        borderColor: "var(--background-modifier-border)",
        borderWidth: "1px"
      };
    }
    return {
      backgroundColor: "var(--background-primary)",
      textColor: "var(--text-normal)",
      borderColor: `var(--color-${colorName})`,
      borderWidth: "2px"
    };
  }
  /**
   * 标准化颜色值
   * 将各种颜色格式统一为Canvas颜色编号
   */
  static normalizeCanvasColor(color) {
    if (!color)
      return null;
    if (/^[1-7]$/.test(color)) {
      return color;
    }
    const hexToNumberMap = {
      "#ff6b6b": "1",
      // red
      "#ffa726": "2",
      // orange  
      "#ffeb3b": "3",
      // yellow
      "#66bb6a": "4",
      // green
      "#26c6da": "5",
      // cyan
      "#42a5f5": "6",
      // blue
      "#ab47bc": "7"
      // purple
    };
    const normalizedHex = color.toLowerCase();
    return hexToNumberMap[normalizedHex] || null;
  }
  /**
   * 应用Canvas颜色样式到元素
   */
  static applyCanvasColorToElement(element, colorNumber) {
    if (!colorNumber) {
      element.style.borderColor = "";
      element.style.borderWidth = "";
      element.dataset.canvasColor = "";
      return;
    }
    const styles = this.getCanvasColorStyles(colorNumber);
    element.style.borderColor = styles.borderColor;
    element.style.borderWidth = styles.borderWidth;
    element.dataset.canvasColor = colorNumber;
  }
  /**
   * 获取颜色的显示名称（用于UI显示）
   */
  static getColorDisplayName(colorNumber) {
    const colorName = CANVAS_COLOR_MAP[colorNumber];
    const displayNames = {
      "red": "\u7EA2\u8272",
      "orange": "\u6A59\u8272",
      "yellow": "\u9EC4\u8272",
      "green": "\u7EFF\u8272",
      "cyan": "\u9752\u8272",
      "blue": "\u84DD\u8272",
      "purple": "\u7D2B\u8272"
    };
    return displayNames[colorName] || "\u9ED8\u8BA4";
  }
  /**
   * 验证颜色编号是否有效
   */
  static isValidCanvasColor(colorNumber) {
    return colorNumber in CANVAS_COLOR_MAP;
  }
  /**
   * 获取所有可用的Canvas颜色
   */
  static getAllCanvasColors() {
    return Object.entries(CANVAS_COLOR_MAP).map(([number, name]) => ({
      number,
      name,
      displayName: this.getColorDisplayName(number)
    }));
  }
};

// src/constants/AppConstants.ts
var SEARCH_CONSTANTS = {
  // 文本长度限制
  MAX_SEARCH_TEXT_LENGTH: 50,
  PRIMARY_SEARCH_LENGTH: 30,
  MAX_PREVIEW_LENGTH: 100,
  MAX_CONTENT_LENGTH: 150,
  MAX_NOTICE_TEXT_LENGTH: 30,
  // 搜索阈值
  SIMILARITY_THRESHOLD: 0.3,
  MAX_SEARCH_RESULTS: 10,
  // 搜索关键词过滤
  MIN_WORD_LENGTH: 1,
  // 文件读取
  MAX_FILE_READ_ATTEMPTS: 3
};
var GRID_CONSTANTS = {
  // 卡片尺寸
  CARD_WIDTH: 300,
  CARD_HEIGHT: 200,
  LARGE_CARD_WIDTH: 400,
  LARGE_CARD_HEIGHT: 300,
  MIN_CARD_WIDTH: 280,
  // 间距
  CARD_SPACING: 20,
  GRID_GAP: 16,
  GROUP_PADDING: 40,
  GROUP_SPACING: 50,
  // 布局参数
  MIN_WIDTH: 300,
  EXPANDED_HEIGHT_MULTIPLIER: 2,
  MIN_EXPANDED_HEIGHT: 400,
  // 响应式断点
  BREAKPOINTS: {
    SMALL: 800,
    MEDIUM: 1200,
    LARGE: 1600
  }
};
var PERFORMANCE_CONSTANTS = {
  // 超时设置
  DEFAULT_TIMEOUT: 3e3,
  METADATA_FETCH_TIMEOUT: 3e3,
  FILE_OPERATION_TIMEOUT: 5e3,
  // 缓存设置
  MAX_CACHE_SIZE: 1e3,
  MAX_LOG_SIZE: 100,
  MAX_HISTORY_SIZE: 100,
  CACHE_TTL: 3e5,
  // 5分钟
  // 节流防抖
  DEBOUNCE_DELAY: 300,
  THROTTLE_DELAY: 100,
  // 延迟设置
  MINIMAL_DELAY: 100,
  QUICK_DELAY: 300,
  SHORT_DELAY: 500,
  STANDARD_DELAY: 1e3,
  // 批处理
  BATCH_SIZE: 50,
  MAX_CONCURRENT_OPERATIONS: 5
};
var NOTIFICATION_CONSTANTS = {
  // 显示时长
  SHORT_DURATION: 2e3,
  MEDIUM_DURATION: 3e3,
  LONG_DURATION: 5e3,
  PERSISTENT_DURATION: 0,
  // 详细信息显示时长
  INFO_DURATION: 6e3
};
var FILE_CONSTANTS = {
  // 文件扩展名
  CANVAS_EXTENSION: ".canvas",
  MARKDOWN_EXTENSION: ".md",
  // 文件大小限制
  MAX_FILE_SIZE: 10 * 1024 * 1024,
  // 10MB
  // 编码
  DEFAULT_ENCODING: "utf8"
};

// src/constants/UIMessages.ts
var ERROR_MESSAGES = {
  // 节点相关错误
  EMPTY_NODE_TEXT: "\u8282\u70B9\u6587\u672C\u4E3A\u7A7A\uFF0C\u65E0\u6CD5\u641C\u7D22",
  TEXT_NODE_ONLY: "\u53EA\u80FD\u4E3A\u6587\u672C\u8282\u70B9\u641C\u7D22\u76F8\u5173\u6587\u4EF6",
  NODE_NOT_FOUND: "\u8282\u70B9\u4E0D\u5B58\u5728\uFF0C\u53EF\u80FD\u5DF2\u88AB\u5220\u9664",
  // 搜索相关错误
  NO_MATCHES_FOUND: "\u672A\u627E\u5230\u5339\u914D\u7684\u539F\u6587\u5185\u5BB9",
  NO_SELECTED_TEXT: "\u6CA1\u6709\u9009\u4E2D\u7684\u6587\u672C",
  SEARCH_FAILED: "\u641C\u7D22\u76F8\u5173\u6587\u4EF6\u5931\u8D25",
  // 文件相关错误
  FILE_NOT_FOUND: "\u6587\u4EF6\u4E0D\u5B58\u5728",
  FILE_READ_FAILED: "\u6587\u4EF6\u8BFB\u53D6\u5931\u8D25",
  FILE_SAVE_FAILED: "\u6587\u4EF6\u4FDD\u5B58\u5931\u8D25",
  CANVAS_LOAD_FAILED: "\u65E0\u6CD5\u52A0\u8F7DCanvas\u6587\u4EF6",
  // 拖拽相关错误
  DRAG_TO_CANVAS_FAILED: "\u62D6\u62FD\u5230Canvas\u5931\u8D25",
  NO_DRAG_DATA: "\u6CA1\u6709\u68C0\u6D4B\u5230\u6709\u6548\u7684\u62D6\u62FD\u6570\u636E",
  INVALID_DROP_TARGET: "\u65E0\u6548\u7684\u62D6\u62FD\u76EE\u6807",
  // 时间线相关错误
  TIMELINE_LOAD_FAILED: "\u65F6\u95F4\u7EBF\u52A0\u8F7D\u5931\u8D25",
  TIMELINE_CARD_CREATE_FAILED: "\u521B\u5EFA\u65F6\u95F4\u7EBF\u5361\u7247\u5931\u8D25",
  // 网络相关错误
  NETWORK_ERROR: "\u7F51\u7EDC\u8FDE\u63A5\u5931\u8D25",
  TIMEOUT_ERROR: "\u64CD\u4F5C\u8D85\u65F6",
  // 权限相关错误
  PERMISSION_DENIED: "\u6743\u9650\u4E0D\u8DB3",
  ACCESS_DENIED: "\u8BBF\u95EE\u88AB\u62D2\u7EDD"
};
var SUCCESS_MESSAGES = {
  // 文件操作成功
  FILE_SAVED: "\u6587\u4EF6\u4FDD\u5B58\u6210\u529F",
  CANVAS_LOADED: "Canvas\u6587\u4EF6\u52A0\u8F7D\u6210\u529F",
  // 搜索成功
  SEARCH_COMPLETED: "\u641C\u7D22\u5B8C\u6210",
  LOCATION_FOUND: "\u5DF2\u5B9A\u4F4D\u5230\u539F\u6587",
  // 拖拽成功
  CARD_CREATED: "\u5361\u7247\u521B\u5EFA\u6210\u529F",
  CARD_MOVED: "\u5361\u7247\u5DF2\u79FB\u52A8\u5230Canvas",
  CARD_COPIED: "\u5361\u7247\u5DF2\u590D\u5236\u5230Canvas",
  // 时间线成功
  TIMELINE_CARD_CREATED: "\u65F6\u95F4\u7EBF\u5361\u7247\u5DF2\u521B\u5EFA",
  TIMELINE_LOADED: "\u65F6\u95F4\u7EBF\u52A0\u8F7D\u6210\u529F",
  // 导航成功
  NAVIGATION_SUCCESS: "\u5BFC\u822A\u6210\u529F",
  BACKLINK_NAVIGATION: "\u5DF2\u8DF3\u8F6C\u5230\u6E90\u6587\u4EF6"
};
var INFO_MESSAGES = {
  // 搜索提示
  SEARCH_SUGGESTION: "\u5EFA\u8BAE\u5728\u641C\u7D22\u9762\u677F\u4E2D\u67E5\u627E",
  GLOBAL_SEARCH_STARTED: "\u5DF2\u5728\u5168\u5C40\u641C\u7D22\u4E2D\u67E5\u627E",
  // 操作提示
  LOADING: "\u6B63\u5728\u52A0\u8F7D...",
  PROCESSING: "\u6B63\u5728\u5904\u7406...",
  SAVING: "\u6B63\u5728\u4FDD\u5B58...",
  // 拖拽提示
  DRAG_TO_CREATE: "\u62D6\u62FD\u5230\u6B64\u5904\u521B\u5EFA\u65B0\u5361\u7247",
  DRAG_TO_TIMELINE: "\u62D6\u62FD\u5230\u6B64\u5904\u521B\u5EFA\u65F6\u95F4\u7EBF\u5361\u7247",
  // 状态提示
  NO_CANVAS_SELECTED: "\u8BF7\u5148\u9009\u62E9\u4E00\u4E2ACanvas\u6587\u4EF6",
  NO_RESULTS: "\u672A\u627E\u5230\u7ED3\u679C",
  EMPTY_CANVAS: "Canvas\u6587\u4EF6\u4E3A\u7A7A",
  // 功能提示
  RIGHT_CLICK_FOR_OPTIONS: "\u53F3\u952E\u70B9\u51FB\u67E5\u770B\u66F4\u591A\u9009\u9879",
  DOUBLE_CLICK_TO_EDIT: "\u53CC\u51FB\u7F16\u8F91",
  // 时间线提示
  SELECT_DATE: "\u8BF7\u9009\u62E9\u65E5\u671F",
  TIME_SLOT_OCCUPIED: "\u8BE5\u65F6\u95F4\u6BB5\u5DF2\u6709\u5185\u5BB9"
};

// src/managers/ValidationManager.ts
var TextValidationStrategy = class {
  constructor() {
    this.name = "text";
  }
  canValidate(type) {
    return type === "text" || type === "string" || type === "textarea";
  }
  async validate(value, rules, context) {
    const errors = [];
    const warnings = [];
    const stringValue = String(value || "");
    for (const rule of rules.sort((a, b) => a.priority - b.priority)) {
      try {
        let isValid = true;
        switch (rule.type) {
          case "required":
            isValid = stringValue.trim().length > 0;
            break;
          case "minLength":
            isValid = stringValue.length >= (rule.value || 0);
            break;
          case "maxLength":
            isValid = stringValue.length <= (rule.value || Infinity);
            break;
          case "pattern":
            if (rule.value instanceof RegExp) {
              isValid = rule.value.test(stringValue);
            }
            break;
          case "custom":
            if (rule.validator) {
              isValid = await rule.validator(stringValue, context);
            }
            break;
        }
        if (!isValid) {
          errors.push({
            field: rule.field,
            rule: rule.name,
            message: rule.message,
            value: stringValue,
            severity: "error"
          });
        }
      } catch (error) {
        errors.push({
          field: rule.field,
          rule: rule.name,
          message: `\u9A8C\u8BC1\u89C4\u5219\u6267\u884C\u5931\u8D25: ${error instanceof Error ? error.message : "Unknown error"}`,
          value: stringValue,
          severity: "error"
        });
      }
    }
    if (stringValue.length > 1e3) {
      warnings.push({
        field: rules[0]?.field || "text",
        message: "\u6587\u672C\u5185\u5BB9\u8F83\u957F\uFF0C\u53EF\u80FD\u5F71\u54CD\u6027\u80FD",
        suggestion: "\u8003\u8651\u5206\u6BB5\u6216\u4F7F\u7528\u6587\u4EF6\u94FE\u63A5"
      });
    }
    return {
      field: rules[0]?.field || "text",
      isValid: errors.length === 0,
      errors,
      warnings,
      value: stringValue
    };
  }
  getDefaultRules(type) {
    return [
      {
        name: "maxLength",
        field: type,
        type: "maxLength",
        value: 1e4,
        message: "\u6587\u672C\u957F\u5EA6\u4E0D\u80FD\u8D85\u8FC710000\u4E2A\u5B57\u7B26",
        priority: 1
      }
    ];
  }
};
var NumberValidationStrategy = class {
  constructor() {
    this.name = "number";
  }
  canValidate(type) {
    return type === "number" || type === "integer" || type === "float";
  }
  async validate(value, rules, context) {
    const errors = [];
    const warnings = [];
    const numValue = Number(value);
    if (value !== "" && value !== null && value !== void 0 && isNaN(numValue)) {
      errors.push({
        field: rules[0]?.field || "number",
        rule: "type",
        message: "\u5FC5\u987B\u662F\u6709\u6548\u7684\u6570\u5B57",
        value,
        severity: "error"
      });
    } else {
      for (const rule of rules.sort((a, b) => a.priority - b.priority)) {
        try {
          let isValid = true;
          switch (rule.type) {
            case "required":
              isValid = !isNaN(numValue);
              break;
            case "custom":
              if (rule.validator) {
                isValid = await rule.validator(numValue, context);
              }
              break;
          }
          if (!isValid) {
            errors.push({
              field: rule.field,
              rule: rule.name,
              message: rule.message,
              value: numValue,
              severity: "error"
            });
          }
        } catch (error) {
          errors.push({
            field: rule.field,
            rule: rule.name,
            message: `\u9A8C\u8BC1\u89C4\u5219\u6267\u884C\u5931\u8D25: ${error instanceof Error ? error.message : "Unknown error"}`,
            value: numValue,
            severity: "error"
          });
        }
      }
    }
    return {
      field: rules[0]?.field || "number",
      isValid: errors.length === 0,
      errors,
      warnings,
      value: numValue
    };
  }
  getDefaultRules(type) {
    return [
      {
        name: "type",
        field: type,
        type: "custom",
        message: "\u5FC5\u987B\u662F\u6709\u6548\u7684\u6570\u5B57",
        validator: (value) => !isNaN(Number(value)),
        priority: 1
      }
    ];
  }
};
var CanvasValidationStrategy = class {
  constructor() {
    this.name = "canvas";
  }
  canValidate(type) {
    return type === "canvas" || type === "canvasData" || type === "canvasNode";
  }
  async validate(value, rules, context) {
    const errors = [];
    const warnings = [];
    try {
      if (typeof value !== "object" || value === null) {
        errors.push({
          field: "canvas",
          rule: "structure",
          message: "Canvas\u6570\u636E\u5FC5\u987B\u662F\u5BF9\u8C61",
          value,
          severity: "error"
        });
      } else {
        if (!value.nodes || !Array.isArray(value.nodes)) {
          errors.push({
            field: "canvas.nodes",
            rule: "required",
            message: "Canvas\u5FC5\u987B\u5305\u542Bnodes\u6570\u7EC4",
            value: value.nodes,
            severity: "error"
          });
        }
        if (!value.edges || !Array.isArray(value.edges)) {
          errors.push({
            field: "canvas.edges",
            rule: "required",
            message: "Canvas\u5FC5\u987B\u5305\u542Bedges\u6570\u7EC4",
            value: value.edges,
            severity: "error"
          });
        }
        if (value.nodes && Array.isArray(value.nodes)) {
          value.nodes.forEach((node, index) => {
            if (!node.id) {
              errors.push({
                field: `canvas.nodes[${index}].id`,
                rule: "required",
                message: "\u8282\u70B9\u5FC5\u987B\u6709ID",
                value: node.id,
                severity: "error"
              });
            }
            if (typeof node.x !== "number" || typeof node.y !== "number") {
              errors.push({
                field: `canvas.nodes[${index}].position`,
                rule: "type",
                message: "\u8282\u70B9\u4F4D\u7F6E\u5FC5\u987B\u662F\u6570\u5B57",
                value: { x: node.x, y: node.y },
                severity: "error"
              });
            }
          });
        }
        if (value.nodes && value.nodes.length > 1e3) {
          warnings.push({
            field: "canvas.nodes",
            message: "\u8282\u70B9\u6570\u91CF\u8FC7\u591A\uFF0C\u53EF\u80FD\u5F71\u54CD\u6027\u80FD",
            suggestion: "\u8003\u8651\u5206\u7EC4\u6216\u5206\u9875\u663E\u793A"
          });
        }
      }
      for (const rule of rules.sort((a, b) => a.priority - b.priority)) {
        if (rule.type === "custom" && rule.validator) {
          try {
            const isValid = await rule.validator(value, context);
            if (!isValid) {
              errors.push({
                field: rule.field,
                rule: rule.name,
                message: rule.message,
                value,
                severity: "error"
              });
            }
          } catch (error) {
            errors.push({
              field: rule.field,
              rule: rule.name,
              message: `\u81EA\u5B9A\u4E49\u9A8C\u8BC1\u5931\u8D25: ${error instanceof Error ? error.message : "Unknown error"}`,
              value,
              severity: "error"
            });
          }
        }
      }
    } catch (error) {
      errors.push({
        field: "canvas",
        rule: "validation",
        message: `Canvas\u9A8C\u8BC1\u5931\u8D25: ${error instanceof Error ? error.message : "Unknown error"}`,
        value,
        severity: "error"
      });
    }
    return {
      field: "canvas",
      isValid: errors.length === 0,
      errors,
      warnings,
      value
    };
  }
  getDefaultRules(type) {
    return [
      {
        name: "structure",
        field: "canvas",
        type: "custom",
        message: "Canvas\u6570\u636E\u7ED3\u6784\u65E0\u6548",
        validator: (value) => {
          return typeof value === "object" && value !== null && Array.isArray(value.nodes) && Array.isArray(value.edges);
        },
        priority: 1
      }
    ];
  }
};
var ValidationManager = class {
  constructor(app, config) {
    this.strategies = /* @__PURE__ */ new Map();
    this.rules = /* @__PURE__ */ new Map();
    this.validationCache = /* @__PURE__ */ new Map();
    this.debounceTimers = /* @__PURE__ */ new Map();
    this.app = app;
    this.config = config;
    this.initializeStrategies();
    this.setupDefaultRules();
  }
  /**
   * 初始化验证策略
   */
  initializeStrategies() {
    this.strategies.set("text", new TextValidationStrategy());
    this.strategies.set("number", new NumberValidationStrategy());
    this.strategies.set("canvas", new CanvasValidationStrategy());
  }
  /**
   * 设置默认验证规则
   */
  setupDefaultRules() {
    for (const [type, strategy] of this.strategies) {
      const defaultRules = strategy.getDefaultRules(type);
      this.rules.set(type, defaultRules);
    }
    if (this.config.enableCustomRules && this.config.customRules) {
      this.config.customRules.forEach((rule) => {
        const existingRules = this.rules.get(rule.field) || [];
        existingRules.push(rule);
        this.rules.set(rule.field, existingRules);
      });
    }
  }
  /**
   * 验证单个字段
   */
  async validateField(field, value, type, context) {
    const strategy = this.findStrategy(type);
    if (!strategy) {
      return {
        field,
        isValid: false,
        errors: [{
          field,
          rule: "strategy",
          message: `\u4E0D\u652F\u6301\u7684\u9A8C\u8BC1\u7C7B\u578B: ${type}`,
          value,
          severity: "error"
        }],
        warnings: [],
        value
      };
    }
    const rules = this.rules.get(field) || strategy.getDefaultRules(type);
    return await strategy.validate(value, rules, context);
  }
  /**
   * 验证多个字段
   */
  async validateFields(data, schema, context) {
    const startTime = Date.now();
    const fieldResults = /* @__PURE__ */ new Map();
    const allErrors = [];
    const allWarnings = [];
    const validationPromises = Object.entries(data).map(async ([field, value]) => {
      const type = schema[field] || "text";
      const result2 = await this.validateField(field, value, type, context);
      fieldResults.set(field, result2);
      allErrors.push(...result2.errors);
      allWarnings.push(...result2.warnings);
    });
    await Promise.all(validationPromises);
    const result = {
      isValid: allErrors.length === 0,
      errors: allErrors,
      warnings: allWarnings,
      fieldResults,
      timestamp: startTime,
      duration: Date.now() - startTime
    };
    const cacheKey = this.generateCacheKey(data, schema);
    this.validationCache.set(cacheKey, result);
    return result;
  }
  /**
   * 实时验证（带防抖）
   */
  async validateRealTime(field, value, type, context) {
    if (!this.config.enableRealTimeValidation) {
      return;
    }
    const existingTimer = this.debounceTimers.get(field);
    if (existingTimer) {
      clearTimeout(existingTimer);
    }
    const timer = setTimeout(async () => {
      const result = await this.validateField(field, value, type, context);
      this.emitValidationResult(field, result);
      this.debounceTimers.delete(field);
    }, this.config.debounceDelay);
    this.debounceTimers.set(field, timer);
  }
  /**
   * 添加验证规则
   */
  addRule(field, rule) {
    const existingRules = this.rules.get(field) || [];
    existingRules.push(rule);
    this.rules.set(field, existingRules.sort((a, b) => a.priority - b.priority));
  }
  /**
   * 移除验证规则
   */
  removeRule(field, ruleName) {
    const existingRules = this.rules.get(field) || [];
    const filteredRules = existingRules.filter((rule) => rule.name !== ruleName);
    this.rules.set(field, filteredRules);
  }
  /**
   * 清空验证缓存
   */
  clearCache() {
    this.validationCache.clear();
  }
  /**
   * 查找验证策略
   */
  findStrategy(type) {
    for (const strategy of this.strategies.values()) {
      if (strategy.canValidate(type)) {
        return strategy;
      }
    }
    return null;
  }
  /**
   * 生成缓存键
   */
  generateCacheKey(data, schema) {
    return JSON.stringify({ data, schema });
  }
  /**
   * 触发验证结果事件
   */
  emitValidationResult(field, result) {
    console.log(`Validation result for ${field}:`, result);
  }
  /**
   * 注册验证策略
   */
  registerStrategy(strategy) {
    this.strategies.set(strategy.name, strategy);
  }
  /**
   * 更新配置
   */
  updateConfig(config) {
    this.config = { ...this.config, ...config };
    this.setupDefaultRules();
  }
  /**
   * 销毁管理器
   */
  destroy() {
    for (const timer of this.debounceTimers.values()) {
      clearTimeout(timer);
    }
    this.debounceTimers.clear();
    this.validationCache.clear();
    this.strategies.clear();
    this.rules.clear();
  }
};

// src/managers/PerformanceManager.ts
var PerformanceMonitor = class {
  constructor(config) {
    this.config = config;
    this.metrics = [];
    this.observers = [];
    this.startTime = Date.now();
    this.setupObservers();
  }
  /**
   * 设置性能观察器
   */
  setupObservers() {
    if (!this.config.enableMonitoring)
      return;
    if ("PerformanceObserver" in window) {
      try {
        const navigationObserver = new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            this.recordNavigationMetrics(entry);
          }
        });
        navigationObserver.observe({ entryTypes: ["navigation"] });
        this.observers.push(navigationObserver);
      } catch (error) {
        DebugManager.warn("Navigation performance observer not supported:", error);
      }
      try {
        const resourceObserver = new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            this.recordResourceMetrics(entry);
          }
        });
        resourceObserver.observe({ entryTypes: ["resource"] });
        this.observers.push(resourceObserver);
      } catch (error) {
        DebugManager.warn("Resource performance observer not supported:", error);
      }
      try {
        const measureObserver = new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            this.recordMeasureMetrics(entry);
          }
        });
        measureObserver.observe({ entryTypes: ["measure"] });
        this.observers.push(measureObserver);
      } catch (error) {
        DebugManager.warn("Measure performance observer not supported:", error);
      }
    }
  }
  /**
   * 记录导航指标
   */
  recordNavigationMetrics(entry) {
    const navigationEntry = entry;
    const metrics = {
      timestamp: Date.now(),
      responseTime: navigationEntry.responseEnd - navigationEntry.responseStart,
      memoryUsage: this.getMemoryUsage(),
      renderTime: navigationEntry.loadEventEnd - navigationEntry.loadEventStart,
      fps: this.getFPS(),
      domNodes: document.querySelectorAll("*").length,
      eventListeners: this.getEventListenerCount(),
      cacheHitRate: 0,
      // 需要从缓存管理器获取
      bundleSize: 0,
      // 需要计算
      networkRequests: performance.getEntriesByType("resource").length,
      errors: 0
    };
    this.addMetrics(metrics);
  }
  /**
   * 记录资源指标
   */
  recordResourceMetrics(entry) {
    const resourceEntry = entry;
    if (resourceEntry.transferSize) {
    }
  }
  /**
   * 记录测量指标
   */
  recordMeasureMetrics(entry) {
    console.log("Custom measure:", entry.name, entry.duration);
  }
  /**
   * 获取内存使用情况
   */
  getMemoryUsage() {
    if ("memory" in performance) {
      const memory = performance.memory;
      return memory.usedJSHeapSize / 1024 / 1024;
    }
    return 0;
  }
  /**
   * 获取FPS
   */
  getFPS() {
    return 60;
  }
  /**
   * 获取事件监听器数量
   */
  getEventListenerCount() {
    return document.querySelectorAll("[onclick], [onload], [onchange]").length;
  }
  /**
   * 添加指标
   */
  addMetrics(metrics) {
    this.metrics.push(metrics);
    if (this.metrics.length > this.config.maxMetricsHistory) {
      this.metrics = this.metrics.slice(-this.config.maxMetricsHistory);
    }
  }
  /**
   * 获取所有指标
   */
  getMetrics() {
    return [...this.metrics];
  }
  /**
   * 获取最新指标
   */
  getLatestMetrics() {
    return this.metrics.length > 0 ? this.metrics[this.metrics.length - 1] : null;
  }
  /**
   * 清理观察器
   */
  destroy() {
    this.observers.forEach((observer) => observer.disconnect());
    this.observers = [];
    this.metrics = [];
  }
};
var PerformanceProfiler = class {
  constructor() {
    this.profiles = /* @__PURE__ */ new Map();
    this.activeProfiles = /* @__PURE__ */ new Set();
  }
  /**
   * 开始性能分析
   */
  start(name) {
    if (this.activeProfiles.has(name)) {
      DebugManager.warn(`Profile ${name} is already active`);
      return;
    }
    this.activeProfiles.add(name);
    performance.mark(`${name}-start`);
  }
  /**
   * 结束性能分析
   */
  end(name) {
    if (!this.activeProfiles.has(name)) {
      console.warn(`Profile ${name} is not active`);
      return 0;
    }
    performance.mark(`${name}-end`);
    performance.measure(name, `${name}-start`, `${name}-end`);
    const entries = performance.getEntriesByName(name, "measure");
    const duration = entries.length > 0 ? entries[entries.length - 1].duration : 0;
    this.profiles.set(name, duration);
    this.activeProfiles.delete(name);
    performance.clearMarks(`${name}-start`);
    performance.clearMarks(`${name}-end`);
    performance.clearMeasures(name);
    return duration;
  }
  /**
   * 获取分析结果
   */
  getProfile(name) {
    return this.profiles.get(name);
  }
  /**
   * 获取所有分析结果
   */
  getAllProfiles() {
    return new Map(this.profiles);
  }
  /**
   * 清理分析数据
   */
  clear() {
    this.profiles.clear();
    this.activeProfiles.clear();
  }
};
var PerformanceOptimizer = class {
  constructor(config) {
    this.config = config;
    this.strategies = [];
    this.initializeStrategies();
  }
  /**
   * 初始化优化策略
   */
  initializeStrategies() {
    this.strategies.push({
      name: "memory-cleanup",
      enabled: true,
      trigger: (metrics) => metrics.memoryUsage > this.config.alertThresholds.memoryUsage,
      execute: async () => {
        if (window.gc) {
          window.gc();
        }
      },
      description: "\u5185\u5B58\u4F7F\u7528\u8FC7\u9AD8\u65F6\u6267\u884C\u6E05\u7406"
    });
    this.strategies.push({
      name: "render-optimization",
      enabled: true,
      trigger: (metrics) => metrics.renderTime > this.config.alertThresholds.renderTime,
      execute: async () => {
      },
      description: "\u6E32\u67D3\u65F6\u95F4\u8FC7\u957F\u65F6\u4F18\u5316\u6E32\u67D3\u6027\u80FD"
    });
    this.strategies.push({
      name: "fps-optimization",
      enabled: true,
      trigger: (metrics) => metrics.fps < this.config.alertThresholds.fpsThreshold,
      execute: async () => {
      },
      description: "FPS\u8FC7\u4F4E\u65F6\u4F18\u5316\u52A8\u753B\u6027\u80FD"
    });
  }
  /**
   * 执行优化
   */
  async optimize(metrics) {
    if (!this.config.enableOptimizations)
      return;
    for (const strategy of this.strategies) {
      if (strategy.enabled && strategy.trigger(metrics)) {
        try {
          await strategy.execute();
          console.log(`Executed optimization strategy: ${strategy.name}`);
        } catch (error) {
          console.error(`Failed to execute optimization strategy ${strategy.name}:`, error);
        }
      }
    }
  }
  /**
   * 添加优化策略
   */
  addStrategy(strategy) {
    this.strategies.push(strategy);
  }
  /**
   * 移除优化策略
   */
  removeStrategy(name) {
    this.strategies = this.strategies.filter((s) => s.name !== name);
  }
};
var PerformanceManager = class {
  constructor(app, config) {
    this.alerts = [];
    this.monitoringTimer = null;
    this.app = app;
    this.config = config;
    this.monitor = new PerformanceMonitor(config);
    this.profiler = new PerformanceProfiler();
    this.optimizer = new PerformanceOptimizer(config);
    this.startMonitoring();
  }
  /**
   * 开始监控
   */
  startMonitoring() {
    if (!this.config.enableMonitoring)
      return;
    this.monitoringTimer = setInterval(() => {
      this.collectMetrics();
    }, 5e3);
  }
  /**
   * 收集指标
   */
  async collectMetrics() {
    const metrics = {
      timestamp: Date.now(),
      responseTime: 0,
      // 需要从实际操作中测量
      memoryUsage: this.getMemoryUsage(),
      renderTime: 0,
      // 需要从渲染操作中测量
      fps: this.getFPS(),
      domNodes: document.querySelectorAll("*").length,
      eventListeners: 0,
      // 需要计算
      cacheHitRate: 0,
      // 需要从缓存管理器获取
      bundleSize: 0,
      // 需要计算
      networkRequests: performance.getEntriesByType("resource").length,
      errors: 0
    };
    this.monitor.addMetrics(metrics);
    this.checkThresholds(metrics);
    await this.optimizer.optimize(metrics);
  }
  /**
   * 检查阈值
   */
  checkThresholds(metrics) {
    const thresholds = this.config.alertThresholds;
    if (metrics.responseTime > thresholds.responseTime) {
      this.addAlert("warning", "responseTime", metrics.responseTime, thresholds.responseTime, "\u54CD\u5E94\u65F6\u95F4\u8FC7\u957F");
    }
    if (metrics.memoryUsage > thresholds.memoryUsage) {
      this.addAlert("error", "memoryUsage", metrics.memoryUsage, thresholds.memoryUsage, "\u5185\u5B58\u4F7F\u7528\u8FC7\u9AD8");
    }
    if (metrics.renderTime > thresholds.renderTime) {
      this.addAlert("warning", "renderTime", metrics.renderTime, thresholds.renderTime, "\u6E32\u67D3\u65F6\u95F4\u8FC7\u957F");
    }
    if (metrics.fps < thresholds.fpsThreshold) {
      this.addAlert("warning", "fps", metrics.fps, thresholds.fpsThreshold, "FPS\u8FC7\u4F4E");
    }
  }
  /**
   * 添加警报
   */
  addAlert(type, metric, value, threshold, message) {
    const alert = {
      type,
      metric,
      value,
      threshold,
      timestamp: Date.now(),
      message
    };
    this.alerts.push(alert);
    if (this.alerts.length > 100) {
      this.alerts = this.alerts.slice(-100);
    }
    DebugManager.warn(`Performance Alert [${type}]: ${message}`, alert);
  }
  /**
   * 开始性能分析
   */
  startProfile(name) {
    this.profiler.start(name);
  }
  /**
   * 结束性能分析
   */
  endProfile(name) {
    return this.profiler.end(name);
  }
  /**
   * 生成性能报告
   */
  generateReport(startTime, endTime) {
    const now = Date.now();
    const start = startTime || now - 36e5;
    const end = endTime || now;
    const metrics = this.monitor.getMetrics().filter(
      (m) => m.timestamp >= start && m.timestamp <= end
    );
    const summary = this.calculateSummary(metrics);
    const alerts = this.alerts.filter(
      (a) => a.timestamp >= start && a.timestamp <= end
    );
    const recommendations = this.generateRecommendations(metrics);
    return {
      period: { start, end },
      summary,
      metrics,
      alerts,
      recommendations
    };
  }
  /**
   * 计算摘要
   */
  calculateSummary(metrics) {
    if (metrics.length === 0) {
      return {
        averageResponseTime: 0,
        maxResponseTime: 0,
        averageMemoryUsage: 0,
        maxMemoryUsage: 0,
        averageFPS: 0,
        minFPS: 0,
        totalErrors: 0,
        uptime: 0
      };
    }
    return {
      averageResponseTime: metrics.reduce((sum, m) => sum + m.responseTime, 0) / metrics.length,
      maxResponseTime: Math.max(...metrics.map((m) => m.responseTime)),
      averageMemoryUsage: metrics.reduce((sum, m) => sum + m.memoryUsage, 0) / metrics.length,
      maxMemoryUsage: Math.max(...metrics.map((m) => m.memoryUsage)),
      averageFPS: metrics.reduce((sum, m) => sum + m.fps, 0) / metrics.length,
      minFPS: Math.min(...metrics.map((m) => m.fps)),
      totalErrors: metrics.reduce((sum, m) => sum + m.errors, 0),
      uptime: Date.now() - this.monitor["startTime"]
    };
  }
  /**
   * 生成建议
   */
  generateRecommendations(metrics) {
    const recommendations = [];
    const avgMemory = metrics.reduce((sum, m) => sum + m.memoryUsage, 0) / metrics.length;
    if (avgMemory > 50) {
      recommendations.push({
        category: "memory",
        priority: "high",
        title: "\u5185\u5B58\u4F7F\u7528\u4F18\u5316",
        description: "\u5E73\u5747\u5185\u5B58\u4F7F\u7528\u8FC7\u9AD8\uFF0C\u5EFA\u8BAE\u4F18\u5316\u5185\u5B58\u7BA1\u7406",
        impact: "\u51CF\u5C11\u5185\u5B58\u4F7F\u7528\uFF0C\u63D0\u9AD8\u5E94\u7528\u7A33\u5B9A\u6027",
        implementation: "\u5B9E\u65BD\u7F13\u5B58\u6E05\u7406\u3001\u5BF9\u8C61\u6C60\u3001\u5F31\u5F15\u7528\u7B49\u7B56\u7565"
      });
    }
    return recommendations;
  }
  /**
   * 获取内存使用情况
   */
  getMemoryUsage() {
    if ("memory" in performance) {
      const memory = performance.memory;
      return memory.usedJSHeapSize / 1024 / 1024;
    }
    return 0;
  }
  /**
   * 获取FPS
   */
  getFPS() {
    return 60;
  }
  /**
   * 更新配置
   */
  updateConfig(config) {
    this.config = { ...this.config, ...config };
  }
  /**
   * 销毁管理器
   */
  destroy() {
    if (this.monitoringTimer) {
      clearInterval(this.monitoringTimer);
      this.monitoringTimer = null;
    }
    this.monitor.destroy();
    this.profiler.clear();
    this.alerts = [];
  }
};

// main.ts
var SVGIconManager = class {
  static createIcon(iconName, customSize) {
    DebugManager.verbose(`Creating icon: ${iconName}`);
    const emojiMap = {
      timeCapsule: "\u23F3",
      hourglass: "\u23F3",
      clock: "\u{1F550}",
      grid: "\u229E",
      back: "\u2190",
      refresh: "\u21BB",
      settings: "\u2699",
      close: "\u2715",
      menu: "\u22EE",
      archive: "\u{1F4E6}"
      // 🔧 新增：archive图标的emoji后备
    };
    const iconSvg = this.icons[iconName];
    if (!iconSvg) {
      DebugManager.warn(`Icon '${iconName}' not found in icons:`, Object.keys(this.icons));
      const fallback = document.createElement("span");
      fallback.textContent = emojiMap[iconName] || "?";
      fallback.style.fontSize = "16px";
      fallback.style.display = "inline-flex";
      fallback.style.alignItems = "center";
      fallback.style.justifyContent = "center";
      return fallback;
    }
    const container = document.createElement("span");
    container.className = "svg-icon";
    container.style.display = "inline-flex";
    container.style.alignItems = "center";
    container.style.justifyContent = "center";
    try {
      let svgContent = iconSvg;
      if (customSize) {
        svgContent = svgContent.replace(/width="[^"]*"/, `width="${customSize}"`);
        svgContent = svgContent.replace(/height="[^"]*"/, `height="${customSize}"`);
      }
      DebugManager.log(`Setting SVG content for ${iconName}:`, svgContent.substring(0, SEARCH_CONSTANTS.MAX_PREVIEW_LENGTH) + "...");
      container.innerHTML = svgContent;
      const svgElement = container.querySelector("svg");
      if (!svgElement) {
        throw new Error("SVG element not created");
      }
      DebugManager.log(`Icon ${iconName} created successfully`);
    } catch (error) {
      DebugManager.error("Failed to create SVG icon:", error);
      container.innerHTML = "";
      container.textContent = emojiMap[iconName] || "?";
      container.style.fontSize = "16px";
    }
    return container;
  }
  static setIcon(element, iconName, customSize) {
    DebugManager.log(`Setting icon ${iconName} on element:`, element);
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
    const icon = this.createIcon(iconName, customSize);
    element.appendChild(icon);
    DebugManager.log(`Icon ${iconName} set successfully, element now contains:`, element.innerHTML);
  }
};
SVGIconManager.icons = {
  grid: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/></svg>',
  back: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="19" y1="12" x2="5" y2="12"/><polyline points="12,19 5,12 12,5"/></svg>',
  refresh: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M3 21v-5h5"/></svg>',
  settings: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="m12 1 1.27 2.22 2.22 1.27-1.27 2.22L12 8.5l-1.27-2.22L8.5 5.23l1.27-2.22L12 1"/><path d="m21 12-2.22 1.27-1.27 2.22-2.22-1.27L12 15.5l1.27-2.22 2.22-1.27 1.27-2.22L21 12"/><path d="m12 23-1.27-2.22-2.22-1.27 1.27-2.22L12 15.5l1.27 2.22 2.22 1.27-1.27 2.22L12 23"/><path d="m3 12 2.22-1.27 1.27-2.22 2.22 1.27L12 8.5l-1.27 2.22-2.22 1.27-1.27 2.22L3 12"/></svg>',
  close: '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>',
  menu: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="1"/><circle cx="12" cy="5" r="1"/><circle cx="12" cy="19" r="1"/></svg>',
  timeCapsule: '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M6 2h12v6l-6 6 6 6v6H6v-6l6-6-6-6V2z"/></svg>',
  hourglass: '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M6 2h12v6l-6 6 6 6v6H6v-6l6-6-6-6V2z"/></svg>',
  clock: '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="none"><circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/></svg>',
  externalLink: '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/><polyline points="15,3 21,3 21,9"/><line x1="10" y1="14" x2="21" y2="3"/></svg>',
  edit: '<svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>',
  file: '<svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/></svg>',
  link: '<svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/></svg>',
  group: '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><path d="M9 9h6v6H9z"/></svg>',
  arrow: '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6,9 12,15 18,9"/></svg>',
  arrowRight: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9,18 15,12 9,6"/></svg>',
  arrowLeft: '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15,18 9,12 15,6"/></svg>',
  // 🔧 新增：Font Awesome archive图标（收集功能专用）
  archive: '<svg width="16" height="16" viewBox="0 0 512 512" fill="currentColor"><path d="M32 32H480c17.7 0 32 14.3 32 32V96c0 17.7-14.3 32-32 32H32C14.3 128 0 113.7 0 96V64C0 46.3 14.3 32 32 32zm0 128H480V416c0 35.3-28.7 64-64 64H96c-35.3 0-64-28.7-64-64V160zm128 80c0 8.8 7.2 16 16 16H336c8.8 0 16-7.2 16-16s-7.2-16-16-16H176c-8.8 0-16 7.2-16 16z"/></svg>'
};
var LoadingManager = class {
  /**
   * 开始加载操作
   */
  static startLoading(operationId, description, container) {
    this.activeOperations.set(operationId, {
      startTime: Date.now(),
      description
    });
    if (container) {
      this.showLoadingIndicator(operationId, description, container);
    }
    DebugManager.log(`\u{1F504} \u5F00\u59CB\u52A0\u8F7D: ${description}`);
  }
  /**
   * 结束加载操作
   */
  static endLoading(operationId) {
    const operation = this.activeOperations.get(operationId);
    if (operation) {
      const duration = Date.now() - operation.startTime;
      DebugManager.log(`\u2705 \u52A0\u8F7D\u5B8C\u6210: ${operation.description} (\u8017\u65F6: ${duration}ms)`);
      this.activeOperations.delete(operationId);
    }
    this.hideLoadingIndicator(operationId);
  }
  /**
   * 显示加载指示器
   */
  static showLoadingIndicator(operationId, description, container) {
    const indicator = container.createDiv("loading-indicator");
    indicator.innerHTML = `
			<div class="loading-spinner"></div>
			<div class="loading-text">${description}...</div>
		`;
    this.loadingIndicators.set(operationId, indicator);
  }
  /**
   * 隐藏加载指示器
   */
  static hideLoadingIndicator(operationId) {
    const indicator = this.loadingIndicators.get(operationId);
    if (indicator) {
      indicator.remove();
      this.loadingIndicators.delete(operationId);
    }
  }
  /**
   * 检查是否有正在进行的操作
   */
  static isLoading(operationId) {
    if (operationId) {
      return this.activeOperations.has(operationId);
    }
    return this.activeOperations.size > 0;
  }
  /**
   * 获取所有活动操作
   */
  static getActiveOperations() {
    const now = Date.now();
    return Array.from(this.activeOperations.entries()).map(([id, operation]) => ({
      id,
      description: operation.description,
      duration: now - operation.startTime
    }));
  }
  /**
   * 清理所有加载状态
   */
  static cleanup() {
    this.activeOperations.clear();
    this.loadingIndicators.forEach((indicator) => indicator.remove());
    this.loadingIndicators.clear();
  }
};
LoadingManager.activeOperations = /* @__PURE__ */ new Map();
LoadingManager.loadingIndicators = /* @__PURE__ */ new Map();
var ErrorHandler = class _ErrorHandler {
  constructor() {
    this.errorLog = [];
    this.maxLogSize = PERFORMANCE_CONSTANTS.MAX_LOG_SIZE;
  }
  static getInstance() {
    if (!this.instance) {
      this.instance = new _ErrorHandler();
    }
    return this.instance;
  }
  /**
   * 处理错误并提供用户友好的反馈
   */
  handleError(error, context, showToUser = true) {
    const errorObj = typeof error === "string" ? new Error(error) : error;
    this.logError(errorObj, context);
    if (showToUser) {
      this.showUserFriendlyError(errorObj, context);
    }
    DebugManager.error(`[${context}]`, errorObj);
  }
  /**
   * 处理异步操作的错误
   */
  async handleAsyncOperation(operation, context, fallbackValue, showErrorToUser = true) {
    try {
      return await operation();
    } catch (error) {
      this.handleError(error, context, showErrorToUser);
      return fallbackValue;
    }
  }
  /**
   * 创建带有重试机制的异步操作
   */
  async withRetry(operation, context, maxRetries = 3, delay = 1e3) {
    let lastError;
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        if (attempt === maxRetries) {
          this.handleError(lastError, `${context} (\u6700\u7EC8\u5931\u8D25\uFF0C\u5DF2\u91CD\u8BD5${maxRetries}\u6B21)`);
          break;
        }
        DebugManager.warn(`[${context}] \u7B2C${attempt}\u6B21\u5C1D\u8BD5\u5931\u8D25\uFF0C${delay}ms\u540E\u91CD\u8BD5:`, error);
        await new Promise((resolve) => setTimeout(resolve, delay));
        delay *= 2;
      }
    }
    return void 0;
  }
  /**
   * 记录错误到内部日志
   */
  logError(error, context) {
    this.errorLog.push({
      timestamp: Date.now(),
      error,
      context
    });
    if (this.errorLog.length > this.maxLogSize) {
      this.errorLog.shift();
    }
  }
  /**
   * 显示用户友好的错误信息
   */
  showUserFriendlyError(error, context) {
    const userMessage = this.getUserFriendlyMessage(error, context);
    if (window.app) {
      new import_obsidian12.Notice(userMessage, NOTIFICATION_CONSTANTS.LONG_DURATION);
    }
  }
  /**
   * 将技术错误转换为用户友好的消息
   */
  getUserFriendlyMessage(error, context) {
    const message = error.message.toLowerCase();
    if (message.includes("fetch") || message.includes("network") || message.includes("timeout")) {
      return "\u7F51\u7EDC\u8FDE\u63A5\u5931\u8D25\uFF0C\u8BF7\u68C0\u67E5\u7F51\u7EDC\u8BBE\u7F6E\u540E\u91CD\u8BD5";
    }
    if (message.includes("file") || message.includes("read") || message.includes("write")) {
      return "\u6587\u4EF6\u64CD\u4F5C\u5931\u8D25\uFF0C\u8BF7\u68C0\u67E5\u6587\u4EF6\u6743\u9650\u6216\u78C1\u76D8\u7A7A\u95F4";
    }
    if (message.includes("json") || message.includes("parse")) {
      return "Canvas\u6587\u4EF6\u683C\u5F0F\u9519\u8BEF\uFF0C\u8BF7\u68C0\u67E5\u6587\u4EF6\u5185\u5BB9";
    }
    if (message.includes("permission") || message.includes("access")) {
      return "\u6743\u9650\u4E0D\u8DB3\uFF0C\u8BF7\u68C0\u67E5\u6587\u4EF6\u8BBF\u95EE\u6743\u9650";
    }
    if (context.includes("canvas")) {
      return "Canvas\u64CD\u4F5C\u5931\u8D25\uFF0C\u8BF7\u5C1D\u8BD5\u5237\u65B0\u6216\u91CD\u65B0\u6253\u5F00\u6587\u4EF6";
    }
    return `\u64CD\u4F5C\u5931\u8D25: ${context}`;
  }
  /**
   * 获取错误统计信息
   */
  getErrorStats() {
    const now = Date.now();
    const oneHourAgo = now - 60 * 60 * 1e3;
    const recentErrors = this.errorLog.filter((log) => log.timestamp > oneHourAgo);
    const contexts = [...new Set(this.errorLog.map((log) => log.context))];
    return {
      totalErrors: this.errorLog.length,
      recentErrors: recentErrors.length,
      contexts
    };
  }
  /**
   * 清理错误日志
   */
  clearErrorLog() {
    this.errorLog.length = 0;
  }
};
var MemoryManager = class {
  /**
   * 注册清理回调函数
   */
  static registerCleanup(callback) {
    this.cleanupCallbacks.push(callback);
  }
  /**
   * 启动定期内存清理
   */
  static startPeriodicCleanup(intervalMs = 3e5) {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
    }
    this.cleanupInterval = setInterval(() => {
      this.performCleanup();
    }, intervalMs);
  }
  /**
   * 执行内存清理
   */
  static performCleanup() {
    DebugManager.log("\u{1F9F9} \u6267\u884C\u5185\u5B58\u6E05\u7406...");
    this.cleanupCallbacks.forEach((callback, index) => {
      try {
        callback();
      } catch (error) {
        DebugManager.error(`\u6E05\u7406\u56DE\u8C03[${index}]\u6267\u884C\u5931\u8D25:`, error);
      }
    });
    if (global.gc) {
      global.gc();
    }
  }
  /**
   * 停止定期清理
   */
  static stopPeriodicCleanup() {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
    }
  }
  /**
   * 清理所有注册的回调
   */
  static cleanup() {
    this.stopPeriodicCleanup();
    this.performCleanup();
    this.cleanupCallbacks.length = 0;
  }
};
MemoryManager.cleanupCallbacks = [];
MemoryManager.cleanupInterval = null;
var SafeHTMLRenderer = class {
  /**
   * 安全地设置元素的HTML内容，防止XSS攻击
   * @param element 目标元素
   * @param htmlContent HTML内容字符串
   * @param allowedTags 允许的HTML标签列表
   */
  static setHTML(element, htmlContent, allowedTags = ["svg", "path", "rect", "circle", "polyline", "line", "g", "defs", "use"]) {
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
    if (!htmlContent.includes("<")) {
      element.textContent = htmlContent;
      return;
    }
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = htmlContent;
    this.sanitizeAndAppend(tempDiv, element, allowedTags);
  }
  /**
   * 安全地创建SVG图标元素
   * @param svgContent SVG内容
   * @returns 安全的SVG元素
   */
  static createSVGIcon(svgContent) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(svgContent, "image/svg+xml");
    const svgElement = doc.documentElement;
    if (svgElement.tagName !== "svg") {
      throw new Error("Invalid SVG content");
    }
    this.removeDangerousAttributes(svgElement);
    return svgElement;
  }
  /**
   * 递归清理和复制安全的元素
   */
  static sanitizeAndAppend(source, target, allowedTags) {
    Array.from(source.childNodes).forEach((node) => {
      if (node.nodeType === Node.TEXT_NODE) {
        target.appendChild(node.cloneNode(true));
      } else if (node.nodeType === Node.ELEMENT_NODE) {
        const element = node;
        const tagName = element.tagName.toLowerCase();
        if (allowedTags.includes(tagName)) {
          const newElement = document.createElement(tagName);
          this.copySafeAttributes(element, newElement);
          this.sanitizeAndAppend(element, newElement, allowedTags);
          target.appendChild(newElement);
        }
      }
    });
  }
  /**
   * 复制安全的属性
   */
  static copySafeAttributes(source, target) {
    const safeAttributes = [
      "width",
      "height",
      "viewBox",
      "fill",
      "stroke",
      "stroke-width",
      "stroke-linecap",
      "stroke-linejoin",
      "opacity",
      "transform",
      "x",
      "y",
      "x1",
      "y1",
      "x2",
      "y2",
      "cx",
      "cy",
      "r",
      "rx",
      "ry",
      "d",
      "points",
      "class",
      "id"
    ];
    safeAttributes.forEach((attr) => {
      const value = source.getAttribute(attr);
      if (value !== null) {
        target.setAttribute(attr, value);
      }
    });
  }
  /**
   * 移除危险的属性
   */
  static removeDangerousAttributes(element) {
    const dangerousAttributes = ["onload", "onerror", "onclick", "onmouseover", "onfocus", "onblur"];
    dangerousAttributes.forEach((attr) => {
      element.removeAttribute(attr);
    });
    Array.from(element.children).forEach((child) => {
      this.removeDangerousAttributes(child);
    });
  }
};
var DEFAULT_SETTINGS = {
  enableAutoLayout: true,
  colorFilterColors: ["1", "2", "4", "6", "7"],
  // 默认显示红、橙、绿、蓝、紫
  language: "zh",
  // 默认中文
  enableColorCategories: true,
  // 启用颜色分类
  colorCategories: [
    { id: "important", name: "\u91CD\u8981", description: "\u91CD\u8981\u5185\u5BB9\u548C\u7D27\u6025\u4E8B\u9879", color: "1" },
    // 红色
    { id: "todo", name: "\u5F85\u529E", description: "\u5F85\u529E\u4E8B\u9879\u548C\u4EFB\u52A1", color: "2" },
    // 橙色
    { id: "note", name: "\u8BB0\u4E8B", description: "\u4E00\u822C\u7B14\u8BB0\u548C\u8BB0\u5F55", color: "6" },
    // 蓝色
    { id: "inspiration", name: "\u7075\u611F", description: "\u521B\u610F\u60F3\u6CD5\u548C\u7075\u611F", color: "7" },
    // 紫色
    { id: "collection", name: "\u6536\u96C6", description: "\u65F6\u95F4\u80F6\u56CA\u6536\u96C6\u7684\u5185\u5BB9", color: "5" }
    // 青色
  ],
  // 标注功能默认设置
  annotationName: "card",
  // 默认标注名称
  // 置顶功能默认设置
  enablePinnedCards: true,
  // 默认启用置顶功能
  pinnedTagName: "#\u7F6E\u9876",
  // 默认置顶标签
  pinnedTagPosition: "start",
  // 默认在首部插入
  showPinnedIndicator: true,
  // 默认显示置顶标识
  // Anki Connect默认设置
  ankiConnect: {
    enabled: false,
    // 默认禁用，需要用户手动启用
    apiUrl: "http://localhost:8765",
    // 默认Anki Connect地址
    apiKey: void 0,
    // 默认无API密钥
    defaultDeck: "Default",
    // 默认牌组
    modelName: "Basic",
    // 默认模板
    syncColors: ["1", "2", "4"],
    // 默认同步红、橙、绿色卡片
    enableIncrementalSync: true,
    // 默认启用增量同步
    enableAutoSync: false,
    // 默认禁用自动同步
    batchSize: 50,
    // 默认批次大小
    retryAttempts: 3,
    // 默认重试次数
    timeout: 5e3,
    // 默认超时时间（毫秒）
    contentDivider: "---div---",
    // 默认内容分隔符
    forceSync: false
    // 默认禁用强制同步
  },
  // Anki同步历史默认设置
  ankiSyncHistory: {
    lastSyncTime: 0,
    // 上次同步时间
    syncedNodes: {},
    // 已同步节点记录
    failedNodes: [],
    // 同步失败节点
    totalSynced: 0,
    // 总同步数量
    lastSyncResult: null
    // 最后同步结果
  }
};
var CARD_CONSTANTS = {
  width: GRID_CONSTANTS.CARD_WIDTH,
  height: GRID_CONSTANTS.CARD_HEIGHT,
  spacing: 20
};
var CANVAS_GRID_VIEW_TYPE = "canvas-grid-view";
var CANVAS_TIMELINE_VIEW_TYPE = "canvas-timeline-view";
var I18N_TEXTS = {
  zh: {
    // 通用
    search: "\u641C\u7D22",
    refresh: "\u5237\u65B0",
    settings: "\u8BBE\u7F6E",
    cancel: "\u53D6\u6D88",
    confirm: "\u786E\u8BA4",
    delete: "\u5220\u9664",
    edit: "\u7F16\u8F91",
    save: "\u4FDD\u5B58",
    // 网格视图
    gridView: "\u7F51\u683C\u89C6\u56FE",
    switchToGridView: "\u5207\u6362\u5230\u7F51\u683C\u89C6\u56FE",
    canvasGridView: "Canvasgrid Transit",
    noCanvasData: "\u6CA1\u6709Canvas\u6570\u636E",
    loadingCanvas: "\u52A0\u8F7DCanvas\u4E2D...",
    // 菜单
    refreshData: "\u5237\u65B0\u6570\u636E",
    syncCanvas: "\u540C\u6B65Canvas",
    newCanvasFile: "\u65B0\u5EFACanvas\u6587\u4EF6",
    sortBy: "\u6392\u5E8F\u65B9\u5F0F",
    filterConditions: "\u7B5B\u9009\u6761\u4EF6",
    returnToCanvas: "\u8FD4\u56DECanvas\u767D\u677F",
    // 排序
    sortByCreated: "\u521B\u5EFA\u65F6\u95F4",
    sortByModified: "\u4FEE\u6539\u65F6\u95F4",
    sortByTitle: "\u6807\u9898",
    ascending: "\u5347\u5E8F",
    descending: "\u964D\u5E8F",
    // 筛选
    filterByColor: "\u6309\u989C\u8272\u7B5B\u9009",
    allColors: "\u6240\u6709\u989C\u8272",
    // 分组
    groupView: "\u5206\u7EC4\u89C6\u56FE",
    returnToMainView: "\u8FD4\u56DE\u4E3B\u89C6\u56FE",
    groupMembers: "\u6210\u5458",
    // 设置
    gridLayoutSettings: "\u7F51\u683C\u5E03\u5C40\u8BBE\u7F6E",
    enableAutoLayout: "\u542F\u7528\u81EA\u52A8\u5E03\u5C40",
    interfaceLanguage: "\u754C\u9762\u8BED\u8A00",
    colorFilterSettings: "\u989C\u8272\u7B5B\u9009\u5668\u8BBE\u7F6E",
    aboutPlugin: "\u5173\u4E8E\u63D2\u4EF6",
    // Obsidian块链接功能
    blockLinkSettings: "Obsidian\u5757\u94FE\u63A5\u8BBE\u7F6E",
    enableBlockLinkMode: "\u542F\u7528\u5757\u94FE\u63A5\u6A21\u5F0F",
    blockLinkModeDesc: "\u62D6\u62FD\u6587\u672C\u5230Canvas\u65F6\u81EA\u52A8\u5728\u6E90\u6587\u6863\u4E2D\u521B\u5EFAObsidian\u5757\u94FE\u63A5\u6807\u6CE8",
    blockLinkName: "\u5757\u94FE\u63A5\u6807\u8BC6\u540D\u79F0",
    blockLinkNameDesc: "\u81EA\u5B9A\u4E49\u5757\u94FE\u63A5\u7684\u6807\u8BC6\u540D\u79F0\uFF0C\u7528\u4E8E\u5728\u6E90\u6587\u6863\u4E2D\u6807\u8BB0\u5DF2\u63D0\u53D6\u7684\u5185\u5BB9",
    // 关于
    mainFeatures: "\u4E3B\u8981\u529F\u80FD",
    quickStart: "\u5FEB\u901F\u5F00\u59CB",
    thanks: "\u611F\u8C22\u4F7F\u7528",
    feedback: "\u53CD\u9988\u5EFA\u8BAE",
    contact: "\u8054\u7CFB\u4F5C\u8005",
    buyCoffee: "\u8BF7\u559D\u5496\u5561",
    alipaySupport: "\u652F\u4ED8\u5B9D\u652F\u6301",
    githubSponsor: "GitHub\u8D5E\u52A9",
    projectLinks: "\u9879\u76EE\u94FE\u63A5"
  },
  en: {
    // 通用
    search: "Search",
    refresh: "Refresh",
    settings: "Settings",
    cancel: "Cancel",
    confirm: "Confirm",
    delete: "Delete",
    edit: "Edit",
    save: "Save",
    // 网格视图
    gridView: "Grid View",
    switchToGridView: "Switch to Grid View",
    canvasGridView: "Canvasgrid Transit",
    noCanvasData: "No Canvas Data",
    loadingCanvas: "Loading Canvas...",
    // 菜单
    refreshData: "Refresh Data",
    syncCanvas: "Sync Canvas",
    newCanvasFile: "New Canvas File",
    sortBy: "Sort By",
    filterConditions: "Filter Conditions",
    returnToCanvas: "Return to Canvas",
    // 排序
    sortByCreated: "Created Time",
    sortByModified: "Modified Time",
    sortByTitle: "Title",
    ascending: "Ascending",
    descending: "Descending",
    // 筛选
    filterByColor: "Filter by Color",
    allColors: "All Colors",
    // 分组
    groupView: "Group View",
    returnToMainView: "Return to Main View",
    groupMembers: "Members",
    // 设置
    gridLayoutSettings: "Grid Layout Settings",
    enableAutoLayout: "Enable Auto Layout",
    interfaceLanguage: "Interface Language",
    colorFilterSettings: "Color Filter Settings",
    aboutPlugin: "About Plugin",
    // Obsidian块链接功能
    blockLinkSettings: "Obsidian Block Link Settings",
    enableBlockLinkMode: "Enable Block Link Mode",
    blockLinkModeDesc: "Automatically create Obsidian block link annotations in source documents when dragging text to Canvas",
    blockLinkName: "Block Link Identifier Name",
    blockLinkNameDesc: "Customize the identifier name for block links, used to mark extracted content in source documents",
    // 关于
    mainFeatures: "Main Features",
    quickStart: "Quick Start",
    thanks: "Thanks for Using",
    feedback: "Feedback",
    contact: "Contact",
    buyCoffee: "Buy Me a Coffee",
    alipaySupport: "Alipay Support",
    githubSponsor: "GitHub Sponsor",
    projectLinks: "Project Links"
  }
};
var I18nManager = class {
  constructor() {
    this.language = "zh";
  }
  setLanguage(lang) {
    this.language = lang;
  }
  t(key) {
    return I18N_TEXTS[this.language][key] || key;
  }
};
var i18n = new I18nManager();
var DOMElementRegistry = class {
  constructor() {
    this.elementMap = /* @__PURE__ */ new Map();
    this.nodeToElementMap = /* @__PURE__ */ new Map();
  }
  // 创建唯一DOM元素
  createUniqueElement(nodeId, elementType = "div") {
    const uniqueId = `card-${nodeId}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    if (this.nodeToElementMap.has(nodeId)) {
      this.removeElement(nodeId);
    }
    const element = document.createElement(elementType);
    element.dataset.nodeId = nodeId;
    element.dataset.uniqueId = uniqueId;
    this.elementMap.set(uniqueId, element);
    this.nodeToElementMap.set(nodeId, uniqueId);
    return element;
  }
  // 获取节点对应的DOM元素
  getElement(nodeId) {
    const uniqueId = this.nodeToElementMap.get(nodeId);
    return uniqueId ? this.elementMap.get(uniqueId) || null : null;
  }
  // 移除DOM元素
  removeElement(nodeId) {
    const uniqueId = this.nodeToElementMap.get(nodeId);
    if (uniqueId) {
      const element = this.elementMap.get(uniqueId);
      if (element && element.parentNode) {
        element.parentNode.removeChild(element);
      }
      this.elementMap.delete(uniqueId);
      this.nodeToElementMap.delete(nodeId);
      return true;
    }
    return false;
  }
  // 清理所有元素
  clearAll() {
    for (const [uniqueId, element] of this.elementMap) {
      if (element && element.parentNode) {
        element.parentNode.removeChild(element);
      }
    }
    this.elementMap.clear();
    this.nodeToElementMap.clear();
  }
  // 获取所有映射关系
  getAllMappings() {
    const mappings = [];
    for (const [nodeId, uniqueId] of this.nodeToElementMap) {
      mappings.push({
        nodeId,
        uniqueId,
        hasElement: this.elementMap.has(uniqueId)
      });
    }
    return mappings;
  }
  // 验证DOM元素一致性
  validateConsistency() {
    const issues = [];
    const fixes = [];
    const nodeIds = /* @__PURE__ */ new Set();
    for (const [nodeId] of this.nodeToElementMap) {
      if (nodeIds.has(nodeId)) {
        issues.push(`\u91CD\u590D\u7684\u8282\u70B9ID: ${nodeId}`);
        fixes.push(`\u79FB\u9664\u91CD\u590D\u7684DOM\u5143\u7D20`);
      }
      nodeIds.add(nodeId);
    }
    for (const [uniqueId, element] of this.elementMap) {
      if (!element.parentNode) {
        issues.push(`\u5B64\u7ACB\u7684DOM\u5143\u7D20: ${uniqueId}`);
        fixes.push(`\u6E05\u7406\u5B64\u7ACB\u5143\u7D20`);
      }
    }
    return { isValid: issues.length === 0, issues, fixes };
  }
};
var DataConsistencyValidator = class {
  constructor(gridContainer, canvasData, domElementRegistry) {
    this.gridContainer = gridContainer;
    this.canvasData = canvasData;
    this.domElementRegistry = domElementRegistry;
  }
  // 全面的一致性检查
  validateFullConsistency() {
    const report = {
      isConsistent: true,
      issues: [],
      fixes: [],
      statistics: {
        totalNodes: this.canvasData?.nodes.length || 0,
        totalDOMElements: 0,
        duplicateElements: 0,
        orphanElements: 0,
        missingElements: 0
      }
    };
    this.checkDuplicateElements(report);
    this.checkOrphanElements(report);
    this.checkMissingElements(report);
    this.checkNodeDataConsistency(report);
    report.isConsistent = report.issues.length === 0;
    return report;
  }
  // 检查重复DOM元素
  checkDuplicateElements(report) {
    const domCards = this.gridContainer.querySelectorAll("[data-node-id]");
    const nodeIds = /* @__PURE__ */ new Set();
    const duplicates = [];
    domCards.forEach((card) => {
      const nodeId = card.getAttribute("data-node-id");
      if (nodeId) {
        if (nodeIds.has(nodeId)) {
          duplicates.push(nodeId);
          report.statistics.duplicateElements++;
        }
        nodeIds.add(nodeId);
      }
    });
    report.statistics.totalDOMElements = domCards.length;
    if (duplicates.length > 0) {
      report.issues.push(`\u53D1\u73B0\u91CD\u590D\u7684DOM\u5143\u7D20: ${duplicates.join(", ")}`);
      report.fixes.push(`\u79FB\u9664\u91CD\u590D\u7684DOM\u5143\u7D20`);
    }
  }
  // 检查孤立DOM元素
  checkOrphanElements(report) {
    const domCards = this.gridContainer.querySelectorAll("[data-node-id]");
    const dataNodeIds = new Set((this.canvasData?.nodes || []).map((n) => n.id));
    domCards.forEach((card) => {
      const nodeId = card.getAttribute("data-node-id");
      if (nodeId && !dataNodeIds.has(nodeId)) {
        report.statistics.orphanElements++;
        report.issues.push(`\u53D1\u73B0\u5B64\u7ACB\u7684DOM\u5143\u7D20: ${nodeId}`);
        report.fixes.push(`\u79FB\u9664\u5B64\u7ACB\u7684DOM\u5143\u7D20`);
      }
    });
  }
  // 检查缺失DOM元素
  checkMissingElements(report) {
    const domNodeIds = /* @__PURE__ */ new Set();
    const domCards = this.gridContainer.querySelectorAll("[data-node-id]");
    domCards.forEach((card) => {
      const nodeId = card.getAttribute("data-node-id");
      if (nodeId)
        domNodeIds.add(nodeId);
    });
    (this.canvasData?.nodes || []).forEach((node) => {
      if (!domNodeIds.has(node.id)) {
        report.statistics.missingElements++;
        report.issues.push(`\u7F3A\u5931DOM\u5143\u7D20: ${node.id}`);
        report.fixes.push(`\u521B\u5EFA\u7F3A\u5931\u7684DOM\u5143\u7D20`);
      }
    });
  }
  // 检查节点数据一致性
  checkNodeDataConsistency(report) {
    const registryValidation = this.domElementRegistry.validateConsistency();
    if (!registryValidation.isValid) {
      report.issues.push(...registryValidation.issues);
      report.fixes.push(...registryValidation.fixes);
    }
  }
  // 自动修复数据不一致问题
  async autoFixInconsistencies(report) {
    const fixResult = {
      success: true,
      fixedIssues: [],
      failedFixes: []
    };
    try {
      await this.fixDuplicateElements(fixResult);
      await this.fixOrphanElements(fixResult);
      await this.fixMissingElements(fixResult);
    } catch (error) {
      fixResult.success = false;
      fixResult.failedFixes.push(`\u81EA\u52A8\u4FEE\u590D\u5931\u8D25: ${error}`);
    }
    return fixResult;
  }
  // 修复重复元素
  async fixDuplicateElements(fixResult) {
    const domCards = this.gridContainer.querySelectorAll("[data-node-id]");
    const seenNodeIds = /* @__PURE__ */ new Set();
    domCards.forEach((card) => {
      const nodeId = card.getAttribute("data-node-id");
      if (nodeId) {
        if (seenNodeIds.has(nodeId)) {
          card.remove();
          fixResult.fixedIssues.push(`\u79FB\u9664\u91CD\u590DDOM\u5143\u7D20: ${nodeId}`);
        } else {
          seenNodeIds.add(nodeId);
        }
      }
    });
  }
  // 修复孤立元素
  async fixOrphanElements(fixResult) {
    const domCards = this.gridContainer.querySelectorAll("[data-node-id]");
    const dataNodeIds = new Set((this.canvasData?.nodes || []).map((n) => n.id));
    domCards.forEach((card) => {
      const nodeId = card.getAttribute("data-node-id");
      if (nodeId && !dataNodeIds.has(nodeId)) {
        card.remove();
        fixResult.fixedIssues.push(`\u79FB\u9664\u5B64\u7ACBDOM\u5143\u7D20: ${nodeId}`);
      }
    });
  }
  // 修复缺失元素
  async fixMissingElements(fixResult) {
    fixResult.failedFixes.push("\u7F3A\u5931\u5143\u7D20\u4FEE\u590D\u9700\u8981\u4E3B\u7C7B\u652F\u6301");
  }
};
var IncrementalRenderer = class {
  constructor() {
    this.lastRenderState = /* @__PURE__ */ new Map();
  }
  // 检测节点变更
  detectChanges(currentNodes) {
    const changes = [];
    const currentNodeMap = new Map(currentNodes.map((node) => [node.id, node]));
    for (const node of currentNodes) {
      const lastState = this.lastRenderState.get(node.id);
      if (!lastState) {
        changes.push({ type: "add", node });
      } else if (this.hasNodeChanged(node, lastState)) {
        changes.push({ type: "update", node, oldState: lastState });
      }
    }
    for (const [nodeId, lastState] of this.lastRenderState) {
      if (!currentNodeMap.has(nodeId)) {
        changes.push({ type: "delete", nodeId, oldState: lastState });
      }
    }
    return changes;
  }
  // 检查节点是否发生变化
  hasNodeChanged(node, lastState) {
    const currentHash = this.generateNodeHash(node);
    return currentHash !== lastState.contentHash;
  }
  // 生成节点内容哈希
  generateNodeHash(node) {
    const content = JSON.stringify({
      type: node.type,
      text: node.text,
      url: node.url,
      file: node.file,
      color: node.color,
      flag: node.flag
    });
    return this.simpleHash(content).toString();
  }
  // 🚨 统一：简单哈希函数 - 用于生成精确缓存键
  simpleHash(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash);
  }
  // 更新渲染状态
  updateRenderState(changes) {
    for (const change of changes) {
      switch (change.type) {
        case "add":
        case "update":
          if (change.node) {
            this.lastRenderState.set(change.node.id, {
              nodeId: change.node.id,
              contentHash: this.generateNodeHash(change.node),
              lastRendered: Date.now()
            });
          }
          break;
        case "delete":
          if (change.nodeId) {
            this.lastRenderState.delete(change.nodeId);
          }
          break;
      }
    }
  }
  // 检查是否有初始状态
  hasInitialState() {
    return this.lastRenderState.size > 0;
  }
  // 清理渲染状态
  clearRenderState() {
    this.lastRenderState.clear();
  }
};
var DOMStateMonitor = class {
  constructor(gridContainer, onStateChange) {
    this.monitorInterval = null;
    this.gridContainer = gridContainer;
    this.onStateChange = onStateChange;
  }
  // 开始监控
  startMonitoring() {
    if (this.monitorInterval)
      return;
    this.monitorInterval = setInterval(() => {
      const report = this.generateStateReport();
      if (!report.isHealthy && this.onStateChange) {
        this.onStateChange(report);
      }
    }, 5e3);
  }
  // 停止监控
  stopMonitoring() {
    if (this.monitorInterval) {
      clearInterval(this.monitorInterval);
      this.monitorInterval = null;
    }
  }
  // 生成状态报告
  generateStateReport() {
    const domCards = this.gridContainer.querySelectorAll("[data-node-id]");
    const nodeIds = /* @__PURE__ */ new Set();
    const duplicates = [];
    domCards.forEach((card) => {
      const nodeId = card.getAttribute("data-node-id");
      if (nodeId) {
        if (nodeIds.has(nodeId)) {
          duplicates.push(nodeId);
        }
        nodeIds.add(nodeId);
      }
    });
    return {
      isHealthy: duplicates.length === 0,
      totalElements: domCards.length,
      uniqueNodes: nodeIds.size,
      duplicates,
      timestamp: Date.now()
    };
  }
  // 手动检查状态
  checkState() {
    return this.generateStateReport();
  }
};
function hasProperty(obj, prop) {
  return prop in obj;
}
var LinkedTabManager = class {
  constructor(app) {
    this.linkedCanvasFile = null;
    this.gridView = null;
    this.fileWatcherRefs = [];
    this.app = app;
  }
  // 建立关联
  linkCanvasFile(canvasFile, gridView) {
    this.unlinkCanvas();
    this.linkedCanvasFile = canvasFile;
    this.gridView = gridView;
    this.registerFileWatcher();
    this.updateGridViewHeader();
    DebugManager.log(`Linked canvas file: ${canvasFile.path}`);
  }
  // 移除官方API关联方法 - 改为简单关联
  // 查找Canvas文件对应的leaf
  findCanvasLeaf(canvasFile) {
    const canvasLeaves = this.app.workspace.getLeavesOfType("canvas");
    return canvasLeaves.find((leaf) => {
      const view = leaf.view;
      return view.file?.path === canvasFile.path;
    }) || null;
  }
  // 查找网格视图对应的leaf
  findGridViewLeaf(gridView) {
    const gridLeaves = this.app.workspace.getLeavesOfType(CANVAS_GRID_VIEW_TYPE);
    return gridLeaves.find((leaf) => leaf.view === gridView) || null;
  }
  // 解除关联
  unlinkCanvas() {
    this.linkedCanvasFile = null;
    this.gridView = null;
    this.unregisterFileWatcher();
    DebugManager.log("Canvas link removed");
  }
  // 获取关联的Canvas文件
  getLinkedCanvasFile() {
    return this.linkedCanvasFile;
  }
  // 检查关联是否有效
  isLinked() {
    return this.linkedCanvasFile !== null && this.app.vault.getAbstractFileByPath(this.linkedCanvasFile.path) !== null;
  }
  // 注册文件监听器
  registerFileWatcher() {
    if (!this.linkedCanvasFile)
      return;
    DebugManager.log("Registering file watchers for:", this.linkedCanvasFile.path);
    const modifyRef = this.app.vault.on("modify", (file) => {
      if (file.path === this.linkedCanvasFile?.path && this.gridView && file instanceof import_obsidian12.TFile) {
        this.gridView.onLinkedFileModified(file);
      }
    });
    const deleteRef = this.app.vault.on("delete", (file) => {
      if (file.path === this.linkedCanvasFile?.path && this.gridView) {
        this.gridView.onLinkedFileDeleted();
        this.unlinkCanvas();
      }
    });
    const renameRef = this.app.vault.on("rename", (file, oldPath) => {
      if (oldPath === this.linkedCanvasFile?.path && this.gridView) {
        this.linkedCanvasFile = file;
        this.gridView.onLinkedFileRenamed(file);
      }
    });
    this.fileWatcherRefs = [modifyRef, deleteRef, renameRef];
  }
  // 注销文件监听器
  unregisterFileWatcher() {
    this.fileWatcherRefs.forEach((ref) => {
      this.app.vault.offref(ref);
    });
    this.fileWatcherRefs = [];
    DebugManager.log("File watchers unregistered");
  }
  // 更新网格视图头部
  updateGridViewHeader() {
    if (this.gridView && this.linkedCanvasFile) {
      this.gridView.updateLinkedCanvasDisplay(this.linkedCanvasFile);
    }
  }
};
var GroupRenameModal = class extends import_obsidian12.Modal {
  constructor(app, currentName, onRename) {
    super(app);
    this.inputEl = null;
    this.currentName = currentName;
    this.onRename = onRename;
  }
  onOpen() {
    this.titleEl.setText("\u91CD\u547D\u540D\u5206\u7EC4");
    this.createContent();
  }
  createContent() {
    const content = this.contentEl;
    content.empty();
    const inputContainer = content.createDiv("group-rename-input-container");
    const label = inputContainer.createEl("label", {
      text: "\u5206\u7EC4\u540D\u79F0:",
      cls: "group-rename-label"
    });
    this.inputEl = inputContainer.createEl("input", {
      type: "text",
      value: this.currentName,
      cls: "group-rename-input"
    });
    this.inputEl.focus();
    this.inputEl.select();
    const buttonContainer = content.createDiv("group-rename-buttons");
    const confirmBtn = buttonContainer.createEl("button", {
      text: "\u786E\u8BA4",
      cls: "mod-cta"
    });
    confirmBtn.onclick = () => this.handleConfirm();
    const cancelBtn = buttonContainer.createEl("button", {
      text: "\u53D6\u6D88"
    });
    cancelBtn.onclick = () => this.close();
    this.inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        this.handleConfirm();
      } else if (e.key === "Escape") {
        this.close();
      }
    });
  }
  handleConfirm() {
    if (!this.inputEl)
      return;
    const newName = this.inputEl.value.trim();
    if (!newName) {
      new import_obsidian12.Notice("\u5206\u7EC4\u540D\u79F0\u4E0D\u80FD\u4E3A\u7A7A");
      return;
    }
    if (newName === this.currentName) {
      this.close();
      return;
    }
    this.onRename(newName);
    this.close();
  }
};
var CanvasSelectionModal = class extends import_obsidian12.Modal {
  constructor(app, gridView, onSelect) {
    super(app);
    this.allCanvasFiles = [];
    this.filteredFiles = [];
    this.gridView = gridView;
    this.onSelect = onSelect;
  }
  onOpen() {
    this.titleEl.setText(this.gridView.settings.language === "zh" ? "\u9009\u62E9\u8981\u5173\u8054\u7684Canvas\u6587\u4EF6" : "Select Canvas File to Associate");
    this.createContent();
  }
  createContent() {
    this.allCanvasFiles = this.app.vault.getFiles().filter((file) => file.extension === "canvas");
    this.filteredFiles = [...this.allCanvasFiles];
    this.createSearchBox();
    if (this.allCanvasFiles.length === 0) {
      this.createEmptyState();
    } else {
      this.createFileListContainer();
      this.updateFileList();
    }
    this.createActions();
  }
  // 创建搜索框
  createSearchBox() {
    const searchContainer = this.contentEl.createDiv("canvas-search-container");
    this.searchInput = searchContainer.createEl("input", {
      type: "text",
      placeholder: this.gridView.settings.language === "zh" ? "\u{1F50D} \u641C\u7D22Canvas\u6587\u4EF6..." : "\u{1F50D} Search Canvas files...",
      cls: "canvas-search-input"
    });
    const clearButton = searchContainer.createEl("button", {
      cls: "canvas-search-clear",
      text: "\xD7"
    });
    this.searchInput.addEventListener("input", this.handleSearch.bind(this));
    clearButton.addEventListener("click", () => {
      this.searchInput.value = "";
      this.handleSearch();
      this.searchInput.focus();
    });
    this.searchInput.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        this.searchInput.value = "";
        this.handleSearch();
      }
    });
  }
  // 处理搜索
  handleSearch() {
    const searchTerm = this.searchInput.value.toLowerCase().trim();
    if (searchTerm === "") {
      this.filteredFiles = [...this.allCanvasFiles];
    } else {
      this.filteredFiles = this.allCanvasFiles.filter((file) => {
        const fileName = file.basename.toLowerCase();
        const filePath = file.path.toLowerCase();
        return fileName.includes(searchTerm) || filePath.includes(searchTerm);
      });
    }
    this.updateFileList();
  }
  // 创建文件列表容器
  createFileListContainer() {
    this.fileListContainer = this.contentEl.createDiv("canvas-file-list");
  }
  // 更新文件列表
  updateFileList() {
    if (!this.fileListContainer)
      return;
    this.fileListContainer.empty();
    if (this.filteredFiles.length === 0) {
      this.showNoResultsMessage();
      return;
    }
    this.filteredFiles.forEach((file) => {
      const itemEl = this.fileListContainer.createDiv("canvas-file-item");
      itemEl.innerHTML = `
				<div class="file-icon">\u{1F3A8}</div>
				<div class="file-info">
					<div class="file-name">${this.highlightSearchTerm(file.basename)}</div>
					<div class="file-path">${this.highlightSearchTerm(file.path)}</div>
				</div>
				<div class="file-action">
					<button class="select-btn">\u9009\u62E9</button>
				</div>
			`;
      const selectBtn = itemEl.querySelector(".select-btn");
      selectBtn.onclick = () => {
        this.onSelect(file);
        this.close();
      };
    });
  }
  // 高亮搜索词
  highlightSearchTerm(text) {
    const searchTerm = this.searchInput?.value.toLowerCase().trim();
    if (!searchTerm)
      return text;
    const regex = new RegExp(`(${searchTerm.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")})`, "gi");
    return text.replace(regex, "<mark>$1</mark>");
  }
  // 显示无结果消息
  showNoResultsMessage() {
    const noResultsEl = this.fileListContainer.createDiv("canvas-search-no-results");
    noResultsEl.innerHTML = `
			<div class="no-results-icon">\u{1F50D}</div>
			<div class="no-results-title">\u672A\u627E\u5230\u5339\u914D\u7684Canvas\u6587\u4EF6</div>
			<div class="no-results-desc">\u5C1D\u8BD5\u4F7F\u7528\u4E0D\u540C\u7684\u5173\u952E\u8BCD\u641C\u7D22</div>
		`;
  }
  createEmptyState() {
    const emptyEl = this.contentEl.createDiv("canvas-selection-empty");
    emptyEl.innerHTML = `
			<div class="empty-icon">\u{1F4C4}</div>
			<div class="empty-title">\u6CA1\u6709\u627E\u5230Canvas\u6587\u4EF6</div>
			<div class="empty-desc">\u8BF7\u5148\u521B\u5EFA\u4E00\u4E2ACanvas\u6587\u4EF6\uFF0C\u7136\u540E\u518D\u8FDB\u884C\u5173\u8054</div>
		`;
  }
  createActions() {
    const actionsEl = this.contentEl.createDiv("canvas-selection-actions");
    const createBtn = actionsEl.createEl("button", {
      cls: "mod-cta",
      text: "\u521B\u5EFA\u65B0Canvas\u6587\u4EF6"
    });
    createBtn.onclick = () => this.createNewCanvas();
    const cancelBtn = actionsEl.createEl("button", {
      text: "\u53D6\u6D88"
    });
    cancelBtn.onclick = () => this.close();
  }
  async createNewCanvas() {
    const fileName = `\u65B0\u5EFACanvas-${Date.now()}.canvas`;
    const initialData = { nodes: [], edges: [] };
    try {
      const newFile = await this.app.vault.create(
        fileName,
        JSON.stringify(initialData, null, 2)
      );
      this.onSelect(newFile);
      this.close();
      new import_obsidian12.Notice(`\u5DF2\u521B\u5EFA\u65B0Canvas\u6587\u4EF6: ${newFile.basename}`);
    } catch (error) {
      new import_obsidian12.Notice("\u521B\u5EFACanvas\u6587\u4EF6\u5931\u8D25");
      DebugManager.error("Failed to create canvas file:", error);
    }
  }
};
var CanvasGridView = class extends import_obsidian12.ItemView {
  // 当前查看的分组ID
  constructor(leaf, plugin) {
    super(leaf);
    this.canvasData = null;
    // 缓存管理器 - 使用简单Map实现
    this.cacheManager = /* @__PURE__ */ new Map();
    // 拖拽相关属性
    this.isDragging = false;
    this.dragData = null;
    this.dropIndicator = null;
    // 长按拖拽相关属性
    this.longPressTimer = null;
    this.longPressStartTime = 0;
    this.longPressThreshold = 500;
    // 500ms长按阈值
    this.isDragFromGrid = false;
    this.dragStartPosition = { x: 0, y: 0 };
    this.currentDragCard = null;
    // 拖拽预览相关属性
    this.dragPreviewElement = null;
    // 视图相关属性
    this.currentView = "grid";
    this.linkedCanvasFile = null;
    this.linkedIndicatorEl = null;
    this.updateTimeout = null;
    // 搜索和排序相关属性
    this.searchQuery = "";
    this.sortBy = "created";
    this.sortOrder = "desc";
    this.filteredNodes = [];
    this.searchInputEl = null;
    this.statusElements = null;
    // 颜色筛选相关属性
    this.activeColorFilter = null;
    // 当前激活的颜色筛选器
    this.colorFilterContainer = null;
    // 时间胶囊相关属性
    this.timeCapsuleState = {
      isActive: false,
      startTime: 0,
      duration: 15 * 60 * 1e3,
      // 默认15分钟
      remainingTime: 0,
      groupId: null,
      collectedItems: [],
      groupName: ""
    };
    this.timeCapsuleButton = null;
    this.timeCapsuleTimer = null;
    this.timeCapsuleUpdateInterval = null;
    // 宽度控制相关属性
    this.resizeObserver = null;
    this.minWidth = 300;
    // 最小宽度（一张卡片的宽度）
    this.isWidthLimited = false;
    // 链接预览缓存 - 使用简单的Map实现
    this.linkPreviewCache = /* @__PURE__ */ new Map();
    this.previewLoadingUrls = /* @__PURE__ */ new Set();
    this.CACHE_TTL = 30 * 60 * 1e3;
    // 缓存30分钟过期
    // Canvas兼容模式：使用保存操作标志替代文件监听器禁用机制
    this.isSaveOperationInProgress = false;
    this.lastSaveTimestamp = 0;
    // 事件监听器清理追踪
    this.globalEventListeners = [];
    // 定时器清理追踪
    this.activeTimeouts = /* @__PURE__ */ new Set();
    this.activeIntervals = /* @__PURE__ */ new Set();
    this.cacheCleanupInterval = null;
    // 🎯 修复：DOM元素注册表，确保元素唯一性
    this.domElementRegistry = new DOMElementRegistry();
    // 🎯 修复：数据缓存替代DOM缓存
    this.dataCache = /* @__PURE__ */ new Map();
    // 🎯 修复：数据一致性验证器
    this.dataConsistencyValidator = null;
    // 数据验证器实例
    this.dataValidator = new DataValidator();
    // 🎯 修复：增量渲染器
    this.incrementalRenderer = null;
    // 🎯 修复：DOM状态监控器
    this.domStateMonitor = null;
    // 🚨 新增：DOM一致性检查标志
    this.isDOMValidationInProgress = false;
    // 编辑状态管理
    this.currentEditingCard = null;
    this.currentEditingNode = null;
    // 卡片选中状态管理（官方Canvas逻辑）
    this.selectedCard = null;
    this.selectedNode = null;
    // 右键菜单操作标志
    this.isContextMenuActionExecuting = false;
    // 分组功能相关
    this.groupAnalysis = /* @__PURE__ */ new Map();
    this.currentGroupView = null;
    // 事件处理器引用，用于清理
    this.refreshTimer = null;
    // 统一处理网格中的所有点击事件
    this.handleGridClick = (e) => {
      const target = e.target;
      DebugManager.log("\u{1F5B1}\uFE0F \u7F51\u683C\u70B9\u51FB\u4E8B\u4EF6:", {
        className: target.className,
        tagName: target.tagName,
        eventType: e.type
      });
      const groupBadge = target.closest(".canvas-grid-group-badge");
      if (groupBadge) {
        DebugManager.log("\u{1F3F7}\uFE0F \u68C0\u6D4B\u5230\u5206\u7EC4\u6807\u8BC6\u70B9\u51FB");
        e.stopPropagation();
        const card2 = groupBadge.closest(".canvas-grid-card");
        if (card2 && card2.dataset.groupId) {
          this.enterGroupView(card2.dataset.groupId);
        }
        return;
      }
      const toolbarBtn = target.closest(".canvas-card-toolbar-btn");
      if (toolbarBtn) {
        DebugManager.log("\u{1F527} \u68C0\u6D4B\u5230\u5DE5\u5177\u680F\u6309\u94AE\u70B9\u51FB");
        e.stopPropagation();
        this.handleToolbarButtonClick(toolbarBtn);
        return;
      }
      const card = target.closest(".canvas-grid-card");
      if (card && card.dataset.nodeId) {
        DebugManager.log("\u{1F3AF} \u68C0\u6D4B\u5230\u5361\u7247\u70B9\u51FB:", {
          nodeId: card.dataset.nodeId,
          nodeType: card.dataset.nodeType,
          hasCanvasData: !!this.canvasData,
          nodesCount: this.canvasData?.nodes.length || 0
        });
        if (card.dataset.nodeType === "group") {
          DebugManager.log("\u{1F50D} \u5206\u7EC4\u5361\u7247\u76F4\u63A5\u5904\u7406\uFF0C\u8FDB\u5165\u5206\u7EC4\u89C6\u56FE:", card.dataset.nodeId);
          this.enterGroupView(card.dataset.nodeId);
          return;
        }
        const node = this.canvasData?.nodes.find((n) => n.id === card.dataset.nodeId);
        if (node) {
          DebugManager.log("\u2705 \u627E\u5230\u8282\u70B9\u6570\u636E\uFF0C\u8C03\u7528onCardClick");
          this.onCardClick(node, card);
        } else {
          DebugManager.log("\u274C \u672A\u627E\u5230\u8282\u70B9\u6570\u636E:", card.dataset.nodeId);
        }
      } else {
        DebugManager.log("\u{1F532} \u70B9\u51FB\u7A7A\u767D\u533A\u57DF\uFF0C\u6E05\u9664\u9009\u4E2D\u72B6\u6001");
        this.clearSelection();
      }
    };
    // 处理工具栏按钮点击
    this.handleToolbarButtonClick = (button) => {
      DebugManager.log("\u5DE5\u5177\u680F\u6309\u94AE\u88AB\u70B9\u51FB:", button.className);
      const card = button.closest(".canvas-grid-card");
      if (!card || !card.dataset.nodeId) {
        DebugManager.log("\u672A\u627E\u5230\u5361\u7247\u6216\u8282\u70B9ID");
        return;
      }
      const node = this.canvasData?.nodes.find((n) => n.id === card.dataset.nodeId);
      if (!node) {
        DebugManager.log("\u672A\u627E\u5230\u5BF9\u5E94\u7684\u8282\u70B9\u6570\u636E");
        return;
      }
      DebugManager.log("\u6267\u884C\u5DE5\u5177\u680F\u64CD\u4F5C\uFF0C\u8282\u70B9:", node.id);
      if (button.classList.contains("canvas-card-toolbar-delete")) {
        DebugManager.log("\u6267\u884C\u5220\u9664\u64CD\u4F5C");
        this.deleteCardFromToolbar(card);
      } else if (button.classList.contains("canvas-card-toolbar-color")) {
        DebugManager.log("\u6267\u884C\u989C\u8272\u8BBE\u7F6E\u64CD\u4F5C");
        this.showColorPicker(card, node);
      } else if (button.classList.contains("canvas-card-toolbar-pinned")) {
        DebugManager.log("\u6267\u884C\u7F6E\u9876\u64CD\u4F5C");
        this.togglePinnedStatus(card, node);
      } else {
        DebugManager.log("\u672A\u8BC6\u522B\u7684\u6309\u94AE\u7C7B\u578B:", button.className);
      }
    };
    // 保留原有的卡片点击处理方法（用于向后兼容）
    this.handleCardClick = (e) => {
      const card = e.target.closest(".canvas-grid-card");
      if (card && card.dataset.nodeId) {
        const node = this.canvasData?.nodes.find((n) => n.id === card.dataset.nodeId);
        if (node) {
          this.onCardClick(node, card);
        }
      }
    };
    this.handleKeyDown = (e) => {
      const target = e.target;
      if (target.classList.contains("canvas-card-toolbar-btn") && (e.key === "Enter" || e.key === " ")) {
        e.preventDefault();
        e.stopPropagation();
        this.handleToolbarButtonClick(target);
        return;
      }
      const card = target;
      if (card.classList.contains("canvas-grid-card") && (e.key === "Enter" || e.key === " ")) {
        e.preventDefault();
        if (e.key === "Enter") {
          const node = this.canvasData?.nodes.find((n) => n.id === card.dataset.nodeId);
          if (node) {
            const editCheck = this.canEnterEditMode(node, card);
            if (editCheck.canEdit) {
              this.startEditingFromSelection(node, card);
            } else {
              DebugManager.log(`\u{1F6AB} \u952E\u76D8\u963B\u6B62\u7F16\u8F91: ${editCheck.reason}`);
            }
          }
        } else {
          card.click();
        }
      }
    };
    // 处理右键菜单
    this.handleCardContextMenu = (e) => {
      const target = e.target;
      const card = target.closest(".canvas-grid-card");
      if (card) {
        e.preventDefault();
        this.showContextMenu(card, e.clientX, e.clientY);
      }
    };
    // 处理文档点击，关闭右键菜单和退出编辑状态（增强Obsidian原生菜单支持）
    this.handleDocumentClick = (e) => {
      const target = e.target;
      const clickedInContextMenu = target.closest(".canvas-grid-context-menu");
      const clickedInObsidianMenu = this.isClickInObsidianNativeMenu(target);
      const clickedInToolbar = target.closest(".canvas-grid-toolbar");
      const clickedInMainDropdown = target.closest(".canvas-grid-main-dropdown");
      const clickedInMultiMenuContainer = target.closest(".canvas-grid-multi-menu-container");
      const clickedInDynamicContent = target.closest(".canvas-grid-toolbar-dynamic-content");
      const clickedInFunctionButton = target.closest(".function-btn");
      const clickedInMultiMenuButton = target.closest(".multi-menu-btn");
      DebugManager.log("\u{1F5B1}\uFE0F Document click detected (Enhanced):", {
        target: target.className,
        tagName: target.tagName,
        clickedInContextMenu: !!clickedInContextMenu,
        clickedInObsidianMenu: !!clickedInObsidianMenu,
        clickedInToolbar: !!clickedInToolbar,
        clickedInMainDropdown: !!clickedInMainDropdown,
        clickedInMultiMenuContainer: !!clickedInMultiMenuContainer,
        clickedInDynamicContent: !!clickedInDynamicContent,
        clickedInFunctionButton: !!clickedInFunctionButton,
        clickedInMultiMenuButton: !!clickedInMultiMenuButton,
        hasCurrentEditingCard: !!this.currentEditingCard,
        currentEditingNodeId: this.currentEditingNode?.id
      });
      this.handleToolbarOutsideClick(target, {
        clickedInMainDropdown: !!clickedInMainDropdown,
        clickedInMultiMenuContainer: !!clickedInMultiMenuContainer,
        clickedInDynamicContent: !!clickedInDynamicContent,
        clickedInFunctionButton: !!clickedInFunctionButton,
        clickedInMultiMenuButton: !!clickedInMultiMenuButton,
        clickedInObsidianMenu: !!clickedInObsidianMenu
      });
      if (!clickedInContextMenu && !clickedInObsidianMenu) {
        this.hideContextMenu();
      }
      if (this.currentEditingCard && this.currentEditingNode && !clickedInContextMenu && !clickedInObsidianMenu && // 新增：Obsidian原生菜单保护
      !this.isContextMenuActionExecuting && !this.isSaveOperationInProgress) {
        const clickedInCurrentCard = target.closest(".canvas-grid-card") === this.currentEditingCard;
        const clickedInEditor = target.closest(".card-editor-container");
        const clickedInGrid = target.closest(".canvas-grid-container");
        DebugManager.log("\u{1F50D} Enhanced editing state check:", {
          clickedInCurrentCard: !!clickedInCurrentCard,
          clickedInEditor: !!clickedInEditor,
          clickedInGrid: !!clickedInGrid,
          clickedInContextMenu: !!clickedInContextMenu,
          clickedInObsidianMenu: !!clickedInObsidianMenu,
          // 新增：显示Obsidian菜单检测结果
          isContextMenuActionExecuting: this.isContextMenuActionExecuting,
          isSaveOperationInProgress: this.isSaveOperationInProgress
        });
        if (!clickedInGrid || !clickedInCurrentCard && !clickedInEditor && clickedInGrid) {
          DebugManager.log("\u26A0\uFE0F \u89E6\u53D1\u7F16\u8F91\u72B6\u6001\u9000\u51FA: \u70B9\u51FB\u7F51\u683C\u5916\u6216\u5176\u4ED6\u533A\u57DF\uFF0C\u9000\u51FA\u7F16\u8F91\u72B6\u6001\u5E76\u4FDD\u5B58");
          this.exitCurrentEditingState(true);
        } else {
          DebugManager.log("\u2705 \u7F16\u8F91\u72B6\u6001\u4FDD\u6301: \u70B9\u51FB\u5728\u5141\u8BB8\u7684\u533A\u57DF\u5185\uFF08\u5305\u62ECObsidian\u539F\u751F\u83DC\u5355\u4FDD\u62A4\uFF09");
        }
      }
    };
    // 🔧 新增：保存操作锁机制
    this.saveLock = false;
    this.saveQueue = [];
    // 全局鼠标事件监听器引用
    this.globalMouseMoveHandler = null;
    this.globalMouseUpHandler = null;
    // 窗口失焦处理器
    this.handleWindowBlur = () => {
      setTimeout(() => {
        if (this.isDragFromGrid && !document.hasFocus()) {
          DebugManager.log("Window lost focus, canceling drag...");
          this.cancelDrag();
        }
      }, 100);
    };
    // ESC键取消拖拽处理器
    this.handleDragEscape = (e) => {
      if (e.key === "Escape" && this.isDragFromGrid) {
        DebugManager.log("ESC pressed, canceling drag...");
        this.cancelDrag();
      }
    };
    // 清理拖拽预览的函数（会被动态赋值，保持向后兼容）
    this.cleanupDragPreview = () => {
      this.forceCleanupDragPreview();
    };
    // 拖拽提示元素
    this.dragHintElement = null;
    this.plugin = plugin;
    this.settings = plugin.settings;
    i18n.setLanguage(plugin.settings.language);
    this.linkedTabManager = new LinkedTabManager(this.app);
    this.initializeUIComponentManager();
    this.initializeSearchAndFilterManager();
    this.initializeDragDropManager();
    this.initializeCanvasAPIManager();
    this.initializeFileSystemManager();
    this.initializeThemeManager();
    this.initializeTimeCapsuleManager();
    this.initializeNavigationManager();
    this.initializeStateManagers();
    this.initializeValidationManager();
    this.initializeCacheManager();
    this.initializePerformanceManager();
    this.initializeObsidianRenderManager();
    this.setupCanvasDataSync();
  }
  // 初始化UI组件管理器
  initializeUIComponentManager() {
    const uiConfig = {
      theme: "auto",
      language: "zh",
      showTooltips: true,
      animationEnabled: true,
      compactMode: false
    };
    this.uiComponentManager = new UIComponentManager(this.app, uiConfig);
    DebugManager.log("\u2705 UIComponentManager initialized");
  }
  // 初始化搜索和过滤管理器
  initializeSearchAndFilterManager() {
    const searchConfig = {
      caseSensitive: false,
      wholeWord: false,
      useRegex: false,
      searchInContent: true,
      searchInTags: false,
      searchInFilenames: true,
      debounceDelay: 300
    };
    const filterConfig = {
      enableColorFilter: true,
      enableTypeFilter: true,
      enableDateFilter: false,
      enableSizeFilter: false
    };
    const sortConfig = {
      sortBy: "name",
      sortOrder: "asc",
      groupBy: "none"
    };
    this.searchAndFilterManager = new SearchAndFilterManager(
      this.app,
      searchConfig,
      filterConfig,
      sortConfig
    );
    DebugManager.log("\u2705 SearchAndFilterManager initialized");
  }
  // 初始化拖拽管理器
  initializeDragDropManager() {
    const dragDropConfig = {
      enableDragToCreate: true,
      enableDragToReorder: true,
      enableDropFromExternal: true,
      enableDropToCanvas: true,
      dragThreshold: 5,
      dropZoneHighlight: true,
      autoScroll: true,
      dragPreview: true
    };
    this.dragDropManager = new DragDropManager(this.app, dragDropConfig);
    if (this.gridContainer) {
      this.dragDropManager.registerDropZone(this.gridContainer, "grid");
    }
    DebugManager.log("\u2705 DragDropManager initialized with grid support");
  }
  // 初始化Canvas API管理器
  initializeCanvasAPIManager() {
    const canvasAPIConfig = {
      enableAutoSave: true,
      autoSaveInterval: 3e4,
      // 30秒
      enableVersionControl: true,
      maxBackupVersions: 10,
      enableConflictResolution: true,
      syncMode: "auto"
    };
    this.canvasAPIManager = new CanvasAPIManager(this.app, canvasAPIConfig);
    DebugManager.log("\u2705 CanvasAPIManager initialized");
  }
  // 初始化文件系统管理器
  initializeFileSystemManager() {
    const fileSystemConfig = {
      enableFileWatcher: true,
      enableAutoBackup: false,
      backupInterval: 3e5,
      // 5分钟
      maxBackupFiles: 5,
      enableFileValidation: true,
      allowedFileTypes: [".md", ".canvas", ".json", ".txt"],
      enableTrash: true,
      enableFileHistory: true
    };
    this.fileSystemManager = new FileSystemManager(this.app, fileSystemConfig);
    DebugManager.log("\u2705 FileSystemManager initialized");
  }
  // 初始化主题管理器
  initializeThemeManager() {
    const themeConfig = {
      mode: "auto",
      enableTransitions: true,
      transitionDuration: 200,
      enableColorScheme: true,
      colorScheme: DEFAULT_COLOR_SCHEMES.obsidian,
      enableCustomCSS: false,
      customCSS: ""
    };
    this.themeManager = new ThemeManager(this.app, themeConfig);
    DebugManager.log("\u2705 ThemeManager initialized");
  }
  // 初始化时间胶囊管理器
  initializeTimeCapsuleManager() {
    const timeCapsuleConfig = {
      enabled: true,
      defaultDuration: 60,
      // 60分钟
      autoCollectClipboard: false,
      showNotifications: true,
      maxCapsules: 100,
      enableAutoCleanup: true,
      cleanupInterval: 36e5,
      // 1小时
      enableEncryption: false,
      storageLocation: "time-capsules.json"
    };
    this.timeCapsuleManager = new TimeCapsuleManager(this.app, timeCapsuleConfig);
    DebugManager.log("\u2705 TimeCapsuleManager initialized");
  }
  // 初始化导航管理器
  initializeNavigationManager() {
    const navigationConfig = {
      enableBreadcrumbs: true,
      enableBackForward: true,
      enableQuickJump: true,
      maxHistorySize: PERFORMANCE_CONSTANTS.MAX_HISTORY_SIZE,
      enableKeyboardShortcuts: true,
      shortcuts: {
        back: "Alt+Left",
        forward: "Alt+Right",
        home: "Alt+Home",
        search: "Ctrl+K",
        jumpToFile: "Ctrl+O",
        jumpToLine: "Ctrl+G"
      },
      enableContextMenu: true,
      enableMinimap: false
    };
    this.navigationManager = new NavigationManager(this.app, navigationConfig);
    DebugManager.log("\u2705 NavigationManager initialized");
  }
  // 初始化状态管理器
  initializeStateManagers() {
    this.editorStateManager = new EditorStateManager();
    this.memoryBufferManager = new MemoryBufferManager({
      autoSaveDelay: 0,
      // 立即保存，无延迟
      enableAutoSave: false,
      // 禁用自动保存，采用官方Canvas兼容策略
      saveOnBlur: false,
      // 禁用失焦保存，避免冲突
      saveOnViewSwitch: false
      // 禁用视图切换保存
    });
    this.conflictResolver = new ConflictResolver(this.app);
    this.saveTriggerManager = new SaveTriggerManager(this.app, {
      onBlur: false,
      // 禁用失焦保存，避免与官方Canvas冲突
      onManualSave: true,
      // 保留手动保存（Ctrl+S）
      onAppClose: true,
      // 保留应用关闭保存
      onViewSwitch: false,
      // 禁用视图切换保存
      onFileClose: false,
      // 禁用文件关闭保存
      onAutoSave: false
      // 禁用自动保存
    });
    this.tempFileManager = TempFileManager.getInstance(this.app);
    this.hiddenEditorManager = new HiddenEditorManager(this.app);
    this.editorStateCoordinator = new EditorStateCoordinator(this.app, this.editorStateManager);
    this.diagnosticsManager = new DiagnosticsManager(
      this.app,
      this.tempFileManager,
      this.editorStateCoordinator
    );
    this.setupStateManagerCallbacks();
    this.startPeriodicHealthCheck();
    DebugManager.log("\u2705 State managers initialized");
  }
  // 设置状态管理器回调函数
  setupStateManagerCallbacks() {
    this.saveTriggerManager.setCallbacks({
      hasUnsavedChanges: () => this.memoryBufferManager.hasUnsavedChanges(),
      getMemoryVersion: () => this.memoryBufferManager.getMemoryVersion(),
      getFileVersion: () => this.memoryBufferManager.getFileVersion(),
      hasActiveEditors: () => this.editorStateManager.hasActiveEditors()
    });
    this.saveTriggerManager.addSaveCallback(async (trigger) => {
      await this.performSaveWithNewSystem(trigger);
    });
    this.memoryBufferManager.addSaveCallback(async (trigger) => {
      await this.performSaveWithNewSystem(trigger);
    });
    this.editorStateManager.addStateChangeListener((nodeId, state) => {
      this.onEditorStateChanged(nodeId, state);
      this.showEditingIndicator(nodeId, state.editingMode !== "none");
    });
    this.memoryBufferManager.addChangeListener((hasChanges) => {
      this.showUnsavedChangesIndicator(hasChanges);
    });
    this.registerKeyboardShortcuts();
    this.startPerformanceMonitoring();
    setTimeout(() => {
      this.runBasicSystemValidation();
    }, 2e3);
    DebugManager.log("State manager callbacks configured");
  }
  // 初始化验证管理器
  initializeValidationManager() {
    const validationConfig = {
      enableRealTimeValidation: true,
      enableStrictMode: false,
      maxErrorsPerField: 5,
      validationTimeout: 5e3,
      enableCustomRules: true,
      customRules: [],
      enableAsyncValidation: true,
      debounceDelay: 300
    };
    this.validationManager = new ValidationManager(this.app, validationConfig);
    DebugManager.log("\u2705 ValidationManager initialized");
  }
  // 初始化缓存管理器 - 简化实现
  initializeCacheManager() {
    DebugManager.log("\u2705 Simple cache manager initialized");
  }
  // 初始化性能管理器
  initializePerformanceManager() {
    const performanceConfig = {
      enableMonitoring: true,
      enableProfiling: true,
      sampleRate: 0.1,
      // 10%采样率
      maxMetricsHistory: 1e3,
      enableMemoryTracking: true,
      enableRenderTracking: true,
      enableNetworkTracking: true,
      alertThresholds: {
        responseTime: 1e3,
        // 1秒
        memoryUsage: 350,
        // 🎯 修复：提高内存阈值到350MB，避免进程级误报
        renderTime: 100,
        // 100ms
        fpsThreshold: 30,
        // 30FPS
        bundleSize: 1024
        // 1MB
      },
      enableOptimizations: true,
      optimizationStrategies: []
    };
    this.performanceManager = new PerformanceManager(this.app, performanceConfig);
    DebugManager.log("\u2705 PerformanceManager initialized");
  }
  // 初始化Obsidian渲染管理器
  initializeObsidianRenderManager() {
    this.obsidianRenderManager = new ObsidianRenderManager(this.app, {
      enableCache: true,
      cacheTimeout: 5 * 60 * 1e3,
      // 5分钟缓存
      maxCacheSize: 100,
      enableLazyLoading: true,
      performanceMonitoring: true
    });
    DebugManager.log("\u2705 ObsidianRenderManager initialized");
  }
  // 🎯 新增：初始化数据一致性组件
  initializeDataConsistencyComponents() {
    this.incrementalRenderer = new IncrementalRenderer();
    DebugManager.log("\u2705 \u6570\u636E\u4E00\u81F4\u6027\u7EC4\u4EF6\u521D\u59CB\u5316\u5B8C\u6210");
  }
  // 🎯 新增：完成数据一致性组件初始化（在gridContainer创建后）
  completeDataConsistencyInitialization() {
    if (!this.gridContainer)
      return;
    this.dataConsistencyValidator = new DataConsistencyValidator(
      this.gridContainer,
      this.canvasData,
      this.domElementRegistry
    );
    this.domStateMonitor = new DOMStateMonitor(
      this.gridContainer,
      (report) => {
        DebugManager.warn("DOM\u72B6\u6001\u5F02\u5E38:", report);
        this.handleDOMStateIssue(report);
      }
    );
    this.domStateMonitor.startMonitoring();
    this.startPeriodicDOMValidation();
    DebugManager.log("\u2705 \u6570\u636E\u4E00\u81F4\u6027\u7EC4\u4EF6\u5B8C\u6574\u521D\u59CB\u5316\u5B8C\u6210");
  }
  // 🎯 新增：处理DOM状态问题
  handleDOMStateIssue(report) {
    if (this.dataConsistencyValidator) {
      const consistencyReport = this.dataConsistencyValidator.validateFullConsistency();
      if (!consistencyReport.isConsistent) {
        DebugManager.warn("\u68C0\u6D4B\u5230\u6570\u636E\u4E0D\u4E00\u81F4\uFF0C\u5C1D\u8BD5\u81EA\u52A8\u4FEE\u590D");
        this.dataConsistencyValidator.autoFixInconsistencies(consistencyReport).then((fixResult) => {
          if (fixResult.success) {
            DebugManager.log("\u81EA\u52A8\u4FEE\u590D\u6210\u529F:", fixResult.fixedIssues);
          } else {
            DebugManager.error("\u81EA\u52A8\u4FEE\u590D\u5931\u8D25:", fixResult.failedFixes);
          }
        });
      }
    }
  }
  // 🚨 新增：启动定期DOM一致性检查
  startPeriodicDOMValidation() {
    setInterval(async () => {
      if (!this.isDOMValidationInProgress && this.gridContainer && this.canvasData) {
        try {
          await this.validateDOMConsistency();
        } catch (error) {
          DebugManager.error("\u5B9A\u671FDOM\u9A8C\u8BC1\u5931\u8D25:", error);
        }
      }
    }, 3e4);
    DebugManager.log("\u2705 \u5B9A\u671FDOM\u4E00\u81F4\u6027\u68C0\u67E5\u5DF2\u542F\u52A8 (30\u79D2\u95F4\u9694)");
  }
  // 🎯 新增：彻底清理方法
  async thoroughCleanup() {
    DebugManager.log("\u{1F9F9} \u5F00\u59CB\u5F7B\u5E95\u6E05\u7406");
    if (this.domStateMonitor) {
      this.domStateMonitor.stopMonitoring();
    }
    if (this.gridContainer) {
      this.gridContainer.empty();
    }
    this.domElementRegistry.clearAll();
    this.clearDataCache();
    if (this.incrementalRenderer) {
      this.incrementalRenderer.clearRenderState();
    }
    this.resetRenderState();
    this.cleanupEventReferences();
    DebugManager.log("\u2705 \u5F7B\u5E95\u6E05\u7406\u5B8C\u6210");
  }
  // 🎯 新增：重置渲染状态
  resetRenderState() {
    this.currentEditingCard = null;
    this.currentEditingNode = null;
    this.selectedCard = null;
    this.selectedNode = null;
  }
  // 🎯 新增：清理事件引用
  cleanupEventReferences() {
  }
  // 安全的事件监听器添加方法
  addGlobalEventListener(element, event, handler, options) {
    element.addEventListener(event, handler, options);
    this.globalEventListeners.push({ element, event, handler, options });
  }
  // 安全的定时器管理方法
  safeSetTimeout(callback, delay) {
    const timeoutId = setTimeout(() => {
      this.activeTimeouts.delete(timeoutId);
      callback();
    }, delay);
    this.activeTimeouts.add(timeoutId);
    return timeoutId;
  }
  safeSetInterval(callback, delay) {
    const intervalId = setInterval(callback, delay);
    this.activeIntervals.add(intervalId);
    return intervalId;
  }
  // 清理单个定时器
  safeClearTimeout(timeoutId) {
    clearTimeout(timeoutId);
    this.activeTimeouts.delete(timeoutId);
  }
  safeClearInterval(intervalId) {
    clearInterval(intervalId);
    this.activeIntervals.delete(intervalId);
  }
  // 清理过期的缓存项
  cleanupExpiredCache() {
    const now = Date.now();
    const expiredKeys = [];
    DebugManager.log("\u7F13\u5B58\u6E05\u7406\u5B8C\u6210\uFF0C\u5F53\u524D\u7F13\u5B58\u5927\u5C0F:", this.linkPreviewCache.size);
  }
  // 清理过期的加载状态
  cleanupLoadingUrls() {
    this.previewLoadingUrls.clear();
  }
  // 获取缓存项
  getCacheItem(url) {
    const cached = this.linkPreviewCache.get(url);
    if (cached) {
      const now = Date.now();
      if (now - cached.timestamp < this.CACHE_TTL) {
        return cached.data;
      } else {
        this.linkPreviewCache.delete(url);
      }
    }
    return null;
  }
  // 设置缓存项
  setCacheItem(url, data) {
    this.linkPreviewCache.set(url, {
      data,
      timestamp: Date.now()
    });
  }
  getViewType() {
    return CANVAS_GRID_VIEW_TYPE;
  }
  getDisplayText() {
    return "Canvasgrid Transit";
  }
  getIcon() {
    return "grid";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    if (!container) {
      DebugManager.error("Canvasgrid Transit: Container element not found");
      return;
    }
    container.empty();
    this.gridContainer = container.createDiv("canvas-grid-container");
    this.createToolbar(container);
    this.gridContainer.remove();
    this.gridContainer = container.createDiv("canvas-grid-container");
    this.gridContainer.classList.remove("toolbar-hidden");
    this.gridContainer.style.removeProperty("margin-top");
    this.gridContainer.style.removeProperty("height");
    this.setupGridStyles();
    this.completeDataConsistencyInitialization();
    this.setupEventDelegation();
    await this.loadActiveCanvas();
    this.initializeDragSystem();
    this.initializeSearchAndSort();
    this.initializeWidthControl();
    this.cacheCleanupInterval = this.safeSetInterval(() => {
      this.cleanupExpiredCache();
      this.cleanupLoadingUrls();
    }, 10 * 60 * 1e3);
    MemoryManager.registerCleanup(() => {
      this.cleanupExpiredCache();
      this.cleanupLoadingUrls();
    });
  }
  // 初始化搜索和排序功能
  initializeSearchAndSort() {
    DebugManager.log("\u{1F527} Initializing search and sort functionality");
    this.filteredNodes = this.canvasData?.nodes || [];
    this.searchQuery = "";
    this.activeColorFilter = null;
    DebugManager.log(`\u{1F4CA} Initialized with ${this.filteredNodes.length} nodes`);
    DebugManager.log(`\u{1F504} Default sort: ${this.sortBy} (${this.sortOrder})`);
    this.applySortAndFilter();
  }
  // 创建新的工具栏布局
  createToolbar(container) {
    const toolbar = container.createDiv("canvas-grid-toolbar");
    const functionRow = toolbar.createDiv("canvas-grid-toolbar-function-row");
    this.createFunctionButtons(functionRow);
    const dynamicContent = toolbar.createDiv("canvas-grid-toolbar-dynamic-content");
    this.createDynamicContentPanels(dynamicContent);
  }
  // 创建功能按钮
  createFunctionButtons(container) {
    const buttons = [
      {
        id: "search",
        text: this.settings.language === "zh" ? "\u641C\u7D22" : "Search",
        icon: "search",
        handler: this.toggleSearchPanel.bind(this)
      },
      {
        id: "create",
        text: this.settings.language === "zh" ? "\u521B\u5EFA" : "Create",
        icon: "plus",
        handler: this.toggleCreatePanel.bind(this)
      },
      {
        id: "color-dots",
        text: this.settings.language === "zh" ? "\u5F69\u8272\u5706\u70B9" : "Color Filter",
        icon: "palette",
        handler: this.toggleColorDotsPanel.bind(this)
      },
      {
        id: "export",
        text: this.settings.language === "zh" ? "Anki\u540C\u6B65" : "Anki Sync",
        icon: "download",
        handler: this.toggleExportPanel.bind(this)
      }
    ];
    this.createMultiMenuButton(container);
    buttons.forEach((btn) => {
      const buttonEl = container.createEl("button", {
        cls: `function-btn responsive-btn ${btn.id}-btn`
      });
      const iconEl = buttonEl.createEl("span", {
        cls: "btn-icon"
      });
      iconEl.innerHTML = this.getIconSVG(btn.icon);
      const textEl = buttonEl.createEl("span", {
        cls: "btn-text",
        text: btn.text
      });
      buttonEl.setAttribute("title", btn.text);
      buttonEl.setAttribute("aria-label", btn.text);
      buttonEl.addEventListener("click", btn.handler);
    });
    this.setupResponsiveToolbar(container);
  }
  // 🎯 修复：创建多功能菜单按钮（独立容器，正确的DOM结构）
  createMultiMenuButton(container) {
    const menuContainer = container.createDiv("canvas-grid-multi-menu-container");
    const menuButton = menuContainer.createEl("button", {
      cls: "function-btn responsive-btn multi-menu-btn"
    });
    const iconEl = menuButton.createEl("span", {
      cls: "btn-icon"
    });
    iconEl.innerHTML = this.getIconSVG("menu");
    const textEl = menuButton.createEl("span", {
      cls: "btn-text",
      text: this.settings.language === "zh" ? "\u591A\u529F\u80FD\u83DC\u5355" : "Multi Menu"
    });
    menuButton.setAttribute("title", this.settings.language === "zh" ? "\u591A\u529F\u80FD\u83DC\u5355" : "Multi Menu");
    menuButton.setAttribute("aria-label", this.settings.language === "zh" ? "\u591A\u529F\u80FD\u83DC\u5355" : "Multi Menu");
    const dropdown = menuContainer.createDiv("canvas-grid-main-dropdown");
    dropdown.style.display = "none";
    this.createMainMenuContent(dropdown);
    menuButton.addEventListener("click", (e) => {
      e.stopPropagation();
      const isVisible = dropdown.style.display !== "none";
      if (isVisible) {
        this.hideAllDropdowns();
      } else {
        this.hideAllDropdowns();
        this.closeDynamicContent();
        dropdown.style.display = "block";
        menuButton.classList.add("active");
      }
    });
    dropdown.addEventListener("click", (e) => {
      e.stopPropagation();
    });
  }
  // 获取图标SVG
  getIconSVG(iconName) {
    const icons = {
      "menu": '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" x2="20" y1="6" y2="6"/><line x1="4" x2="20" y1="12" y2="12"/><line x1="4" x2="20" y1="18" y2="18"/></svg>',
      "search": '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/></svg>',
      "plus": '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"/><path d="M12 5v14"/></svg>',
      "palette": '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="13.5" cy="6.5" r=".5" fill="currentColor"/><circle cx="17.5" cy="10.5" r=".5" fill="currentColor"/><circle cx="8.5" cy="7.5" r=".5" fill="currentColor"/><circle cx="6.5" cy="12.5" r=".5" fill="currentColor"/><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z"/></svg>',
      "download": '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7,10 12,15 17,10"/><line x1="12" x2="12" y1="15" y2="3"/></svg>'
    };
    return icons[iconName] || icons["menu"];
  }
  // 设置响应式工具栏
  setupResponsiveToolbar(container) {
    const toolbar = container.closest(".canvas-grid-toolbar");
    if (!toolbar)
      return;
    const BREAKPOINTS = {
      ICON_ONLY: 500,
      COMPACT: 700,
      FULL: 900
    };
    const updateButtonDisplay = () => {
      const width = toolbar.offsetWidth;
      const buttons = toolbar.querySelectorAll(".responsive-btn");
      buttons.forEach((btn) => {
        const textEl = btn.querySelector(".btn-text");
        if (!textEl)
          return;
        btn.classList.remove("icon-only", "compact", "full");
        if (width < BREAKPOINTS.ICON_ONLY) {
          btn.classList.add("icon-only");
          textEl.style.display = "none";
        } else if (width < BREAKPOINTS.COMPACT) {
          btn.classList.add("compact");
          textEl.style.display = "inline";
        } else {
          btn.classList.add("full");
          textEl.style.display = "inline";
        }
      });
    };
    if (window.ResizeObserver) {
      const resizeObserver = new ResizeObserver(() => {
        updateButtonDisplay();
      });
      resizeObserver.observe(toolbar);
    } else {
      window.addEventListener("resize", updateButtonDisplay);
    }
    updateButtonDisplay();
  }
  // 创建动态内容面板
  createDynamicContentPanels(container) {
    const searchPanel = container.createDiv("content-panel search-panel");
    const searchWrapper = searchPanel.createDiv("panel-content-wrapper");
    const searchMainContent = searchWrapper.createDiv("panel-main-content");
    this.createSearchBox(searchMainContent);
    const searchRightSide = searchWrapper.createDiv("panel-right-side");
    this.createTimeCapsuleInPanel(searchRightSide);
    const createPanel = container.createDiv("content-panel create-panel");
    this.createNewCardForm(createPanel);
    const colorPanel = container.createDiv("content-panel color-dots-panel");
    const colorWrapper = colorPanel.createDiv("panel-content-wrapper");
    const colorMainContent = colorWrapper.createDiv("panel-main-content");
    this.createColorFilter(colorMainContent);
    const colorRightSide = colorWrapper.createDiv("panel-right-side");
    this.createTimeCapsuleInPanel(colorRightSide);
    const exportPanel = container.createDiv("content-panel export-panel");
    this.createExportOptions(exportPanel);
  }
  // 面板切换逻辑
  togglePanel(panelType) {
    const dynamicContent = this.containerEl.querySelector(".canvas-grid-toolbar-dynamic-content");
    const allPanels = dynamicContent?.querySelectorAll(".content-panel");
    const allButtons = this.containerEl.querySelectorAll(".function-btn");
    const targetPanel = dynamicContent?.querySelector(`.${panelType}-panel`);
    const targetButton = this.containerEl.querySelector(`.${panelType}-btn`);
    if (targetPanel?.classList.contains("active")) {
      this.closeDynamicContent();
      return;
    }
    this.hideAllDropdowns();
    allPanels?.forEach((panel) => panel.classList.remove("active"));
    allButtons?.forEach((btn) => btn.classList.remove("active"));
    targetPanel?.classList.add("active");
    targetButton?.classList.add("active");
    dynamicContent?.classList.add("expanded");
  }
  // 关闭动态内容区域
  closeDynamicContent() {
    const dynamicContent = this.containerEl.querySelector(".canvas-grid-toolbar-dynamic-content");
    const allPanels = dynamicContent?.querySelectorAll(".content-panel");
    const allButtons = this.containerEl.querySelectorAll(".function-btn");
    allPanels?.forEach((panel) => panel.classList.remove("active"));
    allButtons?.forEach((btn) => btn.classList.remove("active"));
    dynamicContent?.classList.remove("expanded");
  }
  // 各个面板的切换方法（多功能菜单现在由按钮直接处理）
  // 在面板中创建时间胶囊
  createTimeCapsuleInPanel(container) {
    const timeCapsuleBtn = container.createEl("button", {
      cls: "canvas-grid-time-capsule-btn panel-time-capsule",
      title: "\u65F6\u95F4\u80F6\u56CA - \u70B9\u51FB\u5F00\u59CB\u5012\u8BA1\u65F6"
    });
    const timerDisplay = timeCapsuleBtn.createEl("span", {
      cls: "timer-display"
    });
    this.updatePanelTimeCapsuleDisplay(timeCapsuleBtn, timerDisplay);
    timeCapsuleBtn.addEventListener("click", () => {
      this.toggleTimeCapsule();
    });
    container.setAttribute("data-time-capsule-btn", "true");
  }
  // 更新面板中时间胶囊的显示
  updatePanelTimeCapsuleDisplay(button, display) {
    if (this.timeCapsuleState.isActive) {
      const minutes = Math.floor(this.timeCapsuleState.remainingTime / 6e4);
      const seconds = Math.floor(this.timeCapsuleState.remainingTime % 6e4 / 1e3);
      const timeText = `${minutes}:${seconds.toString().padStart(2, "0")}`;
      display.innerHTML = timeText;
      button.classList.add("active", "counting");
      button.title = `\u65F6\u95F4\u80F6\u56CA\u6536\u96C6\u4E2D - \u5269\u4F59 ${timeText}`;
    } else {
      display.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/></svg>';
      button.classList.remove("active", "counting");
      button.title = "\u65F6\u95F4\u80F6\u56CA - \u70B9\u51FB\u5F00\u59CB\u5012\u8BA1\u65F6";
    }
  }
  // 更新所有面板中的时间胶囊按钮
  updateAllPanelTimeCapsules() {
    const panelButtons = this.containerEl.querySelectorAll(".panel-time-capsule");
    panelButtons.forEach((button) => {
      const display = button.querySelector(".timer-display");
      if (display) {
        this.updatePanelTimeCapsuleDisplay(button, display);
      }
    });
  }
  toggleSearchPanel() {
    this.togglePanel("search");
  }
  toggleCreatePanel() {
    this.togglePanel("create");
  }
  toggleColorDotsPanel() {
    this.togglePanel("color-dots");
  }
  toggleExportPanel() {
    this.togglePanel("export");
  }
  // 创建新卡片表单
  createNewCardForm(container) {
    const form = container.createDiv("new-card-form");
    const typeSelect = form.createEl("select", { cls: "card-type-select" });
    typeSelect.createEl("option", { value: "text", text: "\u6587\u672C\u5361\u7247" });
    typeSelect.createEl("option", { value: "link", text: "\u94FE\u63A5\u5361\u7247" });
    const contentInput = form.createEl("textarea", {
      cls: "card-content-input",
      attr: { placeholder: "\u8F93\u5165\u5361\u7247\u5185\u5BB9..." }
    });
    const createBtn = form.createEl("button", {
      cls: "create-card-btn mod-cta",
      text: "\u521B\u5EFA\u5361\u7247"
    });
    createBtn.addEventListener("click", () => {
      this.handleCreateNewCard(typeSelect.value, contentInput.value);
    });
  }
  // 创建Anki同步选项
  createExportOptions(container) {
    const ankiSyncContainer = container.createDiv("anki-sync-options");
    if (!this.settings.ankiConnect.enabled) {
      this.createAnkiDisabledMessage(ankiSyncContainer);
      return;
    }
    this.createCurrentCanvasSyncHistory(ankiSyncContainer);
  }
  // 创建当前Canvas同步历史
  createCurrentCanvasSyncHistory(container) {
    const historyContainer = container.createDiv("current-canvas-sync-history");
    const tableContainer = historyContainer.createDiv("current-sync-table-container");
    tableContainer.style.cssText = `
			background: var(--background-secondary);
			border-radius: 8px;
			padding: 12px;
			border: 1px solid var(--background-modifier-border);
			margin-bottom: 12px;
		`;
    const table = tableContainer.createEl("table", {
      cls: "current-sync-table"
    });
    table.style.cssText = `
			width: 100%;
			border-collapse: collapse;
			font-size: 12px;
		`;
    const thead = table.createEl("thead");
    const headerRow = thead.createEl("tr");
    headerRow.style.cssText = `
			border-bottom: 1px solid var(--background-modifier-border);
		`;
    const headers = this.settings.language === "zh" ? ["\u724C\u7EC4", "\u65B0\u589E", "\u66F4\u65B0", "\u8DF3\u8FC7", "\u5931\u8D25", "\u65F6\u95F4"] : ["Deck", "New", "Updated", "Skipped", "Failed", "Time"];
    headers.forEach((headerText, index) => {
      const th = headerRow.createEl("th");
      th.textContent = headerText;
      th.style.cssText = `
				padding: 8px 4px;
				text-align: center;
				font-weight: 600;
				color: var(--text-normal);
				font-size: 11px;
				${index < headers.length - 1 ? "border-right: 1px solid var(--background-modifier-border);" : ""}
			`;
    });
    const tbody = table.createEl("tbody");
    const lastResult = this.settings.ankiSyncHistory.lastSyncResult;
    const lastSyncTime = this.settings.ankiSyncHistory.lastSyncTime;
    if (lastResult && lastSyncTime) {
      const dataRow = tbody.createEl("tr");
      dataRow.style.cssText = `
				border-bottom: 1px solid var(--background-modifier-border);
			`;
      const data = [
        this.settings.ankiConnect.defaultDeck || "Default",
        lastResult.created || 0,
        lastResult.updated || 0,
        lastResult.skipped || 0,
        lastResult.errors?.length || 0,
        this.formatSyncTime(lastSyncTime)
      ];
      data.forEach((cellData, index) => {
        const td = dataRow.createEl("td");
        td.textContent = cellData.toString();
        td.style.cssText = `
					padding: 8px 4px;
					text-align: center;
					color: var(--text-normal);
					font-size: 11px;
					${index < data.length - 1 ? "border-right: 1px solid var(--background-modifier-border);" : ""}
				`;
        if (index === 4 && cellData > 0) {
          td.style.color = "var(--text-error)";
          td.style.fontWeight = "600";
        }
        if ((index === 1 || index === 2) && cellData > 0) {
          td.style.color = "var(--text-success)";
          td.style.fontWeight = "500";
        }
      });
    } else {
      const noDataRow = tbody.createEl("tr");
      const noDataCell = noDataRow.createEl("td");
      noDataCell.setAttribute("colspan", "6");
      noDataCell.textContent = this.settings.language === "zh" ? "\u6682\u65E0\u540C\u6B65\u5386\u53F2" : "No sync history";
      noDataCell.style.cssText = `
				padding: 16px;
				text-align: center;
				color: var(--text-muted);
				font-style: italic;
				font-size: 11px;
			`;
    }
    const buttonContainer = historyContainer.createDiv("sync-button-container");
    buttonContainer.style.cssText = `
			display: flex;
			gap: 8px;
			margin-top: 12px;
		`;
    const configButton = buttonContainer.createEl("button", {
      text: this.settings.language === "zh" ? "\u2699\uFE0F \u914D\u7F6E" : "\u2699\uFE0F Config",
      cls: "canvas-grid-button toolbar-button"
    });
    configButton.style.cssText = `
			flex: 1;
			min-width: 80px;
			height: 36px;
			padding: 8px 16px;
			font-size: 13px;
			font-weight: 500;
			border-radius: 6px;
			background: var(--interactive-normal);
			color: var(--text-normal);
			border: 1px solid var(--background-modifier-border);
			cursor: pointer;
			transition: all 0.2s ease;
			display: flex;
			align-items: center;
			justify-content: center;
		`;
    configButton.addEventListener("click", () => {
      this.openAnkiSyncModal();
    });
    const syncButton = buttonContainer.createEl("button", {
      text: this.settings.language === "zh" ? "\u{1F0CF} \u5F00\u59CB\u540C\u6B65" : "\u{1F0CF} Start Sync",
      cls: "canvas-grid-button toolbar-button mod-cta"
    });
    syncButton.style.cssText = `
			flex: 2;
			min-width: 120px;
			height: 36px;
			padding: 8px 16px;
			font-size: 13px;
			font-weight: 500;
			border-radius: 6px;
			background: var(--interactive-accent);
			color: var(--text-on-accent);
			border: none;
			cursor: pointer;
			transition: all 0.2s ease;
			display: flex;
			align-items: center;
			justify-content: center;
		`;
    syncButton.addEventListener("click", async () => {
      await this.startDirectSync();
    });
    configButton.addEventListener("mouseenter", () => {
      configButton.style.background = "var(--interactive-hover)";
      configButton.style.borderColor = "var(--interactive-accent)";
    });
    configButton.addEventListener("mouseleave", () => {
      configButton.style.background = "var(--interactive-normal)";
      configButton.style.borderColor = "var(--background-modifier-border)";
    });
    syncButton.addEventListener("mouseenter", () => {
      syncButton.style.background = "var(--interactive-accent-hover)";
    });
    syncButton.addEventListener("mouseleave", () => {
      syncButton.style.background = "var(--interactive-accent)";
    });
  }
  // 格式化同步时间
  formatSyncTime(timestamp) {
    const date = new Date(timestamp);
    const now = /* @__PURE__ */ new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMins = Math.floor(diffMs / (1e3 * 60));
    const diffHours = Math.floor(diffMs / (1e3 * 60 * 60));
    const diffDays = Math.floor(diffMs / (1e3 * 60 * 60 * 24));
    if (diffMins < 1) {
      return this.settings.language === "zh" ? "\u521A\u521A" : "Just now";
    } else if (diffMins < 60) {
      return this.settings.language === "zh" ? `${diffMins}\u5206\u949F\u524D` : `${diffMins}m ago`;
    } else if (diffHours < 24) {
      return this.settings.language === "zh" ? `${diffHours}\u5C0F\u65F6\u524D` : `${diffHours}h ago`;
    } else if (diffDays < 7) {
      return this.settings.language === "zh" ? `${diffDays}\u5929\u524D` : `${diffDays}d ago`;
    } else {
      return date.toLocaleDateString();
    }
  }
  // 直接开始同步
  async startDirectSync() {
    try {
      if (!this.settings.ankiConnect.enabled) {
        new import_obsidian12.Notice(this.settings.language === "zh" ? "\u8BF7\u5148\u5728\u8BBE\u7F6E\u4E2D\u542F\u7528Anki Connect" : "Please enable Anki Connect in settings first");
        return;
      }
      if (this.settings.ankiConnect.syncColors.length === 0) {
        new import_obsidian12.Notice(this.settings.language === "zh" ? "\u8BF7\u5148\u9009\u62E9\u8981\u540C\u6B65\u7684\u989C\u8272" : "Please select colors to sync first");
        return;
      }
      await this.syncAllSelectedColorCards();
      const exportPanel = this.containerEl.querySelector(".export-panel");
      if (exportPanel) {
        while (exportPanel.firstChild) {
          exportPanel.removeChild(exportPanel.firstChild);
        }
        this.createExportOptions(exportPanel);
      }
    } catch (error) {
      console.error("\u76F4\u63A5\u540C\u6B65\u5931\u8D25:", error);
      new import_obsidian12.Notice(this.settings.language === "zh" ? "\u540C\u6B65\u5931\u8D25\uFF0C\u8BF7\u68C0\u67E5Anki Connect\u8FDE\u63A5" : "Sync failed, please check Anki Connect connection");
    }
  }
  // 打开Anki同步模态窗
  openAnkiSyncModal() {
    const modal = new AnkiSyncModal(this.app, this);
    modal.open();
  }
  // 更新简要Anki状态
  updateBriefAnkiStatus(container) {
    container.empty();
    const syncHistory = this.settings.ankiSyncHistory;
    if (syncHistory.lastSyncTime) {
      const lastSync = new Date(syncHistory.lastSyncTime);
      const statusText = this.settings.language === "zh" ? `\u4E0A\u6B21\u540C\u6B65: ${lastSync.toLocaleString()}` : `Last sync: ${lastSync.toLocaleString()}`;
      const statusEl = container.createEl("div", {
        text: statusText,
        cls: "anki-status-text"
      });
      statusEl.style.cssText = `
				font-size: 12px;
				color: var(--text-muted);
				text-align: center;
			`;
    } else {
      const noSyncText = this.settings.language === "zh" ? "\u5C1A\u672A\u540C\u6B65" : "Not synced yet";
      const statusEl = container.createEl("div", {
        text: noSyncText,
        cls: "anki-status-text"
      });
      statusEl.style.cssText = `
				font-size: 12px;
				color: var(--text-muted);
				text-align: center;
			`;
    }
  }
  // 创建右侧时间胶囊
  createSideTimeCapsule(container) {
    const sideContainer = document.body.createDiv("canvas-grid-time-capsule-sidebar");
    this.createTimeCapsuleButton(sideContainer);
  }
  // 处理创建新卡片
  async handleCreateNewCard(type, content) {
    if (!content.trim()) {
      new import_obsidian12.Notice("\u8BF7\u8F93\u5165\u5361\u7247\u5185\u5BB9");
      return;
    }
    if (!this.canvasData) {
      new import_obsidian12.Notice("\u65E0\u6CD5\u521B\u5EFA\u5361\u7247\uFF1ACanvas\u6570\u636E\u4E0D\u5B58\u5728");
      return;
    }
    try {
      const nodeId = `node-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      const position = this.calculateNewCardPosition();
      const newNode = {
        id: nodeId,
        type,
        x: position.x,
        y: position.y,
        width: GRID_CONSTANTS.CARD_WIDTH,
        height: GRID_CONSTANTS.CARD_HEIGHT,
        ...type === "text" ? { text: content } : { url: content }
      };
      this.canvasData.nodes.push(newNode);
      await this.saveCanvasData();
      await this.renderGrid();
      this.closeDynamicContent();
      new import_obsidian12.Notice(`\u5DF2\u521B\u5EFA${type === "text" ? "\u6587\u672C" : "\u94FE\u63A5"}\u5361\u7247`);
      const contentInput = this.containerEl.querySelector(".card-content-input");
      if (contentInput) {
        contentInput.value = "";
      }
    } catch (error) {
      DebugManager.error("\u521B\u5EFA\u5361\u7247\u5931\u8D25:", error);
      new import_obsidian12.Notice("\u521B\u5EFA\u5361\u7247\u5931\u8D25");
    }
  }
  // 计算新卡片位置
  calculateNewCardPosition() {
    if (!this.canvasData || this.canvasData.nodes.length === 0) {
      return { x: 100, y: 100 };
    }
    let maxX = 0;
    let maxY = 0;
    this.canvasData.nodes.forEach((node) => {
      const rightEdge = node.x + (node.width || GRID_CONSTANTS.CARD_WIDTH);
      const bottomEdge = node.y + (node.height || GRID_CONSTANTS.CARD_HEIGHT);
      if (rightEdge > maxX)
        maxX = rightEdge;
      if (bottomEdge > maxY)
        maxY = bottomEdge;
    });
    return {
      x: maxX + 50,
      y: maxY + 50
    };
  }
  // 创建主菜单按钮
  createMainMenuButton(container) {
    const menuContainer = container.createDiv("canvas-grid-main-menu");
    const mainBtn = menuContainer.createEl("button", {
      cls: "canvas-grid-main-btn canvas-grid-icon-only",
      title: this.settings.language === "zh" ? "\u7F51\u683C\u89C6\u56FE\u83DC\u5355" : "Grid View Menu"
    });
    const btnContent = mainBtn.createDiv("canvas-grid-main-btn-content");
    const iconEl = btnContent.createDiv("canvas-grid-main-icon");
    iconEl.innerHTML = `
			<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<rect x="3" y="3" width="7" height="7"/>
				<rect x="14" y="3" width="7" height="7"/>
				<rect x="3" y="14" width="7" height="7"/>
				<rect x="14" y="14" width="7" height="7"/>
			</svg>
		`;
    const arrowEl = btnContent.createDiv("canvas-grid-main-arrow");
    arrowEl.innerHTML = `
			<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<polyline points="6,9 12,15 18,9"/>
			</svg>
		`;
    this.linkedIndicatorEl = document.createElement("div");
    this.linkedIndicatorEl.className = "canvas-grid-linked-indicator-hidden";
    this.linkedIndicatorEl.style.display = "none";
    btnContent.appendChild(this.linkedIndicatorEl);
    this.updateLinkedCanvasDisplay(null);
    const mainDropdown = menuContainer.createDiv("canvas-grid-main-dropdown");
    mainDropdown.style.display = "none";
    this.createMainMenuContent(mainDropdown);
    mainBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      const isVisible = mainDropdown.style.display !== "none";
      this.hideAllDropdowns();
      if (!isVisible) {
        mainDropdown.style.display = "block";
        mainBtn.classList.add("active");
      }
    });
    mainDropdown.addEventListener("click", (e) => {
      e.stopPropagation();
    });
  }
  // 创建主菜单内容
  createMainMenuContent(container) {
    this.createLinkManagementSection(container);
    this.createDataOperationsSection(container);
    this.createSortFilterSection(container);
    this.createNavigationSection(container);
  }
  // 创建关联管理部分
  createLinkManagementSection(container) {
    const section = container.createDiv("canvas-grid-menu-section");
    const autoLinkItem = section.createDiv("canvas-grid-menu-item");
    autoLinkItem.innerHTML = `
			<svg class="menu-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/>
			</svg>
			<span class="menu-text">\u81EA\u52A8\u5173\u8054\u5F53\u524DCanvas</span>
		`;
    autoLinkItem.addEventListener("click", () => {
      this.autoLinkCurrentCanvas();
      this.hideAllDropdowns();
    });
    const customLinkItem = section.createDiv("canvas-grid-menu-item");
    customLinkItem.innerHTML = `
			<svg class="menu-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
				<path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
			</svg>
			<span class="menu-text">\u9009\u62E9\u5173\u8054Canvas\u6587\u4EF6</span>
		`;
    customLinkItem.addEventListener("click", () => {
      this.showCanvasSelectionDialog();
      this.hideAllDropdowns();
    });
    const unlinkItem = section.createDiv("canvas-grid-menu-item");
    unlinkItem.innerHTML = `
			<svg class="menu-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<path d="M18 6L6 18M6 6l12 12"/>
			</svg>
			<span class="menu-text">\u89E3\u9664\u5173\u8054</span>
		`;
    unlinkItem.addEventListener("click", () => {
      this.linkedCanvasFile = null;
      this.canvasData = null;
      this.renderGrid();
      new import_obsidian12.Notice("\u5DF2\u89E3\u9664Canvas\u6587\u4EF6\u5173\u8054");
      this.hideAllDropdowns();
    });
  }
  // 视图设置部分已移除，功能简化
  // 创建数据操作部分
  createDataOperationsSection(container) {
    const section = container.createDiv("canvas-grid-menu-section");
    const syncItem = section.createDiv("canvas-grid-menu-item");
    syncItem.innerHTML = `
			<svg class="menu-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<polyline points="23,4 23,10 17,10"/>
				<polyline points="1,20 1,14 7,14"/>
				<path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"/>
			</svg>
			<span class="menu-text">\u540C\u6B65\u6570\u636E</span>
		`;
    syncItem.addEventListener("click", () => {
      this.syncCanvasData();
      this.hideAllDropdowns();
    });
    const createItem = section.createDiv("canvas-grid-menu-item");
    createItem.innerHTML = `
			<svg class="menu-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
				<polyline points="14,2 14,8 20,8"/>
				<line x1="12" y1="18" x2="12" y2="12"/>
				<line x1="9" y1="15" x2="15" y2="15"/>
			</svg>
			<span class="menu-text">\u65B0\u5EFACanvas\u6587\u4EF6</span>
		`;
    createItem.addEventListener("click", () => {
      this.createNewCanvasFile();
      this.hideAllDropdowns();
    });
  }
  // 创建排序和筛选部分
  createSortFilterSection(container) {
    const section = container.createDiv("canvas-grid-menu-section");
    i18n.setLanguage(this.settings.language);
    const sortItem = section.createDiv("canvas-grid-menu-item canvas-grid-submenu-item");
    sortItem.innerHTML = `
			<svg class="menu-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<path d="M3 6h18"/>
				<path d="M7 12h10"/>
				<path d="M10 18h4"/>
			</svg>
			<span class="menu-text">${i18n.t("sortBy")}</span>
			<svg class="menu-arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<polyline points="9,18 15,12 9,6"/>
			</svg>
		`;
    const filterItem = section.createDiv("canvas-grid-menu-item canvas-grid-submenu-item");
    filterItem.innerHTML = `
			<svg class="menu-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<polyline points="22,12 18,12 15,21 9,3 6,12 2,12"/>
			</svg>
			<span class="menu-text">\u7B5B\u9009\u6761\u4EF6</span>
			<svg class="menu-arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<polyline points="9,18 15,12 9,6"/>
			</svg>
		`;
    this.addSubmenuEvents(sortItem, "sort");
    this.addSubmenuEvents(filterItem, "filter");
  }
  // 添加子菜单事件
  addSubmenuEvents(menuItem, type) {
    menuItem.addEventListener("click", (e) => {
      e.stopPropagation();
      const existingSubmenu = document.querySelector(`.canvas-grid-submenu[data-submenu-type="${type}"]`);
      if (existingSubmenu) {
        this.closeAllSubmenus();
      } else {
        this.showSubmenu(menuItem, type);
      }
    });
  }
  // 显示子菜单
  showSubmenu(parentItem, type) {
    this.closeAllSubmenus();
    const submenu = document.createElement("div");
    submenu.className = "canvas-grid-submenu";
    submenu.dataset.submenuType = type;
    switch (type) {
      case "sort":
        this.createSortSubmenu(submenu);
        break;
      case "filter":
        this.createFilterSubmenu(submenu);
        break;
    }
    const rect = parentItem.getBoundingClientRect();
    submenu.style.position = "fixed";
    submenu.style.left = `${rect.right + 8}px`;
    submenu.style.top = `${rect.top}px`;
    submenu.style.zIndex = "1001";
    document.body.appendChild(submenu);
    const closeSubmenu = (e) => {
      if (!submenu.contains(e.target) && !parentItem.contains(e.target)) {
        submenu.remove();
        document.removeEventListener("click", closeSubmenu);
        const index = this.globalEventListeners.findIndex(
          (listener) => listener.element === document && listener.event === "click" && listener.handler === closeSubmenu
        );
        if (index > -1) {
          this.globalEventListeners.splice(index, 1);
        }
      }
    };
    this.safeSetTimeout(() => {
      this.addGlobalEventListener(document, "click", closeSubmenu);
    }, 0);
  }
  // 关闭所有子菜单
  closeAllSubmenus() {
    const existingSubmenus = document.querySelectorAll(".canvas-grid-submenu");
    existingSubmenus.forEach((submenu) => {
      submenu.remove();
    });
  }
  // 创建合并排序子菜单（排序方式+顺序）
  createSortSubmenu(container) {
    i18n.setLanguage(this.settings.language);
    const sortOptions = [
      { key: "created", label: i18n.t("sortByCreated") },
      { key: "modified", label: i18n.t("sortByModified") },
      { key: "title", label: i18n.t("sortByTitle") }
    ];
    DebugManager.log(`\u{1F39B}\uFE0F Creating sort submenu with current sort: ${this.sortBy} (${this.sortOrder})`);
    sortOptions.forEach((option) => {
      const item = container.createDiv("canvas-grid-menu-item");
      const isActive = this.sortBy === option.key;
      const isAsc = this.sortOrder === "asc";
      let statusIcon = "";
      if (isActive) {
        statusIcon = isAsc ? "\u2191" : "\u2193";
      }
      item.innerHTML = `
				<span class="menu-text">${option.label}</span>
				<span class="menu-status">${statusIcon}</span>
			`;
      if (isActive) {
        item.style.backgroundColor = "var(--background-modifier-hover)";
        item.style.fontWeight = "600";
      }
      item.addEventListener("click", () => {
        DebugManager.log(`\u{1F504} Sort option clicked: ${option.key} (current: ${this.sortBy})`);
        if (this.sortBy === option.key) {
          this.sortOrder = this.sortOrder === "asc" ? "desc" : "asc";
          DebugManager.log(`\u{1F504} Toggled sort order to: ${this.sortOrder}`);
        } else {
          this.sortBy = option.key;
          this.sortOrder = "desc";
          DebugManager.log(`\u{1F504} Changed sort to: ${this.sortBy} (${this.sortOrder})`);
        }
        this.applySortAndFilter();
        this.hideAllDropdowns();
        container.parentElement?.remove();
      });
    });
  }
  // 创建筛选子菜单
  createFilterSubmenu(container) {
    const filterOptions = [
      { key: "all", label: "\u663E\u793A\u5168\u90E8" },
      { key: "text", label: "\u4EC5\u6587\u672C\u5361\u7247" },
      { key: "file", label: "\u4EC5\u6587\u4EF6\u5361\u7247" },
      { key: "link", label: "\u4EC5\u94FE\u63A5\u5361\u7247" }
    ];
    filterOptions.forEach((option) => {
      const item = container.createDiv("canvas-grid-menu-item");
      item.innerHTML = `<span class="menu-text">${option.label}</span>`;
      item.addEventListener("click", () => {
        this.applyTypeFilter(option.key);
        this.hideAllDropdowns();
        container.parentElement?.remove();
      });
    });
  }
  // 创建导航部分
  createNavigationSection(container) {
    const section = container.createDiv("canvas-grid-menu-section");
    const backItem = section.createDiv("canvas-grid-menu-item canvas-grid-menu-back");
    backItem.innerHTML = `
			<svg class="menu-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<line x1="19" y1="12" x2="5" y2="12"/>
				<polyline points="12,19 5,12 12,5"/>
			</svg>
			<span class="menu-text">\u8FD4\u56DECanvas\u767D\u677F</span>
		`;
    backItem.addEventListener("click", () => {
      this.returnToCanvas();
      this.hideAllDropdowns();
    });
  }
  // 卡片大小相关方法已移除
  // 创建新Canvas文件
  async createNewCanvasFile() {
    try {
      const fileName = `Canvas-${Date.now()}.canvas`;
      const newFile = await this.app.vault.create(fileName, JSON.stringify({
        nodes: [],
        edges: []
      }));
      await this.setLinkedCanvas(newFile);
      new import_obsidian12.Notice(`\u5DF2\u521B\u5EFA\u5E76\u5173\u8054\u65B0Canvas\u6587\u4EF6: ${newFile.basename}`);
    } catch (error) {
      DebugManager.error("Failed to create new canvas file:", error);
      new import_obsidian12.Notice("\u521B\u5EFACanvas\u6587\u4EF6\u5931\u8D25");
    }
  }
  // 同步Canvas数据（合并刷新和同步功能）
  async syncCanvasData() {
    try {
      if (this.linkedCanvasFile) {
        await this.loadCanvasDataFromOfficialView(this.linkedCanvasFile);
        this.notifyCanvasViewRefresh();
        new import_obsidian12.Notice("Canvas\u6570\u636E\u5DF2\u540C\u6B65");
      } else {
        await this.loadActiveCanvas();
        new import_obsidian12.Notice("Canvas\u6570\u636E\u5DF2\u5237\u65B0");
      }
    } catch (error) {
      DebugManager.error("Failed to sync canvas data:", error);
      const errorMessage = error instanceof Error ? error.message : "\u672A\u77E5\u9519\u8BEF";
      new import_obsidian12.Notice(`\u540C\u6B65\u6570\u636E\u5931\u8D25: ${errorMessage}`);
      this.showErrorState(`\u540C\u6B65\u5931\u8D25: ${errorMessage}`);
    }
  }
  // exportGridData 已迁移到 FileSystemManager
  // 返回Canvas白板
  returnToCanvas() {
    if (this.linkedCanvasFile) {
      this.app.workspace.openLinkText(this.linkedCanvasFile.path, "", false);
    } else {
      const canvasLeaves = this.app.workspace.getLeavesOfType("canvas");
      if (canvasLeaves.length > 0) {
        this.app.workspace.setActiveLeaf(canvasLeaves[0]);
      } else {
        new import_obsidian12.Notice("\u6CA1\u6709\u627E\u5230\u53EF\u8FD4\u56DE\u7684Canvas\u6587\u4EF6");
      }
    }
  }
  // createActionButtons 已迁移到 UIComponentManager
  // 创建搜索框
  createSearchBox(container) {
    const searchContainer = container.createDiv("canvas-grid-search-container");
    this.searchInputEl = searchContainer.createEl("input", {
      cls: "canvas-grid-search-input",
      type: "text",
      placeholder: this.settings.language === "zh" ? "\u641C\u7D22\u5361\u7247\u5185\u5BB9..." : "Search card content..."
    });
    const clearBtn = searchContainer.createDiv("canvas-grid-search-clear");
    SVGIconManager.setIcon(clearBtn, "close");
    clearBtn.style.display = "none";
    this.searchInputEl.addEventListener("input", (e) => {
      const target = e.target;
      this.searchQuery = target.value.trim();
      if (this.searchQuery) {
        clearBtn.style.display = "flex";
      } else {
        clearBtn.style.display = "none";
      }
      this.performSearch();
    });
    clearBtn.addEventListener("click", () => {
      this.searchInputEl.value = "";
      this.searchQuery = "";
      clearBtn.style.display = "none";
      this.performSearch();
      this.searchInputEl.focus();
    });
    this.searchInputEl.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        this.searchInputEl.blur();
      }
    });
  }
  // 创建时间胶囊按钮
  createTimeCapsuleButton(container) {
    const buttonContainer = container.createDiv("canvas-grid-time-capsule-container");
    this.timeCapsuleButton = buttonContainer.createEl("button", {
      cls: "canvas-grid-time-capsule-btn",
      title: "\u65F6\u95F4\u80F6\u56CA - \u70B9\u51FB\u5F00\u59CB\u6536\u96C6"
    });
    this.updateTimeCapsuleButton();
    this.timeCapsuleButton.addEventListener("click", () => {
      this.toggleTimeCapsuleInternal();
    });
    let longPressTimer = null;
    this.timeCapsuleButton.addEventListener("mousedown", () => {
      longPressTimer = setTimeout(() => {
        this.showDurationMenu();
      }, 800);
    });
    this.timeCapsuleButton.addEventListener("mouseup", () => {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    });
    this.timeCapsuleButton.addEventListener("mouseleave", () => {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    });
  }
  // 创建颜色筛选器
  createColorFilter(container) {
    this.colorFilterContainer = container.createDiv("canvas-grid-color-filter");
    const allBtn = this.colorFilterContainer.createDiv("canvas-grid-color-dot all-colors");
    allBtn.title = "\u663E\u793A\u5168\u90E8\u989C\u8272";
    allBtn.classList.add("active");
    allBtn.style.background = "conic-gradient(from 45deg, #ff6b6b 0deg 45deg, #ffa726 45deg 90deg, #ffeb3b 90deg 135deg, #66bb6a 135deg 180deg, #26c6da 180deg 225deg, #42a5f5 225deg 270deg, #ab47bc 270deg 315deg, #ff6b6b 315deg 360deg)";
    allBtn.style.boxShadow = "0 0 0 1px rgba(255, 255, 255, 0.3), inset 0 0 0 1px rgba(0, 0, 0, 0.1)";
    allBtn.style.position = "relative";
    allBtn.addEventListener("click", () => {
      this.setColorFilter(null);
    });
    this.settings.colorFilterColors.forEach((colorValue) => {
      const colorDot = this.colorFilterContainer.createDiv("canvas-grid-color-dot");
      colorDot.dataset.color = colorValue;
      const colorMap = {
        "1": "#ff6b6b",
        // 红色
        "2": "#ffa726",
        // 橙色
        "3": "#ffeb3b",
        // 黄色
        "4": "#66bb6a",
        // 绿色
        "5": "#26c6da",
        // 青色
        "6": "#42a5f5",
        // 蓝色
        "7": "#ab47bc"
        // 紫色
      };
      const color = colorMap[colorValue];
      if (color) {
        colorDot.style.backgroundColor = color;
        colorDot.style.borderColor = color;
      }
      const colorCategory = this.settings.colorCategories.find((cat) => cat.color === colorValue);
      if (colorCategory) {
        colorDot.title = this.settings.language === "zh" ? `\u7B5B\u9009${colorCategory.name}\u5361\u7247` : `Filter ${colorCategory.name} cards`;
      } else {
        const colorNames = this.settings.language === "zh" ? ["\u7EA2", "\u6A59", "\u9EC4", "\u7EFF", "\u9752", "\u84DD", "\u7D2B"] : ["Red", "Orange", "Yellow", "Green", "Cyan", "Blue", "Purple"];
        const index = parseInt(colorValue) - 1;
        if (index >= 0 && index < colorNames.length) {
          colorDot.title = this.settings.language === "zh" ? `\u7B5B\u9009${colorNames[index]}\u8272\u5361\u7247` : `Filter ${colorNames[index]} cards`;
        }
      }
      colorDot.addEventListener("click", () => {
        this.setColorFilter(colorValue);
      });
    });
  }
  // 设置颜色筛选器（互斥选择）
  setColorFilter(color) {
    DebugManager.log("\u8BBE\u7F6E\u989C\u8272\u7B5B\u9009\u5668:", color);
    if (this.activeColorFilter === color) {
      this.activeColorFilter = null;
      color = null;
      DebugManager.log("\u53D6\u6D88\u5F53\u524D\u989C\u8272\u7B5B\u9009\uFF0C\u56DE\u5230\u663E\u793A\u5168\u90E8");
    } else {
      this.activeColorFilter = color;
    }
    if (this.colorFilterContainer) {
      const dots = this.colorFilterContainer.querySelectorAll(".canvas-grid-color-dot");
      DebugManager.log("\u627E\u5230\u989C\u8272\u5706\u70B9\u6570\u91CF:", dots.length);
      dots.forEach((dot) => {
        dot.classList.remove("active");
      });
      if (color === null) {
        const allBtn = this.colorFilterContainer.querySelector(".all-colors");
        if (allBtn) {
          allBtn.classList.add("active");
          DebugManager.log('\u6FC0\u6D3B"\u5168\u90E8"\u6309\u94AE');
        }
      } else {
        const targetDot = this.colorFilterContainer.querySelector(`[data-color="${color}"]`);
        if (targetDot) {
          targetDot.classList.add("active");
          DebugManager.log("\u6FC0\u6D3B\u989C\u8272\u5706\u70B9:", color);
        }
      }
    }
    DebugManager.log("\u6267\u884C\u989C\u8272\u7B5B\u9009\uFF0C\u5F53\u524D\u7B5B\u9009\u989C\u8272:", this.activeColorFilter);
    this.performSearch();
  }
  // ==================== 时间胶囊功能方法 ====================
  // 更新时间胶囊按钮显示
  updateTimeCapsuleButton() {
    if (!this.timeCapsuleButton)
      return;
    const state = this.timeCapsuleState;
    if (state.isActive) {
      const minutes = Math.floor(state.remainingTime / 6e4);
      const seconds = Math.floor(state.remainingTime % 6e4 / 1e3);
      const timeText = `${minutes}:${seconds.toString().padStart(2, "0")}`;
      let colorClass = "active";
      if (state.remainingTime < 6e4) {
        colorClass = "warning";
      }
      this.timeCapsuleButton.className = `canvas-grid-time-capsule-btn ${colorClass}`;
      while (this.timeCapsuleButton.firstChild) {
        this.timeCapsuleButton.removeChild(this.timeCapsuleButton.firstChild);
      }
      const iconContainer = this.timeCapsuleButton.createSpan();
      SVGIconManager.setIcon(iconContainer, "timeCapsule");
      const timeDisplay = this.timeCapsuleButton.createSpan("time-display");
      timeDisplay.textContent = timeText;
      this.timeCapsuleButton.title = `\u65F6\u95F4\u80F6\u56CA\u6536\u96C6\u4E2D - \u5269\u4F59 ${timeText}`;
    } else {
      this.timeCapsuleButton.className = "canvas-grid-time-capsule-btn";
      while (this.timeCapsuleButton.firstChild) {
        this.timeCapsuleButton.removeChild(this.timeCapsuleButton.firstChild);
      }
      const iconContainer = this.timeCapsuleButton.createSpan();
      SVGIconManager.setIcon(iconContainer, "timeCapsule");
      this.timeCapsuleButton.title = "\u65F6\u95F4\u80F6\u56CA - \u70B9\u51FB\u5F00\u59CB\u6536\u96C6";
    }
  }
  // 切换时间胶囊状态（私有方法，供按钮点击使用）
  toggleTimeCapsuleInternal() {
    if (this.timeCapsuleState.isActive) {
      this.stopTimeCapsule();
    } else {
      this.startTimeCapsule();
    }
  }
  // 开始时间胶囊
  startTimeCapsule() {
    const duration = this.timeCapsuleState.duration;
    const now = Date.now();
    const groupName = `\u65F6\u95F4\u80F6\u56CA ${(/* @__PURE__ */ new Date()).toLocaleString("zh-CN", {
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit"
    })}`;
    this.timeCapsuleState = {
      isActive: true,
      startTime: now,
      duration,
      remainingTime: duration,
      groupId: null,
      // 稍后创建分组时设置
      collectedItems: [],
      groupName
    };
    this.createTimeCapsuleGroup();
    this.startTimeCapsuleTimer();
    this.renderGrid().catch((error) => {
      DebugManager.error("Failed to render grid after starting time capsule:", error);
    });
    new import_obsidian12.Notice(`\u65F6\u95F4\u80F6\u56CA\u5DF2\u542F\u52A8\uFF01\u6536\u96C6\u65F6\u957F\uFF1A${Math.floor(duration / 6e4)}\u5206\u949F`);
    DebugManager.log("\u65F6\u95F4\u80F6\u56CA\u5DF2\u542F\u52A8\uFF0C\u7F51\u683C\u89C6\u56FE\u5DF2\u5237\u65B0:", this.timeCapsuleState);
  }
  // 停止时间胶囊
  stopTimeCapsule() {
    if (this.timeCapsuleTimer) {
      clearTimeout(this.timeCapsuleTimer);
      this.timeCapsuleTimer = null;
    }
    if (this.timeCapsuleUpdateInterval) {
      clearInterval(this.timeCapsuleUpdateInterval);
      this.timeCapsuleUpdateInterval = null;
    }
    const collectedCount = this.timeCapsuleState.collectedItems.length;
    this.timeCapsuleState = {
      isActive: false,
      startTime: 0,
      duration: 15 * 60 * 1e3,
      remainingTime: 0,
      groupId: null,
      collectedItems: [],
      groupName: ""
    };
    this.updateTimeCapsuleButton();
    this.updateAllPanelTimeCapsules();
    this.renderGrid().catch((error) => {
      DebugManager.error("Failed to render grid after ending time capsule:", error);
    });
    new import_obsidian12.Notice(`\u65F6\u95F4\u80F6\u56CA\u5DF2\u7ED3\u675F\uFF01\u5171\u6536\u96C6\u4E86 ${collectedCount} \u4E2A\u9879\u76EE`);
    DebugManager.log("\u65F6\u95F4\u80F6\u56CA\u5DF2\u505C\u6B62\uFF0C\u7F51\u683C\u89C6\u56FE\u5DF2\u5237\u65B0");
  }
  // 开始倒计时定时器
  startTimeCapsuleTimer() {
    this.timeCapsuleTimer = setTimeout(() => {
      this.stopTimeCapsule();
    }, this.timeCapsuleState.duration);
    this.timeCapsuleUpdateInterval = setInterval(() => {
      const elapsed = Date.now() - this.timeCapsuleState.startTime;
      this.timeCapsuleState.remainingTime = Math.max(0, this.timeCapsuleState.duration - elapsed);
      this.updateTimeCapsuleButton();
      this.updateTimeCapsuleGroupDisplay();
      this.updateAllPanelTimeCapsules();
      if (this.timeCapsuleState.remainingTime <= 0) {
        this.stopTimeCapsule();
      }
    }, 1e3);
  }
  // 创建时间胶囊分组
  createTimeCapsuleGroup() {
    if (!this.canvasData) {
      DebugManager.warn("\u65E0\u6CD5\u521B\u5EFA\u65F6\u95F4\u80F6\u56CA\u5206\u7EC4\uFF1ACanvas\u6570\u636E\u4E0D\u5B58\u5728");
      return;
    }
    const groupId = `time-capsule-${Date.now()}`;
    const timeCapsuleSize = { width: GRID_CONSTANTS.LARGE_CARD_WIDTH, height: 300 };
    const position = this.findSafePositionForTimeCapsule(timeCapsuleSize);
    DebugManager.log(`\u{1F3AF} \u65F6\u95F4\u80F6\u56CA\u5206\u7EC4\u4F4D\u7F6E\u8BA1\u7B97\u5B8C\u6210: (${position.x}, ${position.y})`);
    const groupNode = {
      id: groupId,
      type: "group",
      x: position.x,
      y: position.y,
      width: timeCapsuleSize.width,
      height: timeCapsuleSize.height,
      color: "5",
      // 青色 - 时间胶囊主题色
      label: this.timeCapsuleState.groupName
    };
    this.canvasData.nodes.push(groupNode);
    this.timeCapsuleState.groupId = groupId;
    this.saveCanvasData();
    DebugManager.log("\u65F6\u95F4\u80F6\u56CA\u5206\u7EC4\u5DF2\u521B\u5EFA:", groupId, "\u4F4D\u7F6E:", position);
  }
  // 为时间胶囊分组寻找安全位置，避免与现有分组重叠
  findSafePositionForTimeCapsule(size) {
    if (!this.canvasData) {
      return { x: 100, y: 100 };
    }
    const existingGroups = this.canvasData.nodes.filter((node) => node.type === "group");
    DebugManager.log(`\u{1F4CA} \u68C0\u6D4B\u5230 ${existingGroups.length} \u4E2A\u73B0\u6709\u5206\u7EC4`);
    const candidatePositions = [
      { x: 50, y: 50 },
      // 左上角
      { x: 500, y: 50 },
      // 右上角
      { x: 50, y: 400 },
      // 左下角
      { x: 500, y: 400 },
      // 右下角
      { x: 250, y: 50 },
      // 顶部中央
      { x: 50, y: 225 },
      // 左侧中央
      { x: 500, y: 225 },
      // 右侧中央
      { x: 250, y: 400 },
      // 底部中央
      { x: 800, y: 50 },
      // 更右上角
      { x: 800, y: 400 }
      // 更右下角
    ];
    for (const candidate of candidatePositions) {
      if (this.isPositionSafe(candidate, size, existingGroups)) {
        DebugManager.log(`\u2705 \u627E\u5230\u5B89\u5168\u4F4D\u7F6E: (${candidate.x}, ${candidate.y})`);
        return candidate;
      }
    }
    const dynamicPosition = this.findDynamicSafePosition(size, existingGroups);
    if (dynamicPosition) {
      DebugManager.log(`\u{1F50D} \u52A8\u6001\u627E\u5230\u5B89\u5168\u4F4D\u7F6E: (${dynamicPosition.x}, ${dynamicPosition.y})`);
      return dynamicPosition;
    }
    const fallbackPosition = { x: 1e3, y: 50 };
    DebugManager.log(`\u26A0\uFE0F \u4F7F\u7528\u5907\u7528\u4F4D\u7F6E: (${fallbackPosition.x}, ${fallbackPosition.y})`);
    return fallbackPosition;
  }
  // 检查指定位置是否安全（不与现有分组重叠）
  isPositionSafe(position, size, existingGroups) {
    const newGroupBounds = {
      left: position.x,
      top: position.y,
      right: position.x + size.width,
      bottom: position.y + size.height
    };
    for (const group of existingGroups) {
      const groupBounds = {
        left: group.x,
        top: group.y,
        right: group.x + (group.width || 200),
        bottom: group.y + (group.height || 200)
      };
      const isOverlapping = !(newGroupBounds.right < groupBounds.left || newGroupBounds.left > groupBounds.right || newGroupBounds.bottom < groupBounds.top || newGroupBounds.top > groupBounds.bottom);
      if (isOverlapping) {
        DebugManager.log(`\u274C \u4F4D\u7F6E (${position.x}, ${position.y}) \u4E0E\u5206\u7EC4 ${group.id} \u91CD\u53E0`);
        return false;
      }
    }
    return true;
  }
  // 动态寻找安全位置
  findDynamicSafePosition(size, existingGroups) {
    const canvasBounds = this.calculateCanvasBounds(existingGroups);
    const rightSideX = canvasBounds.maxX + 100;
    const testPosition = { x: rightSideX, y: 50 };
    if (this.isPositionSafe(testPosition, size, existingGroups)) {
      return testPosition;
    }
    const bottomY = canvasBounds.maxY + 100;
    const bottomPosition = { x: 50, y: bottomY };
    if (this.isPositionSafe(bottomPosition, size, existingGroups)) {
      return bottomPosition;
    }
    const gridStep = 50;
    for (let x = 50; x <= 1200; x += gridStep) {
      for (let y = 50; y <= 800; y += gridStep) {
        const gridPosition = { x, y };
        if (this.isPositionSafe(gridPosition, size, existingGroups)) {
          return gridPosition;
        }
      }
    }
    return null;
  }
  // 计算Canvas的使用边界
  calculateCanvasBounds(existingGroups) {
    if (existingGroups.length === 0) {
      return { minX: 0, minY: 0, maxX: 0, maxY: 0 };
    }
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    existingGroups.forEach((group) => {
      const left = group.x;
      const top = group.y;
      const right = group.x + (group.width || 200);
      const bottom = group.y + (group.height || 200);
      minX = Math.min(minX, left);
      minY = Math.min(minY, top);
      maxX = Math.max(maxX, right);
      maxY = Math.max(maxY, bottom);
    });
    DebugManager.log(`\u{1F4D0} Canvas\u4F7F\u7528\u8FB9\u754C: (${minX}, ${minY}) \u5230 (${maxX}, ${maxY})`);
    return { minX, minY, maxX, maxY };
  }
  // 更新时间胶囊分组显示
  updateTimeCapsuleGroupDisplay() {
    if (!this.timeCapsuleState.isActive || !this.timeCapsuleState.groupId)
      return;
    const groupCard = this.gridContainer.querySelector(`[data-node-id="${this.timeCapsuleState.groupId}"]`);
    if (!groupCard)
      return;
    const countInfo = groupCard.querySelector(".time-capsule-count-info");
    if (countInfo) {
      const minutes = Math.floor(this.timeCapsuleState.remainingTime / 6e4);
      const seconds = Math.floor(this.timeCapsuleState.remainingTime % 6e4 / 1e3);
      const timeText = `${minutes}:${seconds.toString().padStart(2, "0")}`;
      const collectedCount = this.timeCapsuleState.collectedItems.length;
      countInfo.innerHTML = `
				<div class="countdown-display">${timeText}</div>
				<div class="item-count-text">${collectedCount} \u4E2A\u9879\u76EE</div>
			`;
    }
    if (this.timeCapsuleState.remainingTime < 6e4) {
      groupCard.classList.add("time-capsule-urgent");
    }
  }
  // 获取时间胶囊最大收集数量（基于时长）
  getMaxCollectionCount() {
    const durationMinutes = Math.floor(this.timeCapsuleState.duration / 6e4);
    return Math.max(10, durationMinutes * 2);
  }
  // 显示时长选择菜单
  showDurationMenu() {
    const menu = document.createElement("div");
    menu.className = "canvas-grid-duration-menu";
    const durations = [
      { label: "5\u5206\u949F", value: 5 * 60 * 1e3 },
      { label: "15\u5206\u949F", value: 15 * 60 * 1e3 },
      { label: "30\u5206\u949F", value: 30 * 60 * 1e3 },
      { label: "1\u5C0F\u65F6", value: 60 * 60 * 1e3 }
    ];
    durations.forEach((duration) => {
      const item = menu.createDiv("duration-menu-item");
      item.textContent = duration.label;
      item.onclick = () => {
        this.timeCapsuleState.duration = duration.value;
        menu.remove();
        new import_obsidian12.Notice(`\u65F6\u95F4\u80F6\u56CA\u65F6\u957F\u8BBE\u7F6E\u4E3A\uFF1A${duration.label}`);
      };
    });
    const buttonRect = this.timeCapsuleButton.getBoundingClientRect();
    menu.style.position = "fixed";
    menu.style.top = `${buttonRect.bottom + 5}px`;
    menu.style.left = `${buttonRect.left}px`;
    menu.style.zIndex = "1000";
    document.body.appendChild(menu);
    const closeMenu = (e) => {
      if (!menu.contains(e.target)) {
        menu.remove();
        document.removeEventListener("click", closeMenu);
      }
    };
    setTimeout(() => document.addEventListener("click", closeMenu), 100);
  }
  // 检查时间胶囊是否激活
  isTimeCapsuleActive() {
    return this.timeCapsuleState.isActive;
  }
  // 收集内容到时间胶囊
  collectToTimeCapsule(content, sourceInfo) {
    if (!this.timeCapsuleState.isActive || !this.timeCapsuleState.groupId) {
      DebugManager.warn("\u65F6\u95F4\u80F6\u56CA\u672A\u6FC0\u6D3B\u6216\u5206\u7EC4\u4E0D\u5B58\u5728");
      return;
    }
    const nodeId = `collected-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
    const timestamp = (/* @__PURE__ */ new Date()).toLocaleTimeString();
    let nodeText = content;
    if (sourceInfo.sourcePath && sourceInfo.sourcePath !== "\u526A\u8D34\u677F") {
      const fileName = sourceInfo.sourcePath.split("/").pop()?.replace(".md", "") || sourceInfo.sourcePath;
      nodeText += `

---
\u{1F4CD} \u6765\u6E90: [[${fileName}]]`;
      if (sourceInfo.sourcePosition) {
        nodeText += ` (\u884C ${sourceInfo.sourcePosition.line + 1})`;
      }
    }
    nodeText += `
\u23F0 \u6536\u96C6\u65F6\u95F4: ${timestamp}`;
    const groupNode = this.canvasData?.nodes.find((n) => n.id === this.timeCapsuleState.groupId);
    if (!groupNode) {
      DebugManager.warn("\u627E\u4E0D\u5230\u65F6\u95F4\u80F6\u56CA\u5206\u7EC4");
      return;
    }
    const itemIndex = this.timeCapsuleState.collectedItems.length;
    const nodeX = groupNode.x + 20 + itemIndex % 2 * 180;
    const nodeY = groupNode.y + 50 + Math.floor(itemIndex / 2) * 120;
    const newNode = {
      id: nodeId,
      type: "text",
      x: nodeX,
      y: nodeY,
      width: 160,
      height: 100,
      color: "5",
      // 青色标记为收集的内容
      text: nodeText
    };
    if (this.canvasData) {
      this.canvasData.nodes.push(newNode);
      this.timeCapsuleState.collectedItems.push(nodeId);
      this.saveCanvasData();
      if (this.currentGroupView) {
        DebugManager.log("\u65F6\u95F4\u80F6\u56CA\u6536\u96C6\uFF1A\u5728\u5206\u7EC4\u89C6\u56FE\u4E2D\uFF0C\u91CD\u65B0\u5206\u6790\u5206\u7EC4");
        this.analyzeGroups();
        this.enterGroupView(this.currentGroupView);
      } else {
        this.renderGrid().catch((error) => {
          DebugManager.error("Failed to render grid after data update:", error);
        });
      }
      this.updateTimeCapsuleGroupDisplay();
      new import_obsidian12.Notice(`\u5DF2\u6536\u96C6\u5230\u65F6\u95F4\u80F6\u56CA (${this.timeCapsuleState.collectedItems.length}/${this.getMaxCollectionCount()})`);
      DebugManager.log("\u5185\u5BB9\u5DF2\u6536\u96C6\u5230\u65F6\u95F4\u80F6\u56CA:", nodeId);
    }
  }
  // 公开切换时间胶囊方法
  toggleTimeCapsule() {
    if (this.timeCapsuleState.isActive) {
      this.stopTimeCapsule();
    } else {
      this.startTimeCapsule();
    }
  }
  // 获取当前编辑卡片
  getCurrentEditingCard() {
    return this.currentEditingCard;
  }
  // 更新颜色筛选器（公共方法）
  updateColorFilter() {
    if (this.colorFilterContainer) {
      this.colorFilterContainer.remove();
      this.colorFilterContainer = null;
    }
    const container = this.containerEl.children[1];
    if (!container) {
      DebugManager.error("Canvasgrid Transit: Container element not found");
      return;
    }
    const colorPanel = container.querySelector(".color-dots-panel");
    if (colorPanel) {
      this.createColorFilter(colorPanel);
    } else {
      DebugManager.warn("Canvasgrid Transit: Color panel not found, recreating toolbar");
      const toolbar = container.querySelector(".canvas-grid-toolbar");
      if (toolbar) {
        toolbar.remove();
      }
      this.createToolbar(container);
    }
  }
  // 视图选项方法已移除，功能已整合到主菜单
  // ==================== 搜索和排序功能实现 ====================
  // 执行搜索（优化版本，减少不必要的重新渲染）
  performSearch() {
    if (!this.canvasData) {
      this.filteredNodes = [];
      this.applySortAndFilter();
      return;
    }
    DebugManager.log(`\u{1F50D} Performing search with query: "${this.searchQuery}", currentGroupView: ${this.currentGroupView}`);
    const previousFilteredNodes = [...this.filteredNodes];
    let baseNodes;
    if (this.currentGroupView) {
      const groupInfo = this.groupAnalysis.get(this.currentGroupView);
      baseNodes = groupInfo ? groupInfo.members : [];
      DebugManager.log(`\u5206\u7EC4\u89C6\u56FE\u641C\u7D22\uFF0C\u57FA\u7840\u8282\u70B9\u6570\u91CF: ${baseNodes.length}`);
    } else {
      baseNodes = this.getAllSearchableNodes();
      DebugManager.log(`\u4E3B\u89C6\u56FE\u641C\u7D22\uFF0C\u57FA\u7840\u8282\u70B9\u6570\u91CF: ${baseNodes.length}`);
    }
    let searchResults;
    if (!this.searchQuery || this.searchQuery.trim() === "") {
      if (this.currentGroupView) {
        searchResults = baseNodes;
      } else {
        searchResults = this.getAllDisplayNodes();
        DebugManager.log("\u4E3B\u89C6\u56FE\u65E0\u641C\u7D22\uFF0C\u663E\u793A\u6240\u6709\u8282\u70B9:", searchResults.length);
      }
      DebugManager.log("\u65E0\u641C\u7D22\u67E5\u8BE2\uFF0C\u4F7F\u7528\u57FA\u7840\u8282\u70B9:", searchResults.length);
    } else {
      const query = this.searchQuery.toLowerCase().trim();
      searchResults = baseNodes.filter((node) => {
        if (node.text && node.text.toLowerCase().includes(query)) {
          return true;
        }
        if (node.file && node.file.toLowerCase().includes(query)) {
          return true;
        }
        if (node.url && node.url.toLowerCase().includes(query)) {
          return true;
        }
        return false;
      });
      DebugManager.log(`\u641C\u7D22 "${query}" \u5728${this.currentGroupView ? "\u5206\u7EC4" : "\u4E3B\u89C6\u56FE"}\u4E2D\u627E\u5230 ${searchResults.length} \u4E2A\u7ED3\u679C`);
    }
    DebugManager.log("\u5E94\u7528\u989C\u8272\u7B5B\u9009\uFF0C\u5F53\u524D\u7B5B\u9009\u989C\u8272:", this.activeColorFilter);
    if (this.activeColorFilter !== null) {
      this.filteredNodes = searchResults.filter((node) => {
        if (node.type === "group") {
          return false;
        }
        const matches = node.color === this.activeColorFilter;
        DebugManager.log(`\u8282\u70B9 ${node.id} \u989C\u8272 ${node.color} ${matches ? "\u5339\u914D" : "\u4E0D\u5339\u914D"} \u7B5B\u9009\u5668 ${this.activeColorFilter}`);
        return matches;
      });
      if (!this.currentGroupView) {
        const groupMembersWithColor = this.getGroupMembersWithColor(this.activeColorFilter);
        const allMatchingNodes = [...this.filteredNodes, ...groupMembersWithColor];
        const uniqueNodes = allMatchingNodes.filter(
          (node, index, arr) => arr.findIndex((n) => n.id === node.id) === index
        );
        this.filteredNodes = uniqueNodes;
        DebugManager.log(`\u989C\u8272\u7B5B\u9009 [${this.activeColorFilter}] \u7ED3\u679C:`, {
          nonGroupMembers: this.filteredNodes.length - groupMembersWithColor.length,
          groupMembers: groupMembersWithColor.length,
          total: this.filteredNodes.length
        });
      } else {
        DebugManager.log("\u5206\u7EC4\u89C6\u56FE\u989C\u8272\u7B5B\u9009\u540E\u8282\u70B9\u6570\u91CF:", this.filteredNodes.length);
      }
    } else {
      this.filteredNodes = searchResults;
      DebugManager.log("\u6DF7\u5408\u8272\u6A21\u5F0F\uFF0C\u4F7F\u7528\u6240\u6709\u641C\u7D22\u7ED3\u679C:", this.filteredNodes.length);
    }
    DebugManager.log(`\u{1F4CA} Final filtered nodes: ${this.filteredNodes.length}, applying sort...`);
    this.applySortAndFilter();
  }
  // 获取所有可搜索的节点（包括分组内的成员节点）
  getAllSearchableNodes() {
    if (!this.canvasData)
      return [];
    return this.canvasData.nodes.filter((node) => node.type !== "group");
  }
  // 获取非分组成员节点（主视图默认显示的节点）
  getNonGroupMemberNodes() {
    if (!this.canvasData)
      return [];
    this.analyzeGroups();
    const groupMemberIds = /* @__PURE__ */ new Set();
    this.groupAnalysis.forEach((groupInfo) => {
      groupInfo.members.forEach((member) => {
        groupMemberIds.add(member.id);
      });
    });
    return this.canvasData.nodes.filter(
      (node) => node.type !== "group" && !groupMemberIds.has(node.id)
    );
  }
  // 获取所有显示节点（包括分组卡片和非分组成员节点）
  getAllDisplayNodes() {
    if (!this.canvasData)
      return [];
    this.analyzeGroups();
    const groupMemberIds = /* @__PURE__ */ new Set();
    this.groupAnalysis.forEach((groupInfo) => {
      groupInfo.members.forEach((member) => {
        groupMemberIds.add(member.id);
      });
    });
    return this.canvasData.nodes.filter((node) => {
      if (node.type === "group") {
        return true;
      }
      return !groupMemberIds.has(node.id);
    });
  }
  // 根据颜色筛选获取分组内匹配的成员节点
  getGroupMembersWithColor(colorFilter) {
    if (!this.canvasData || !colorFilter)
      return [];
    const matchingMembers = [];
    this.groupAnalysis.forEach((groupInfo) => {
      const colorMatchingMembers = groupInfo.members.filter(
        (member) => member.color === colorFilter
      );
      matchingMembers.push(...colorMatchingMembers);
    });
    return matchingMembers;
  }
  // 获取节点所属的分组信息
  getNodeGroupInfo(nodeId) {
    for (const [groupId, groupInfo] of this.groupAnalysis) {
      if (groupInfo.members.some((member) => member.id === nodeId)) {
        return {
          groupId,
          groupName: groupInfo.group.label || "\u672A\u547D\u540D\u5206\u7EC4"
        };
      }
    }
    return null;
  }
  // 为分组内的卡片添加分组标识
  addGroupBadgeToCard(card, groupName) {
    const badge = document.createElement("div");
    badge.className = "canvas-grid-group-badge";
    badge.textContent = `\u{1F4C1} ${groupName}`;
    badge.title = `\u6B64\u5361\u7247\u5C5E\u4E8E\u5206\u7EC4: ${groupName}`;
    card.style.position = "relative";
    card.appendChild(badge);
  }
  // 添加分组来源标识到卡片左下角
  addGroupSourceIndicator(card, groupInfo) {
    const indicator = document.createElement("div");
    indicator.className = "canvas-grid-card-group-source";
    indicator.innerHTML = `
			<div class="group-source-icon">\u{1F4C1}</div>
			<div class="group-source-text">${groupInfo.groupName}</div>
		`;
    indicator.title = `\u6765\u81EA\u5206\u7EC4: ${groupInfo.groupName}`;
    indicator.dataset.groupId = groupInfo.groupId;
    card.style.position = "relative";
    card.appendChild(indicator);
    indicator.addEventListener("click", (e) => {
      e.stopPropagation();
      this.enterGroupView(groupInfo.groupId);
    });
  }
  // 比较两个数组是否相等（基于节点ID）
  arraysEqual(arr1, arr2) {
    if (arr1.length !== arr2.length)
      return false;
    const ids1 = arr1.map((node) => node.id).sort();
    const ids2 = arr2.map((node) => node.id).sort();
    return ids1.every((id, index) => id === ids2[index]);
  }
  // 应用排序和筛选
  applySortAndFilter() {
    if (!this.filteredNodes || this.filteredNodes.length === 0) {
      this.renderGrid().catch((error) => {
        DebugManager.error("Failed to render empty grid:", error);
      });
      return;
    }
    DebugManager.log(`\u{1F504} Applying sort with pinned priority: ${this.sortBy} (${this.sortOrder}) to ${this.filteredNodes.length} nodes`);
    this.filteredNodes.sort((a, b) => {
      const aExtended = a;
      const bExtended = b;
      const aIsPinned = this.detectPinnedStatus(a);
      const bIsPinned = this.detectPinnedStatus(b);
      if (aIsPinned && !bIsPinned)
        return -1;
      if (!aIsPinned && bIsPinned)
        return 1;
      if (aIsPinned && bIsPinned) {
        const aPinnedAt = aExtended.pinnedAt || 0;
        const bPinnedAt = bExtended.pinnedAt || 0;
        return bPinnedAt - aPinnedAt;
      }
      let comparison = 0;
      try {
        switch (this.sortBy) {
          case "created":
            const timeA = this.extractTimestamp(a.id);
            const timeB = this.extractTimestamp(b.id);
            comparison = timeA - timeB;
            break;
          case "modified":
            const modA = a.modified || this.extractTimestamp(a.id);
            const modB = b.modified || this.extractTimestamp(b.id);
            comparison = modA - modB;
            break;
          case "title":
            const titleA = this.getNodeTitle(a).toLowerCase();
            const titleB = this.getNodeTitle(b).toLowerCase();
            comparison = titleA.localeCompare(titleB);
            break;
          default:
            const defaultTimeA = this.extractTimestamp(a.id);
            const defaultTimeB = this.extractTimestamp(b.id);
            comparison = defaultTimeA - defaultTimeB;
            break;
        }
      } catch (error) {
        DebugManager.error("\u6392\u5E8F\u8FC7\u7A0B\u4E2D\u51FA\u9519:", error);
        comparison = a.id.localeCompare(b.id);
      }
      return this.sortOrder === "asc" ? comparison : -comparison;
    });
    DebugManager.log(`\u2705 Sort completed. First node: ${this.getNodeTitle(this.filteredNodes[0])}`);
    this.renderGrid().catch((error) => {
      DebugManager.error("Failed to render grid after sorting:", error);
    });
  }
  // 提取时间戳
  extractTimestamp(nodeId) {
    const match = nodeId.match(/(\d{13})/);
    return match ? parseInt(match[1]) : 0;
  }
  // 获取节点标题
  getNodeTitle(node) {
    if (node.text) {
      return node.text.split("\n")[0].substring(0, SEARCH_CONSTANTS.MAX_PREVIEW_LENGTH);
    }
    if (node.file) {
      return node.file;
    }
    if (node.url) {
      return node.url;
    }
    return "Untitled";
  }
  // 强制刷新排序（用于数据更新后）
  refreshSort() {
    DebugManager.log("\u{1F504} Refreshing sort...");
    if (!this.canvasData) {
      return;
    }
    this.filteredNodes = [...this.canvasData.nodes];
    this.performSearch();
  }
  // 应用类型筛选
  applyTypeFilter(filterType) {
    if (!this.canvasData)
      return;
    if (filterType === "all") {
      this.filteredNodes = [...this.canvasData.nodes];
    } else {
      this.filteredNodes = this.canvasData.nodes.filter((node) => {
        return node.type === filterType;
      });
    }
    if (this.searchQuery) {
      this.performSearch();
    } else {
      this.applySortAndFilter();
    }
  }
  // 卡片大小调整方法已移除
  // 隐藏所有下拉菜单
  hideAllDropdowns() {
    const mainDropdowns = this.containerEl.querySelectorAll(".canvas-grid-main-dropdown");
    mainDropdowns.forEach((dropdown) => {
      dropdown.style.display = "none";
    });
    const multiMenuButtons = this.containerEl.querySelectorAll(".multi-menu-btn");
    multiMenuButtons.forEach((btn) => {
      btn.classList.remove("active");
    });
    const oldMainButtons = this.containerEl.querySelectorAll(".canvas-grid-main-btn");
    oldMainButtons.forEach((btn) => {
      btn.classList.remove("active");
    });
    this.closeAllSubmenus();
  }
  // 隐藏下拉菜单
  hideDropdownMenu(dropdownMenu) {
    dropdownMenu.style.display = "none";
  }
  // 切换下拉菜单
  toggleDropdownMenu(dropdownMenu) {
    const isVisible = dropdownMenu.style.display !== "none";
    if (isVisible) {
      dropdownMenu.style.display = "none";
    } else {
      dropdownMenu.style.display = "block";
    }
  }
  // 显示空状态
  showEmptyState() {
    const emptyEl = this.gridContainer.createDiv("canvas-grid-empty-state");
    emptyEl.innerHTML = `
			<div class="empty-icon">\u{1F4C4}</div>
			<div class="empty-title">\u6CA1\u6709Canvas\u8282\u70B9</div>
			<div class="empty-desc">\u5F53\u524DCanvas\u6587\u4EF6\u4E2D\u6CA1\u6709\u8282\u70B9\uFF0C\u8BF7\u5148\u5728Canvas\u4E2D\u6DFB\u52A0\u4E00\u4E9B\u5185\u5BB9</div>
		`;
  }
  // 创建菜单区域 (已整合到主菜单，保留以防兼容性问题)
  createMenuSection(container) {
    return;
    const menuSection = container.createDiv("canvas-grid-toolbar-menu");
    const menuBtn = menuSection.createDiv("canvas-grid-menu-btn");
    menuBtn.innerHTML = `
			<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<circle cx="12" cy="12" r="1"/>
				<circle cx="12" cy="5" r="1"/>
				<circle cx="12" cy="19" r="1"/>
			</svg>
		`;
    menuBtn.title = "\u66F4\u591A\u9009\u9879";
    const dropdownMenu = menuSection.createDiv("canvas-grid-dropdown-menu");
    dropdownMenu.style.display = "none";
    const backMenuItem = dropdownMenu.createDiv("canvas-grid-menu-item");
    backMenuItem.innerHTML = `
			<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<path d="m12 19-7-7 7-7"/>
				<path d="m19 12H5"/>
			</svg>
			<span>\u8FD4\u56DECanvas</span>
		`;
    backMenuItem.onclick = () => {
      this.switchToCanvasView();
      this.hideDropdownMenu(dropdownMenu);
    };
    const refreshMenuItem = dropdownMenu.createDiv("canvas-grid-menu-item");
    refreshMenuItem.innerHTML = `
			<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/>
				<path d="M21 3v5h-5"/>
				<path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/>
				<path d="M3 21v-5h5"/>
			</svg>
			<span>\u5237\u65B0</span>
		`;
    refreshMenuItem.onclick = () => {
      this.refreshCanvasData();
      this.hideDropdownMenu(dropdownMenu);
    };
    const settingsMenuItem = dropdownMenu.createDiv("canvas-grid-menu-item");
    settingsMenuItem.innerHTML = `
			<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<circle cx="12" cy="12" r="3"/>
				<path d="m12 1 1.27 2.22 2.22 1.27-1.27 2.22L12 8.5l-1.27-2.22L8.5 5.23l1.27-2.22L12 1"/>
				<path d="m12 15.5 1.27 2.22 2.22 1.27-1.27 2.22L12 22.5l-1.27-2.22L8.5 18.77l1.27-2.22L12 15.5"/>
			</svg>
			<span>\u7F51\u683C\u8BBE\u7F6E</span>
		`;
    settingsMenuItem.onclick = () => {
      this.openGridSettings();
      this.hideDropdownMenu(dropdownMenu);
    };
    menuBtn.onclick = (e) => {
      e.stopPropagation();
      this.toggleDropdownMenu(dropdownMenu);
    };
  }
  // 设置网格样式 - 使用CSS Grid自动布局
  setupGridStyles() {
    this.gridContainer.style.setProperty("--grid-card-spacing", `${CARD_CONSTANTS.spacing}px`);
    this.gridContainer.style.setProperty("--grid-card-min-width", `${CARD_CONSTANTS.width}px`);
    this.gridContainer.style.setProperty("--grid-card-height", `${CARD_CONSTANTS.height}px`);
    this.gridContainer.style.removeProperty("grid-template-columns");
  }
  // 设置事件委托，提升性能
  setupEventDelegation() {
    this.cleanupEventListeners();
    if (!this.gridContainer) {
      DebugManager.error("\u274C Grid container not found, cannot setup event delegation");
      return;
    }
    this.gridContainer.addEventListener("click", this.handleGridClick);
    DebugManager.log("\u{1F3AF} Grid click event listener added");
    this.gridContainer.addEventListener("contextmenu", this.handleCardContextMenu);
    this.gridContainer.addEventListener("keydown", this.handleKeyDown);
    document.addEventListener("click", this.handleDocumentClick);
    DebugManager.log("\u2705 Event delegation setup completed", {
      gridContainer: !!this.gridContainer,
      hasClickListener: true,
      containerTagName: this.gridContainer.tagName,
      containerClassName: this.gridContainer.className
    });
    this.testEventListenerBinding();
    this.setupScrollListener();
    this.setupGridCardDragEvents();
  }
  // 🔧 新增：测试事件监听器绑定
  testEventListenerBinding() {
    if (!this.gridContainer)
      return;
    const testEvent = new MouseEvent("click", {
      bubbles: true,
      cancelable: true,
      view: window
    });
    let testEventReceived = false;
    const originalHandler = this.handleGridClick;
    this.handleGridClick = (e) => {
      if (e === testEvent) {
        testEventReceived = true;
        DebugManager.log("\u{1F9EA} \u6D4B\u8BD5\u4E8B\u4EF6\u76D1\u542C\u5668\uFF1A\u6B63\u5E38\u5DE5\u4F5C");
        return;
      }
      return originalHandler.call(this, e);
    };
    this.gridContainer.dispatchEvent(testEvent);
    this.handleGridClick = originalHandler;
    if (!testEventReceived) {
      DebugManager.error("\u274C \u4E8B\u4EF6\u76D1\u542C\u5668\u6D4B\u8BD5\u5931\u8D25\uFF1A\u672A\u63A5\u6536\u5230\u6D4B\u8BD5\u4E8B\u4EF6");
    }
  }
  // 清理事件监听器
  cleanupEventListeners() {
    if (this.gridContainer) {
      this.gridContainer.removeEventListener("click", this.handleGridClick);
      this.gridContainer.removeEventListener("contextmenu", this.handleCardContextMenu);
      this.gridContainer.removeEventListener("keydown", this.handleKeyDown);
      DebugManager.log("\u{1F9F9} Grid container event listeners removed");
    }
    document.removeEventListener("click", this.handleDocumentClick);
    DebugManager.log("\u{1F9F9} Event listeners cleaned up", {
      hadGridContainer: !!this.gridContainer
    });
  }
  // 设置网格卡片拖拽事件 - 使用HTML5 Drag & Drop API
  setupGridCardDragEvents() {
    this.setupCardDragAttributes();
    this.registerDomEvent(this.gridContainer, "dragstart", this.handleCardDragStart.bind(this));
    this.registerDomEvent(this.gridContainer, "dragend", this.handleCardDragEnd.bind(this));
  }
  // 为卡片设置拖拽属性
  setupCardDragAttributes() {
    const cards = this.gridContainer.querySelectorAll(".canvas-grid-card");
    cards.forEach((card) => {
      card.draggable = false;
      const nodeType = card.dataset.nodeType;
      if (nodeType === "group") {
        card.style.cursor = "pointer";
      } else {
        card.style.cursor = "grab";
      }
      this.setupCardLongPress(card);
    });
  }
  // 设置卡片长按检测
  setupCardLongPress(cardElement) {
    let longPressTimer = null;
    let longPressStartTime = 0;
    const handleMouseDown = (e) => {
      if (e.target.closest(".canvas-card-toolbar")) {
        return;
      }
      longPressStartTime = Date.now();
      longPressTimer = setTimeout(() => {
        cardElement.draggable = true;
        cardElement.style.cursor = "grabbing";
        DebugManager.log("\u{1F525} Long press detected, drag enabled");
        cardElement.classList.add("long-press-active");
      }, 500);
    };
    const handleMouseUp = () => {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
      setTimeout(() => {
      }, PERFORMANCE_CONSTANTS.MINIMAL_DELAY);
    };
    const handleMouseLeave = () => {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    };
    cardElement.addEventListener("mousedown", handleMouseDown);
    cardElement.addEventListener("mouseup", handleMouseUp);
    cardElement.addEventListener("mouseleave", handleMouseLeave);
  }
  // 设置滚动监听，实现功能栏自动隐藏/显示
  setupScrollListener() {
    let lastScrollTop = 0;
    let isToolbarHidden = false;
    let scrollTimeout = null;
    const getContainer = () => {
      return this.containerEl.children[1];
    };
    const getToolbar = () => {
      const container = getContainer();
      return container?.querySelector(".canvas-grid-toolbar");
    };
    const showToolbar = () => {
      const toolbar2 = getToolbar();
      const container = getContainer();
      if (toolbar2 && container && isToolbarHidden) {
        toolbar2.style.position = "relative";
        toolbar2.style.transform = "translateY(0)";
        toolbar2.style.opacity = "1";
        toolbar2.style.zIndex = "100";
        this.gridContainer.classList.remove("toolbar-hidden");
        const viewContent = this.containerEl.querySelector(".view-content");
        if (viewContent) {
          viewContent.classList.remove("toolbar-hidden-parent");
        }
        this.gridContainer.style.removeProperty("margin-top");
        this.gridContainer.style.removeProperty("height");
        isToolbarHidden = false;
      }
    };
    const hideToolbar = () => {
      const toolbar2 = getToolbar();
      const container = getContainer();
      if (toolbar2 && container && !isToolbarHidden) {
        const toolbarHeight = toolbar2.offsetHeight;
        toolbar2.style.position = "fixed";
        toolbar2.style.top = "0";
        toolbar2.style.left = "0";
        toolbar2.style.right = "0";
        toolbar2.style.transform = "translateY(-100%)";
        toolbar2.style.opacity = "0";
        toolbar2.style.zIndex = "100";
        this.gridContainer.classList.add("toolbar-hidden");
        const viewContent = this.containerEl.querySelector(".view-content");
        if (viewContent) {
          viewContent.classList.add("toolbar-hidden-parent");
        }
        this.gridContainer.style.marginTop = `-${toolbarHeight}px`;
        isToolbarHidden = true;
      }
    };
    const handleScroll = () => {
      const currentScrollTop = this.gridContainer.scrollTop;
      const scrollDelta = currentScrollTop - lastScrollTop;
      if (scrollTimeout) {
        clearTimeout(scrollTimeout);
      }
      if (Math.abs(scrollDelta) < 5) {
        return;
      }
      if (currentScrollTop < 50) {
        showToolbar();
      } else {
        if (scrollDelta > 0 && !isToolbarHidden) {
          hideToolbar();
        } else if (scrollDelta < 0 && isToolbarHidden) {
          showToolbar();
        }
      }
      scrollTimeout = setTimeout(() => {
        showToolbar();
      }, 2e3);
      lastScrollTop = currentScrollTop;
    };
    this.gridContainer.addEventListener("scroll", handleScroll, { passive: true });
    const toolbar = getToolbar();
    if (toolbar) {
      toolbar.style.transition = "transform 0.3s ease, opacity 0.3s ease";
      toolbar.style.zIndex = "100";
    }
  }
  // 加载当前活动的Canvas文件 - 优化版本
  async loadActiveCanvas() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile || activeFile.extension !== "canvas") {
      this.showMessage("\u8BF7\u5148\u6253\u5F00\u4E00\u4E2ACanvas\u6587\u4EF6");
      return;
    }
    LoadingManager.startLoading("canvas-load", "Canvas\u52A0\u8F7D", this.gridContainer);
    const errorHandler = ErrorHandler.getInstance();
    const result = await errorHandler.handleAsyncOperation(async () => {
      const content = await this.app.vault.read(activeFile);
      let parsedData;
      try {
        parsedData = JSON.parse(content);
      } catch (parseError) {
        throw new Error("Canvas\u6587\u4EF6\u683C\u5F0F\u65E0\u6548");
      }
      if (!parsedData.nodes || !Array.isArray(parsedData.nodes)) {
        throw new Error("Canvas\u6587\u4EF6\u7F3A\u5C11\u6709\u6548\u7684\u8282\u70B9\u6570\u636E");
      }
      this.canvasData = parsedData;
      this.initializeSearchAndSort();
      DebugManager.log("\u2705 Canvas loaded and sort applied");
      return true;
    }, "Canvas\u52A0\u8F7D", false, false);
    LoadingManager.endLoading("canvas-load");
    if (!result) {
      this.showErrorState("Canvas\u52A0\u8F7D\u5931\u8D25\uFF0C\u8BF7\u68C0\u67E5\u6587\u4EF6\u683C\u5F0F\u6216\u91CD\u8BD5");
    }
  }
  // 🎯 修复：渲染网格视图 - 使用增量更新和数据一致性检查
  async renderGrid() {
    if (!this.gridContainer)
      return;
    DebugManager.log("\u{1F3AF} \u5F00\u59CB\u6E32\u67D3\u7F51\u683C (\u589E\u91CF\u66F4\u65B0\u6A21\u5F0F)");
    await this.validateDOMConsistency();
    if (this.currentGroupView) {
      await this.renderGroupMembers();
      return;
    }
    await this.thoroughCleanup();
    this.analyzeGroups();
    const nodesToRender = this.filteredNodes && this.filteredNodes.length > 0 ? this.filteredNodes : this.canvasData?.nodes || [];
    DebugManager.log("\u{1F3AF} \u6E32\u67D3\u8282\u70B9\u51B3\u7B56 (\u4FEE\u590D\u540E):", {
      searchQuery: this.searchQuery,
      activeColorFilter: this.activeColorFilter,
      filteredNodesLength: this.filteredNodes.length,
      nodesToRenderLength: nodesToRender.length,
      groupCount: this.groupAnalysis.size,
      sortBy: this.sortBy,
      sortOrder: this.sortOrder,
      usingFilteredNodes: nodesToRender === this.filteredNodes
    });
    if (nodesToRender.length === 0) {
      if (this.searchQuery) {
        this.showNoSearchResults();
      } else {
        this.showEmptyState();
      }
      return;
    }
    const groupNodes = nodesToRender.filter((node) => node.type === "group");
    const regularNodes = nodesToRender.filter((node) => node.type !== "group");
    const itemsToRender = [];
    const sortedGroups = this.getGroupsForGridView();
    sortedGroups.forEach((groupInfo) => {
      if (groupNodes.some((node) => node.id === groupInfo.group.id)) {
        itemsToRender.push({ type: "group", data: groupInfo });
      }
    });
    const ungroupedNodes = this.getUngroupedNodes(regularNodes);
    ungroupedNodes.forEach((node) => {
      itemsToRender.push({ type: "node", data: node });
    });
    await this.renderGridItems(itemsToRender);
    this.setupCardDragAttributes();
  }
  // 🎯 新增：应用增量更新
  async applyIncrementalUpdate(changes) {
    if (!this.incrementalRenderer)
      return;
    for (const change of changes) {
      try {
        switch (change.type) {
          case "add":
            if (change.node) {
              await this.addNodeToGrid(change.node);
            }
            break;
          case "update":
            if (change.node) {
              await this.updateNodeInGrid(change.node);
            }
            break;
          case "delete":
            if (change.nodeId) {
              await this.removeNodeFromGridDOM(change.nodeId);
            }
            break;
        }
      } catch (error) {
        DebugManager.error(`\u589E\u91CF\u66F4\u65B0\u5931\u8D25 (${change.type}):`, error);
      }
    }
    this.incrementalRenderer.updateRenderState(changes);
  }
  // 🎯 新增：首次渲染网格
  async renderInitialGrid(nodesToRender) {
    const cardPromises = nodesToRender.map((node) => this.createCard(node));
    const cards = await Promise.all(cardPromises);
    cards.forEach((card, index) => {
      if (this.searchQuery) {
        this.highlightSearchResults(card, this.searchQuery);
      }
    });
    const fragment = document.createDocumentFragment();
    cards.forEach((card) => fragment.appendChild(card));
    this.gridContainer.appendChild(fragment);
    if (this.incrementalRenderer) {
      const changes = nodesToRender.map((node) => ({
        type: "add",
        node
      }));
      this.incrementalRenderer.updateRenderState(changes);
    }
  }
  // 🎯 新增：添加节点到网格
  async addNodeToGrid(node) {
    const card = await this.createCard(node);
    if (this.searchQuery) {
      this.highlightSearchResults(card, this.searchQuery);
    }
    this.gridContainer.appendChild(card);
  }
  // 🎯 新增：更新网格中的节点
  async updateNodeInGrid(node) {
    this.domElementRegistry.removeElement(node.id);
    await this.addNodeToGrid(node);
  }
  // 🎯 新增：从网格中移除节点（DOM层面）
  async removeNodeFromGridDOM(nodeId) {
    this.domElementRegistry.removeElement(nodeId);
  }
  // ==================== 置顶功能相关方法 ====================
  /**
   * 检测卡片是否包含置顶标签
   */
  detectPinnedStatus(node) {
    if (node.type !== "text" || !node.text)
      return false;
    const pinnedTag = this.settings.pinnedTagName;
    const escapedTag = pinnedTag.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const regex = new RegExp(`^\\s*${escapedTag}(?=\\s|$)`, "i");
    return regex.test(node.text.trim());
  }
  /**
   * 在卡片内容中添加置顶标签
   */
  addPinnedTag(content) {
    const pinnedTag = this.settings.pinnedTagName;
    const trimmedContent = content.trim();
    if (this.detectPinnedStatus({ type: "text", text: trimmedContent })) {
      return content;
    }
    if (this.settings.pinnedTagPosition === "start") {
      return trimmedContent ? `${pinnedTag} ${trimmedContent}` : pinnedTag;
    } else {
      return trimmedContent ? `${trimmedContent} ${pinnedTag}` : pinnedTag;
    }
  }
  /**
   * 从卡片内容中移除置顶标签
   */
  removePinnedTag(content) {
    const pinnedTag = this.settings.pinnedTagName;
    const escapedTag = pinnedTag.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const startRegex = new RegExp(`^\\s*${escapedTag}\\s*`, "i");
    let result = content.replace(startRegex, "");
    const endRegex = new RegExp(`\\s*${escapedTag}\\s*$`, "i");
    result = result.replace(endRegex, "");
    return result.trim();
  }
  /**
   * 切换卡片置顶状态
   */
  async togglePinnedStatus(card, node) {
    if (node.type !== "text" || !node.text)
      return;
    const isPinned = this.detectPinnedStatus(node);
    let newContent;
    let newStatus;
    if (isPinned) {
      newContent = this.removePinnedTag(node.text);
      newStatus = false;
      new import_obsidian12.Notice("\u5DF2\u53D6\u6D88\u7F6E\u9876");
    } else {
      newContent = this.addPinnedTag(node.text);
      newStatus = true;
      new import_obsidian12.Notice("\u5DF2\u7F6E\u9876");
    }
    node.text = newContent;
    node.isPinned = newStatus;
    node.pinnedAt = newStatus ? Date.now() : void 0;
    this.updatePinnedButtonState(card, newStatus);
    this.updateCardPinnedStyle(card, newStatus);
    await this.saveCanvasData();
    if (this.filteredNodes && this.filteredNodes.length > 0) {
      const nodeIndex = this.filteredNodes.findIndex((n) => n.id === node.id);
      if (nodeIndex !== -1) {
        this.filteredNodes[nodeIndex] = node;
      }
    } else {
      this.filteredNodes = this.canvasData?.nodes || [];
    }
    this.applySortAndFilter();
  }
  /**
   * 更新置顶按钮状态
   */
  updatePinnedButtonState(card, isPinned) {
    const pinnedBtn = card.querySelector(".canvas-card-toolbar-pinned");
    if (!pinnedBtn)
      return;
    if (isPinned) {
      pinnedBtn.classList.add("pinned-active");
      pinnedBtn.title = "\u53D6\u6D88\u7F6E\u9876";
      pinnedBtn.setAttribute("aria-label", "\u53D6\u6D88\u7F6E\u9876");
    } else {
      pinnedBtn.classList.remove("pinned-active");
      pinnedBtn.title = "\u7F6E\u9876";
      pinnedBtn.setAttribute("aria-label", "\u7F6E\u9876");
    }
  }
  /**
   * 更新卡片置顶样式
   */
  updateCardPinnedStyle(card, isPinned) {
    if (isPinned) {
      card.classList.add("pinned");
      this.addPinIndicator(card);
    } else {
      card.classList.remove("pinned");
      this.removePinIndicator(card);
    }
  }
  /**
   * 添加置顶图钉指示器
   */
  addPinIndicator(card) {
    let indicator = card.querySelector(".canvas-grid-card-pin-indicator");
    if (!indicator) {
      indicator = document.createElement("div");
      indicator.className = "canvas-grid-card-pin-indicator adding";
      indicator.addEventListener("click", (e) => {
        e.stopPropagation();
        this.handlePinIndicatorClick(card);
      });
      card.appendChild(indicator);
      setTimeout(() => {
        indicator.classList.remove("adding");
      }, 300);
    }
  }
  /**
   * 移除置顶图钉指示器
   */
  removePinIndicator(card) {
    const indicator = card.querySelector(".canvas-grid-card-pin-indicator");
    if (indicator) {
      indicator.classList.add("removing");
      setTimeout(() => {
        if (indicator.parentNode) {
          indicator.parentNode.removeChild(indicator);
        }
      }, 300);
    }
  }
  /**
   * 处理置顶图钉指示器点击
   */
  handlePinIndicatorClick(card) {
    const nodeId = card.dataset.nodeId;
    if (!nodeId)
      return;
    const node = this.canvasData?.nodes.find((n) => n.id === nodeId);
    if (!node)
      return;
    this.togglePinnedStatus(card, node);
  }
  /**
   * 刷新所有卡片的置顶状态
   */
  refreshPinnedStatus() {
    if (!this.canvasData)
      return;
    this.canvasData.nodes.forEach((node) => {
      if (node.type === "text") {
        const extendedNode = node;
        const isPinned = this.detectPinnedStatus(node);
        extendedNode.isPinned = isPinned;
        if (isPinned && !extendedNode.pinnedAt) {
          extendedNode.pinnedAt = Date.now();
        } else if (!isPinned) {
          extendedNode.pinnedAt = void 0;
        }
      }
    });
    this.applySortAndFilter();
  }
  /**
   * 刷新所有视图
   */
  refreshAllViews() {
    this.renderGrid().catch((error) => {
      DebugManager.error("Failed to refresh grid view:", error);
    });
    this.app.workspace.getLeavesOfType(CANVAS_GRID_VIEW_TYPE).forEach((leaf) => {
      const view = leaf.view;
      if (view !== this) {
        view.renderGrid().catch((error) => {
          DebugManager.error("Failed to refresh other grid view:", error);
        });
      }
    });
  }
  // ==================== 渲染相关方法 ====================
  // 🚨 新增：DOM一致性验证方法 - 防止假数据问题
  async validateDOMConsistency() {
    if (this.isDOMValidationInProgress) {
      DebugManager.log("\u23F3 DOM\u9A8C\u8BC1\u5DF2\u5728\u8FDB\u884C\u4E2D\uFF0C\u8DF3\u8FC7\u91CD\u590D\u9A8C\u8BC1");
      return;
    }
    this.isDOMValidationInProgress = true;
    try {
      const existingCards = this.gridContainer.querySelectorAll("[data-node-id]");
      const nodeIds = /* @__PURE__ */ new Set();
      const duplicates = [];
      const orphanElements = [];
      DebugManager.log("\u{1F50D} \u5F00\u59CBDOM\u4E00\u81F4\u6027\u68C0\u67E5", {
        existingCardsCount: existingCards.length,
        canvasNodesCount: this.canvasData?.nodes.length || 0
      });
      existingCards.forEach((card) => {
        const nodeId = card.getAttribute("data-node-id");
        if (nodeId) {
          if (nodeIds.has(nodeId)) {
            duplicates.push(nodeId);
            DebugManager.warn("\u{1F6A8} \u53D1\u73B0\u91CD\u590DDOM\u5143\u7D20:", nodeId);
          }
          nodeIds.add(nodeId);
          const nodeExists = this.canvasData?.nodes.some((n) => n.id === nodeId);
          if (!nodeExists) {
            orphanElements.push(card);
            DebugManager.warn("\u{1F6A8} \u53D1\u73B0\u5B64\u7ACBDOM\u5143\u7D20:", nodeId);
          }
        }
      });
      if (duplicates.length > 0 || orphanElements.length > 0) {
        DebugManager.error("\u{1F6A8} \u68C0\u6D4B\u5230DOM\u4E0D\u4E00\u81F4\u95EE\u9898", {
          duplicates: duplicates.length,
          orphans: orphanElements.length
        });
        await this.forceClearInconsistentElements(duplicates, orphanElements);
      } else {
        DebugManager.log("\u2705 DOM\u4E00\u81F4\u6027\u68C0\u67E5\u901A\u8FC7");
      }
    } catch (error) {
      DebugManager.error("\u274C DOM\u4E00\u81F4\u6027\u68C0\u67E5\u5931\u8D25:", error);
    } finally {
      this.isDOMValidationInProgress = false;
    }
  }
  // 🚨 新增：强制清理不一致的DOM元素
  async forceClearInconsistentElements(duplicates, orphanElements) {
    let cleanedCount = 0;
    duplicates.forEach((nodeId) => {
      const elements = this.gridContainer.querySelectorAll(`[data-node-id="${nodeId}"]`);
      for (let i = 1; i < elements.length; i++) {
        elements[i].remove();
        cleanedCount++;
        DebugManager.log("\u{1F9F9} \u6E05\u7406\u91CD\u590DDOM\u5143\u7D20:", nodeId, `(\u7B2C${i + 1}\u4E2A)`);
      }
    });
    orphanElements.forEach((element) => {
      const nodeId = element.getAttribute("data-node-id");
      element.remove();
      cleanedCount++;
      DebugManager.log("\u{1F9F9} \u6E05\u7406\u5B64\u7ACBDOM\u5143\u7D20:", nodeId);
    });
    duplicates.concat(orphanElements.map((el) => el.getAttribute("data-node-id")).filter(Boolean)).forEach((nodeId) => {
      this.domElementRegistry.removeElement(nodeId);
    });
    DebugManager.log(`\u2705 DOM\u6E05\u7406\u5B8C\u6210\uFF0C\u5171\u6E05\u7406 ${cleanedCount} \u4E2A\u95EE\u9898\u5143\u7D20`);
    if (cleanedCount > 0) {
      await new Promise((resolve) => setTimeout(resolve, 50));
      const remainingIssues = this.gridContainer.querySelectorAll("[data-node-id]");
      DebugManager.log("\u{1F50D} \u6E05\u7406\u540EDOM\u72B6\u6001:", {
        remainingElements: remainingIssues.length,
        expectedElements: this.canvasData?.nodes.length || 0
      });
    }
  }
  // 立即渲染（小量数据）
  async renderGridImmediate(nodes) {
    const fragment = document.createDocumentFragment();
    const cardPromises = nodes.map((node) => this.createCard(node));
    const cards = await Promise.all(cardPromises);
    cards.forEach((card, index) => {
      if (this.searchQuery) {
        this.highlightSearchResults(card, this.searchQuery);
      }
      fragment.appendChild(card);
    });
    this.gridContainer.appendChild(fragment);
  }
  // 批量渲染（大量数据）
  async renderGridBatched(nodes) {
    const batchSize = 20;
    let currentIndex = 0;
    this.showLoadingState();
    const renderBatch = async () => {
      const fragment = document.createDocumentFragment();
      const endIndex = Math.min(currentIndex + batchSize, nodes.length);
      const batchNodes = nodes.slice(currentIndex, endIndex);
      const cardPromises = batchNodes.map((node) => this.createCard(node));
      const cards = await Promise.all(cardPromises);
      cards.forEach((card) => {
        if (this.searchQuery) {
          this.highlightSearchResults(card, this.searchQuery);
        }
        fragment.appendChild(card);
      });
      this.gridContainer.appendChild(fragment);
      currentIndex = endIndex;
      if (currentIndex < nodes.length) {
        requestAnimationFrame(renderBatch);
      } else {
        this.hideLoadingState();
      }
    };
    requestAnimationFrame(renderBatch);
  }
  // 显示无搜索结果状态
  showNoSearchResults() {
    const emptyEl = this.gridContainer.createDiv("canvas-grid-empty-state");
    emptyEl.innerHTML = `
			<div class="empty-icon">\u{1F50D}</div>
			<div class="empty-title">\u672A\u627E\u5230\u5339\u914D\u7684\u5361\u7247</div>
			<div class="empty-desc">\u5C1D\u8BD5\u4F7F\u7528\u4E0D\u540C\u7684\u5173\u952E\u8BCD\u641C\u7D22</div>
			<button class="empty-action" onclick="this.closest('.canvas-grid-view').querySelector('.canvas-grid-search-input').value = ''; this.closest('.canvas-grid-view').querySelector('.canvas-grid-search-input').dispatchEvent(new Event('input'));">\u6E05\u7A7A\u641C\u7D22</button>
		`;
  }
  // 高亮搜索结果
  highlightSearchResults(cardEl, query) {
    const textElements = cardEl.querySelectorAll(".canvas-grid-card-content, .canvas-grid-card-title");
    const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")})`, "gi");
    textElements.forEach((el) => {
      const element = el;
      if (element.textContent) {
        const highlightedText = element.textContent.replace(regex, '<mark class="search-highlight">$1</mark>');
        SafeHTMLRenderer.setHTML(element, highlightedText, ["mark"]);
      }
    });
  }
  // 保存设置
  async saveSettings() {
    DebugManager.log("Settings saved:", this.settings);
  }
  // 🎯 修复：创建单个卡片 - 使用DOM元素注册表和数据缓存
  async createCard(node) {
    const existingElement = this.domElementRegistry.getElement(node.id);
    if (existingElement && existingElement.parentNode) {
      DebugManager.warn("\u{1F6A8} \u68C0\u6D4B\u5230\u91CD\u590D\u521B\u5EFA\u5361\u7247\uFF0C\u79FB\u9664\u65E7\u5143\u7D20:", node.id);
      existingElement.remove();
      this.domElementRegistry.removeElement(node.id);
    }
    const card = this.domElementRegistry.createUniqueElement(node.id, "div");
    card.className = "canvas-grid-card";
    card.style.minHeight = `${CARD_CONSTANTS.height}px`;
    card.dataset.nodeType = node.type;
    card.dataset.nodeId = node.id;
    card.dataset.createdAt = Date.now().toString();
    const cacheKey = this.generatePreciseCacheKey(node);
    const cachedData = this.getDataCacheItem(cacheKey);
    if (cachedData && this.isDataCacheValid(cachedData, node)) {
      await this.renderCardFromCachedData(card, node, cachedData);
    } else {
      const renderData = await this.createCardRenderData(node);
      await this.renderCardFromData(card, node, renderData);
      this.setDataCacheItem(cacheKey, renderData);
    }
    return card;
  }
  // 内部创建卡片方法
  async createCardInternal(node) {
    const card = document.createElement("div");
    card.className = "canvas-grid-card";
    card.style.minHeight = `${CARD_CONSTANTS.height}px`;
    card.dataset.nodeId = node.id;
    card.dataset.nodeType = node.type;
    const groupInfo = this.getNodeGroupInfo(node.id);
    if (groupInfo && !this.currentGroupView) {
      card.classList.add("canvas-grid-card-in-group");
      card.dataset.groupId = groupInfo.groupId;
      card.dataset.groupName = groupInfo.groupName;
    }
    if (node.color) {
      const normalizedColor = this.normalizeColorValue(node.color);
      if (normalizedColor) {
        ColorUtils.applyCanvasColorToElement(card, normalizedColor);
      }
    }
    if (node.flag) {
      card.dataset.flag = node.flag.toString();
    }
    card.setAttribute("role", "button");
    card.setAttribute("tabindex", "0");
    card.setAttribute("aria-label", `${node.type}\u8282\u70B9`);
    await this.renderCardContent(card, node);
    if (groupInfo && !this.currentGroupView) {
      this.addGroupBadgeToCard(card, groupInfo.groupName);
      this.addGroupSourceIndicator(card, groupInfo);
    }
    this.createCardToolbar(card, node);
    if (this.settings.enablePinnedCards && this.detectPinnedStatus(node)) {
      card.classList.add("pinned");
      this.addPinIndicator(card);
    }
    return card;
  }
  // 生成卡片缓存键
  generateCardCacheKey(node) {
    const keyData = {
      id: node.id,
      type: node.type,
      color: node.color,
      flag: node.flag,
      // 对于文本节点，包含文本内容的哈希
      textHash: node.text ? this.simpleHash(node.text) : null,
      // 对于文件节点，包含文件路径
      file: node.file,
      // 对于链接节点，包含URL
      url: node.url,
      // 设置相关
      cardHeight: CARD_CONSTANTS.height
    };
    return JSON.stringify(keyData);
  }
  // 🚨 新增：简单哈希函数（用于精确缓存键生成）
  simpleHash(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash);
  }
  // 🎯 修复：获取数据缓存项（替代DOM缓存）
  getDataCacheItem(key) {
    return this.dataCache.get(key) || null;
  }
  // 🎯 修复：设置数据缓存项（替代DOM缓存）
  setDataCacheItem(key, data) {
    this.dataCache.set(key, data);
  }
  // 🎯 修复：清理数据缓存（替代DOM缓存）
  clearDataCache() {
    this.dataCache.clear();
  }
  // 🎯 新增：生成数据缓存键（替代DOM缓存键）- 增强精确性防止假数据
  generateDataCacheKey(node) {
    const contentHash = this.getNodeContentHash(node);
    const timestamp = Date.now();
    const groupInfo = this.getNodeGroupInfo(node.id);
    const isPinned = this.settings.enablePinnedCards && this.detectPinnedStatus(node);
    return `data-${node.id}-${node.type}-${contentHash}-${groupInfo ? "grouped" : "ungrouped"}-${isPinned ? "pinned" : "unpinned"}-${timestamp}`;
  }
  // 🚨 新增：生成精确缓存键（用于关键渲染）
  generatePreciseCacheKey(node) {
    const baseKey = this.generateDataCacheKey(node);
    const renderContext = {
      currentView: this.currentView,
      groupView: this.currentGroupView,
      searchQuery: this.searchQuery,
      colorFilter: this.activeColorFilter
    };
    const contextHash = JSON.stringify(renderContext);
    return `${baseKey}-ctx:${this.simpleHash(contextHash)}`;
  }
  // 🎯 新增：获取节点内容哈希
  getNodeContentHash(node) {
    const content = JSON.stringify({
      type: node.type,
      text: node.text,
      url: node.url,
      file: node.file,
      color: node.color,
      flag: node.flag
    });
    return this.simpleHash(content).toString();
  }
  // 🎯 新增：验证数据缓存有效性
  isDataCacheValid(cachedData, node) {
    const currentHash = this.getNodeContentHash(node);
    return cachedData.contentHash === currentHash;
  }
  // 🎯 新增：创建卡片渲染数据
  async createCardRenderData(node) {
    const groupInfo = this.getNodeGroupInfo(node.id);
    const isPinned = this.settings.enablePinnedCards && this.detectPinnedStatus(node);
    return {
      nodeId: node.id,
      nodeType: node.type,
      contentHash: this.getNodeContentHash(node),
      renderedContent: await this.generateRenderedContent(node),
      metadata: {
        hasGroupBadge: !!(groupInfo && !this.currentGroupView),
        isPinned,
        colorStyle: node.color ? this.getColorStyles(node.color).textColor : void 0,
        timestamp: Date.now()
      }
    };
  }
  // 🎯 新增：生成渲染内容
  async generateRenderedContent(node) {
    switch (node.type) {
      case "text":
        return node.text || "";
      case "link":
        return node.url || "";
      case "file":
        return node.file || "";
      default:
        return "";
    }
  }
  // 🎯 新增：从缓存数据渲染卡片
  async renderCardFromCachedData(card, node, cachedData) {
    this.setupCardBasicAttributes(card, node, cachedData);
    await this.renderCardContent(card, node);
    this.applyCardMetadata(card, node, cachedData.metadata);
  }
  // 🎯 新增：从数据渲染卡片
  async renderCardFromData(card, node, renderData) {
    this.setupCardBasicAttributes(card, node, renderData);
    await this.renderCardContent(card, node);
    this.applyCardMetadata(card, node, renderData.metadata);
  }
  // 🎯 新增：设置卡片基本属性
  setupCardBasicAttributes(card, node, renderData) {
    const groupInfo = this.getNodeGroupInfo(node.id);
    if (groupInfo && !this.currentGroupView) {
      card.classList.add("canvas-grid-card-in-group");
      card.dataset.groupId = groupInfo.groupId;
      card.dataset.groupName = groupInfo.groupName;
    }
    if (node.color) {
      const normalizedColor = this.normalizeColorValue(node.color);
      if (normalizedColor) {
        ColorUtils.applyCanvasColorToElement(card, normalizedColor);
      }
    }
    card.setAttribute("role", "button");
    card.setAttribute("tabindex", "0");
    card.setAttribute("aria-label", `${node.type}\u8282\u70B9`);
  }
  // 🎯 新增：应用卡片元数据
  applyCardMetadata(card, node, metadata) {
    if (metadata.hasGroupBadge) {
      const groupInfo = this.getNodeGroupInfo(node.id);
      if (groupInfo) {
        this.addGroupBadgeToCard(card, groupInfo.groupName);
      }
    }
    this.createCardToolbar(card, node);
    if (metadata.isPinned) {
      card.classList.add("pinned");
      this.addPinIndicator(card);
    }
  }
  // 更新卡片事件处理器（用于缓存的卡片）
  updateCardEventHandlers(card, node) {
    card.dataset.nodeId = node.id;
    card.dataset.nodeType = node.type;
  }
  // 清空渲染缓存（已在上面定义，删除重复定义）
  // 创建卡片工具栏
  createCardToolbar(card, node) {
    const toolbar = document.createElement("div");
    toolbar.className = "canvas-card-toolbar";
    if (this.settings.enablePinnedCards) {
      const isPinned = this.detectPinnedStatus(node);
      const pinnedBtn = this.createToolbarButton(
        "pinned",
        isPinned ? this.settings.language === "zh" ? "\u53D6\u6D88\u7F6E\u9876" : "Unpin" : this.settings.language === "zh" ? "\u7F6E\u9876" : "Pin"
      );
      if (isPinned) {
        pinnedBtn.classList.add("pinned-active");
      }
      toolbar.appendChild(pinnedBtn);
    }
    const deleteBtn = this.createToolbarButton("delete", this.settings.language === "zh" ? "\u5220\u9664" : "Delete");
    const colorBtn = this.createToolbarButton("color", this.settings.language === "zh" ? "\u8BBE\u7F6E\u989C\u8272" : "Set Color");
    toolbar.appendChild(deleteBtn);
    toolbar.appendChild(colorBtn);
    card.appendChild(toolbar);
  }
  // 创建工具栏按钮（使用事件委托，不直接绑定onclick）
  createToolbarButton(type, title, onClick) {
    const button = document.createElement("div");
    button.className = `canvas-card-toolbar-btn canvas-card-toolbar-${type}`;
    button.title = title;
    button.setAttribute("role", "button");
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-label", title);
    const icon = document.createElement("div");
    icon.className = `canvas-card-toolbar-icon canvas-card-toolbar-icon-${type}`;
    button.appendChild(icon);
    return button;
  }
  // 从工具栏删除卡片
  async deleteCardFromToolbar(card) {
    const nodeId = card.dataset.nodeId;
    if (!nodeId)
      return;
    const confirmed = confirm("\u786E\u5B9A\u8981\u5220\u9664\u8FD9\u4E2A\u8282\u70B9\u5417\uFF1F");
    if (!confirmed)
      return;
    try {
      await this.deleteNodeFromCanvas(nodeId);
      card.remove();
      DebugManager.log("\u5361\u7247\u5220\u9664\u5B8C\u6210\uFF0CUI\u5DF2\u66F4\u65B0");
    } catch (error) {
      DebugManager.error("\u5220\u9664\u5361\u7247\u5931\u8D25:", error);
      new import_obsidian12.Notice("\u5220\u9664\u5361\u7247\u5931\u8D25");
    }
  }
  // 显示颜色选择器
  showColorPicker(card, node) {
    const colorPicker = document.createElement("div");
    colorPicker.className = "canvas-color-picker";
    const colors = [
      { name: "\u9ED8\u8BA4", value: "", bgColor: "var(--background-primary)", textColor: "var(--text-normal)" },
      { name: "\u7EA2\u8272", value: "1" },
      { name: "\u6A59\u8272", value: "2" },
      { name: "\u9EC4\u8272", value: "3" },
      { name: "\u7EFF\u8272", value: "4" },
      { name: "\u9752\u8272", value: "5" },
      { name: "\u84DD\u8272", value: "6" },
      { name: "\u7D2B\u8272", value: "7" }
    ];
    colors.forEach((colorOption) => {
      const colorItem = document.createElement("div");
      colorItem.className = "canvas-color-item";
      if (colorOption.value) {
        const pureColorMap = {
          "1": "#ff6b6b",
          // 红色
          "2": "#ffa726",
          // 橙色
          "3": "#ffeb3b",
          // 黄色
          "4": "#66bb6a",
          // 绿色
          "5": "#26c6da",
          // 青色
          "6": "#42a5f5",
          // 蓝色
          "7": "#ab47bc"
          // 紫色
        };
        const pureColor = pureColorMap[colorOption.value];
        colorItem.style.backgroundColor = pureColor;
        colorItem.style.border = `2px solid ${pureColor}`;
      } else {
        colorItem.style.backgroundColor = "var(--background-secondary)";
        colorItem.style.border = "2px solid var(--background-modifier-border)";
      }
      colorItem.style.borderRadius = "50%";
      colorItem.style.width = "24px";
      colorItem.style.height = "24px";
      colorItem.style.cursor = "pointer";
      colorItem.style.transition = "all 0.2s ease";
      colorItem.addEventListener("mouseenter", () => {
        colorItem.style.transform = "scale(1.1)";
        colorItem.style.boxShadow = "0 2px 8px rgba(0, 0, 0, 0.2)";
      });
      colorItem.addEventListener("mouseleave", () => {
        colorItem.style.transform = "scale(1)";
        colorItem.style.boxShadow = "none";
      });
      colorItem.title = colorOption.name;
      if (node.color === colorOption.value || !node.color && !colorOption.value) {
        colorItem.classList.add("selected");
        colorItem.style.boxShadow = "0 0 0 2px var(--interactive-accent)";
      }
      colorItem.onclick = () => {
        this.setCardColor(card, node, colorOption.value);
        colorPicker.remove();
      };
      colorPicker.appendChild(colorItem);
    });
    const rect = card.getBoundingClientRect();
    colorPicker.style.position = "fixed";
    colorPicker.style.top = `${rect.top - 40}px`;
    colorPicker.style.left = `${rect.left}px`;
    colorPicker.style.zIndex = "10000";
    document.body.appendChild(colorPicker);
    const closeHandler = (e) => {
      const mouseEvent = e;
      if (!colorPicker.contains(mouseEvent.target)) {
        colorPicker.remove();
        document.removeEventListener("click", closeHandler);
        const index = this.globalEventListeners.findIndex(
          (listener) => listener.element === document && listener.event === "click" && listener.handler === closeHandler
        );
        if (index > -1) {
          this.globalEventListeners.splice(index, 1);
        }
      }
    };
    this.safeSetTimeout(() => {
      this.addGlobalEventListener(document, "click", closeHandler);
    }, 0);
  }
  // 设置卡片颜色 - 设置背景色、文字色和边框色
  async setCardColor(card, node, color) {
    const normalizedColor = color ? this.normalizeColorValue(color) : null;
    node.color = normalizedColor || void 0;
    ColorUtils.applyCanvasColorToElement(card, normalizedColor);
    await this.saveNodeToCanvas(node);
  }
  // 渲染卡片内容
  async renderCardContent(card, node) {
    switch (node.type) {
      case "text":
        this.renderTextNode(card, node);
        break;
      case "file":
        this.renderFileNode(card, node);
        break;
      case "link":
        this.renderLinkNode(card, node);
        break;
      default:
        card.createDiv().textContent = `\u672A\u652F\u6301\u7684\u8282\u70B9\u7C7B\u578B: ${node.type}`;
    }
  }
  // 渲染文本节点 - 简化DOM结构，对齐官方Canvas样式
  renderTextNode(card, node) {
    const content = card.createDiv("card-content");
    content.style.lineHeight = "var(--line-height-normal)";
    content.style.fontSize = "var(--font-text-size)";
    content.style.fontFamily = "var(--font-text)";
    content.style.color = "var(--text-normal)";
    content.style.padding = "0";
    content.style.margin = "0";
    this.renderTextNodeContent(content, node);
  }
  // 🔧 新增：检查是否为图片文件
  isImageFile(fileName) {
    const imageExtensions = [
      ".jpg",
      ".jpeg",
      ".png",
      ".gif",
      ".bmp",
      ".svg",
      ".webp",
      ".tiff",
      ".tif",
      ".ico",
      ".avif",
      ".heic",
      ".heif"
    ];
    const lowerFileName = fileName.toLowerCase();
    return imageExtensions.some((ext) => lowerFileName.endsWith(ext));
  }
  // 🔧 新增：检查是否为视频文件
  isVideoFile(fileName) {
    const videoExtensions = [
      ".mp4",
      ".webm",
      ".ogv",
      ".mov",
      ".avi",
      ".mkv",
      ".m4v",
      ".wmv",
      ".flv",
      ".3gp",
      ".m2v",
      ".mpg",
      ".mpeg"
    ];
    const lowerFileName = fileName.toLowerCase();
    return videoExtensions.some((ext) => lowerFileName.endsWith(ext));
  }
  // 🔧 新增：渲染图片预览
  renderImagePreview(content, node, fileName) {
    const imageContainer = content.createDiv("file-image-container");
    const img = imageContainer.createEl("img", {
      cls: "file-image-preview"
    });
    const vault = this.app.vault;
    const file = vault.getAbstractFileByPath(node.file);
    if (file instanceof import_obsidian12.TFile) {
      img.src = this.app.vault.getResourcePath(file);
    } else {
      this.handleImageLoadError(imageContainer, fileName);
      return;
    }
    img.alt = fileName;
    img.title = fileName;
    img.onerror = () => {
      this.handleImageLoadError(imageContainer, fileName);
    };
    img.onload = () => {
      imageContainer.classList.add("image-loaded");
    };
    const fileNameLabel = imageContainer.createDiv("file-image-name");
    fileNameLabel.textContent = fileName;
  }
  // 🔧 新增：处理图片加载错误
  handleImageLoadError(container, fileName) {
    container.empty();
    container.classList.add("file-image-error");
    const errorIcon = container.createDiv("file-image-error-icon");
    errorIcon.textContent = "\u{1F5BC}\uFE0F";
    const errorText = container.createDiv("file-image-error-text");
    errorText.textContent = "\u56FE\u7247\u52A0\u8F7D\u5931\u8D25";
    const fileNameText = container.createDiv("file-image-error-filename");
    fileNameText.textContent = fileName;
  }
  // 🔧 新增：渲染视频预览
  renderVideoPreview(content, node, fileName) {
    try {
      const file = this.app.vault.getAbstractFileByPath(node.file);
      if (!file) {
        this.handleVideoLoadError(content, fileName, "\u6587\u4EF6\u4E0D\u5B58\u5728");
        return;
      }
      const videoContainer = content.createDiv("file-video-container");
      const video = videoContainer.createEl("video", {
        cls: "file-video-preview",
        attr: {
          controls: "true",
          preload: "metadata"
        }
      });
      video.src = this.app.vault.getResourcePath(file);
      video.addEventListener("error", () => {
        this.handleVideoLoadError(videoContainer, fileName, "\u89C6\u9891\u52A0\u8F7D\u5931\u8D25");
      });
      video.addEventListener("loadedmetadata", () => {
        DebugManager.log("Video loaded successfully:", fileName);
      });
      const fileNameLabel = videoContainer.createDiv("file-video-name");
      fileNameLabel.textContent = fileName;
    } catch (error) {
      DebugManager.error("Failed to render video preview:", error);
      this.handleVideoLoadError(content, fileName, "\u6E32\u67D3\u5931\u8D25");
    }
  }
  // 🔧 新增：处理视频加载错误
  handleVideoLoadError(container, fileName, errorMessage) {
    container.empty();
    container.classList.add("file-video-error");
    const errorIcon = container.createDiv("file-video-error-icon");
    errorIcon.textContent = "\u{1F3AC}";
    const errorText = container.createDiv("file-video-error-text");
    errorText.textContent = errorMessage;
    const fileNameText = container.createDiv("file-video-error-filename");
    fileNameText.textContent = fileName;
  }
  // 渲染文件节点 - 简化DOM结构，对齐官方Canvas样式
  renderFileNode(card, node) {
    const content = card.createDiv("card-content");
    content.style.lineHeight = "var(--line-height-normal)";
    content.style.fontSize = "var(--font-text-size)";
    content.style.fontFamily = "var(--font-text)";
    content.style.color = "var(--text-normal)";
    content.style.padding = "0";
    content.style.margin = "0";
    if (node.file) {
      const fileName = node.file.split("/").pop() || node.file;
      if (this.isImageFile(fileName)) {
        this.renderImagePreview(content, node, fileName);
      } else if (this.isVideoFile(fileName)) {
        this.renderVideoPreview(content, node, fileName);
      } else {
        const fileContainer = content.createDiv("file-container");
        fileContainer.style.display = "flex";
        fileContainer.style.alignItems = "center";
        fileContainer.style.gap = "8px";
        const fileIcon = fileContainer.createSpan("file-icon");
        fileIcon.textContent = "\u{1F4C4}";
        fileIcon.style.fontSize = "16px";
        const fileName2 = fileContainer.createSpan("file-name");
        fileName2.textContent = node.file.split("/").pop() || node.file;
        fileName2.style.wordBreak = "break-word";
        if (node.file.includes("#")) {
          const subpath = node.file.split("#")[1];
          const subpathEl = content.createDiv("file-subpath");
          subpathEl.textContent = `#${subpath}`;
          subpathEl.style.color = "var(--text-muted)";
          subpathEl.style.fontSize = "var(--font-smaller)";
          subpathEl.style.marginTop = "4px";
        }
      }
    } else {
      content.textContent = "\u65E0\u6548\u7684\u6587\u4EF6\u5F15\u7528";
      content.style.color = "var(--text-error)";
      content.style.fontStyle = "italic";
    }
  }
  // 渲染链接节点 - 简化DOM结构，对齐官方Canvas样式
  renderLinkNode(card, node) {
    const content = card.createDiv("card-content");
    content.style.lineHeight = "var(--line-height-normal)";
    content.style.fontSize = "var(--font-text-size)";
    content.style.fontFamily = "var(--font-text)";
    content.style.color = "var(--text-normal)";
    content.style.padding = "0";
    content.style.margin = "0";
    this.renderLinkNodeWithPreview(content, node);
  }
  // 获取节点颜色
  getNodeColor(color) {
    const colorMap = {
      "1": "#ff6b6b",
      // red
      "2": "#ffa726",
      // orange
      "3": "#ffeb3b",
      // yellow
      "4": "#66bb6a",
      // green
      "5": "#26c6da",
      // cyan
      "6": "#42a5f5",
      // blue
      "7": "#ab47bc"
      // purple
    };
    return colorMap[color] || color;
  }
  // 获取官方Canvas颜色样式
  getColorStyles(color) {
    return ColorUtils.getCanvasColorStyles(color);
  }
  // 标准化颜色值 - 使用官方Canvas颜色系统
  normalizeColorValue(color) {
    return ColorUtils.normalizeCanvasColor(color);
  }
  // 卡片点击事件（官方Canvas逻辑：单击选中，再次点击编辑）
  onCardClick(node, cardElement) {
    const clickedCard = cardElement || this.gridContainer.querySelector(`[data-node-id="${node.id}"]`);
    if (!clickedCard)
      return;
    DebugManager.log("\u{1F5B1}\uFE0F \u5361\u7247\u70B9\u51FB\u4E8B\u4EF6 (onCardClick)", {
      nodeId: node.id,
      nodeType: node.type,
      isSelected: this.selectedCard === clickedCard,
      hasCurrentEditing: !!this.currentEditingCard,
      isCurrentEditing: this.currentEditingCard === clickedCard
    });
    const editCheck = this.canEnterEditMode(node, clickedCard);
    DebugManager.log("\u{1F3AF} \u7F16\u8F91\u72B6\u6001\u68C0\u67E5:", {
      nodeId: node.id,
      isCurrentEditingCard: this.currentEditingCard === clickedCard,
      hasCurrentEditingCard: !!this.currentEditingCard,
      cardHasEditingClass: clickedCard.classList.contains("editing"),
      editCheck
    });
    if (this.currentEditingCard && this.currentEditingNode) {
      if (clickedCard !== this.currentEditingCard) {
        DebugManager.log("\u{1F504} \u5207\u6362\u7F16\u8F91\u5361\u7247\uFF0C\u5148\u4FDD\u5B58\u5F53\u524D\u7F16\u8F91");
        this.exitCurrentEditingState(true);
      }
    }
    if (this.selectedCard === clickedCard && this.selectedNode?.id === node.id) {
      if (editCheck.canEdit) {
        if (editCheck.action === "switch") {
          this.exitCurrentEditingState(true);
        }
        DebugManager.log("\u{1F3AF} \u518D\u6B21\u70B9\u51FB\u5DF2\u9009\u4E2D\u5361\u7247\uFF0C\u8FDB\u5165\u7F16\u8F91\u6A21\u5F0F");
        this.startEditingFromSelection(node, clickedCard);
      } else {
        DebugManager.log(`\u{1F6AB} \u963B\u6B62\u91CD\u590D\u7F16\u8F91: ${editCheck.reason}`);
      }
    } else {
      DebugManager.log("\u{1F4CC} \u9009\u4E2D\u5361\u7247");
      this.selectCard(node, clickedCard);
    }
  }
  /**
   * 选中卡片（官方Canvas风格）
   */
  selectCard(node, cardElement) {
    if (this.selectedCard) {
      this.selectedCard.classList.remove("selected");
    }
    this.selectedCard = cardElement;
    this.selectedNode = node;
    cardElement.classList.add("selected");
    DebugManager.log("\u5361\u7247\u5DF2\u9009\u4E2D:", node.id);
  }
  /**
   * 清除卡片选中状态
   */
  clearSelection() {
    if (this.selectedCard) {
      this.selectedCard.classList.remove("selected");
      this.selectedCard = null;
      this.selectedNode = null;
    }
  }
  /**
   * 完整的编辑状态清理（官方Canvas风格）
   * 确保退出编辑后回到正确的未选中状态
   */
  completeEditingStateCleanup() {
    DebugManager.log("\u{1F9F9} \u6267\u884C\u5B8C\u6574\u7684\u7F16\u8F91\u72B6\u6001\u6E05\u7406");
    this.clearEditingState();
    this.clearSelection();
    if (this.gridContainer) {
      this.gridContainer.classList.remove("has-editing-card");
      const editingCards = this.gridContainer.querySelectorAll(".canvas-grid-card.editing");
      editingCards.forEach((card) => {
        card.classList.remove("editing");
        card.style.zIndex = "";
        card.style.position = "";
      });
    }
    DebugManager.log("\u2705 \u7F16\u8F91\u72B6\u6001\u6E05\u7406\u5B8C\u6210\uFF0C\u56DE\u5230\u672A\u9009\u4E2D\u72B6\u6001");
  }
  /**
   * 统一的编辑状态检查方法
   * 防止重复进入编辑模式，解决双击高度递增问题
   */
  canEnterEditMode(node, cardElement) {
    if (this.currentEditingCard === cardElement) {
      return {
        canEdit: false,
        reason: "\u5361\u7247\u5DF2\u5728\u7F16\u8F91\u72B6\u6001\uFF0C\u9632\u6B62\u91CD\u590D\u7F16\u8F91",
        action: "prevent"
      };
    }
    if (this.currentEditingCard && this.currentEditingNode) {
      return {
        canEdit: true,
        reason: "\u9700\u8981\u5207\u6362\u7F16\u8F91\u5361\u7247",
        action: "switch"
      };
    }
    if (node.type !== "text" && node.type !== "link") {
      return {
        canEdit: false,
        reason: "\u5361\u7247\u7C7B\u578B\u4E0D\u652F\u6301\u7F16\u8F91",
        action: "prevent"
      };
    }
    if (cardElement.classList.contains("editing")) {
      return {
        canEdit: false,
        reason: "DOM\u663E\u793A\u5361\u7247\u5DF2\u5728\u7F16\u8F91\u72B6\u6001",
        action: "prevent"
      };
    }
    return {
      canEdit: true,
      reason: "\u53EF\u4EE5\u8FDB\u5165\u7F16\u8F91\u6A21\u5F0F",
      action: "allow"
    };
  }
  /**
   * 状态一致性验证方法
   * 检查编辑状态的内存与DOM一致性
   */
  validateEditingStateConsistency() {
    const issues = [];
    const fixes = [];
    const editingCards = this.gridContainer.querySelectorAll(".canvas-grid-card.editing");
    if (this.currentEditingCard && !this.currentEditingCard.classList.contains("editing")) {
      issues.push("\u5185\u5B58\u4E2D\u7684\u7F16\u8F91\u5361\u7247\u7F3A\u5C11editing CSS\u7C7B");
      fixes.push("\u6DFB\u52A0editing CSS\u7C7B");
    }
    if (editingCards.length > 1) {
      issues.push("\u53D1\u73B0\u591A\u4E2A\u7F16\u8F91\u72B6\u6001\u7684\u5361\u7247");
      fixes.push("\u6E05\u7406\u591A\u4F59\u7684\u7F16\u8F91\u72B6\u6001");
    }
    if (editingCards.length === 0 && this.currentEditingCard) {
      issues.push("\u5185\u5B58\u72B6\u6001\u663E\u793A\u6709\u7F16\u8F91\u5361\u7247\uFF0C\u4F46DOM\u4E2D\u65E0\u7F16\u8F91\u72B6\u6001");
      fixes.push("\u6E05\u7406\u5185\u5B58\u72B6\u6001\u6216\u6062\u590DDOM\u72B6\u6001");
    }
    if (editingCards.length === 1 && !this.currentEditingCard) {
      issues.push("DOM\u663E\u793A\u6709\u7F16\u8F91\u5361\u7247\uFF0C\u4F46\u5185\u5B58\u72B6\u6001\u4E3A\u7A7A");
      fixes.push("\u540C\u6B65\u5185\u5B58\u72B6\u6001\u6216\u6E05\u7406DOM\u72B6\u6001");
    }
    return {
      isConsistent: issues.length === 0,
      issues,
      fixes
    };
  }
  /**
   * 进入编辑模式（官方Canvas风格）
   */
  startEditingFromSelection(node, cardElement) {
    const editCheck = this.canEnterEditMode(node, cardElement);
    if (!editCheck.canEdit) {
      DebugManager.log(`\u{1F6AB} \u963B\u6B62\u4ECE\u9009\u4E2D\u72B6\u6001\u8FDB\u5165\u7F16\u8F91: ${editCheck.reason}`);
      return;
    }
    if (node.type === "text") {
      this.startTextEditing(node, cardElement);
    } else if (node.type === "link") {
      this.startLinkEditing(node, cardElement);
    }
  }
  // 开始文本编辑（使用新状态管理系统）
  startTextEditing(node, cardElement) {
    const editCheck = this.canEnterEditMode(node, cardElement);
    if (!editCheck.canEdit) {
      DebugManager.log(`\u{1F6AB} \u963B\u6B62\u6587\u672C\u7F16\u8F91: ${editCheck.reason}`);
      return;
    }
    this.clearSelection();
    if (this.currentEditingCard && this.currentEditingCard !== cardElement) {
      this.exitCurrentEditingState(true);
    }
    const contentDiv = cardElement.querySelector(".card-content");
    if (!contentDiv)
      return;
    this.currentEditingCard = cardElement;
    this.currentEditingNode = node;
    const originalText = node.text || "";
    this.editorStateCoordinator.createEditor({
      nodeId: node.id,
      content: originalText,
      // 内容变化回调
      onChange: (newText) => {
        this.updateContentWithNewSystem(node.id, { ...node, text: newText });
      },
      // 保存回调
      onSave: async (newText) => {
        this.stopEditingWithNewSystem(node.id, true);
        await this.exitEditModeWithNewSystem(cardElement, contentDiv, node.id, newText);
        this.completeEditingStateCleanup();
      },
      // 取消回调
      onCancel: async () => {
        this.stopEditingWithNewSystem(node.id, false);
        await this.exitEditModeWithNewSystem(cardElement, contentDiv, node.id, originalText);
        this.completeEditingStateCleanup();
      }
    }).then((editor) => {
      this.enterEditMode(cardElement, contentDiv, editor);
    }).catch((error) => {
      DebugManager.error("Failed to create editor with coordinator, falling back to legacy method:", error);
      this.startTextEditingLegacy(node, cardElement);
    });
  }
  // 原有的文本编辑方法（重命名为legacy）
  startTextEditingLegacy(node, cardElement) {
    const contentDiv = cardElement.querySelector(".card-content");
    if (!contentDiv)
      return;
    const editorState = this.startEditingWithNewSystem(node.id, node, cardElement);
    const originalText = node.text || "";
    const editor = this.createTextEditorWithNewSystem(
      originalText,
      // 内容变化回调
      (newText) => {
        this.updateContentWithNewSystem(node.id, { ...node, text: newText });
      },
      // 保存回调
      async (newText) => {
        this.stopEditingWithNewSystem(node.id, true);
        await this.exitEditModeWithNewSystem(cardElement, contentDiv, node.id, newText);
        this.completeEditingStateCleanup();
      },
      // 取消回调
      async () => {
        this.stopEditingWithNewSystem(node.id, false);
        await this.exitEditModeWithNewSystem(cardElement, contentDiv, node.id, originalText);
        this.completeEditingStateCleanup();
      }
    );
    this.enterEditMode(cardElement, contentDiv, editor);
  }
  // 创建文本编辑器 - 使用Obsidian的CodeMirror编辑器
  createTextEditor(text, onSave, onCancel, enableAutoSave = true) {
    const editorContainer = document.createElement("div");
    editorContainer.className = "card-editor-container obsidian-editor";
    editorContainer.style.width = "100%";
    editorContainer.style.height = "100%";
    editorContainer.style.position = "relative";
    editorContainer.style.overflow = "hidden";
    this.createObsidianEditor(editorContainer, text, onSave, onCancel, enableAutoSave);
    return editorContainer;
  }
  // 创建文本编辑器（新状态管理系统版本）
  createTextEditorWithNewSystem(text, onChange, onSave, onCancel) {
    const nodeId = `temp-${Date.now()}`;
    const placeholderContainer = document.createElement("div");
    placeholderContainer.className = "card-editor-container obsidian-editor";
    placeholderContainer.style.width = "100%";
    placeholderContainer.style.height = "100%";
    placeholderContainer.style.position = "relative";
    placeholderContainer.style.overflow = "hidden";
    this.editorStateCoordinator.createEditor({
      nodeId,
      content: text,
      onChange,
      onSave,
      onCancel
    }).then((editorContainer) => {
      placeholderContainer.innerHTML = "";
      placeholderContainer.appendChild(editorContainer);
      placeholderContainer.cleanup = editorContainer.cleanup;
    }).catch((error) => {
      DebugManager.error("Failed to create editor with coordinator:", error);
      this.createObsidianEditorWithNewSystem(placeholderContainer, text, onChange, onSave, onCancel);
    });
    return placeholderContainer;
  }
  // 创建Obsidian编辑器实例
  async createObsidianEditor(container, text, onSave, onCancel, enableAutoSave) {
    try {
      const tempFileName = `temp-editor-${Date.now()}.md`;
      const tempFile = await this.app.vault.create(tempFileName, text);
      const leaf = this.app.workspace.createLeafInParent(this.app.workspace.rootSplit, 0);
      await leaf.openFile(tempFile);
      const markdownView = leaf.view;
      if (markdownView && markdownView.editor) {
        const editor = markdownView.editor;
        const editorEl = markdownView.contentEl;
        if (editorEl) {
          container.empty();
          container.appendChild(editorEl);
          this.setupLegacyEditorStyles(editorEl);
          editor.setValue(text);
          let autoSaveTimeout = null;
          const autoSave = () => {
            if (!enableAutoSave)
              return;
            if (autoSaveTimeout) {
              clearTimeout(autoSaveTimeout);
            }
            autoSaveTimeout = setTimeout(() => {
            }, PERFORMANCE_CONSTANTS.STANDARD_DELAY);
          };
          const changeHandler = () => {
            if (enableAutoSave) {
              autoSave();
            }
          };
          this.app.workspace.on("editor-change", changeHandler);
          const keyHandler = (evt) => {
            if (evt.key === "Escape") {
              evt.preventDefault();
              if (autoSaveTimeout) {
                clearTimeout(autoSaveTimeout);
                autoSaveTimeout = null;
              }
              onSave(editor.getValue());
              this.cleanupTempEditor(leaf, tempFile, changeHandler);
            } else if (evt.key === "Enter" && (evt.ctrlKey || evt.metaKey)) {
              evt.preventDefault();
              if (autoSaveTimeout) {
                clearTimeout(autoSaveTimeout);
                autoSaveTimeout = null;
              }
              onSave(editor.getValue());
              this.cleanupTempEditor(leaf, tempFile, changeHandler);
            }
          };
          editorEl.addEventListener("keydown", keyHandler);
          setTimeout(() => {
            editor.focus();
            const lastLine = editor.lastLine();
            const lastLineLength = editor.getLine(lastLine).length;
            editor.setCursor({ line: lastLine, ch: lastLineLength });
          }, 100);
          container.editorInstance = editor;
          container.cleanup = () => {
            this.cleanupTempEditor(leaf, tempFile, changeHandler);
            editorEl.removeEventListener("keydown", keyHandler);
          };
        }
      }
    } catch (error) {
      DebugManager.error("Failed to create Obsidian editor:", error);
      this.createFallbackEditor(container, text, onSave, onCancel, enableAutoSave);
    }
  }
  // 清理临时编辑器（保留向后兼容）
  async cleanupTempEditor(leaf, tempFile, changeHandler) {
    try {
      this.app.workspace.off("editor-change", changeHandler);
      leaf.detach();
      await this.app.vault.delete(tempFile);
    } catch (error) {
      DebugManager.error("Failed to cleanup temp editor:", error);
    }
  }
  // 新的统一清理方法
  async cleanupEditorWithCoordinator(nodeId, saveChanges = false) {
    try {
      await this.editorStateCoordinator.cleanupEditor(nodeId, saveChanges);
      DebugManager.log("Editor cleaned up with coordinator:", nodeId);
    } catch (error) {
      DebugManager.error("Failed to cleanup editor with coordinator:", error);
    }
  }
  // 启动定期健康检查
  startPeriodicHealthCheck() {
    setInterval(() => {
      this.performHealthCheck();
    }, 5 * 60 * 1e3);
    setTimeout(() => {
      this.performHealthCheck();
    }, 1e4);
  }
  // 执行健康检查
  async performHealthCheck() {
    try {
      const healthStatus = this.diagnosticsManager.checkSystemHealth();
      if (!healthStatus.isHealthy) {
        DebugManager.warn("System health check detected issues:", healthStatus.issues);
        const fixAttempted = await this.diagnosticsManager.performAutoFix(healthStatus);
        if (fixAttempted) {
          DebugManager.log("Auto-fix attempted for health issues");
          const recheck = this.diagnosticsManager.checkSystemHealth();
          if (recheck.isHealthy) {
            DebugManager.log("Auto-fix successful, system is now healthy");
          } else {
            DebugManager.warn("Auto-fix completed but issues remain:", recheck.issues);
          }
        }
      } else {
        DebugManager.log("System health check passed");
      }
    } catch (error) {
      DebugManager.error("Health check failed:", error);
    }
  }
  // 回退编辑器（当Obsidian编辑器创建失败时使用）
  createFallbackEditor(container, text, onSave, onCancel, enableAutoSave) {
    const textarea = document.createElement("textarea");
    textarea.className = "card-editor-textarea fallback-editor";
    textarea.value = text;
    textarea.style.width = "100%";
    textarea.style.height = "100%";
    textarea.style.border = "none";
    textarea.style.outline = "none";
    textarea.style.resize = "none";
    textarea.style.padding = "0";
    textarea.style.fontFamily = "var(--font-text)";
    textarea.style.fontSize = "var(--font-text-size)";
    textarea.style.lineHeight = "1.5";
    textarea.style.background = "transparent";
    textarea.style.color = "var(--text-normal)";
    textarea.style.borderRadius = "inherit";
    textarea.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        e.preventDefault();
        onSave(textarea.value);
      } else if (e.key === "Enter" && (e.ctrlKey || e.metaKey)) {
        e.preventDefault();
        onSave(textarea.value);
      }
    });
    container.empty();
    container.appendChild(textarea);
    setTimeout(() => {
      textarea.focus();
      textarea.setSelectionRange(textarea.value.length, textarea.value.length);
    }, 0);
  }
  // 创建Obsidian编辑器实例（新状态管理系统版本）
  async createObsidianEditorWithNewSystem(container, text, onChange, onSave, onCancel) {
    try {
      const tempFileName = `temp-editor-${Date.now()}.md`;
      const tempFile = await this.app.vault.create(tempFileName, text);
      const leaf = this.app.workspace.createLeafInParent(this.app.workspace.rootSplit, 0);
      await leaf.openFile(tempFile);
      const markdownView = leaf.view;
      if (markdownView && markdownView.editor) {
        const editor = markdownView.editor;
        const editorEl = markdownView.contentEl;
        if (editorEl) {
          container.empty();
          container.appendChild(editorEl);
          this.setupLegacyEditorStyles(editorEl);
          editor.setValue(text);
          const changeHandler = () => {
            const currentText = editor.getValue();
            onChange(currentText);
          };
          this.app.workspace.on("editor-change", changeHandler);
          const keyHandler = (evt) => {
            if (evt.key === "Escape") {
              evt.preventDefault();
              onCancel();
              this.cleanupTempEditor(leaf, tempFile, changeHandler);
            } else if (evt.key === "Enter" && (evt.ctrlKey || evt.metaKey)) {
              evt.preventDefault();
              onSave(editor.getValue());
              this.cleanupTempEditor(leaf, tempFile, changeHandler);
            }
          };
          editorEl.addEventListener("keydown", keyHandler);
          setTimeout(() => {
            editor.focus();
            const lastLine = editor.lastLine();
            const lastLineLength = editor.getLine(lastLine).length;
            editor.setCursor({ line: lastLine, ch: lastLineLength });
          }, 100);
          container.editorInstance = editor;
          container.cleanup = () => {
            this.cleanupTempEditor(leaf, tempFile, changeHandler);
            editorEl.removeEventListener("keydown", keyHandler);
          };
        }
      }
    } catch (error) {
      DebugManager.error("Failed to create Obsidian editor with new system:", error);
      this.createFallbackEditorWithNewSystem(container, text, onChange, onSave, onCancel);
    }
  }
  // 回退编辑器（新状态管理系统版本）
  createFallbackEditorWithNewSystem(container, text, onChange, onSave, onCancel) {
    const textarea = document.createElement("textarea");
    textarea.className = "card-editor-textarea fallback-editor";
    textarea.value = text;
    textarea.style.width = "100%";
    textarea.style.height = "100%";
    textarea.style.border = "none";
    textarea.style.outline = "none";
    textarea.style.resize = "none";
    textarea.style.fontFamily = "var(--font-text)";
    textarea.style.fontSize = "var(--font-text-size)";
    textarea.style.lineHeight = "var(--line-height-normal)";
    textarea.style.color = "var(--text-normal)";
    textarea.style.background = "transparent";
    textarea.style.padding = "0";
    textarea.style.borderRadius = "inherit";
    textarea.addEventListener("input", () => {
      onChange(textarea.value);
    });
    textarea.addEventListener("keydown", (evt) => {
      if (evt.key === "Escape") {
        evt.preventDefault();
        onCancel();
      } else if (evt.key === "Enter" && (evt.ctrlKey || evt.metaKey)) {
        evt.preventDefault();
        onSave(textarea.value);
      }
    });
    container.empty();
    container.appendChild(textarea);
    setTimeout(() => {
      textarea.focus();
      textarea.setSelectionRange(textarea.value.length, textarea.value.length);
    }, 0);
  }
  // 从编辑器容器获取内容
  getEditorContent(editorContainer) {
    const storedEditor = editorContainer.editorInstance;
    if (storedEditor && typeof storedEditor.getValue === "function") {
      return storedEditor.getValue();
    }
    const textarea = editorContainer.querySelector("textarea");
    if (textarea) {
      return textarea.value;
    }
    return "";
  }
  // 清除编辑状态
  clearEditingState() {
    this.currentEditingCard = null;
    this.currentEditingNode = null;
  }
  /**
   * 🎯 新增：获取当前编辑的内容容器
   */
  getEditingContentDiv() {
    if (!this.currentEditingCard) {
      DebugManager.warn("\u26A0\uFE0F \u5F53\u524D\u65E0\u7F16\u8F91\u5361\u7247");
      return null;
    }
    const contentDiv = this.currentEditingCard.querySelector(".card-content");
    if (!contentDiv) {
      DebugManager.error("\u274C \u65E0\u6CD5\u627E\u5230\u5361\u7247\u5185\u5BB9\u5BB9\u5668", {
        cardId: this.currentEditingCard.dataset.nodeId
      });
      return null;
    }
    return contentDiv;
  }
  /**
   * 🎯 新增：验证编辑上下文的完整性
   */
  validateEditingContext() {
    const isValid = !!(this.currentEditingCard && this.currentEditingNode);
    if (!isValid) {
      DebugManager.warn("\u26A0\uFE0F \u7F16\u8F91\u4E0A\u4E0B\u6587\u9A8C\u8BC1\u5931\u8D25", {
        hasCard: !!this.currentEditingCard,
        hasNode: !!this.currentEditingNode
      });
    }
    return isValid;
  }
  // 退出当前编辑状态
  exitCurrentEditingState(save = false) {
    if (!this.currentEditingCard || !this.currentEditingNode)
      return;
    const nodeId = this.currentEditingNode.id;
    const cardElement = this.currentEditingCard;
    const contentDiv = this.getEditingContentDiv();
    if (!contentDiv) {
      DebugManager.error("\u274C \u65E0\u6CD5\u83B7\u53D6\u5185\u5BB9\u5BB9\u5668\uFF0C\u56DE\u9000\u5230\u4F20\u7EDF\u65B9\u6CD5", { nodeId });
      this.exitCurrentEditingStateLegacy(save);
      return;
    }
    if (this.editorStateCoordinator && this.editorStateCoordinator.isEditorActive(nodeId)) {
      DebugManager.log("\u{1F504} \u4F7F\u7528\u534F\u8C03\u5668\u6E05\u7406\u7F16\u8F91\u72B6\u6001", { nodeId, save });
      this.editorStateCoordinator.cleanupEditor(nodeId, save).then((cleanupResult) => {
        DebugManager.log("\u2705 \u534F\u8C03\u5668\u6E05\u7406\u5B8C\u6210\uFF0C\u5F00\u59CBUI\u6062\u590D", {
          nodeId,
          hasContent: !!cleanupResult?.content,
          contentLength: cleanupResult?.content?.length || 0
        });
        if (contentDiv && cardElement) {
          const editedContent = cleanupResult?.content || this.currentEditingNode?.text || "";
          DebugManager.log("\u{1F527} \u6267\u884CUI\u6062\u590D\u548C\u5185\u5BB9\u6E32\u67D3", {
            nodeId,
            contentPreview: editedContent.substring(0, 50) + (editedContent.length > 50 ? "..." : ""),
            contentLength: editedContent.length
          });
          this.exitEditModeWithNewSystem(cardElement, contentDiv, nodeId, editedContent);
        } else {
          DebugManager.error("\u274C UI\u6062\u590D\u5931\u8D25\uFF1A\u7F3A\u5C11\u5FC5\u8981\u7684DOM\u5143\u7D20", {
            nodeId,
            hasCardElement: !!cardElement,
            hasContentDiv: !!contentDiv
          });
        }
        this.completeEditingStateCleanup();
      }).catch((error) => {
        DebugManager.error("Failed to cleanup with coordinator, falling back to legacy method:", error);
        this.exitCurrentEditingStateLegacy(save);
      });
      return;
    }
    this.exitCurrentEditingStateLegacy(save);
  }
  // 原有的退出编辑状态方法（重命名为legacy）
  exitCurrentEditingStateLegacy(save = false) {
    if (!this.currentEditingCard || !this.currentEditingNode)
      return;
    const contentDiv = this.currentEditingCard.querySelector(".card-content");
    if (!contentDiv)
      return;
    const textarea = this.currentEditingCard.querySelector("textarea");
    const input = this.currentEditingCard.querySelector("input");
    const editorContainer = this.currentEditingCard.querySelector(".card-editor-container");
    if (save) {
      if (this.currentEditingNode.type === "text") {
        let textContent = "";
        if (editorContainer) {
          textContent = this.getEditorContent(editorContainer);
        } else if (textarea) {
          textContent = textarea.value;
        }
        this.saveTextNode(this.currentEditingNode, textContent);
        this.exitEditMode(this.currentEditingCard, contentDiv, textContent);
      } else if (input && this.currentEditingNode.type === "link") {
        this.saveLinkNodeAndRefresh(this.currentEditingNode, input.value, this.currentEditingCard, contentDiv);
      }
    } else {
      if (this.currentEditingNode.type === "text") {
        this.exitEditMode(this.currentEditingCard, contentDiv, this.currentEditingNode.text || "");
      } else if (this.currentEditingNode.type === "link") {
        this.exitEditModeAndRefresh(this.currentEditingCard, contentDiv, this.currentEditingNode);
      }
    }
    this.completeEditingStateCleanup();
  }
  // ==================== Canvas数据同步方法 ====================
  // 建立与官方Canvas的双向数据同步
  setupCanvasDataSync() {
    try {
      this.registerEvent(
        this.app.vault.on("modify", (file) => {
          if (file instanceof import_obsidian12.TFile && file.extension === "canvas" && file === this.linkedCanvasFile) {
            DebugManager.log("\u{1F504} Canvas\u6587\u4EF6\u53D8\u5316\uFF0C\u540C\u6B65\u6570\u636E:", file.path);
            this.syncCanvasDataFromFile(file);
          }
        })
      );
      this.registerEvent(
        this.app.workspace.on("active-leaf-change", (leaf) => {
          if (leaf?.view?.getViewType() === "canvas") {
            const canvasView = leaf.view;
            if (canvasView.file === this.linkedCanvasFile) {
              DebugManager.log("\u{1F504} Canvas\u89C6\u56FE\u6FC0\u6D3B\uFF0C\u540C\u6B65\u6570\u636E");
              this.syncCanvasDataFromView(canvasView);
            }
          }
        })
      );
      this.registerEvent(
        this.app.vault.on("delete", (file) => {
          if (file instanceof import_obsidian12.TFile && file.extension === "canvas" && file === this.linkedCanvasFile) {
            DebugManager.log("\u{1F5D1}\uFE0F Canvas\u6587\u4EF6\u88AB\u5220\u9664\uFF0C\u6E05\u7406\u89C6\u56FE\u72B6\u6001");
            this.canvasData = null;
            this.filteredNodes = [];
            this.renderGrid();
          }
        })
      );
      this.setupCanvasSpecificEventListeners();
      DebugManager.log("\u2705 Canvas\u6570\u636E\u540C\u6B65\u673A\u5236\u5DF2\u5EFA\u7ACB\uFF08\u589E\u5F3A\u7248\uFF09");
    } catch (error) {
      DebugManager.error("Failed to setup Canvas data sync:", error);
    }
  }
  // 设置Canvas特定事件监听器
  setupCanvasSpecificEventListeners() {
    try {
      const events = [
        "canvas:node-moved",
        "canvas:node-resized",
        "canvas:node-added",
        "canvas:node-removed",
        "canvas:group-changed"
      ];
      events.forEach((eventName) => {
        try {
          this.registerEvent(
            this.app.workspace.on(eventName, (data) => {
              if (this.linkedCanvasFile) {
                DebugManager.log(`\u{1F504} Canvas\u4E8B\u4EF6 [${eventName}]:`, data);
                this.handleCanvasEvent(eventName, data);
              }
            })
          );
        } catch (e) {
          DebugManager.log(`Canvas\u4E8B\u4EF6 [${eventName}] \u4E0D\u53EF\u7528`);
        }
      });
    } catch (error) {
      DebugManager.error("Failed to setup Canvas specific event listeners:", error);
    }
  }
  // 处理Canvas事件
  handleCanvasEvent(eventName, data) {
    switch (eventName) {
      case "canvas:group-changed":
        this.analyzeGroups();
        this.renderGrid();
        break;
      case "canvas:node-added":
      case "canvas:node-removed":
        if (this.linkedCanvasFile) {
          this.syncCanvasDataFromFile(this.linkedCanvasFile);
        }
        break;
      case "canvas:node-moved":
      case "canvas:node-resized":
        this.analyzeGroups();
        break;
    }
  }
  // 从文件同步Canvas数据
  async syncCanvasDataFromFile(file) {
    try {
      await this.loadCanvasDataFromOfficialView(file);
      this.analyzeGroups();
      this.renderGrid();
      DebugManager.log("\u2705 Canvas\u6570\u636E\u4ECE\u6587\u4EF6\u540C\u6B65\u5B8C\u6210");
    } catch (error) {
      DebugManager.error("Failed to sync Canvas data from file:", error);
    }
  }
  // 从视图同步Canvas数据
  syncCanvasDataFromView(canvasView) {
    try {
      const canvasData = this.extractCanvasDataFromView(canvasView);
      if (canvasData) {
        this.canvasData = canvasData;
        this.filteredNodes = [...canvasData.nodes];
        this.analyzeGroups();
        this.renderGrid();
        DebugManager.log("\u2705 Canvas\u6570\u636E\u4ECE\u89C6\u56FE\u540C\u6B65\u5B8C\u6210");
      }
    } catch (error) {
      DebugManager.error("Failed to sync Canvas data from view:", error);
    }
  }
  // ==================== 分组功能相关方法 ====================
  // 分析Canvas中的分组和成员关系（使用官方Canvas状态）
  analyzeGroups() {
    if (!this.canvasData)
      return;
    this.groupAnalysis.clear();
    const groupNodes = this.canvasData.nodes.filter((node) => node.type === "group");
    groupNodes.forEach((group) => {
      const members = this.findGroupMembersFromOfficialState(group);
      const groupInfo = {
        group,
        members,
        memberCount: members.length,
        bounds: this.calculateGroupBounds(group)
      };
      this.groupAnalysis.set(group.id, groupInfo);
      DebugManager.log(`\u2705 \u5206\u7EC4\u5206\u6790 [${group.id}]: ${members.length} \u4E2A\u6210\u5458`);
    });
    DebugManager.log("\u5206\u7EC4\u5206\u6790\u5B8C\u6210\uFF0C\u603B\u5206\u7EC4\u6570:", this.groupAnalysis.size);
  }
  // 从官方Canvas状态查找分组成员
  findGroupMembersFromOfficialState(group) {
    if (!this.canvasData) {
      DebugManager.log(`\u274C Canvas\u6570\u636E\u4E0D\u5B58\u5728 [${group.id}]`);
      return [];
    }
    DebugManager.log(`\u{1F50D} \u5F00\u59CB\u67E5\u627E\u5206\u7EC4\u6210\u5458 [${group.id}]:`, {
      groupType: group.type,
      groupText: group.text?.substring(0, 50),
      totalNodes: this.canvasData.nodes.length
    });
    const officialMembers = this.getGroupMembersFromOfficialView(group.id);
    if (officialMembers && officialMembers.length > 0) {
      DebugManager.log(`\u2705 \u4ECE\u5B98\u65B9Canvas\u83B7\u53D6\u5206\u7EC4\u6210\u5458 [${group.id}]: ${officialMembers.length} \u4E2A`);
      return officialMembers;
    }
    DebugManager.log(`\u{1F504} \u56DE\u9000\u5230\u8FB9\u754C\u68C0\u6D4B\u65B9\u6CD5 [${group.id}]`);
    const boundaryMembers = this.findGroupMembersByBounds(group);
    DebugManager.log(`\u{1F504} \u8FB9\u754C\u68C0\u6D4B\u7ED3\u679C [${group.id}]: ${boundaryMembers.length} \u4E2A\u6210\u5458`);
    return boundaryMembers;
  }
  // 从官方Canvas视图获取分组成员
  getGroupMembersFromOfficialView(groupId) {
    try {
      if (!this.linkedCanvasFile)
        return [];
      const canvasView = this.getOfficialCanvasView(this.linkedCanvasFile);
      if (!canvasView)
        return [];
      let groupMembers = [];
      if (canvasView.canvas?.groups?.[groupId]) {
        const groupData = canvasView.canvas.groups[groupId];
        if (Array.isArray(groupData.members)) {
          groupMembers = groupData.members;
        } else if (groupData.children) {
          groupMembers = Array.isArray(groupData.children) ? groupData.children : [];
        }
      } else if (canvasView.canvas?.data?.groups?.[groupId]) {
        const groupData = canvasView.canvas.data.groups[groupId];
        groupMembers = groupData.members || groupData.children || [];
      } else if (canvasView.canvas?.nodes) {
        const nodes = canvasView.canvas.nodes;
        for (const [nodeId, nodeData] of Object.entries(nodes)) {
          if (nodeData.parent === groupId || nodeData.groupId === groupId) {
            groupMembers.push(nodeId);
          }
        }
      }
      if (groupMembers.length > 0) {
        const memberNodes = groupMembers.map((memberId) => this.canvasData?.nodes.find((node) => node.id === memberId)).filter((node) => node !== void 0);
        DebugManager.log(`\u2705 \u5B98\u65B9Canvas\u5206\u7EC4\u6210\u5458 [${groupId}]: ${memberNodes.length} \u4E2A`);
        return memberNodes;
      }
      return [];
    } catch (error) {
      DebugManager.error("Error getting group members from official view:", error);
      return [];
    }
  }
  // 传统的边界检测方法（回退方案）
  findGroupMembersByBounds(group) {
    if (!this.canvasData)
      return [];
    const groupBounds = this.calculateGroupBounds(group);
    const members = [];
    this.canvasData.nodes.forEach((node) => {
      if (node.type !== "group" && node.id !== group.id) {
        if (this.isNodeInsideGroup(node, groupBounds)) {
          members.push(node);
        }
      }
    });
    DebugManager.log(`\u{1F504} \u8FB9\u754C\u68C0\u6D4B\u5206\u7EC4\u6210\u5458 [${group.id}]: ${members.length} \u4E2A`);
    return members;
  }
  // 计算分组的边界框
  calculateGroupBounds(group) {
    return {
      minX: group.x,
      minY: group.y,
      maxX: group.x + group.width,
      maxY: group.y + group.height
    };
  }
  // 判断节点是否在分组内
  isNodeInsideGroup(node, groupBounds) {
    const nodeCenter = {
      x: node.x + node.width / 2,
      y: node.y + node.height / 2
    };
    return nodeCenter.x >= groupBounds.minX && nodeCenter.x <= groupBounds.maxX && nodeCenter.y >= groupBounds.minY && nodeCenter.y <= groupBounds.maxY;
  }
  // 获取所有分组信息 - 支持时间胶囊分组置顶
  getGroupsForGridView() {
    const groups = Array.from(this.groupAnalysis.values());
    const sortedGroups = groups.sort((a, b) => {
      const aIsActive = this.isActiveTimeCapsuleGroup(a.group.id);
      const bIsActive = this.isActiveTimeCapsuleGroup(b.group.id);
      const aIsHistorical = this.isHistoricalTimeCapsuleGroup(a.group.id);
      const bIsHistorical = this.isHistoricalTimeCapsuleGroup(b.group.id);
      if (aIsActive && !bIsActive)
        return -1;
      if (!aIsActive && bIsActive)
        return 1;
      if (aIsHistorical && !bIsHistorical && !bIsActive)
        return -1;
      if (!aIsHistorical && bIsHistorical && !aIsActive)
        return 1;
      return b.group.id.localeCompare(a.group.id);
    });
    DebugManager.log("\u{1F504} Group sorting result:");
    sortedGroups.forEach((group, index) => {
      const isActive = this.isActiveTimeCapsuleGroup(group.group.id);
      const isHistorical = this.isHistoricalTimeCapsuleGroup(group.group.id);
      const type = isActive ? "ACTIVE" : isHistorical ? "HISTORICAL" : "NORMAL";
      DebugManager.log(`  ${index + 1}. [${type}] ${group.group.id}`);
    });
    return sortedGroups;
  }
  // 判断是否为时间胶囊分组（包括历史时间胶囊）
  isTimeCapsuleGroup(groupId) {
    if (groupId.startsWith("time-capsule-")) {
      return true;
    }
    const groupInfo = this.groupAnalysis.get(groupId);
    if (groupInfo && groupInfo.group.label) {
      const label = groupInfo.group.label.toLowerCase();
      return label.includes("\u65F6\u95F4\u80F6\u56CA") || label.includes("time-capsule") || label.includes("time capsule");
    }
    return false;
  }
  // 判断是否为当前激活的时间胶囊分组
  isActiveTimeCapsuleGroup(groupId) {
    return this.timeCapsuleState.isActive && groupId === this.timeCapsuleState.groupId;
  }
  // 判断是否为历史时间胶囊分组
  isHistoricalTimeCapsuleGroup(groupId) {
    return this.isTimeCapsuleGroup(groupId) && !this.isActiveTimeCapsuleGroup(groupId);
  }
  // 进入分组视图
  enterGroupView(groupId) {
    DebugManager.log(`\u{1F50D} \u5C1D\u8BD5\u8FDB\u5165\u5206\u7EC4\u89C6\u56FE: ${groupId}`);
    const groupInfo = this.groupAnalysis.get(groupId);
    if (!groupInfo) {
      DebugManager.error(`\u274C \u5206\u7EC4\u4FE1\u606F\u4E0D\u5B58\u5728: ${groupId}`);
      new import_obsidian12.Notice(`\u5206\u7EC4\u4E0D\u5B58\u5728: ${groupId}`);
      return;
    }
    DebugManager.log(`\u2705 \u627E\u5230\u5206\u7EC4\u4FE1\u606F:`, {
      groupId,
      memberCount: groupInfo.members.length,
      members: groupInfo.members.map((m) => ({ id: m.id, type: m.type, text: m.text?.substring(0, 50) }))
    });
    this.currentGroupView = groupId;
    this.filteredNodes = groupInfo.members;
    DebugManager.log(`\u{1F3AF} \u8BBE\u7F6E\u5206\u7EC4\u89C6\u56FE\u7B5B\u9009\u8282\u70B9: ${this.filteredNodes.length} \u4E2A`);
    if (groupInfo.members.length === 0) {
      DebugManager.log(`\u26A0\uFE0F \u5206\u7EC4\u4E3A\u7A7A\uFF0C\u663E\u793A\u7A7A\u72B6\u6001\u63D0\u793A`);
      new import_obsidian12.Notice(`\u5206\u7EC4 "${groupInfo.group.text || groupId}" \u6682\u65E0\u5185\u5BB9`);
    }
    this.renderGrid().catch((error) => {
      DebugManager.error("Failed to render grid in group view:", error);
    });
    this.updateToolbarForGroupView(groupInfo);
    DebugManager.log(`\u2705 \u5206\u7EC4\u89C6\u56FE\u8FDB\u5165\u5B8C\u6210: ${groupId}`);
  }
  // 退出分组视图，返回主视图
  exitGroupView() {
    this.currentGroupView = null;
    if (this.canvasData) {
      this.filteredNodes = this.getAllDisplayNodes();
    }
    this.renderGrid().catch((error) => {
      DebugManager.error("Failed to render grid after exiting group view:", error);
    });
    this.updateToolbarForMainView();
  }
  // 更新工具栏显示分组视图信息
  updateToolbarForGroupView(groupInfo) {
    this.addGroupViewBackButtonToColorRow();
  }
  // 在颜色行中添加返回按钮
  addGroupViewBackButtonToColorRow() {
    const toolbar = this.containerEl.querySelector(".canvas-grid-toolbar");
    if (!toolbar)
      return;
    const functionRow = toolbar.querySelector(".canvas-grid-toolbar-function-row");
    if (!functionRow)
      return;
    const existingBackButton = toolbar.querySelector(".group-back-button-toolbar");
    if (existingBackButton) {
      existingBackButton.remove();
    }
    const backButton = document.createElement("button");
    backButton.className = "group-back-button-toolbar";
    backButton.title = this.settings.language === "zh" ? "\u8FD4\u56DE\u4E3B\u89C6\u56FE" : "Back to main view";
    backButton.setAttribute("aria-label", this.settings.language === "zh" ? "\u8FD4\u56DE\u4E3B\u89C6\u56FE" : "Back to main view");
    backButton.innerHTML = `
			<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<polyline points="15,18 9,12 15,6"/>
			</svg>
		`;
    backButton.onclick = () => this.exitGroupView();
    functionRow.insertBefore(backButton, functionRow.firstChild);
  }
  // 恢复主视图工具栏
  updateToolbarForMainView() {
    const toolbar = this.containerEl.querySelector(".canvas-grid-toolbar");
    if (!toolbar)
      return;
    const existingBackButton = toolbar.querySelector(".group-back-button-toolbar");
    if (existingBackButton) {
      existingBackButton.remove();
    }
  }
  // 渲染分组成员（在分组视图中）
  async renderGroupMembers() {
    if (!this.currentGroupView) {
      DebugManager.log("\u274C \u5F53\u524D\u4E0D\u5728\u5206\u7EC4\u89C6\u56FE\u4E2D");
      return;
    }
    const groupInfo = this.groupAnalysis.get(this.currentGroupView);
    if (!groupInfo) {
      DebugManager.log(`\u274C \u5206\u7EC4\u4FE1\u606F\u4E0D\u5B58\u5728: ${this.currentGroupView}`);
      return;
    }
    DebugManager.log(`\u{1F3AF} \u6E32\u67D3\u5206\u7EC4\u6210\u5458 [${this.currentGroupView}]: ${groupInfo.members.length} \u4E2A`);
    if (this.gridContainer) {
      this.gridContainer.empty();
    }
    if (groupInfo.members.length === 0) {
      this.renderEmptyGroupState(groupInfo);
      return;
    }
    if (groupInfo.members.length > 50) {
      await this.renderGridBatched(groupInfo.members);
    } else {
      await this.renderGridImmediate(groupInfo.members);
    }
    this.setupCardDragAttributes();
    DebugManager.log(`\u2705 \u5206\u7EC4\u6210\u5458\u6E32\u67D3\u5B8C\u6210 [${this.currentGroupView}]: ${groupInfo.members.length} \u4E2A\u5361\u7247`);
  }
  // 渲染空分组状态
  renderEmptyGroupState(groupInfo) {
    if (!this.gridContainer)
      return;
    const emptyState = this.gridContainer.createDiv("canvas-selection-empty");
    emptyState.innerHTML = `
			<div class="empty-icon">\u{1F4C1}</div>
			<div class="empty-title">\u5206\u7EC4\u6682\u65E0\u5185\u5BB9</div>
			<div class="empty-description">
				\u5206\u7EC4 "${groupInfo.group.text || groupInfo.group.id}" \u4E2D\u8FD8\u6CA1\u6709\u4EFB\u4F55\u5361\u7247
			</div>
		`;
    DebugManager.log(`\u{1F4C1} \u663E\u793A\u7A7A\u5206\u7EC4\u72B6\u6001: ${groupInfo.group.id}`);
  }
  // 获取未分组的节点
  getUngroupedNodes(nodes) {
    const ungroupedNodes = [];
    nodes.forEach((node) => {
      let isInGroup = false;
      for (const groupInfo of this.groupAnalysis.values()) {
        if (groupInfo.members.some((member) => member.id === node.id)) {
          isInGroup = true;
          break;
        }
      }
      if (!isInGroup) {
        ungroupedNodes.push(node);
      }
    });
    return ungroupedNodes;
  }
  // 渲染网格项目（分组卡片和普通节点）
  async renderGridItems(items) {
    const fragment = document.createDocumentFragment();
    const groupItems = items.filter((item) => item.type === "group");
    const nodeItems = items.filter((item) => item.type === "node");
    groupItems.forEach((item) => {
      const card = this.createGroupCard(item.data);
      fragment.appendChild(card);
    });
    if (nodeItems.length > 0) {
      const cardPromises = nodeItems.map((item) => this.createCard(item.data));
      const cards = await Promise.all(cardPromises);
      cards.forEach((card) => {
        if (this.searchQuery) {
          this.highlightSearchResults(card, this.searchQuery);
        }
        fragment.appendChild(card);
      });
    }
    this.gridContainer.appendChild(fragment);
  }
  // 创建分组卡片
  createGroupCard(groupInfo) {
    const card = document.createElement("div");
    const isTimeCapsule = this.isTimeCapsuleGroup(groupInfo.group.id);
    const isActiveTimeCapsule = this.isActiveTimeCapsuleGroup(groupInfo.group.id);
    const isHistoricalTimeCapsule = this.isHistoricalTimeCapsuleGroup(groupInfo.group.id);
    DebugManager.log(`\u{1F50D} Creating group card: ${groupInfo.group.label}`);
    DebugManager.log(`   ID: ${groupInfo.group.id}`);
    DebugManager.log(`   Color: ${groupInfo.group.color}`);
    DebugManager.log(`   Member count: ${groupInfo.memberCount}`);
    DebugManager.log(`   isTimeCapsule: ${isTimeCapsule}`);
    DebugManager.log(`   isActiveTimeCapsule: ${isActiveTimeCapsule}`);
    DebugManager.log(`   isHistoricalTimeCapsule: ${isHistoricalTimeCapsule}`);
    DebugManager.log(`   Current timeCapsule state:`, {
      isActive: this.timeCapsuleState.isActive,
      groupId: this.timeCapsuleState.groupId,
      groupName: this.timeCapsuleState.groupName
    });
    if (isActiveTimeCapsule) {
      card.className = "canvas-grid-card group-card time-capsule-group time-capsule-collecting";
    } else if (isHistoricalTimeCapsule) {
      card.className = "canvas-grid-card group-card time-capsule-group time-capsule-historical";
    } else {
      card.className = "canvas-grid-card group-card";
    }
    card.dataset.nodeId = groupInfo.group.id;
    card.dataset.nodeType = "group";
    card.dataset.groupLabel = groupInfo.group.label || "\u672A\u547D\u540D\u5206\u7EC4";
    card.style.minHeight = `${CARD_CONSTANTS.height}px`;
    if (groupInfo.group.color) {
      const normalizedColor = this.normalizeColorValue(groupInfo.group.color);
      if (normalizedColor) {
        const colorStyles = this.getColorStyles(normalizedColor);
        card.style.backgroundColor = colorStyles.backgroundColor;
        card.style.borderColor = colorStyles.borderColor;
        card.style.color = colorStyles.textColor;
      }
    }
    const contentDiv = card.createDiv("group-card-content");
    if (isTimeCapsule) {
      const titleDiv = contentDiv.createDiv("group-title time-capsule-title");
      titleDiv.textContent = groupInfo.group.label || "\u672A\u547D\u540D\u5206\u7EC4";
      const iconContainer = contentDiv.createDiv("time-capsule-icon-container");
      const iconDiv = iconContainer.createDiv("group-icon time-capsule-icon-wrapper");
      if (isActiveTimeCapsule) {
        iconDiv.innerHTML = `
					<svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
						<path d="M6 2v6h.01L6 8.01 10 12l-4 4-.01.01V22h12v-5.99-.01L18 16l-4-4 4-3.99.01-.01V2H6z"/>
					</svg>
				`;
        iconDiv.classList.add("time-capsule-icon", "time-capsule-active");
        const collectingDiv = iconContainer.createDiv("time-capsule-collecting-status");
        collectingDiv.innerHTML = '<span class="collecting-text">\u6B63\u5728\u6536\u96C6</span>';
      } else if (isHistoricalTimeCapsule) {
        iconDiv.innerHTML = `
					<svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
						<path d="M6 2v6h.01L6 8.01 10 12l-4 4-.01.01V22h12v-5.99-.01L18 16l-4-4 4-3.99.01-.01V2H6z"/>
					</svg>
				`;
        iconDiv.classList.add("time-capsule-icon", "time-capsule-historical");
        const completedDiv = iconContainer.createDiv("time-capsule-completed-status");
        completedDiv.innerHTML = '<span class="completed-text">\u5DF2\u5B8C\u6210</span>';
      }
      const bottomInfo = contentDiv.createDiv("time-capsule-bottom-info");
      if (groupInfo.members.length > 0) {
        const fileIconsDiv = bottomInfo.createDiv("time-capsule-file-icons");
        const maxPreview = Math.min(3, groupInfo.members.length);
        for (let i = 0; i < maxPreview; i++) {
          const member = groupInfo.members[i];
          const memberIcon = fileIconsDiv.createDiv("time-capsule-member-icon");
          switch (member.type) {
            case "text":
              memberIcon.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>`;
              break;
            case "file":
              memberIcon.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/></svg>`;
              break;
            case "link":
              memberIcon.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/></svg>`;
              break;
          }
        }
      }
      const countInfo = bottomInfo.createDiv("time-capsule-count-info");
      if (isActiveTimeCapsule) {
        const minutes = Math.floor(this.timeCapsuleState.remainingTime / 6e4);
        const seconds = Math.floor(this.timeCapsuleState.remainingTime % 6e4 / 1e3);
        const timeText = `${minutes}:${seconds.toString().padStart(2, "0")}`;
        countInfo.innerHTML = `
					<div class="countdown-display">${timeText}</div>
					<div class="item-count-text">${groupInfo.memberCount} \u4E2A\u9879\u76EE</div>
				`;
      } else {
        countInfo.innerHTML = `<div class="item-count-text">${groupInfo.memberCount} \u4E2A\u9879\u76EE</div>`;
      }
    } else {
      const iconDiv = contentDiv.createDiv("group-icon");
      const groupLabel = groupInfo.group.label || "\u672A\u547D\u540D\u5206\u7EC4";
      const isCollectionGroup = groupLabel === "\u6536\u96C6" || groupLabel.toLowerCase() === "collection";
      if (isCollectionGroup) {
        SVGIconManager.setIcon(iconDiv, "archive");
        iconDiv.style.fontSize = "24px";
      } else {
        iconDiv.innerHTML = `
					<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
						<rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
						<path d="M9 9h6v6H9z"/>
					</svg>
				`;
      }
      const titleDiv = contentDiv.createDiv("group-title");
      titleDiv.textContent = groupLabel;
      const countDiv = contentDiv.createDiv("group-member-count");
      countDiv.textContent = `${groupInfo.memberCount} \u4E2A\u9879\u76EE`;
    }
    if (!isTimeCapsule && groupInfo.members.length > 0) {
      const previewDiv = contentDiv.createDiv("group-members-preview");
      const maxPreview = Math.min(4, groupInfo.members.length);
      for (let i = 0; i < maxPreview; i++) {
        const member = groupInfo.members[i];
        const memberIcon = previewDiv.createDiv("member-icon");
        memberIcon.className = `member-icon ${member.type}-icon`;
        switch (member.type) {
          case "text":
            memberIcon.innerHTML = `<svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>`;
            break;
          case "file":
            memberIcon.innerHTML = `<svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/></svg>`;
            break;
          case "link":
            memberIcon.innerHTML = `<svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/></svg>`;
            break;
        }
      }
      if (groupInfo.members.length > maxPreview) {
        const moreIcon = previewDiv.createDiv("member-icon more-icon");
        moreIcon.textContent = `+${groupInfo.members.length - maxPreview}`;
      }
    }
    const enterButton = contentDiv.createDiv("group-enter-button");
    enterButton.innerHTML = `
			<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<polyline points="9,18 15,12 9,6"/>
			</svg>
		`;
    enterButton.title = "\u67E5\u770B\u5206\u7EC4\u5185\u5BB9";
    card.addEventListener("mouseenter", () => {
      card.style.transform = "translateY(-2px)";
      card.style.boxShadow = "0 4px 12px rgba(0, 0, 0, 0.15)";
    });
    card.addEventListener("mouseleave", () => {
      card.style.transform = "translateY(0)";
      card.style.boxShadow = "";
    });
    return card;
  }
  // 开始链接编辑（使用新状态管理系统）
  startLinkEditing(node, cardElement) {
    const editCheck = this.canEnterEditMode(node, cardElement);
    if (!editCheck.canEdit) {
      DebugManager.log(`\u{1F6AB} \u963B\u6B62\u94FE\u63A5\u7F16\u8F91: ${editCheck.reason}`);
      return;
    }
    if (this.currentEditingCard && this.currentEditingCard !== cardElement) {
      this.exitCurrentEditingState(true);
    }
    const contentDiv = cardElement.querySelector(".card-content");
    if (!contentDiv)
      return;
    const editorState = this.startEditingWithNewSystem(node.id, node, cardElement);
    this.currentEditingCard = cardElement;
    this.currentEditingNode = node;
    const originalUrl = node.url || "";
    const editor = this.createLinkEditorWithNewSystem(
      originalUrl,
      // 内容变化回调
      (newUrl) => {
        this.updateContentWithNewSystem(node.id, { ...node, url: newUrl });
      },
      // 保存回调
      (newUrl) => {
        this.stopEditingWithNewSystem(node.id, true);
        this.saveLinkNodeAndRefresh(node, newUrl, cardElement, contentDiv);
        this.completeEditingStateCleanup();
      },
      // 取消回调
      () => {
        this.stopEditingWithNewSystem(node.id, false);
        this.exitEditModeAndRefresh(cardElement, contentDiv, node);
        this.completeEditingStateCleanup();
      }
    );
    this.enterEditMode(cardElement, contentDiv, editor);
  }
  // 保存链接节点并刷新显示
  async saveLinkNodeAndRefresh(node, newUrl, cardElement, contentDiv) {
    node.url = newUrl;
    await this.saveCanvasData();
    this.exitEditModeAndRefresh(cardElement, contentDiv, node);
  }
  // 退出编辑模式并刷新内容
  exitEditModeAndRefresh(cardElement, contentDiv, node) {
    const originalHeight = cardElement.originalHeight;
    const originalMinHeight = cardElement.originalMinHeight;
    if (originalHeight) {
      cardElement.style.transition = "height 0.3s ease, min-height 0.3s ease";
      cardElement.style.height = originalMinHeight || "";
      cardElement.style.minHeight = originalMinHeight || "";
      delete cardElement.originalHeight;
      delete cardElement.originalMinHeight;
      setTimeout(() => {
      }, PERFORMANCE_CONSTANTS.QUICK_DELAY);
    }
    cardElement.classList.remove("editing");
    cardElement.style.zIndex = "";
    cardElement.style.boxShadow = "";
    cardElement.style.maxHeight = "";
    const hasOtherEditingCards = this.gridContainer.querySelector(".canvas-grid-card.editing");
    if (!hasOtherEditingCards) {
      this.gridContainer.classList.remove("has-editing-card");
    }
    if (node.url) {
      this.linkPreviewCache.delete(node.url);
    }
    contentDiv.empty();
    contentDiv.removeClass("link-card-content");
    contentDiv.addClass("link-card-content");
    this.renderLinkNodeWithPreview(contentDiv, node);
  }
  // 创建链接编辑器
  createLinkEditor(url, onSave, onCancel, enableAutoSave = true) {
    const editorContainer = document.createElement("div");
    editorContainer.className = "card-editor-container";
    const input = document.createElement("input");
    input.type = "url";
    input.className = "card-editor-input";
    input.value = url;
    input.placeholder = "\u8F93\u5165URL\u5730\u5740...";
    input.style.width = "100%";
    input.style.padding = "8px";
    input.style.border = "1px solid var(--background-modifier-border)";
    input.style.borderRadius = "4px";
    input.style.background = "var(--background-primary)";
    input.style.color = "var(--text-normal)";
    input.style.fontSize = "var(--font-text-size)";
    if (enableAutoSave) {
      input.addEventListener("blur", () => {
        onSave(input.value);
      });
    }
    input.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        e.preventDefault();
        onCancel();
      } else if (e.key === "Enter") {
        e.preventDefault();
        onSave(input.value);
      }
    });
    editorContainer.appendChild(input);
    this.safeSetTimeout(() => {
      input.focus();
      input.select();
    }, 0);
    return editorContainer;
  }
  // 创建链接编辑器（新状态管理系统版本）
  createLinkEditorWithNewSystem(url, onChange, onSave, onCancel) {
    const editorContainer = document.createElement("div");
    editorContainer.className = "card-editor-container";
    const input = document.createElement("input");
    input.type = "url";
    input.className = "card-editor-input";
    input.value = url;
    input.placeholder = "\u8F93\u5165URL\u5730\u5740...";
    input.style.width = "100%";
    input.style.padding = "8px";
    input.style.border = "1px solid var(--background-modifier-border)";
    input.style.borderRadius = "4px";
    input.style.background = "var(--background-primary)";
    input.style.color = "var(--text-normal)";
    input.style.fontSize = "var(--font-text-size)";
    input.addEventListener("input", () => {
      onChange(input.value);
    });
    input.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        e.preventDefault();
        onCancel();
      } else if (e.key === "Enter") {
        e.preventDefault();
        onSave(input.value);
      }
    });
    editorContainer.appendChild(input);
    this.safeSetTimeout(() => {
      input.focus();
      input.select();
    }, 0);
    return editorContainer;
  }
  // 进入编辑模式
  enterEditMode(cardElement, contentDiv, editor) {
    cardElement.classList.add("editing");
    cardElement.style.zIndex = "1000";
    cardElement.style.position = "relative";
    const standardHeight = CARD_CONSTANTS.height;
    const currentMinHeight = cardElement.style.minHeight;
    const expandedHeight = Math.max(standardHeight * 2, 400);
    DebugManager.log("\u{1F3AF} \u9AD8\u5EA6\u8BA1\u7B97:", {
      standardHeight,
      expandedHeight,
      currentDisplayHeight: cardElement.offsetHeight,
      previousHeight: cardElement.originalHeight
    });
    cardElement.style.height = `${expandedHeight}px`;
    cardElement.style.minHeight = `${expandedHeight}px`;
    cardElement.originalHeight = standardHeight;
    cardElement.originalMinHeight = currentMinHeight;
    contentDiv.style.display = "none";
    this.setupEditorStyles(cardElement, editor);
  }
  /**
   * 设置编辑器样式，提取为独立方法便于维护
   */
  setupEditorStyles(cardElement, editor) {
    editor.style.position = "absolute";
    editor.style.top = "0";
    editor.style.left = "0";
    editor.style.right = "0";
    editor.style.bottom = "0";
    editor.style.width = "100%";
    editor.style.height = "100%";
    editor.style.borderRadius = "inherit";
    editor.style.margin = "0";
    editor.style.border = "none";
    editor.style.padding = "0";
    editor.style.boxSizing = "border-box";
    cardElement.appendChild(editor);
  }
  /**
   * 设置传统编辑器样式（用于向后兼容）
   */
  setupLegacyEditorStyles(editorEl) {
    editorEl.style.width = "100%";
    editorEl.style.height = "100%";
    editorEl.style.border = "none";
    editorEl.style.outline = "none";
    editorEl.style.borderRadius = "inherit";
    const cmEditor = editorEl.querySelector(".cm-editor");
    if (cmEditor) {
      cmEditor.style.height = "100%";
      cmEditor.style.fontSize = "var(--font-text-size)";
      cmEditor.style.fontFamily = "var(--font-text)";
    }
    const cmContent = editorEl.querySelector(".cm-content");
    if (cmContent) {
      cmContent.style.padding = "0";
      cmContent.style.minHeight = "100%";
    }
  }
  // 退出编辑模式
  async exitEditMode(cardElement, contentDiv, newContent) {
    const originalHeight = cardElement.originalHeight;
    const originalMinHeight = cardElement.originalMinHeight;
    if (originalHeight) {
      cardElement.style.transition = "height 0.3s ease, min-height 0.3s ease";
      cardElement.style.height = originalMinHeight || "";
      cardElement.style.minHeight = originalMinHeight || "";
      delete cardElement.originalHeight;
      delete cardElement.originalMinHeight;
      setTimeout(() => {
      }, PERFORMANCE_CONSTANTS.QUICK_DELAY);
    }
    cardElement.classList.remove("editing");
    cardElement.style.zIndex = "";
    cardElement.style.position = "";
    cardElement.style.maxHeight = "";
    const hasOtherEditingCards = this.gridContainer.querySelector(".canvas-grid-card.editing");
    if (!hasOtherEditingCards) {
      this.gridContainer.classList.remove("has-editing-card");
    }
    const editorContainer = cardElement.querySelector(".card-editor-container");
    const textarea = cardElement.querySelector(".card-editor-textarea");
    if (editorContainer) {
      const cleanup = editorContainer.cleanup;
      if (cleanup && typeof cleanup === "function") {
        cleanup();
      }
      editorContainer.remove();
    } else if (textarea) {
      textarea.remove();
    }
    if (newContent !== void 0) {
      const nodeId = cardElement.getAttribute("data-node-id");
      if (nodeId) {
        DebugManager.log("\u{1F527} \u4FEE\u590D\uFF1A\u4F20\u7EDF\u9000\u51FA\u7F16\u8F91\u6A21\u5F0F\uFF0C\u4F7F\u7528\u5B9E\u9645\u7F16\u8F91\u5185\u5BB9\u8FDB\u884C\u6E32\u67D3", {
          nodeId,
          newContent: newContent.substring(0, 100) + (newContent.length > 100 ? "..." : ""),
          contentLength: newContent.length
        });
        const baseNode = this.getLatestNodeData(nodeId);
        const renderNode = {
          id: nodeId,
          type: "text",
          text: newContent,
          x: baseNode?.x || 0,
          y: baseNode?.y || 0,
          width: baseNode?.width || 200,
          height: baseNode?.height || 100,
          color: baseNode?.color,
          file: baseNode?.file,
          url: baseNode?.url,
          label: baseNode?.label,
          flag: baseNode?.flag
        };
        this.renderTextNodeContent(contentDiv, renderNode);
        DebugManager.log("\u2705 \u4F20\u7EDF\u7F16\u8F91\u6A21\u5F0F\u5185\u5BB9\u6E32\u67D3\u5B8C\u6210", { nodeId, contentPreview: newContent.substring(0, 50) });
        setTimeout(() => {
          this.syncAllDataSources(nodeId, renderNode);
        }, 0);
      }
    }
    contentDiv.style.display = "";
  }
  // 退出编辑模式（新状态管理系统版本）
  async exitEditModeWithNewSystem(cardElement, contentDiv, nodeId, newContent) {
    const originalHeight = cardElement.originalHeight;
    const originalMinHeight = cardElement.originalMinHeight;
    if (originalHeight) {
      cardElement.style.transition = "height 0.3s ease, min-height 0.3s ease";
      cardElement.style.height = originalMinHeight || "";
      cardElement.style.minHeight = originalMinHeight || "";
      delete cardElement.originalHeight;
      delete cardElement.originalMinHeight;
      setTimeout(() => {
      }, PERFORMANCE_CONSTANTS.QUICK_DELAY);
    }
    cardElement.classList.remove("editing");
    cardElement.style.zIndex = "";
    cardElement.style.position = "";
    cardElement.style.maxHeight = "";
    const hasOtherEditingCards = this.gridContainer.querySelector(".canvas-grid-card.editing");
    if (!hasOtherEditingCards) {
      this.gridContainer.classList.remove("has-editing-card");
    }
    const editorContainer = cardElement.querySelector(".card-editor-container");
    const textarea = cardElement.querySelector(".card-editor-textarea");
    if (editorContainer) {
      const cleanup = editorContainer.cleanup;
      if (cleanup && typeof cleanup === "function") {
        cleanup();
      }
      editorContainer.remove();
    } else if (textarea) {
      textarea.remove();
    }
    if (newContent !== void 0) {
      DebugManager.log("\u{1F527} \u4FEE\u590D\uFF1A\u9000\u51FA\u7F16\u8F91\u6A21\u5F0F\uFF0C\u4F7F\u7528\u5B9E\u9645\u7F16\u8F91\u5185\u5BB9\u8FDB\u884C\u6E32\u67D3", {
        nodeId,
        newContent: newContent.substring(0, 100) + (newContent.length > 100 ? "..." : ""),
        contentLength: newContent.length
      });
      const baseNode = this.getLatestNodeData(nodeId);
      const renderNode = {
        id: nodeId,
        type: "text",
        text: newContent,
        x: baseNode?.x || 0,
        y: baseNode?.y || 0,
        width: baseNode?.width || 200,
        height: baseNode?.height || 100,
        color: baseNode?.color,
        file: baseNode?.file,
        url: baseNode?.url,
        label: baseNode?.label,
        flag: baseNode?.flag
      };
      if (!renderNode.text && newContent) {
        DebugManager.warn("\u26A0\uFE0F \u6E32\u67D3\u8282\u70B9\u6570\u636E\u5F02\u5E38\uFF0C\u4F7F\u7528\u7F16\u8F91\u5185\u5BB9\u4FEE\u6B63", {
          nodeId,
          renderNodeText: renderNode.text,
          newContent
        });
        renderNode.text = newContent;
      }
      if (renderNode.type === "text") {
        this.renderTextNodeContent(contentDiv, renderNode);
        DebugManager.log("\u2705 \u6587\u672C\u5185\u5BB9\u6E32\u67D3\u5B8C\u6210", { nodeId, contentPreview: newContent.substring(0, 50) });
      } else if (renderNode.type === "link") {
        this.renderLinkNodeWithPreview(contentDiv, renderNode);
        DebugManager.log("\u2705 \u94FE\u63A5\u5185\u5BB9\u6E32\u67D3\u5B8C\u6210", { nodeId });
      }
      setTimeout(() => {
        this.syncAllDataSources(nodeId, renderNode);
      }, 0);
    }
    contentDiv.style.display = "";
    DebugManager.log("\u{1F441}\uFE0F \u5185\u5BB9\u5BB9\u5668\u5DF2\u6062\u590D\u53EF\u89C1\uFF08\u65B0\u7CFB\u7EDF\uFF09", {
      nodeId,
      displayStyle: contentDiv.style.display,
      isVisible: contentDiv.style.display !== "none"
    });
  }
  // 保存文本节点
  async saveTextNode(node, newText) {
    if (!this.canvasData)
      return;
    node.text = newText;
    await this.saveCanvasData();
    this.refreshCard(node);
    new import_obsidian12.Notice("\u6587\u672C\u5DF2\u4FDD\u5B58");
  }
  // 保存链接节点
  async saveLinkNode(node, newUrl) {
    if (!this.canvasData)
      return;
    node.url = newUrl;
    await this.saveCanvasData();
    this.refreshCard(node);
    new import_obsidian12.Notice("\u94FE\u63A5\u5DF2\u4FDD\u5B58");
  }
  // 🎯 修复：刷新单个卡片 - 使用统一数据访问
  async refreshCard(node) {
    const cardElement = this.gridContainer.querySelector(`[data-node-id="${node.id}"]`);
    if (!cardElement)
      return;
    const contentDiv = cardElement.querySelector(".card-content");
    if (!contentDiv)
      return;
    DebugManager.log("\u{1F504} \u5237\u65B0\u5361\u7247\u663E\u793A", { nodeId: node.id, nodeType: node.type });
    const latestNode = this.getLatestNodeData(node.id) || node;
    if (latestNode.type === "text") {
      this.renderTextNodeContent(contentDiv, latestNode);
      DebugManager.log("\u2705 \u6587\u672C\u5361\u7247\u5237\u65B0\u5B8C\u6210", { nodeId: node.id });
    } else if (latestNode.type === "link") {
      contentDiv.innerHTML = "";
      this.renderLinkNodeContent(contentDiv, latestNode);
      DebugManager.log("\u2705 \u94FE\u63A5\u5361\u7247\u5237\u65B0\u5B8C\u6210", { nodeId: node.id });
    }
  }
  // 🎯 增强：渲染文本节点内容 - 添加数据验证和调试机制
  renderTextNodeContent(contentDiv, node) {
    this.obsidianRenderManager.disposeContainer(contentDiv);
    if (!this.validateRenderData(node, "renderTextNodeContent")) {
      DebugManager.error("\u274C \u6E32\u67D3\u6570\u636E\u9A8C\u8BC1\u5931\u8D25\uFF0C\u4F7F\u7528\u9ED8\u8BA4\u5185\u5BB9", { nodeId: node.id });
      contentDiv.textContent = "\u6570\u636E\u9A8C\u8BC1\u5931\u8D25";
      contentDiv.style.color = "var(--text-error)";
      contentDiv.style.fontStyle = "italic";
      contentDiv.style.display = "";
      return;
    }
    try {
      const consistencyCheck = this.validateDataConsistency(node.id);
      if (!consistencyCheck.isConsistent) {
        DebugManager.warn("\u26A0\uFE0F \u6E32\u67D3\u65F6\u53D1\u73B0\u6570\u636E\u4E0D\u4E00\u81F4", {
          nodeId: node.id,
          issues: consistencyCheck.issues,
          recommendations: consistencyCheck.recommendations
        });
      }
    } catch (error) {
      DebugManager.error("\u274C \u6570\u636E\u4E00\u81F4\u6027\u68C0\u67E5\u5931\u8D25", { nodeId: node.id, error });
    }
    if (!node.text) {
      DebugManager.log("\u{1F4DD} \u6E32\u67D3\u7A7A\u6587\u672C\u8282\u70B9", { nodeId: node.id });
      contentDiv.textContent = "\u7A7A\u6587\u672C\u8282\u70B9";
      contentDiv.style.color = "var(--text-muted)";
      contentDiv.style.fontStyle = "italic";
      contentDiv.style.display = "";
      return;
    }
    this.obsidianRenderManager.renderMarkdownContent(
      node.text || "",
      contentDiv,
      "",
      // sourcePath
      node.id
    ).then(() => {
      contentDiv.style.display = "";
      DebugManager.log("\u2705 Obsidian\u5F15\u64CE\u6E32\u67D3\u5B8C\u6210", {
        nodeId: node.id,
        textLength: node.text?.length || 0,
        textPreview: (node.text || "").substring(0, 50) + ((node.text?.length || 0) > 50 ? "..." : ""),
        containerVisible: contentDiv.style.display !== "none"
      });
    }).catch((error) => {
      DebugManager.error("\u274C Obsidian\u5F15\u64CE\u6E32\u67D3\u5931\u8D25\uFF0C\u964D\u7EA7\u5230\u7B80\u5355\u6E32\u67D3", { nodeId: node.id, error: error.message });
      this.renderSimpleTextFallback(contentDiv, node);
    });
  }
  // 🎯 简单文本渲染降级方法
  renderSimpleTextFallback(contentDiv, node) {
    contentDiv.empty();
    contentDiv.textContent = node.text || "";
    contentDiv.addClass("canvas-card-content");
    contentDiv.style.color = "var(--text-normal)";
    contentDiv.style.lineHeight = "1.5";
    contentDiv.style.overflowWrap = "break-word";
    contentDiv.style.display = "";
    DebugManager.log("\u2705 \u7B80\u5355\u6587\u672C\u6E32\u67D3\u5B8C\u6210\uFF08\u964D\u7EA7\u6A21\u5F0F\uFF09", {
      nodeId: node.id,
      textLength: node.text?.length || 0,
      textPreview: (node.text || "").substring(0, 50) + ((node.text?.length || 0) > 50 ? "..." : ""),
      containerVisible: contentDiv.style.display !== "none"
    });
  }
  // 渲染带预览的链接节点
  async renderLinkNodeWithPreview(contentDiv, node) {
    this.obsidianRenderManager.disposeContainer(contentDiv);
    if (!node.url) {
      contentDiv.textContent = "\u65E0\u6548\u7684\u94FE\u63A5";
      contentDiv.style.color = "var(--text-error)";
      contentDiv.style.fontStyle = "italic";
      return;
    }
    this.renderLinkLoadingState(contentDiv, node.url);
    try {
      const preview = await this.fetchLinkPreview(node.url);
      contentDiv.empty();
      this.renderLinkPreview(contentDiv, preview);
    } catch (error) {
      DebugManager.error("Failed to render link preview:", error);
      contentDiv.empty();
      this.renderSimpleLinkFallback(contentDiv, node.url);
    }
  }
  // 渲染链接加载状态
  renderLinkLoadingState(contentDiv, url) {
    this.obsidianRenderManager.disposeContainer(contentDiv);
    contentDiv.empty();
    contentDiv.addClass("link-preview-loading");
    const skeleton = contentDiv.createDiv("link-preview-skeleton");
    skeleton.createDiv("skeleton-title");
    skeleton.createDiv("skeleton-description");
    const urlDiv = skeleton.createDiv("skeleton-url");
    urlDiv.textContent = this.formatUrlForDisplay(url);
  }
  // 渲染链接预览
  renderLinkPreview(contentDiv, preview) {
    this.obsidianRenderManager.disposeContainer(contentDiv);
    contentDiv.addClass("link-bookmark-card");
    contentDiv.dataset.nodeUrl = preview.url;
    const bookmarkContainer = contentDiv.createDiv("link-bookmark-container");
    const contentArea = bookmarkContainer.createDiv("link-bookmark-content");
    const titleEl = contentArea.createDiv("link-bookmark-title");
    titleEl.textContent = preview.title || this.extractDomainFromUrl(preview.url);
    if (preview.description) {
      const descEl = contentArea.createDiv("link-bookmark-description");
      descEl.textContent = preview.description;
    }
    const footerEl = contentArea.createDiv("link-bookmark-footer");
    const siteInfo = footerEl.createDiv("link-bookmark-site-info");
    if (preview.favicon) {
      const faviconEl = siteInfo.createEl("img", {
        cls: "link-bookmark-favicon",
        attr: {
          src: preview.favicon,
          alt: "Site icon"
        }
      });
      faviconEl.addEventListener("error", () => {
        faviconEl.style.display = "none";
      });
    }
    const siteNameEl = siteInfo.createSpan("link-bookmark-site-name");
    siteNameEl.textContent = preview.siteName || this.extractDomainFromUrl(preview.url);
    const urlEl = footerEl.createDiv("link-bookmark-url");
    urlEl.textContent = this.formatUrlForDisplay(preview.url);
    if (preview.image) {
      const imageContainer = bookmarkContainer.createDiv("link-bookmark-image-container");
      const img = imageContainer.createEl("img", {
        cls: "link-bookmark-image",
        attr: {
          src: preview.image,
          alt: preview.title || "Link preview image"
        }
      });
      img.addEventListener("error", () => {
        imageContainer.style.display = "none";
        bookmarkContainer.classList.add("no-image");
      });
    } else {
      bookmarkContainer.classList.add("no-image");
    }
    bookmarkContainer.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      window.open(preview.url, "_blank");
    });
    bookmarkContainer.style.cursor = "pointer";
    bookmarkContainer.title = `\u6253\u5F00\u94FE\u63A5: ${preview.url}`;
  }
  // 简单链接回退显示
  renderSimpleLinkFallback(contentDiv, url) {
    this.obsidianRenderManager.disposeContainer(contentDiv);
    const linkElement = contentDiv.createEl("a", {
      cls: "external-link simple-link",
      href: url
    });
    const displayText = this.extractDomainFromUrl(url);
    linkElement.textContent = displayText;
    const linkIcon = linkElement.createSpan("external-link-icon");
    SVGIconManager.setIcon(linkIcon, "externalLink");
    linkElement.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      window.open(url, "_blank");
    });
  }
  // 渲染链接节点内容（编辑时使用的简化版本）
  renderLinkNodeContent(contentDiv, node) {
    if (node.url) {
      this.renderSimpleLinkFallback(contentDiv, node.url);
    } else {
      contentDiv.textContent = "\u65E0\u6548\u7684\u94FE\u63A5";
      contentDiv.style.color = "var(--text-error)";
      contentDiv.style.fontStyle = "italic";
    }
  }
  // 格式化URL用于显示
  formatUrlForDisplay(url) {
    try {
      const urlObj = new URL(url);
      const domain = urlObj.hostname;
      const path = urlObj.pathname;
      if (url.length > 50) {
        if (path.length > 20) {
          return `${domain}${path.substring(0, 15)}...`;
        } else {
          return `${domain}${path}`;
        }
      }
      return url;
    } catch {
      return url.length > 50 ? url.substring(0, 47) + "..." : url;
    }
  }
  // URL验证方法
  isValidURL(url) {
    try {
      const urlObj = new URL(url);
      return ["http:", "https:"].includes(urlObj.protocol);
    } catch {
      return false;
    }
  }
  // 获取链接预览数据
  async fetchLinkPreview(url) {
    if (!this.isValidURL(url)) {
      DebugManager.warn("Invalid or unsafe URL:", url);
      return {
        url,
        title: "\u65E0\u6548\u94FE\u63A5",
        description: "\u94FE\u63A5\u683C\u5F0F\u4E0D\u6B63\u786E\u6216\u4E0D\u5B89\u5168",
        error: "Invalid URL"
      };
    }
    const cachedItem = this.getCacheItem(url);
    if (cachedItem) {
      return cachedItem;
    }
    if (this.previewLoadingUrls.has(url)) {
      return { url, isLoading: true };
    }
    this.previewLoadingUrls.add(url);
    const errorHandler = ErrorHandler.getInstance();
    const preview = await errorHandler.withRetry(async () => {
      return await this.extractLinkMetadata(url);
    }, `\u94FE\u63A5\u9884\u89C8\u83B7\u53D6: ${url}`, 2, 1e3);
    if (preview) {
      this.setCacheItem(url, preview);
      this.previewLoadingUrls.delete(url);
      return preview;
    } else {
      const errorPreview = {
        url,
        error: "Failed to load preview",
        title: this.extractDomainFromUrl(url)
      };
      this.setCacheItem(url, errorPreview);
      this.previewLoadingUrls.delete(url);
      return errorPreview;
    }
  }
  // 提取链接元数据（优化版本 - 快速书签解析）
  async extractLinkMetadata(url) {
    try {
      const urlObj = new URL(url);
      const basicPreview = {
        url,
        title: this.extractTitleFromUrl(url),
        siteName: this.extractDomainFromUrl(url),
        favicon: `https://www.google.com/s2/favicons?domain=${urlObj.hostname}`,
        isBasic: true
        // 标记为基础信息
      };
      this.fetchDetailedMetadata(url);
      return basicPreview;
    } catch (urlError) {
      return {
        url,
        title: "\u65E0\u6548\u94FE\u63A5",
        siteName: "\u672A\u77E5",
        error: "URL\u683C\u5F0F\u65E0\u6548"
      };
    }
  }
  // 从URL提取智能标题
  extractTitleFromUrl(url) {
    try {
      const urlObj = new URL(url);
      const path = urlObj.pathname;
      if (path && path !== "/") {
        const pathParts = path.split("/").filter((part) => part.length > 0);
        if (pathParts.length > 0) {
          const lastPart = pathParts[pathParts.length - 1];
          const cleanTitle = lastPart.replace(/\.(html|htm|php|asp|jsp)$/i, "").replace(/[-_]/g, " ").replace(/\b\w/g, (l) => l.toUpperCase());
          if (cleanTitle.length > 3) {
            return cleanTitle;
          }
        }
      }
      return this.extractDomainFromUrl(url);
    } catch {
      return this.extractDomainFromUrl(url);
    }
  }
  // 异步获取详细元数据（不阻塞UI）
  async fetchDetailedMetadata(url) {
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 3e3);
      const apiServices = [
        `https://api.microlink.io/?url=${encodeURIComponent(url)}&timeout=2000`,
        `https://jsonlink.io/api/extract?url=${encodeURIComponent(url)}`
      ];
      let detailedData = null;
      for (const apiUrl of apiServices) {
        try {
          const response = await Promise.race([
            fetch(apiUrl, {
              signal: controller.signal,
              headers: {
                "Accept": "application/json",
                "User-Agent": "Obsidian Canvasgrid Transit Plugin"
              }
            }),
            new Promise(
              (_, reject) => setTimeout(() => reject(new Error("Service timeout")), 2e3)
            )
          ]);
          if (response.ok) {
            const data = await response.json();
            if (this.isValidMetadata(data)) {
              detailedData = data;
              break;
            }
          }
        } catch (serviceError) {
          DebugManager.log(`API service failed: ${apiUrl}`, serviceError);
          continue;
        }
      }
      clearTimeout(timeoutId);
      if (detailedData) {
        const enhancedPreview = this.parseMetadataResponse(url, detailedData);
        this.setCacheItem(url, enhancedPreview);
        this.updateBookmarkCard(url, enhancedPreview);
      }
    } catch (error) {
      DebugManager.log("\u8BE6\u7EC6\u5143\u6570\u636E\u83B7\u53D6\u5931\u8D25\uFF0C\u4F7F\u7528\u57FA\u7840\u4FE1\u606F:", error);
    }
  }
  // 验证元数据响应是否有效
  isValidMetadata(data) {
    if (!data)
      return false;
    if (data.status === "success" && data.data) {
      return true;
    }
    if (data.title || data.description) {
      return true;
    }
    return false;
  }
  // 解析不同API服务的响应格式
  parseMetadataResponse(url, data) {
    let title = "";
    let description = "";
    let image = "";
    let siteName = "";
    let favicon = "";
    if (data.status === "success" && data.data) {
      title = data.data.title || "";
      description = data.data.description || "";
      image = data.data.image?.url || "";
      siteName = data.data.publisher || "";
      favicon = data.data.logo?.url || "";
    } else if (data.title || data.description) {
      title = data.title || "";
      description = data.description || "";
      image = data.image || "";
      siteName = data.site_name || "";
      favicon = data.favicon || "";
    }
    if (!favicon) {
      try {
        const urlObj = new URL(url);
        favicon = `https://www.google.com/s2/favicons?domain=${urlObj.hostname}`;
      } catch {
        favicon = "";
      }
    }
    return {
      url,
      title: title || this.extractTitleFromUrl(url),
      description: description || "",
      image: image || "",
      siteName: siteName || this.extractDomainFromUrl(url),
      favicon
    };
  }
  // 更新书签卡片显示（当获取到详细信息时）
  updateBookmarkCard(url, enhancedPreview) {
    const cards = this.gridContainer.querySelectorAll(`[data-node-url="${url}"]`);
    cards.forEach((card) => {
      const bookmarkContainer = card.querySelector(".link-bookmark-container");
      if (bookmarkContainer) {
        const titleEl = bookmarkContainer.querySelector(".link-bookmark-title");
        if (titleEl && enhancedPreview.title) {
          titleEl.textContent = enhancedPreview.title;
        }
        let descEl = bookmarkContainer.querySelector(".link-bookmark-description");
        if (enhancedPreview.description) {
          if (!descEl) {
            const contentArea = bookmarkContainer.querySelector(".link-bookmark-content");
            if (contentArea) {
              descEl = contentArea.createDiv("link-bookmark-description");
            }
          }
          if (descEl) {
            descEl.textContent = enhancedPreview.description;
          }
        }
        const imageArea = bookmarkContainer.querySelector(".link-bookmark-image");
        if (imageArea && enhancedPreview.image) {
          const img = imageArea.querySelector("img");
          if (img) {
            img.src = enhancedPreview.image;
          }
        }
        const faviconEl = bookmarkContainer.querySelector(".link-bookmark-favicon");
        if (faviconEl && enhancedPreview.favicon) {
          const img = faviconEl.querySelector("img");
          if (img) {
            img.src = enhancedPreview.favicon;
          }
        }
      }
    });
  }
  // 从URL提取域名
  extractDomainFromUrl(url) {
    try {
      const urlObj = new URL(url);
      return urlObj.hostname.replace("www.", "");
    } catch {
      return url;
    }
  }
  // 显示消息
  showMessage(message) {
    this.gridContainer.empty();
    const messageEl = this.gridContainer.createDiv("grid-message");
    messageEl.textContent = message;
    messageEl.style.textAlign = "center";
    messageEl.style.color = "var(--text-muted)";
    messageEl.style.marginTop = "50px";
  }
  // 显示加载状态
  showLoadingState() {
    this.gridContainer.empty();
    const loadingEl = this.gridContainer.createDiv("canvas-grid-loading");
    loadingEl.textContent = "\u6B63\u5728\u52A0\u8F7DCanvas\u6570\u636E...";
  }
  // 隐藏加载状态
  hideLoadingState() {
    const loadingEl = this.gridContainer.querySelector(".canvas-grid-loading");
    if (loadingEl) {
      loadingEl.remove();
    }
  }
  // 显示错误状态
  showErrorState(errorMessage) {
    this.gridContainer.empty();
    const errorEl = this.gridContainer.createDiv("canvas-grid-error");
    const titleEl = errorEl.createEl("h3");
    titleEl.textContent = "\u52A0\u8F7D\u5931\u8D25";
    titleEl.style.color = "var(--text-error)";
    const messageEl = errorEl.createEl("p");
    messageEl.textContent = errorMessage;
    messageEl.style.color = "var(--text-muted)";
    const retryBtn = errorEl.createEl("button", {
      text: "\u91CD\u8BD5",
      cls: "mod-cta"
    });
    retryBtn.onclick = () => this.loadActiveCanvas();
    errorEl.style.textAlign = "center";
    errorEl.style.marginTop = "50px";
  }
  // 打开网格设置
  openGridSettings() {
    this.app.setting.open();
    this.app.setting.openTabById("canvas-grid-view");
  }
  // 切换到Canvas视图
  async switchToCanvasView() {
    let targetFile = this.app.workspace.getActiveFile();
    if (!targetFile || targetFile.extension !== "canvas") {
      if (this.linkedCanvasFile) {
        targetFile = this.linkedCanvasFile;
        DebugManager.log("Using linked canvas file:", targetFile.path);
      } else {
        new import_obsidian12.Notice("\u6CA1\u6709\u5173\u8054\u7684Canvas\u6587\u4EF6\uFF0C\u8BF7\u5148\u5173\u8054\u4E00\u4E2ACanvas\u6587\u4EF6");
        return;
      }
    }
    const targetLeaf = this.findExistingCanvasLeaf(targetFile);
    if (targetLeaf) {
      this.app.workspace.setActiveLeaf(targetLeaf);
      DebugManager.log("Activated existing canvas view");
    } else {
      try {
        await this.openCanvasInMainWorkspace(targetFile);
      } catch (error) {
        DebugManager.error("Failed to open canvas file:", error);
        new import_obsidian12.Notice("\u65E0\u6CD5\u6253\u5F00Canvas\u6587\u4EF6");
      }
    }
  }
  // 查找现有的Canvas叶子（避免重复打开）
  findExistingCanvasLeaf(targetFile) {
    const canvasLeaves = this.app.workspace.getLeavesOfType("canvas");
    for (const leaf of canvasLeaves) {
      const view = leaf.view;
      if (view && view.file && view.file.path === targetFile.path) {
        if (this.isLeafInMainWorkspace(leaf)) {
          DebugManager.log("Found existing canvas leaf in main workspace");
          return leaf;
        }
      }
    }
    return null;
  }
  // 检查叶子是否在主工作区
  isLeafInMainWorkspace(leaf) {
    let parent = leaf.parent;
    while (parent) {
      if (parent === this.app.workspace.leftSplit || parent === this.app.workspace.rightSplit) {
        return false;
      }
      parent = parent.parent;
    }
    return true;
  }
  // 在主工作区打开Canvas文件
  async openCanvasInMainWorkspace(targetFile) {
    try {
      const newLeaf = this.app.workspace.getLeaf("tab");
      if (newLeaf && this.isLeafInMainWorkspace(newLeaf)) {
        await newLeaf.openFile(targetFile);
        this.app.workspace.setActiveLeaf(newLeaf);
        DebugManager.log("Opened canvas file in new tab in main workspace");
        return;
      }
      const rootLeaf = this.app.workspace.getLeaf(true);
      if (rootLeaf) {
        await rootLeaf.openFile(targetFile);
        this.app.workspace.setActiveLeaf(rootLeaf);
        DebugManager.log("Opened canvas file in new leaf in main workspace");
        return;
      }
      throw new Error("\u65E0\u6CD5\u521B\u5EFA\u65B0\u7684\u5DE5\u4F5C\u533A\u53F6\u5B50");
    } catch (error) {
      DebugManager.error("Failed to open canvas in main workspace:", error);
      throw error;
    }
  }
  async onClose() {
    this.cleanupEventListeners();
    this.removeGlobalMouseListeners();
    this.globalEventListeners.forEach(({ element, event, handler, options }) => {
      try {
        element.removeEventListener(event, handler, options);
      } catch (error) {
        DebugManager.warn("Failed to remove event listener:", error);
      }
    });
    this.globalEventListeners.length = 0;
    this.activeTimeouts.forEach((timeoutId) => {
      try {
        clearTimeout(timeoutId);
      } catch (error) {
        DebugManager.warn("Failed to clear timeout:", error);
      }
    });
    this.activeTimeouts.clear();
    this.activeIntervals.forEach((intervalId) => {
      try {
        clearInterval(intervalId);
      } catch (error) {
        DebugManager.warn("Failed to clear interval:", error);
      }
    });
    this.activeIntervals.clear();
    if (this.refreshTimer) {
      this.safeClearInterval(this.refreshTimer);
      this.refreshTimer = null;
    }
    if (this.cacheCleanupInterval) {
      this.safeClearInterval(this.cacheCleanupInterval);
      this.cacheCleanupInterval = null;
    }
    this.hideContextMenu();
    if (this.obsidianRenderManager) {
      this.obsidianRenderManager.cleanup();
    }
    this.linkPreviewCache.clear();
    this.previewLoadingUrls.clear();
    this.clearDataCache();
    this.canvasData = null;
    this.searchInputEl = null;
    this.colorFilterContainer = null;
    this.dropIndicator = null;
    this.cleanupWidthControl();
    this.linkedCanvasFile = null;
  }
  // 显示右键菜单
  showContextMenu(card, x, y) {
    this.hideContextMenu();
    const nodeId = card.dataset.nodeId;
    const nodeType = card.dataset.nodeType;
    if (!nodeId)
      return;
    const menu = document.createElement("div");
    menu.className = "canvas-grid-context-menu";
    menu.addEventListener("click", (e) => {
      e.stopPropagation();
    });
    if (nodeType === "group") {
      const renameItem = this.createMenuItem("\u91CD\u547D\u540D\u5206\u7EC4", "lucide-edit-3", () => {
        this.renameGroup(nodeId);
        this.hideContextMenu();
      });
      const focusItem = this.createMenuItem("\u805A\u7126\u5206\u7EC4", "lucide-target", () => {
        this.focusNodeInCanvas(nodeId);
        this.hideContextMenu();
      });
      const deleteItem = this.createMenuItem("\u5220\u9664\u5206\u7EC4", "lucide-trash-2", () => {
        this.deleteCard(card);
        this.hideContextMenu();
      });
      menu.appendChild(renameItem);
      menu.appendChild(focusItem);
      menu.appendChild(deleteItem);
    } else {
      const focusItem = this.createMenuItem("\u805A\u7126\u8282\u70B9", "lucide-target", () => {
        this.focusNodeInCanvas(nodeId);
        this.hideContextMenu();
      });
      const editItem = this.createMenuItem("\u7F16\u8F91", "lucide-edit", () => {
        this.editCard(card);
        this.hideContextMenu();
      });
      const deleteItem = this.createMenuItem("\u5220\u9664", "lucide-trash-2", () => {
        this.deleteCard(card);
        this.hideContextMenu();
      });
      menu.appendChild(focusItem);
      menu.appendChild(editItem);
      const node = this.canvasData?.nodes.find((n) => n.id === nodeId);
      if (node) {
        const similarContentItem = this.createMenuItem("\u76F8\u4F3C\u5185\u5BB9", "lucide-search", () => {
          this.handleSmartBlockBacklink(node);
          this.hideContextMenu();
        });
        menu.appendChild(similarContentItem);
        const moveToGroupItem = this.createMenuItem("\u79FB\u52A8\u5206\u7EC4", "lucide-folder-plus", () => {
          this.showGroupSelectionModal(node);
          this.hideContextMenu();
        });
        menu.appendChild(moveToGroupItem);
        DebugManager.log("Added similar content and move to group menu items for node:", nodeId);
      }
      menu.appendChild(deleteItem);
    }
    menu.style.left = `${x}px`;
    menu.style.top = `${y}px`;
    document.body.appendChild(menu);
    this.adjustMenuPosition(menu, x, y);
  }
  // 创建菜单项
  createMenuItem(text, iconClass, onClick) {
    const item = document.createElement("div");
    item.className = "canvas-grid-context-menu-item";
    const icon = document.createElement("div");
    icon.className = `canvas-grid-context-menu-icon ${iconClass}`;
    const label = document.createElement("span");
    label.textContent = text;
    item.appendChild(icon);
    item.appendChild(label);
    item.addEventListener("click", (e) => {
      e.stopPropagation();
      e.preventDefault();
      DebugManager.log("\u{1F3AF} Context menu item clicked:", {
        text,
        hasCurrentEditingCard: !!this.currentEditingCard,
        currentEditingNodeId: this.currentEditingNode?.id,
        timestamp: Date.now()
      });
      this.isContextMenuActionExecuting = true;
      try {
        onClick();
      } finally {
        setTimeout(() => {
          this.isContextMenuActionExecuting = false;
          DebugManager.log("\u{1F504} Context menu action flag reset (Canvas-compatible mode)");
        }, 10);
      }
      DebugManager.log("\u2705 Context menu item action completed:", {
        text,
        hasCurrentEditingCard: !!this.currentEditingCard,
        currentEditingNodeId: this.currentEditingNode?.id
      });
    });
    return item;
  }
  // 调整菜单位置
  adjustMenuPosition(menu, x, y) {
    const rect = menu.getBoundingClientRect();
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    let adjustedX = x;
    let adjustedY = y;
    if (x + rect.width > viewportWidth) {
      adjustedX = viewportWidth - rect.width - 10;
    }
    if (y + rect.height > viewportHeight) {
      adjustedY = viewportHeight - rect.height - 10;
    }
    menu.style.left = `${adjustedX}px`;
    menu.style.top = `${adjustedY}px`;
  }
  // 隐藏右键菜单
  hideContextMenu() {
    const existingMenu = document.querySelector(".canvas-grid-context-menu");
    if (existingMenu) {
      existingMenu.remove();
    }
  }
  // 🔧 新增：显示分组选择模态窗口
  async showGroupSelectionModal(node) {
    return new Promise((resolve) => {
      const modal = new import_obsidian12.Modal(this.app);
      modal.titleEl.textContent = "\u79FB\u52A8\u5230\u5206\u7EC4";
      modal.containerEl.setAttribute("data-node-id", node.id);
      const content = modal.contentEl;
      content.empty();
      const sourceInfo = content.createDiv("group-selection-source");
      sourceInfo.createEl("h4", { text: "\u8981\u79FB\u52A8\u7684\u8282\u70B9:" });
      const sourcePreview = sourceInfo.createDiv("node-preview");
      sourcePreview.textContent = this.getNodeDisplayText(node);
      sourcePreview.className = "node-preview source";
      const tabContainer = content.createDiv("group-tab-container");
      const tabButtons = tabContainer.createDiv("group-tab-buttons");
      const currentTabBtn = tabButtons.createEl("button", {
        text: "\u5F53\u524DCanvas",
        cls: "group-tab-btn active"
      });
      const otherTabBtn = tabButtons.createEl("button", {
        text: "\u5176\u4ED6Canvas",
        cls: "group-tab-btn"
      });
      const searchContainer = content.createDiv("group-search-container");
      const searchInput = searchContainer.createEl("input", {
        type: "text",
        placeholder: "\u641C\u7D22\u5206\u7EC4...",
        cls: "group-search-input"
      });
      const listContainer = content.createDiv("group-list-container");
      const currentGroupList = listContainer.createDiv("group-list current-groups active");
      const otherGroupList = listContainer.createDiv("group-list other-groups");
      this.loadCurrentCanvasGroups(currentGroupList);
      let currentTab = "current";
      currentTabBtn.addEventListener("click", () => {
        if (currentTab === "current")
          return;
        currentTab = "current";
        currentTabBtn.classList.add("active");
        otherTabBtn.classList.remove("active");
        currentGroupList.classList.add("active");
        otherGroupList.classList.remove("active");
        searchInput.value = "";
        this.loadCurrentCanvasGroups(currentGroupList);
      });
      otherTabBtn.addEventListener("click", async () => {
        if (currentTab === "other")
          return;
        currentTab = "other";
        otherTabBtn.classList.add("active");
        currentTabBtn.classList.remove("active");
        otherGroupList.classList.add("active");
        currentGroupList.classList.remove("active");
        searchInput.value = "";
        await this.loadOtherCanvasGroups(otherGroupList);
      });
      let searchTimeout;
      searchInput.addEventListener("input", () => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(async () => {
          const query = searchInput.value.trim();
          if (currentTab === "current") {
            await this.searchCurrentCanvasGroups(currentGroupList, query);
          } else {
            await this.searchOtherCanvasGroups(otherGroupList, query);
          }
        }, 300);
      });
      const buttonContainer = content.createDiv("group-selection-buttons");
      const cancelBtn = buttonContainer.createEl("button", { text: "\u53D6\u6D88" });
      cancelBtn.addEventListener("click", () => {
        modal.close();
        resolve();
      });
      modal.open();
    });
  }
  // 🔧 新增：加载并显示分组列表
  async loadAndDisplayGroups(container, searchQuery) {
    container.empty();
    try {
      const currentGroups = this.getCurrentCanvasGroups();
      const allGroups = await this.searchAllCanvasGroups(searchQuery);
      const allGroupsMap = /* @__PURE__ */ new Map();
      currentGroups.forEach((group) => {
        allGroupsMap.set(group.id, {
          id: group.id,
          name: group.name,
          canvasFile: this.linkedCanvasFile?.path || "current",
          isCurrent: true,
          memberCount: group.memberCount
        });
      });
      allGroups.forEach((group) => {
        if (!allGroupsMap.has(group.id)) {
          allGroupsMap.set(group.id, group);
        }
      });
      const filteredGroups = Array.from(allGroupsMap.values()).filter(
        (group) => searchQuery === "" || group.name.toLowerCase().includes(searchQuery.toLowerCase())
      ).sort((a, b) => {
        if (a.isCurrent && !b.isCurrent)
          return -1;
        if (!a.isCurrent && b.isCurrent)
          return 1;
        return a.name.localeCompare(b.name);
      });
      if (filteredGroups.length === 0) {
        const emptyMsg = container.createDiv("group-list-empty");
        emptyMsg.textContent = searchQuery ? "\u672A\u627E\u5230\u5339\u914D\u7684\u5206\u7EC4" : "\u6CA1\u6709\u53EF\u7528\u7684\u5206\u7EC4";
        return;
      }
      filteredGroups.forEach((group) => {
        this.renderGroupListItem(container, group);
      });
    } catch (error) {
      DebugManager.error("Failed to load groups:", error);
      const errorMsg = container.createDiv("group-list-error");
      errorMsg.textContent = "\u52A0\u8F7D\u5206\u7EC4\u5931\u8D25";
    }
  }
  // 🔧 新增：获取当前Canvas的分组
  getCurrentCanvasGroups() {
    if (!this.canvasData)
      return [];
    return this.canvasData.nodes.filter((node) => node.type === "group").map((group) => ({
      id: group.id,
      name: group.text || "\u672A\u547D\u540D\u5206\u7EC4",
      memberCount: this.getGroupMemberCount(group.id)
    }));
  }
  // 🔧 新增：获取分组成员数量
  getGroupMemberCount(groupId) {
    if (!this.canvasData)
      return 0;
    const groupInfo = this.groupAnalysis.get(groupId);
    return groupInfo?.memberCount || 0;
  }
  // 🔧 新增：加载当前Canvas分组到界面
  loadCurrentCanvasGroups(container) {
    container.empty();
    const currentGroups = this.getCurrentCanvasGroups();
    if (currentGroups.length === 0) {
      const emptyMsg = container.createDiv("group-list-empty");
      emptyMsg.textContent = "\u5F53\u524DCanvas\u4E2D\u6CA1\u6709\u5206\u7EC4";
      return;
    }
    currentGroups.forEach((group) => {
      const groupItem = {
        id: group.id,
        name: group.name,
        canvasFile: this.linkedCanvasFile?.path || "current",
        isCurrent: true,
        memberCount: group.memberCount
      };
      this.renderGroupListItem(container, groupItem);
    });
  }
  // 🔧 新增：加载其他Canvas分组到界面
  async loadOtherCanvasGroups(container) {
    container.empty();
    try {
      const otherGroups = await this.searchAllCanvasGroups("");
      if (otherGroups.length === 0) {
        const emptyMsg = container.createDiv("group-list-empty");
        emptyMsg.textContent = "\u5176\u4ED6Canvas\u6587\u4EF6\u4E2D\u6CA1\u6709\u5206\u7EC4";
        return;
      }
      otherGroups.forEach((group) => {
        this.renderGroupListItem(container, group);
      });
    } catch (error) {
      DebugManager.error("Failed to load other canvas groups:", error);
      const errorMsg = container.createDiv("group-list-error");
      errorMsg.textContent = "\u52A0\u8F7D\u5176\u4ED6Canvas\u5206\u7EC4\u5931\u8D25";
    }
  }
  // 🔧 新增：搜索当前Canvas分组
  async searchCurrentCanvasGroups(container, query) {
    container.empty();
    const currentGroups = this.getCurrentCanvasGroups();
    const filteredGroups = currentGroups.filter(
      (group) => query === "" || group.name.toLowerCase().includes(query.toLowerCase())
    );
    if (filteredGroups.length === 0) {
      const emptyMsg = container.createDiv("group-list-empty");
      emptyMsg.textContent = query ? "\u672A\u627E\u5230\u5339\u914D\u7684\u5206\u7EC4" : "\u5F53\u524DCanvas\u4E2D\u6CA1\u6709\u5206\u7EC4";
      return;
    }
    filteredGroups.forEach((group) => {
      const groupItem = {
        id: group.id,
        name: group.name,
        canvasFile: this.linkedCanvasFile?.path || "current",
        isCurrent: true,
        memberCount: group.memberCount
      };
      this.renderGroupListItem(container, groupItem);
    });
  }
  // 🔧 新增：搜索其他Canvas分组
  async searchOtherCanvasGroups(container, query) {
    container.empty();
    try {
      const otherGroups = await this.searchAllCanvasGroups(query);
      if (otherGroups.length === 0) {
        const emptyMsg = container.createDiv("group-list-empty");
        emptyMsg.textContent = query ? "\u672A\u627E\u5230\u5339\u914D\u7684\u5206\u7EC4" : "\u5176\u4ED6Canvas\u6587\u4EF6\u4E2D\u6CA1\u6709\u5206\u7EC4";
        return;
      }
      otherGroups.forEach((group) => {
        this.renderGroupListItem(container, group);
      });
    } catch (error) {
      DebugManager.error("Failed to search other canvas groups:", error);
      const errorMsg = container.createDiv("group-list-error");
      errorMsg.textContent = "\u641C\u7D22\u5176\u4ED6Canvas\u5206\u7EC4\u5931\u8D25";
    }
  }
  // 🔧 新增：搜索所有Canvas文件的分组
  async searchAllCanvasGroups(searchQuery) {
    const allGroups = [];
    try {
      const canvasFiles = this.app.vault.getFiles().filter((file) => file.extension === "canvas");
      for (const file of canvasFiles) {
        if (file === this.linkedCanvasFile)
          continue;
        try {
          const content = await this.app.vault.read(file);
          const canvasData = JSON.parse(content);
          if (canvasData.nodes) {
            const groups = canvasData.nodes.filter((node) => node.type === "group").map((group) => ({
              id: group.id,
              name: group.text || "\u672A\u547D\u540D\u5206\u7EC4",
              canvasFile: file.path,
              isCurrent: false,
              memberCount: this.countGroupMembers(canvasData.nodes, group.id)
            })).filter(
              (group) => searchQuery === "" || group.name.toLowerCase().includes(searchQuery.toLowerCase())
            );
            allGroups.push(...groups);
          }
        } catch (error) {
          DebugManager.warn(`Failed to parse canvas file: ${file.path}`, error);
        }
      }
    } catch (error) {
      DebugManager.error("Failed to search canvas groups:", error);
    }
    return allGroups;
  }
  // 🔧 新增：计算分组成员数量
  countGroupMembers(nodes, groupId) {
    return nodes.filter((node) => node.type !== "group").length;
  }
  // 🔧 新增：渲染分组列表项
  renderGroupListItem(container, group) {
    const item = container.createDiv("group-list-item");
    const icon = item.createDiv("group-item-icon");
    icon.innerHTML = `
			<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
				<path d="M9 9h6v6H9z"/>
			</svg>
		`;
    const info = item.createDiv("group-item-info");
    const name = info.createDiv("group-item-name");
    name.textContent = group.name;
    const details = info.createDiv("group-item-details");
    details.textContent = `${group.memberCount} \u4E2A\u6210\u5458`;
    if (!group.isCurrent) {
      const file = details.createSpan("group-item-file");
      file.textContent = ` \u2022 ${group.canvasFile.split("/").pop()?.replace(".canvas", "")}`;
    }
    item.addEventListener("click", () => {
      this.handleGroupSelection(group);
    });
    if (group.isCurrent) {
      item.classList.add("current-canvas");
    }
  }
  // 🔧 新增：处理分组选择
  async handleGroupSelection(group) {
    try {
      const modal = document.querySelector(".modal-container");
      const nodeId = modal?.getAttribute("data-node-id");
      if (!nodeId) {
        new import_obsidian12.Notice("\u672A\u627E\u5230\u8981\u79FB\u52A8\u7684\u8282\u70B9");
        return;
      }
      const node = this.canvasData?.nodes.find((n) => n.id === nodeId);
      if (!node) {
        new import_obsidian12.Notice("\u8282\u70B9\u4E0D\u5B58\u5728");
        return;
      }
      await this.moveNodeToSelectedGroup(node, group);
      if (modal) {
        modal.close?.();
      }
      new import_obsidian12.Notice(`\u5DF2\u5C06\u8282\u70B9\u79FB\u52A8\u5230\u5206\u7EC4"${group.name}"`);
      await this.renderGrid();
    } catch (error) {
      DebugManager.error("Failed to move node to group:", error);
      new import_obsidian12.Notice("\u79FB\u52A8\u8282\u70B9\u5931\u8D25");
    }
  }
  // 🔧 新增：移动节点到选中的分组
  async moveNodeToSelectedGroup(node, targetGroup) {
    if (!this.canvasData) {
      throw new Error("Canvas\u6570\u636E\u4E0D\u53EF\u7528");
    }
    if (!targetGroup.isCurrent) {
      await this.moveNodeToOtherCanvasGroup(node, targetGroup);
    } else {
      await this.moveNodeToCurrentCanvasGroup(node, targetGroup);
    }
  }
  // 🔧 新增：移动节点到当前Canvas的分组
  async moveNodeToCurrentCanvasGroup(node, targetGroup) {
    const groupNode = this.canvasData?.nodes.find((n) => n.id === targetGroup.id && n.type === "group");
    if (!groupNode) {
      throw new Error("\u76EE\u6807\u5206\u7EC4\u4E0D\u5B58\u5728");
    }
    const newPosition = this.calculatePositionInGroupForMove(groupNode);
    node.x = newPosition.x;
    node.y = newPosition.y;
    await this.saveCanvasData();
    DebugManager.log("\u8282\u70B9\u5DF2\u79FB\u52A8\u5230\u5F53\u524DCanvas\u5206\u7EC4:", {
      nodeId: node.id,
      groupId: targetGroup.id,
      newPosition
    });
  }
  // 🔧 新增：移动节点到其他Canvas文件的分组
  async moveNodeToOtherCanvasGroup(node, targetGroup) {
    try {
      if (this.canvasData) {
        this.canvasData.nodes = this.canvasData.nodes.filter((n) => n.id !== node.id);
        await this.saveCanvasData();
      }
      const targetFile = this.app.vault.getAbstractFileByPath(targetGroup.canvasFile);
      if (!targetFile) {
        throw new Error("\u76EE\u6807Canvas\u6587\u4EF6\u4E0D\u5B58\u5728");
      }
      const targetContent = await this.app.vault.read(targetFile);
      const targetCanvasData = JSON.parse(targetContent);
      const targetGroupNode = targetCanvasData.nodes.find((n) => n.id === targetGroup.id && n.type === "group");
      if (!targetGroupNode) {
        throw new Error("\u76EE\u6807\u5206\u7EC4\u4E0D\u5B58\u5728");
      }
      const newPosition = this.calculatePositionInTargetGroup(targetGroupNode);
      const newNode = {
        ...node,
        id: this.generateUniqueId(),
        x: newPosition.x,
        y: newPosition.y
      };
      targetCanvasData.nodes.push(newNode);
      const newContent = JSON.stringify(targetCanvasData, null, 2);
      await this.app.vault.modify(targetFile, newContent);
      DebugManager.log("\u8282\u70B9\u5DF2\u79FB\u52A8\u5230\u5176\u4ED6Canvas\u5206\u7EC4:", {
        originalNodeId: node.id,
        newNodeId: newNode.id,
        targetFile: targetGroup.canvasFile,
        targetGroupId: targetGroup.id
      });
    } catch (error) {
      if (this.canvasData && !this.canvasData.nodes.find((n) => n.id === node.id)) {
        this.canvasData.nodes.push(node);
        await this.saveCanvasData();
      }
      throw error;
    }
  }
  // 🔧 新增：计算在分组中的位置（用于移动操作）
  calculatePositionInGroupForMove(groupNode) {
    const padding = 20;
    return {
      x: groupNode.x + padding,
      y: groupNode.y + padding
    };
  }
  // 🔧 新增：计算在目标分组中的位置
  calculatePositionInTargetGroup(groupNode) {
    const padding = 20;
    return {
      x: groupNode.x + padding,
      y: groupNode.y + padding
    };
  }
  // 处理回链功能（旧版本，保留兼容性）
  async handleBacklink(nodeId) {
    try {
      DebugManager.log("Handling backlink for node:", nodeId);
      new import_obsidian12.Notice(`\u56DE\u94FE\u529F\u80FD\u5DF2\u89E6\u53D1\uFF0C\u8282\u70B9ID: ${nodeId}`);
    } catch (error) {
      DebugManager.error("Failed to handle backlink:", error);
      new import_obsidian12.Notice("\u56DE\u94FE\u529F\u80FD\u6267\u884C\u5931\u8D25");
    }
  }
  // 智能处理回链导航（新版本）
  async handleBacklinkNavigation(node) {
    try {
      DebugManager.log("=== Backlink Navigation ===");
      DebugManager.log("Node:", node);
      if (this.hasBacklink(node)) {
        DebugManager.log("\u2705 Found backlink in node, using navigateToBacklink");
        await this.navigateToBacklink(node);
      } else {
        DebugManager.log("\u274C No backlink found, showing alternative options");
        await this.showBacklinkAlternatives(node);
      }
    } catch (error) {
      DebugManager.error("Failed to handle backlink navigation:", error);
      new import_obsidian12.Notice("\u56DE\u94FE\u5BFC\u822A\u5931\u8D25");
    }
  }
  // 显示源信息替代选项（简化版本）
  async showBacklinkAlternatives(node) {
    const modal = new import_obsidian12.Modal(this.app);
    modal.titleEl.setText("\u{1F517} \u56DE\u94FE\u9009\u9879");
    const content = modal.contentEl;
    content.empty();
    const description = content.createEl("div");
    description.innerHTML = `
			<p>\u8BE5\u8282\u70B9\u6CA1\u6709\u68C0\u6D4B\u5230\u56DE\u94FE\u4FE1\u606F\u3002</p>
			<p>\u56DE\u94FE\u529F\u80FD\u53EF\u4EE5\u5E2E\u60A8\u8FFD\u8E2A\u5185\u5BB9\u7684\u6765\u6E90\uFF0C\u5F53\u60A8\u4ECE\u5176\u4ED6\u6587\u4EF6\u62D6\u62FD\u6587\u672C\u5230Canvas\u65F6\u4F1A\u81EA\u52A8\u6DFB\u52A0\u3002</p>
		`;
    description.style.cssText = `
			margin-bottom: 20px;
			line-height: 1.5;
			color: var(--text-muted);
		`;
    const buttonContainer = content.createDiv("source-options-container");
    buttonContainer.style.cssText = `
			display: flex;
			gap: 12px;
			margin-top: 20px;
			justify-content: center;
			flex-wrap: wrap;
		`;
    const infoButton = buttonContainer.createEl("button", { text: "\u{1F4CB} \u8282\u70B9\u4FE1\u606F" });
    infoButton.className = "mod-cta";
    infoButton.onclick = () => {
      modal.close();
      this.showNodeInfo(node);
    };
    const searchButton = buttonContainer.createEl("button", { text: "\u{1F50D} \u641C\u7D22\u76F8\u5173\u6587\u4EF6" });
    searchButton.onclick = () => {
      modal.close();
      this.searchRelatedFiles(node);
    };
    const cancelButton = buttonContainer.createEl("button", { text: "\u53D6\u6D88" });
    cancelButton.onclick = () => {
      modal.close();
    };
    modal.open();
  }
  // 源文件搜索方法已移除（块双链功能已禁用）
  // 显示节点详细信息
  showNodeInfo(node) {
    const info = [
      `\u{1F4CB} \u8282\u70B9ID: ${node.id}`,
      `\u{1F3F7}\uFE0F \u8282\u70B9\u7C7B\u578B: ${node.type}`,
      `\u{1F4CD} \u4F4D\u7F6E: (${node.x}, ${node.y})`,
      `\u{1F4CF} \u5C3A\u5BF8: ${node.width} \xD7 ${node.height}`,
      node.text ? `\u{1F4DD} \u6587\u672C\u957F\u5EA6: ${node.text.length} \u5B57\u7B26` : "\u{1F4DD} \u65E0\u6587\u672C\u5185\u5BB9",
      node.color ? `\u{1F3A8} \u989C\u8272: ${node.color}` : "\u{1F3A8} \u65E0\u989C\u8272\u8BBE\u7F6E"
    ];
    new import_obsidian12.Notice(info.join("\n"), 6e3);
    DebugManager.log("Node Info:", node);
    return Promise.resolve();
  }
  // 搜索相关文件
  async searchRelatedFiles(node) {
    if (node.type !== "text" || !node.text) {
      new import_obsidian12.Notice(ERROR_MESSAGES.TEXT_NODE_ONLY);
      return;
    }
    try {
      const searchText = node.text.substring(0, SEARCH_CONSTANTS.MAX_SEARCH_TEXT_LENGTH).trim();
      if (!searchText) {
        new import_obsidian12.Notice(ERROR_MESSAGES.EMPTY_NODE_TEXT);
        return;
      }
      const searchPlugin = this.app.internalPlugins?.plugins?.["global-search"];
      if (searchPlugin && searchPlugin.enabled) {
        const searchLeaf = this.app.workspace.getLeavesOfType("search")[0];
        if (searchLeaf && searchLeaf.view.setQuery) {
          searchLeaf.view.setQuery(searchText);
          this.app.workspace.revealLeaf(searchLeaf);
          const truncatedText = searchText.substring(0, SEARCH_CONSTANTS.PRIMARY_SEARCH_LENGTH);
          new import_obsidian12.Notice(`${INFO_MESSAGES.GLOBAL_SEARCH_STARTED}: "${truncatedText}..."`);
        } else {
          const truncatedText = searchText.substring(0, SEARCH_CONSTANTS.PRIMARY_SEARCH_LENGTH);
          new import_obsidian12.Notice(`${INFO_MESSAGES.SEARCH_SUGGESTION}: "${truncatedText}..."`);
        }
      } else {
        const truncatedText = searchText.substring(0, SEARCH_CONSTANTS.PRIMARY_SEARCH_LENGTH);
        new import_obsidian12.Notice(`${INFO_MESSAGES.SEARCH_SUGGESTION}: "${truncatedText}..."`);
      }
    } catch (error) {
      DebugManager.error("Failed to search related files:", error);
      new import_obsidian12.Notice(ERROR_MESSAGES.SEARCH_FAILED);
    }
  }
  // 智能块回链功能（合并了回链和定位原文功能）
  async handleSmartBlockBacklink(node) {
    try {
      DebugManager.log("Smart Block Backlink started", { id: node.id, type: node.type, hasText: !!node.text });
      if (this.hasBacklink(node)) {
        DebugManager.log("Found backlink in node, using navigateToBacklink");
        await this.navigateToBacklink(node);
        return;
      }
      if (node.type === "text" && node.text) {
        DebugManager.log("No backlink found, trying content search");
        const cleanText = this.cleanTextForSearch(node.text);
        DebugManager.verbose("Cleaned text for search:", cleanText.substring(0, SEARCH_CONSTANTS.MAX_PREVIEW_LENGTH) + "...");
        if (cleanText.trim()) {
          const searchResults = await this.searchInAllFiles(cleanText);
          DebugManager.log("Search results count:", searchResults.length);
          if (searchResults.length === 1) {
            const result = searchResults[0];
            await this.openFileAndNavigate(result.file, result.line);
            new import_obsidian12.Notice(`${SUCCESS_MESSAGES.LOCATION_FOUND}: ${result.file.basename} (\u7B2C${result.line + 1}\u884C)`);
            return;
          } else if (searchResults.length > 1) {
            this.showLocationChoiceDialog(searchResults, cleanText);
            return;
          }
        }
      }
      DebugManager.log("No matches found, showing alternatives");
      await this.showSmartBacklinkAlternatives(node);
    } catch (error) {
      DebugManager.error("Failed to handle smart block backlink:", error);
      new import_obsidian12.Notice("\u5757\u56DE\u94FE\u529F\u80FD\u6267\u884C\u5931\u8D25");
    }
  }
  // 显示块链接替代选项
  async showBlockLinkAlternatives(nodeId) {
    const node = this.canvasData?.nodes.find((n) => n.id === nodeId);
    if (!node)
      return;
    const modal = new import_obsidian12.Modal(this.app);
    modal.titleEl.setText("\u{1F517} \u5757\u56DE\u94FE\u9009\u9879");
    const content = modal.contentEl;
    content.empty();
    const description = content.createEl("div");
    description.innerHTML = `
			<p><strong>\u672A\u627E\u5230\u8BE5\u5361\u7247\u7684\u5757\u94FE\u63A5\u4FE1\u606F</strong></p>
			<p>\u5757\u56DE\u94FE\u529F\u80FD\u9700\u8981\u4EE5\u4E0B\u6761\u4EF6\u4E4B\u4E00\uFF1A</p>
			<ol>
				<li>\u{1F517} <strong>Obsidian\u5757\u94FE\u63A5</strong>\uFF1A\u4ECE\u5176\u4ED6\u6587\u6863\u62D6\u62FD\u65F6\u81EA\u52A8\u521B\u5EFA\u7684\u5757ID</li>
				<li>\u{1F4CD} <strong>\u4F4D\u7F6E\u4FE1\u606F</strong>\uFF1A\u8BB0\u5F55\u7684\u6E90\u6587\u6863\u4F4D\u7F6E\u4FE1\u606F</li>
			</ol>
			<p style="color: var(--text-muted);">\u5F53\u524D\u5361\u7247\u6CA1\u6709\u627E\u5230\u5757\u94FE\u63A5\u4FE1\u606F\uFF0C\u60A8\u53EF\u4EE5\u5C1D\u8BD5\u4EE5\u4E0B\u9009\u9879\uFF1A</p>
		`;
    description.style.cssText = `
			margin-bottom: 20px;
			line-height: 1.6;
			color: var(--text-normal);
		`;
    const buttonContainer = content.createDiv("block-link-options-container");
    buttonContainer.style.cssText = `
			display: flex;
			gap: 12px;
			margin-top: 20px;
			justify-content: center;
			flex-wrap: wrap;
		`;
    const infoButton = buttonContainer.createEl("button", { text: "\u{1F4CB} \u8282\u70B9\u4FE1\u606F" });
    infoButton.className = "mod-cta";
    infoButton.onclick = () => {
      modal.close();
      this.showNodeInfo(node);
    };
    const searchButton = buttonContainer.createEl("button", { text: "\u{1F50D} \u641C\u7D22\u76F8\u4F3C\u5185\u5BB9" });
    searchButton.onclick = () => {
      modal.close();
      this.handleSmartBlockBacklink(node);
    };
    const cancelButton = buttonContainer.createEl("button", { text: "\u53D6\u6D88" });
    cancelButton.onclick = () => {
      modal.close();
    };
    modal.open();
  }
  // 显示智能块回链替代选项
  async showSmartBacklinkAlternatives(node) {
    const modal = new import_obsidian12.Modal(this.app);
    modal.titleEl.setText("\u{1F517} \u76F8\u4F3C\u5185\u5BB9\u9009\u9879");
    const content = modal.contentEl;
    content.empty();
    const description = content.createEl("div");
    description.innerHTML = `
			<p><strong>\u672A\u627E\u5230\u8BE5\u5361\u7247\u7684\u6E90\u6587\u6863\u4F4D\u7F6E</strong></p>
			<p>\u76F8\u4F3C\u5185\u5BB9\u529F\u80FD\u4F1A\u6309\u4EE5\u4E0B\u4F18\u5148\u7EA7\u67E5\u627E\uFF1A</p>
			<ol>
				<li>\u{1F517} <strong>\u5757\u5F15\u7528</strong>\uFF1A\u4ECE\u5176\u4ED6\u6587\u6863\u62D6\u62FD\u65F6\u81EA\u52A8\u521B\u5EFA\u7684\u7CBE\u786E\u94FE\u63A5</li>
				<li>\u{1F4CD} <strong>\u7B80\u5355\u56DE\u94FE</strong>\uFF1A\u5305\u542B\u6E90\u6587\u4EF6\u548C\u884C\u53F7\u4FE1\u606F\u7684\u94FE\u63A5</li>
				<li>\u{1F50D} <strong>\u5185\u5BB9\u641C\u7D22</strong>\uFF1A\u5728\u6240\u6709\u6587\u6863\u4E2D\u641C\u7D22\u5339\u914D\u7684\u6587\u672C\u5185\u5BB9</li>
			</ol>
			<p style="color: var(--text-muted);">\u5F53\u524D\u5361\u7247\u6CA1\u6709\u627E\u5230\u5339\u914D\u7684\u6E90\u4F4D\u7F6E\uFF0C\u60A8\u53EF\u4EE5\u5C1D\u8BD5\u4EE5\u4E0B\u9009\u9879\uFF1A</p>
		`;
    description.style.cssText = `
			margin-bottom: 20px;
			line-height: 1.6;
			color: var(--text-normal);
		`;
    const buttonContainer = content.createDiv("source-options-container");
    buttonContainer.style.cssText = `
			display: flex;
			gap: 12px;
			margin-top: 20px;
			justify-content: center;
			flex-wrap: wrap;
		`;
    const infoButton = buttonContainer.createEl("button", { text: "\u{1F4CB} \u8282\u70B9\u4FE1\u606F" });
    infoButton.className = "mod-cta";
    infoButton.onclick = () => {
      modal.close();
      this.showNodeInfo(node);
    };
    const searchButton = buttonContainer.createEl("button", { text: "\u{1F50D} \u5168\u5C40\u641C\u7D22" });
    searchButton.onclick = () => {
      modal.close();
      this.searchRelatedFiles(node);
    };
    const cancelButton = buttonContainer.createEl("button", { text: "\u53D6\u6D88" });
    cancelButton.onclick = () => {
      modal.close();
    };
    modal.open();
  }
  // 清理文本内容，移除回链信息和其他干扰内容
  cleanTextForSearch(text) {
    let cleanText = text;
    cleanText = cleanText.replace(/\n\n---\n📍\s*来源:.*?\n🔗\s*路径:.*$/s, "");
    cleanText = cleanText.replace(/\n\n---\n来源：.*?\s\(行\s\d+\)$/s, "");
    cleanText = cleanText.trim();
    cleanText = cleanText.replace(/\n\s*\n/g, "\n");
    return cleanText;
  }
  // 在所有文件中搜索匹配的内容
  async searchInAllFiles(searchText) {
    const results = [];
    const files = this.app.vault.getMarkdownFiles();
    const primarySearch = searchText.substring(0, SEARCH_CONSTANTS.PRIMARY_SEARCH_LENGTH).trim();
    const searchWords = primarySearch.split(/\s+/).filter((word) => word.length > SEARCH_CONSTANTS.MIN_WORD_LENGTH);
    DebugManager.log("\u641C\u7D22\u5173\u952E\u8BCD:", searchWords);
    for (const file of files) {
      try {
        const content = await this.app.vault.read(file);
        const lines = content.split("\n");
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          const similarity = this.calculateTextSimilarity(line, searchText, searchWords);
          if (similarity > SEARCH_CONSTANTS.SIMILARITY_THRESHOLD) {
            results.push({
              file,
              line: i,
              content: line,
              similarity
            });
          }
        }
      } catch (error) {
        DebugManager.warn("Failed to read file:", file.path, error);
      }
    }
    results.sort((a, b) => b.similarity - a.similarity);
    return results.slice(0, SEARCH_CONSTANTS.MAX_SEARCH_RESULTS);
  }
  // 计算文本相似度
  calculateTextSimilarity(line, searchText, searchWords) {
    const lineLower = line.toLowerCase();
    const searchLower = searchText.toLowerCase();
    if (lineLower.includes(searchLower.substring(0, SEARCH_CONSTANTS.MAX_PREVIEW_LENGTH))) {
      return 1;
    }
    let matchedWords = 0;
    for (const word of searchWords) {
      if (lineLower.includes(word.toLowerCase())) {
        matchedWords++;
      }
    }
    const wordMatchRatio = searchWords.length > 0 ? matchedWords / searchWords.length : 0;
    const lengthSimilarity = Math.min(line.length / searchText.length, 1);
    return wordMatchRatio * 0.7 + lengthSimilarity * 0.3;
  }
  // 显示位置选择对话框
  showLocationChoiceDialog(results, searchText) {
    const modal = new import_obsidian12.Modal(this.app);
    modal.titleEl.setText("\u{1F3AF} \u9009\u62E9\u539F\u6587\u4F4D\u7F6E");
    const content = modal.contentEl;
    content.empty();
    const description = content.createEl("div");
    description.innerHTML = `
			<p>\u627E\u5230 <strong>${results.length}</strong> \u4E2A\u53EF\u80FD\u7684\u539F\u6587\u4F4D\u7F6E\uFF0C\u8BF7\u9009\u62E9\u6700\u5339\u914D\u7684\u4E00\u4E2A\uFF1A</p>
			<p style="color: var(--text-muted); font-size: 0.9em;">\u641C\u7D22\u5185\u5BB9: "${searchText.substring(0, SEARCH_CONSTANTS.MAX_PREVIEW_LENGTH)}..."</p>
		`;
    description.style.marginBottom = "16px";
    const resultsList = content.createDiv("locate-results-list");
    resultsList.style.cssText = `
			max-height: 400px;
			overflow-y: auto;
			border: 1px solid var(--background-modifier-border);
			border-radius: 4px;
		`;
    results.forEach((result, index) => {
      const resultItem = resultsList.createDiv("locate-result-item");
      resultItem.style.cssText = `
				padding: 12px;
				border-bottom: 1px solid var(--background-modifier-border);
				cursor: pointer;
				transition: background-color 0.2s;
			`;
      resultItem.innerHTML = `
				<div style="font-weight: 500; margin-bottom: 4px;">
					\u{1F4C4} ${result.file.basename} (\u7B2C${result.line + 1}\u884C)
					<span style="color: var(--text-muted); font-size: 0.8em; margin-left: 8px;">
						\u5339\u914D\u5EA6: ${Math.round(result.similarity * 100)}%
					</span>
				</div>
				<div style="color: var(--text-muted); font-size: 0.9em; line-height: 1.4;">
					${result.content.substring(0, SEARCH_CONSTANTS.MAX_PREVIEW_LENGTH)}${result.content.length > 100 ? "..." : ""}
				</div>
				<div style="color: var(--text-accent); font-size: 0.8em; margin-top: 4px;">
					${result.file.path}
				</div>
			`;
      resultItem.addEventListener("mouseenter", () => {
        resultItem.style.backgroundColor = "var(--background-modifier-hover)";
      });
      resultItem.addEventListener("mouseleave", () => {
        resultItem.style.backgroundColor = "";
      });
      resultItem.addEventListener("click", async () => {
        modal.close();
        await this.openFileAndNavigate(result.file, result.line);
        new import_obsidian12.Notice(`\u2705 \u5DF2\u5B9A\u4F4D\u5230\u539F\u6587: ${result.file.basename} (\u7B2C${result.line + 1}\u884C)`);
      });
      if (index === 0) {
        const recommendBadge = resultItem.createDiv();
        recommendBadge.textContent = "\u{1F31F} \u63A8\u8350";
        recommendBadge.style.cssText = `
					position: absolute;
					right: 12px;
					top: 12px;
					background: var(--color-accent);
					color: white;
					padding: 2px 6px;
					border-radius: 10px;
					font-size: 0.7em;
					font-weight: 500;
				`;
        resultItem.style.position = "relative";
      }
    });
    const buttonContainer = content.createDiv();
    buttonContainer.style.cssText = `
			margin-top: 16px;
			text-align: center;
		`;
    const cancelButton = buttonContainer.createEl("button", { text: "\u53D6\u6D88" });
    cancelButton.onclick = () => modal.close();
    modal.open();
  }
  // 重命名分组
  async renameGroup(groupId) {
    if (!this.canvasData)
      return;
    const groupNode = this.canvasData.nodes.find((n) => n.id === groupId && n.type === "group");
    if (!groupNode) {
      new import_obsidian12.Notice("\u672A\u627E\u5230\u5206\u7EC4\u8282\u70B9");
      return;
    }
    const currentName = groupNode.label || "\u672A\u547D\u540D\u5206\u7EC4";
    const modal = new GroupRenameModal(this.app, currentName, async (newName) => {
      try {
        groupNode.label = newName;
        await this.saveCanvasData();
        const groupInfo = this.groupAnalysis.get(groupId);
        if (groupInfo) {
          groupInfo.group.label = newName;
        }
        this.renderGrid().catch((error) => {
          DebugManager.error("Failed to render grid after renaming:", error);
        });
        this.notifyCanvasViewRefresh();
        new import_obsidian12.Notice(`\u5206\u7EC4\u5DF2\u91CD\u547D\u540D\u4E3A: ${newName}`);
        DebugManager.log(`Group ${groupId} renamed to: ${newName}`);
      } catch (error) {
        DebugManager.error("Failed to rename group:", error);
        new import_obsidian12.Notice("\u91CD\u547D\u540D\u5206\u7EC4\u5931\u8D25");
      }
    });
    modal.open();
  }
  // 编辑卡片（Canvas兼容模式）
  editCard(card) {
    const nodeId = card.dataset.nodeId;
    if (!nodeId)
      return;
    const node = this.canvasData?.nodes.find((n) => n.id === nodeId);
    if (!node)
      return;
    const editCheck = this.canEnterEditMode(node, card);
    if (!editCheck.canEdit) {
      DebugManager.log(`\u{1F6AB} \u53F3\u952E\u83DC\u5355\u963B\u6B62\u7F16\u8F91: ${editCheck.reason}`);
      return;
    }
    if (this.currentEditingCard && this.currentEditingNode) {
      DebugManager.log("Another card is being edited, switching to new card (Canvas-compatible mode)");
    }
    if (node && !card.classList.contains("editing")) {
      DebugManager.log("\u4ECE\u53F3\u952E\u83DC\u5355\u8FDB\u5165\u7F16\u8F91\u6A21\u5F0F (Canvas-compatible mode):", nodeId);
      this.startEditingFromSelection(node, card);
    }
  }
  // 删除卡片
  async deleteCard(card) {
    const nodeId = card.dataset.nodeId;
    if (!nodeId)
      return;
    const confirmed = confirm("\u786E\u5B9A\u8981\u5220\u9664\u8FD9\u4E2A\u8282\u70B9\u5417\uFF1F");
    if (!confirmed)
      return;
    try {
      DebugManager.log("\u{1F5D1}\uFE0F \u5F00\u59CB\u5220\u9664\u5361\u7247\u64CD\u4F5C", { nodeId });
      await this.deleteNodeFromCanvas(nodeId);
      DebugManager.log("\u{1F504} \u5220\u9664\u6210\u529F\uFF0C\u5F00\u59CB\u91CD\u65B0\u6E32\u67D3\u7F51\u683C\u89C6\u56FE");
      await this.renderGrid();
      DebugManager.log("\u2705 \u5361\u7247\u5220\u9664\u5B8C\u6210\uFF0C\u7F51\u683C\u89C6\u56FE\u5DF2\u66F4\u65B0", {
        nodeId,
        remainingNodes: this.filteredNodes.length
      });
      new import_obsidian12.Notice("\u8282\u70B9\u5220\u9664\u6210\u529F");
    } catch (error) {
      DebugManager.error("\u274C \u5220\u9664\u5361\u7247\u5931\u8D25:", error);
      new import_obsidian12.Notice("\u5220\u9664\u5361\u7247\u5931\u8D25");
    }
  }
  // 从Canvas数据中删除节点
  async deleteNodeFromCanvas(nodeId) {
    let targetFile = null;
    if (this.linkedCanvasFile) {
      targetFile = this.linkedCanvasFile;
    } else {
      const activeFile = this.app.workspace.getActiveFile();
      if (activeFile && activeFile.extension === "canvas") {
        targetFile = activeFile;
      }
    }
    if (!targetFile) {
      DebugManager.error("\u65E0\u6CD5\u786E\u5B9A\u76EE\u6807Canvas\u6587\u4EF6");
      new import_obsidian12.Notice("\u5220\u9664\u5931\u8D25\uFF1A\u65E0\u6CD5\u786E\u5B9A\u76EE\u6807Canvas\u6587\u4EF6");
      return;
    }
    try {
      this.startSaveOperation();
      const content = await this.app.vault.read(targetFile);
      const canvasData = JSON.parse(content);
      const nodeExists = canvasData.nodes.some((node) => node.id === nodeId);
      if (!nodeExists) {
        DebugManager.warn("\u8282\u70B9\u4E0D\u5B58\u5728\uFF0C\u53EF\u80FD\u5DF2\u88AB\u5220\u9664:", nodeId);
        return;
      }
      canvasData.nodes = canvasData.nodes.filter((node) => node.id !== nodeId);
      canvasData.edges = canvasData.edges.filter(
        (edge) => edge.fromNode !== nodeId && edge.toNode !== nodeId
      );
      await this.app.vault.modify(targetFile, JSON.stringify(canvasData, null, 2));
      this.canvasData = canvasData;
      this.filteredNodes = this.filteredNodes.filter((node) => node.id !== nodeId);
      DebugManager.log("\u2705 \u8282\u70B9\u5220\u9664\u5B8C\u6210\uFF0C\u6570\u636E\u5DF2\u66F4\u65B0:", {
        deletedNodeId: nodeId,
        remainingFilteredNodes: this.filteredNodes.length,
        remainingTotalNodes: this.canvasData?.nodes?.length || 0
      });
      this.safeSetTimeout(async () => {
        DebugManager.log("\u{1F504} \u5220\u9664\u64CD\u4F5C\u6570\u636E\u540C\u6B65\u5B8C\u6210");
        this.endSaveOperation();
      }, 50);
      DebugManager.log("\u2705 \u8282\u70B9\u5220\u9664\u6210\u529F:", nodeId);
    } catch (error) {
      DebugManager.error("\u5220\u9664\u8282\u70B9\u5931\u8D25:", error);
      new import_obsidian12.Notice("\u5220\u9664\u8282\u70B9\u5931\u8D25");
      this.endSaveOperation();
    }
  }
  // Canvas兼容模式：保存操作标志管理
  startSaveOperation() {
    this.isSaveOperationInProgress = true;
    this.lastSaveTimestamp = Date.now();
    DebugManager.log("Save operation started (Canvas-compatible mode)");
  }
  endSaveOperation() {
    this.isSaveOperationInProgress = false;
    DebugManager.log("Save operation completed (Canvas-compatible mode)");
  }
  async saveWithLock(operation) {
    if (this.saveLock) {
      return new Promise((resolve, reject) => {
        this.saveQueue.push(async () => {
          try {
            await operation();
            resolve();
          } catch (error) {
            reject(error);
          }
        });
      });
    }
    this.saveLock = true;
    try {
      await operation();
      if (this.saveQueue.length > 0) {
        const nextOperation = this.saveQueue.shift();
        if (nextOperation) {
          setTimeout(async () => {
            try {
              await nextOperation();
            } catch (error) {
              DebugManager.error("Queued save operation failed:", error);
            } finally {
              this.saveLock = false;
            }
          }, 10);
          return;
        }
      }
    } finally {
      this.saveLock = false;
    }
  }
  // 🎯 关键修复：检测是否点击了Obsidian原生右键菜单
  isClickInObsidianNativeMenu(target) {
    const obsidianMenuSelectors = [
      ".menu",
      // Obsidian主菜单容器
      ".menu-item",
      // 菜单项
      ".menu-separator",
      // 菜单分隔符
      ".suggestion-container",
      // 建议容器
      ".suggestion-item",
      // 建议项
      ".modal",
      // 模态框
      ".modal-container",
      // 模态框容器
      ".context-menu",
      // 上下文菜单
      ".dropdown-menu",
      // 下拉菜单
      ".popover",
      // 弹出框
      ".tooltip",
      // 工具提示
      ".workspace-leaf-content",
      // 工作区叶子内容
      ".view-content",
      // 视图内容
      ".cm-editor",
      // CodeMirror编辑器
      ".markdown-source-view",
      // Markdown源码视图
      ".markdown-preview-view",
      // Markdown预览视图
      ".canvas-node-content",
      // Canvas节点内容
      ".canvas-menu",
      // Canvas菜单
      ".file-explorer",
      // 文件浏览器
      ".search-result",
      // 搜索结果
      ".tag-pane",
      // 标签面板
      ".outline",
      // 大纲
      ".backlink"
      // 反向链接
    ];
    for (const selector of obsidianMenuSelectors) {
      if (target.closest(selector)) {
        DebugManager.log("\u{1F3AF} Detected click in Obsidian native menu:", selector);
        return true;
      }
    }
    const obsidianClassPatterns = [
      /^menu-/,
      // 以menu-开头的类名
      /^modal-/,
      // 以modal-开头的类名
      /^suggestion-/,
      // 以suggestion-开头的类名
      /^context-/,
      // 以context-开头的类名
      /^dropdown-/,
      // 以dropdown-开头的类名
      /^popover-/,
      // 以popover-开头的类名
      /^tooltip-/
      // 以tooltip-开头的类名
    ];
    let currentElement = target;
    while (currentElement && currentElement !== document.body) {
      const className = currentElement.className;
      if (typeof className === "string") {
        const classes = className.split(" ");
        for (const cls of classes) {
          for (const pattern of obsidianClassPatterns) {
            if (pattern.test(cls)) {
              DebugManager.log("\u{1F3AF} Detected click in Obsidian native menu by class pattern:", cls);
              return true;
            }
          }
        }
      }
      currentElement = currentElement.parentElement;
    }
    return false;
  }
  // 🎯 新增：处理工具栏面板的点击外部关闭逻辑
  handleToolbarOutsideClick(target, clickInfo) {
    const {
      clickedInMainDropdown,
      clickedInMultiMenuContainer,
      clickedInDynamicContent,
      clickedInFunctionButton,
      clickedInMultiMenuButton,
      clickedInObsidianMenu
    } = clickInfo;
    if (clickedInObsidianMenu) {
      DebugManager.log("\u{1F3AF} \u70B9\u51FB\u4E86Obsidian\u539F\u751F\u83DC\u5355\uFF0C\u8DF3\u8FC7\u5DE5\u5177\u680F\u5173\u95ED\u903B\u8F91");
      return;
    }
    const mainDropdown = this.containerEl.querySelector(".canvas-grid-main-dropdown");
    if (mainDropdown && mainDropdown.style.display !== "none") {
      if (clickedInMultiMenuButton) {
        DebugManager.log("\u{1F3AF} \u70B9\u51FB\u591A\u529F\u80FD\u83DC\u5355\u6309\u94AE\uFF0C\u7531\u6309\u94AE\u4E8B\u4EF6\u5904\u7406");
        return;
      }
      if (clickedInMainDropdown || clickedInMultiMenuContainer) {
        DebugManager.log("\u{1F3AF} \u70B9\u51FB\u591A\u529F\u80FD\u83DC\u5355\u5185\u90E8\uFF0C\u4FDD\u6301\u6253\u5F00");
        return;
      }
      DebugManager.log("\u{1F3AF} \u70B9\u51FB\u591A\u529F\u80FD\u83DC\u5355\u5916\u90E8\uFF0C\u5173\u95ED\u83DC\u5355");
      this.hideAllDropdowns();
    }
    const dynamicContent = this.containerEl.querySelector(".canvas-grid-toolbar-dynamic-content");
    if (dynamicContent && dynamicContent.classList.contains("expanded")) {
      if (clickedInFunctionButton) {
        DebugManager.log("\u{1F3AF} \u70B9\u51FB\u529F\u80FD\u6309\u94AE\uFF0C\u7531\u6309\u94AE\u4E8B\u4EF6\u5904\u7406");
        return;
      }
      if (clickedInDynamicContent) {
        DebugManager.log("\u{1F3AF} \u70B9\u51FB\u52A8\u6001\u9762\u677F\u5185\u90E8\uFF0C\u4FDD\u6301\u6253\u5F00");
        return;
      }
      DebugManager.log("\u{1F3AF} \u70B9\u51FB\u52A8\u6001\u9762\u677F\u5916\u90E8\uFF0C\u5173\u95ED\u9762\u677F");
      this.closeDynamicContent();
    }
  }
  // 保存单个节点到Canvas文件
  async saveNodeToCanvas(node) {
    if (!node || !node.id) {
      throw new Error("\u8282\u70B9\u6570\u636E\u65E0\u6548");
    }
    const canvasFile = this.linkedCanvasFile;
    if (!canvasFile) {
      throw new Error("\u6CA1\u6709\u5173\u8054\u7684Canvas\u6587\u4EF6");
    }
    try {
      DebugManager.log("Saving node to canvas:", node.id);
      const content = await this.app.vault.read(canvasFile);
      let canvasData;
      try {
        canvasData = JSON.parse(content);
      } catch (parseError) {
        throw new Error("Canvas\u6587\u4EF6\u683C\u5F0F\u65E0\u6548");
      }
      if (!Array.isArray(canvasData.nodes)) {
        throw new Error("Canvas\u6587\u4EF6\u7F3A\u5C11\u6709\u6548\u7684\u8282\u70B9\u6570\u636E");
      }
      const nodeIndex = canvasData.nodes.findIndex((n) => n.id === node.id);
      if (nodeIndex === -1) {
        throw new Error(`\u8282\u70B9\u4E0D\u5B58\u5728: ${node.id}`);
      }
      canvasData.nodes[nodeIndex] = { ...canvasData.nodes[nodeIndex], ...node };
      const updatedNode = canvasData.nodes[nodeIndex];
      if (!updatedNode.id || !updatedNode.type) {
        throw new Error("\u66F4\u65B0\u540E\u7684\u8282\u70B9\u6570\u636E\u65E0\u6548");
      }
      const jsonContent = JSON.stringify(canvasData, null, 2);
      await this.app.vault.modify(canvasFile, jsonContent);
      DebugManager.log("Node saved successfully:", node.id);
    } catch (error) {
      DebugManager.error("\u4FDD\u5B58\u8282\u70B9\u5931\u8D25:", error);
      const errorMessage = error instanceof Error ? error.message : "\u672A\u77E5\u9519\u8BEF";
      throw new Error(`\u4FDD\u5B58\u8282\u70B9\u5931\u8D25: ${errorMessage}`);
    }
  }
  // ==================== 聚焦功能实现 ====================
  // 聚焦到Canvas中的指定节点
  async focusNodeInCanvas(nodeId) {
    try {
      DebugManager.log("=== Starting focus operation for node:", nodeId);
      new import_obsidian12.Notice("\u64CD\u4F5C\u5B8C\u6210", NOTIFICATION_CONSTANTS.SHORT_DURATION);
      await this.ensureCanvasView();
      await this.waitForCanvasLoad();
      const canvasView = this.getActiveCanvasView();
      if (!canvasView) {
        new import_obsidian12.Notice("\u65E0\u6CD5\u83B7\u53D6Canvas\u89C6\u56FE");
        return false;
      }
      DebugManager.log("Canvas view obtained, detecting API...");
      const canvasAPI = this.detectCanvasAPI(canvasView);
      if (!canvasAPI) {
        DebugManager.log("Canvas API not available, falling back to simulation");
        return this.focusNodeBySimulation(nodeId);
      }
      const nodeData = this.canvasData?.nodes.find((n) => n.id === nodeId);
      if (!nodeData) {
        new import_obsidian12.Notice("\u627E\u4E0D\u5230\u76EE\u6807\u8282\u70B9");
        return false;
      }
      DebugManager.log("Node data found:", nodeData);
      DebugManager.log("Executing focus operations...");
      const success = await this.executeCanvasFocus(canvasAPI, nodeId, nodeData);
      if (success) {
        new import_obsidian12.Notice("\u64CD\u4F5C\u5B8C\u6210", NOTIFICATION_CONSTANTS.MEDIUM_DURATION);
        return true;
      } else {
        DebugManager.log("Canvas API focus failed, falling back to simulation");
        return this.focusNodeBySimulation(nodeId);
      }
    } catch (error) {
      DebugManager.error("\u805A\u7126\u8282\u70B9\u5931\u8D25:", error);
      new import_obsidian12.Notice("\u805A\u7126\u5931\u8D25\uFF0C\u8BF7\u624B\u52A8\u5B9A\u4F4D");
      return false;
    }
  }
  // 确保切换到Canvas视图
  async ensureCanvasView() {
    DebugManager.log("Ensuring canvas view...");
    if (!this.linkedCanvasFile) {
      new import_obsidian12.Notice("\u6CA1\u6709\u5173\u8054\u7684Canvas\u6587\u4EF6\uFF0C\u8BF7\u5148\u5173\u8054\u4E00\u4E2ACanvas\u6587\u4EF6");
      throw new Error("No linked canvas file");
    }
    const targetLeaf = this.findExistingCanvasLeaf(this.linkedCanvasFile);
    if (targetLeaf) {
      DebugManager.log("Found existing canvas view, activating...");
      this.app.workspace.setActiveLeaf(targetLeaf);
      await new Promise((resolve) => {
        this.safeSetTimeout(() => resolve(void 0), 300);
      });
      return;
    }
    const activeLeaf = this.app.workspace.getActiveViewOfType(import_obsidian12.ItemView)?.leaf;
    if (activeLeaf && activeLeaf.view.getViewType() === "canvas") {
      const canvasView = activeLeaf.view;
      if (canvasView && canvasView.file && canvasView.file.path === this.linkedCanvasFile.path) {
        DebugManager.log("Already in correct canvas view");
        return;
      }
    }
    DebugManager.log("Creating new canvas view...");
    await this.openCanvasInMainWorkspace(this.linkedCanvasFile);
    await new Promise((resolve) => {
      this.safeSetTimeout(() => resolve(void 0), 800);
    });
    const newActiveLeaf = this.app.workspace.getActiveViewOfType(import_obsidian12.ItemView)?.leaf;
    if (newActiveLeaf && newActiveLeaf.view.getViewType() === "canvas") {
      DebugManager.log("Successfully switched to canvas view");
    } else {
      DebugManager.warn("Failed to switch to canvas view");
      throw new Error("\u65E0\u6CD5\u5207\u6362\u5230Canvas\u89C6\u56FE");
    }
  }
  // 探测Canvas视图的可用API
  detectCanvasAPI(canvasView) {
    try {
      DebugManager.log("Canvas view object:", canvasView);
      if (!canvasView || typeof canvasView !== "object") {
        DebugManager.warn("Invalid canvas view object");
        return null;
      }
      DebugManager.log("Canvas view properties:", Object.keys(canvasView));
      if (!hasProperty(canvasView, "canvas")) {
        DebugManager.warn("Canvas view does not have canvas property");
        return null;
      }
      const canvas = canvasView.canvas;
      DebugManager.log("Canvas object:", canvas);
      if (!canvas) {
        DebugManager.warn("Canvas object not found in view");
        return null;
      }
      DebugManager.log("Canvas properties:", Object.keys(canvas));
      DebugManager.log("Canvas methods:", Object.getOwnPropertyNames(Object.getPrototypeOf(canvas)));
      this.exploreCanvasAPI(canvas);
      const apiMethods = this.findCanvasAPIMethods(canvas);
      if (!apiMethods) {
        DebugManager.log("No suitable Canvas API methods found");
        return null;
      }
      DebugManager.log("Found Canvas API methods:", apiMethods);
      return apiMethods;
    } catch (error) {
      DebugManager.error("Failed to detect Canvas API:", error);
      return null;
    }
  }
  // 查找Canvas API的实际方法
  findCanvasAPIMethods(canvas) {
    const allMethods = this.getAllMethods(canvas);
    DebugManager.log("All canvas methods:", allMethods);
    const zoomMethods = allMethods.filter(
      (method) => method.toLowerCase().includes("zoom") || method.toLowerCase().includes("scale") || method.toLowerCase().includes("fit")
    );
    DebugManager.log("Zoom methods:", zoomMethods);
    const selectMethods = allMethods.filter(
      (method) => method.toLowerCase().includes("select") || method.toLowerCase().includes("focus") || method.toLowerCase().includes("highlight")
    );
    DebugManager.log("Select methods:", selectMethods);
    const nodeMethods = allMethods.filter(
      (method) => method.toLowerCase().includes("node") || method.toLowerCase().includes("element") || method.toLowerCase().includes("item")
    );
    DebugManager.log("Node methods:", nodeMethods);
    const panMethods = allMethods.filter(
      (method) => method.toLowerCase().includes("pan") || method.toLowerCase().includes("move") || method.toLowerCase().includes("translate")
    );
    DebugManager.log("Pan methods:", panMethods);
    const api = {};
    const zoomToBboxMethod = this.findMethod(canvas, [
      "zoomToBbox",
      "zoomToRect",
      "zoomToArea",
      "fitToRect",
      "focusRect"
    ]);
    if (zoomToBboxMethod) {
      api.zoomToBbox = zoomToBboxMethod;
    }
    const selectMethod = this.findMethod(canvas, [
      "selectNode",
      "selectElement",
      "select",
      "setSelection",
      "addSelection"
    ]);
    if (selectMethod) {
      api.selectNode = selectMethod;
    }
    const deselectMethod = this.findMethod(canvas, [
      "deselectAll",
      "clearSelection",
      "deselect",
      "unselectAll"
    ]);
    if (deselectMethod) {
      api.deselectAll = deselectMethod;
    }
    const getNodeMethod = this.findMethod(canvas, [
      "getNode",
      "getElement",
      "getElementById",
      "findNode"
    ]);
    if (getNodeMethod) {
      api.getNode = getNodeMethod;
    }
    const panMethod = this.findMethod(canvas, [
      "panTo",
      "moveTo",
      "translateTo",
      "setViewport"
    ]);
    if (panMethod) {
      api.panTo = panMethod;
    }
    if (api.zoomToBbox || api.selectNode && api.panMethod) {
      return api;
    }
    return null;
  }
  // 查找指定名称的方法
  findMethod(obj, methodNames) {
    if (!obj || typeof obj !== "object") {
      return null;
    }
    for (const name of methodNames) {
      if (hasProperty(obj, name) && typeof obj[name] === "function") {
        DebugManager.log(`Found method: ${name}`);
        return obj[name].bind(obj);
      }
    }
    return null;
  }
  // 获取对象的所有方法
  getAllMethods(obj) {
    const methods = /* @__PURE__ */ new Set();
    let current = obj;
    while (current && current !== Object.prototype) {
      Object.getOwnPropertyNames(current).forEach((name) => {
        if (typeof obj[name] === "function") {
          methods.add(name);
        }
      });
      current = Object.getPrototypeOf(current);
    }
    return Array.from(methods);
  }
  // 执行Canvas聚焦操作
  async executeCanvasFocus(canvasAPI, nodeId, nodeData) {
    try {
      if (canvasAPI.deselectAll) {
        DebugManager.log("Clearing selection...");
        canvasAPI.deselectAll();
      }
      if (canvasAPI.selectNode) {
        DebugManager.log("Selecting node:", nodeId);
        try {
          canvasAPI.selectNode(nodeId);
        } catch (error) {
          DebugManager.warn("selectNode failed:", error);
        }
      }
      if (canvasAPI.zoomToBbox) {
        DebugManager.log("Zooming to bbox...");
        const bbox = this.calculateOptimalBbox(nodeData);
        DebugManager.log("Calculated bbox:", bbox);
        try {
          canvasAPI.zoomToBbox(bbox);
          return true;
        } catch (error) {
          DebugManager.warn("zoomToBbox failed:", error);
        }
      }
      if (canvasAPI.panTo) {
        DebugManager.log("Using panTo as fallback...");
        const centerX = nodeData.x + nodeData.width / 2;
        const centerY = nodeData.y + nodeData.height / 2;
        try {
          canvasAPI.panTo(centerX, centerY);
          return true;
        } catch (error) {
          DebugManager.warn("panTo failed:", error);
        }
      }
      return false;
    } catch (error) {
      DebugManager.error("executeCanvasFocus failed:", error);
      return false;
    }
  }
  // 探索Canvas API的可用方法
  exploreCanvasAPI(canvas) {
    DebugManager.log("=== Canvas API Exploration ===");
    const allProps = [];
    let obj = canvas;
    while (obj && obj !== Object.prototype) {
      allProps.push(...Object.getOwnPropertyNames(obj));
      obj = Object.getPrototypeOf(obj);
    }
    const uniqueProps = [...new Set(allProps)];
    const methods = uniqueProps.filter((prop) => {
      try {
        return typeof canvas[prop] === "function";
      } catch {
        return false;
      }
    });
    DebugManager.log("All available methods:", methods);
    const focusMethods = methods.filter(
      (method) => method.toLowerCase().includes("zoom") || method.toLowerCase().includes("focus") || method.toLowerCase().includes("select") || method.toLowerCase().includes("center") || method.toLowerCase().includes("pan")
    );
    DebugManager.log("Potential focus-related methods:", focusMethods);
  }
  // 获取当前活动的Canvas视图
  getActiveCanvasView() {
    DebugManager.log("=== Getting Canvas View ===");
    const activeLeaf = this.app.workspace.getActiveViewOfType(import_obsidian12.ItemView)?.leaf;
    DebugManager.log("Active leaf:", activeLeaf);
    DebugManager.log("Active leaf view type:", activeLeaf?.view?.getViewType());
    if (activeLeaf && activeLeaf.view.getViewType() === "canvas") {
      DebugManager.log("Found active canvas view");
      return activeLeaf.view;
    }
    const canvasLeaves = this.app.workspace.getLeavesOfType("canvas");
    DebugManager.log("Canvas leaves found:", canvasLeaves.length);
    const activeFile = this.app.workspace.getActiveFile();
    DebugManager.log("Active file:", activeFile?.path);
    for (const leaf of canvasLeaves) {
      const view = leaf.view;
      DebugManager.log("Checking canvas leaf:", view?.file?.path);
      if (view && view.file && activeFile && view.file.path === activeFile.path) {
        DebugManager.log("Found matching canvas view");
        return view;
      }
    }
    DebugManager.log("No canvas view found");
    return null;
  }
  // 等待Canvas视图加载完成
  async waitForCanvasLoad() {
    return new Promise((resolve) => {
      this.safeSetTimeout(() => resolve(void 0), 300);
    });
  }
  // 计算最佳聚焦边界框
  calculateOptimalBbox(node) {
    const padding = 100;
    return {
      minX: node.x - padding,
      minY: node.y - padding,
      maxX: node.x + node.width + padding,
      maxY: node.y + node.height + padding
    };
  }
  // 模拟操作聚焦节点（回退方案）
  async focusNodeBySimulation(nodeId) {
    try {
      DebugManager.log("=== Starting simulation focus ===");
      const nodeData = this.canvasData?.nodes.find((n) => n.id === nodeId);
      if (!nodeData) {
        new import_obsidian12.Notice("\u627E\u4E0D\u5230\u76EE\u6807\u8282\u70B9");
        return false;
      }
      DebugManager.log("Node data for simulation:", nodeData);
      const canvasView = this.getActiveCanvasView();
      if (!canvasView || !canvasView.containerEl) {
        DebugManager.log("Canvas view or container not found");
        return false;
      }
      const canvasSelectors = [
        ".canvas-wrapper",
        ".canvas-container",
        ".canvas-viewport",
        ".canvas",
        '[data-type="canvas"]',
        '.workspace-leaf-content[data-type="canvas"]'
      ];
      let canvasElement = null;
      for (const selector of canvasSelectors) {
        canvasElement = canvasView.containerEl.querySelector(selector);
        if (canvasElement) {
          DebugManager.log(`Found canvas element with selector: ${selector}`);
          break;
        }
      }
      if (!canvasElement) {
        DebugManager.log("Canvas element not found, trying direct approach");
        canvasElement = canvasView.containerEl;
      }
      if (canvasView.canvas) {
        DebugManager.log("Trying direct canvas manipulation...");
        const success = await this.tryDirectCanvasManipulation(canvasView.canvas, nodeId, nodeData);
        if (success) {
          new import_obsidian12.Notice("\u64CD\u4F5C\u5B8C\u6210", NOTIFICATION_CONSTANTS.MEDIUM_DURATION);
          return true;
        }
      }
      const nodeElement = this.findNodeElement(canvasView.containerEl, nodeId);
      if (nodeElement) {
        DebugManager.log("Found node element, simulating click...");
        nodeElement.scrollIntoView({ behavior: "smooth", block: "center" });
        nodeElement.click();
        new import_obsidian12.Notice("\u64CD\u4F5C\u5B8C\u6210", NOTIFICATION_CONSTANTS.MEDIUM_DURATION);
        return true;
      }
      new import_obsidian12.Notice("\u64CD\u4F5C\u5B8C\u6210", NOTIFICATION_CONSTANTS.MEDIUM_DURATION);
      return false;
    } catch (error) {
      DebugManager.error("\u6A21\u62DF\u805A\u7126\u5931\u8D25:", error);
      new import_obsidian12.Notice("\u805A\u7126\u5931\u8D25\uFF0C\u8BF7\u624B\u52A8\u5B9A\u4F4D");
      return false;
    }
  }
  // 尝试直接操作Canvas对象
  async tryDirectCanvasManipulation(canvas, nodeId, nodeData) {
    try {
      DebugManager.log("Trying direct canvas manipulation...");
      DebugManager.log("Canvas object:", canvas);
      if (canvas.nodes && canvas.nodes.has && canvas.nodes.has(nodeId)) {
        DebugManager.log("Found node in canvas.nodes");
        const node = canvas.nodes.get(nodeId);
        DebugManager.log("Canvas node object:", node);
        if (canvas.selection) {
          DebugManager.log("Setting canvas selection...");
          canvas.selection.clear();
          canvas.selection.add(node);
        }
      }
      if (canvas.viewport || canvas.view) {
        const viewport = canvas.viewport || canvas.view;
        DebugManager.log("Found viewport:", viewport);
        const centerX = nodeData.x + nodeData.width / 2;
        const centerY = nodeData.y + nodeData.height / 2;
        if (viewport.setCenter) {
          viewport.setCenter(centerX, centerY);
          return true;
        } else if (viewport.panTo) {
          viewport.panTo(centerX, centerY);
          return true;
        } else if (viewport.x !== void 0 && viewport.y !== void 0) {
          viewport.x = -centerX + viewport.width / 2;
          viewport.y = -centerY + viewport.height / 2;
          return true;
        }
      }
      return false;
    } catch (error) {
      DebugManager.error("Direct canvas manipulation failed:", error);
      return false;
    }
  }
  // 查找节点对应的DOM元素
  findNodeElement(container, nodeId) {
    const selectors = [
      `[data-node-id="${nodeId}"]`,
      `[data-id="${nodeId}"]`,
      `#${nodeId}`,
      `.canvas-node[data-id="${nodeId}"]`,
      `.canvas-card[data-id="${nodeId}"]`
    ];
    for (const selector of selectors) {
      const element = container.querySelector(selector);
      if (element) {
        DebugManager.log(`Found node element with selector: ${selector}`);
        return element;
      }
    }
    DebugManager.log("Node element not found");
    return null;
  }
  // ==================== 拖拽功能实现 ====================
  // 初始化拖拽系统
  initializeDragSystem() {
    DebugManager.log("Initializing drag system...");
    this.setupDragDropHandlers();
  }
  // 设置拖拽处理器
  setupDragDropHandlers() {
    DebugManager.log("Setting up drag and drop handlers...");
    this.setupEditorDragSource();
    this.setupGridDropTarget();
    this.setupCanvasDropTarget();
  }
  // ==================== 网格卡片拖拽到Canvas功能 (HTML5 Drag & Drop API) ====================
  /*
   * 旧的鼠标事件处理代码已被HTML5 Drag & Drop API替代
   * 保留注释以防需要回退
   */
  // 处理卡片拖拽开始事件
  handleCardDragStart(e) {
    const cardElement = e.target.closest(".canvas-grid-card");
    if (!cardElement || !cardElement.dataset.nodeId) {
      e.preventDefault();
      return;
    }
    if (e.target.closest(".canvas-card-toolbar")) {
      e.preventDefault();
      return;
    }
    const nodeId = cardElement.dataset.nodeId;
    const node = this.canvasData?.nodes.find((n) => n.id === nodeId);
    if (!node) {
      e.preventDefault();
      return;
    }
    DebugManager.log("\u{1F680} Starting card drag with HTML5 API:", node);
    if (e.dataTransfer) {
      e.dataTransfer.setData("text/plain", node.text || "");
      e.dataTransfer.setData("application/json", JSON.stringify({
        type: "canvas-node",
        nodeData: node,
        source: "canvas-grid-view",
        isCtrlDrag: e.ctrlKey
        // 记录是否按住Ctrl键
      }));
      e.dataTransfer.effectAllowed = e.ctrlKey ? "copy" : "move";
      this.setCardDragPreview(e, cardElement);
    }
    cardElement.classList.add("dragging-from-grid");
    cardElement.style.cursor = "grabbing";
    this.isDragFromGrid = true;
    this.currentDragCard = cardElement;
    DebugManager.log("\u2705 Card drag started successfully");
  }
  // 处理卡片拖拽结束事件
  handleCardDragEnd(e) {
    DebugManager.log("\u{1F3C1} Card drag ended");
    if (this.currentDragCard) {
      this.currentDragCard.classList.remove("dragging-from-grid");
      this.currentDragCard.style.cursor = "grab";
    }
    this.isDragFromGrid = false;
    this.currentDragCard = null;
    DebugManager.log("\u2705 Card drag cleanup completed");
  }
  // 设置卡片拖拽预览
  setCardDragPreview(e, cardElement) {
    try {
      const preview = cardElement.cloneNode(true);
      preview.style.cssText = `
				position: absolute;
				top: -1000px;
				left: -1000px;
				width: ${cardElement.offsetWidth}px;
				height: ${cardElement.offsetHeight}px;
				opacity: 0.8;
				transform: rotate(3deg);
				box-shadow: 0 5px 15px rgba(0,0,0,0.3);
				pointer-events: none;
				z-index: var(--layer-popover);
			`;
      document.body.appendChild(preview);
      if (e.dataTransfer) {
        e.dataTransfer.setDragImage(preview, cardElement.offsetWidth / 2, cardElement.offsetHeight / 2);
      }
      setTimeout(() => {
        if (document.body.contains(preview)) {
          document.body.removeChild(preview);
        }
      }, 0);
    } catch (error) {
      DebugManager.error("Failed to set card drag preview:", error);
    }
  }
  // 设置Canvas拖拽目标
  setupCanvasDropTarget() {
    DebugManager.log("Setting up Canvas drop target for grid cards...");
    this.registerDomEvent(document, "dragover", (e) => {
      if (this.isDragFromGrid && e.dataTransfer?.types.includes("application/json")) {
        const canvasElement = this.findCanvasElementUnderCursor(e);
        if (canvasElement) {
          e.preventDefault();
          e.dataTransfer.dropEffect = e.ctrlKey ? "copy" : "move";
        }
      }
    });
    this.registerDomEvent(document, "drop", (e) => {
      if (this.isDragFromGrid && e.dataTransfer?.types.includes("application/json")) {
        const canvasView = this.findCanvasViewUnderCursor(e);
        if (canvasView) {
          e.preventDefault();
          this.handleCanvasDropFromGrid(e, canvasView);
        }
      }
    });
  }
  // 查找鼠标下的Canvas元素
  findCanvasElementUnderCursor(e) {
    const element = document.elementFromPoint(e.clientX, e.clientY);
    if (!element)
      return null;
    const canvasContainer = element.closest('.workspace-leaf-content[data-type="canvas"]');
    return canvasContainer;
  }
  // 处理Canvas接收网格卡片的拖拽
  async handleCanvasDropFromGrid(e, canvasView) {
    try {
      DebugManager.log("\u{1F3AF} Handling Canvas drop from grid...");
      const dragDataStr = e.dataTransfer?.getData("application/json");
      if (!dragDataStr) {
        DebugManager.error("No drag data found");
        return;
      }
      const dragData = JSON.parse(dragDataStr);
      if (dragData.type !== "canvas-node" || dragData.source !== "canvas-grid-view") {
        DebugManager.log("Not a grid card drag, ignoring");
        return;
      }
      const node = dragData.nodeData;
      const isCtrlDrag = dragData.isCtrlDrag || e.ctrlKey;
      DebugManager.log("Processing grid card drop:", node, "Ctrl pressed:", isCtrlDrag);
      const canvasCoords = this.getCanvasCoordinatesFromDrop(e, canvasView);
      DebugManager.log("Canvas coordinates:", canvasCoords);
      const newNode = this.createCanvasNodeFromGridCard(node, canvasCoords);
      await this.addNodeToCanvas(newNode, canvasView);
      if (isCtrlDrag) {
        new import_obsidian12.Notice("\u5361\u7247\u5DF2\u590D\u5236\u5230Canvas");
        DebugManager.log("\u2705 Card copied to Canvas (Ctrl+drag)");
      } else {
        await this.removeNodeFromGrid(node.id);
        new import_obsidian12.Notice("\u5361\u7247\u5DF2\u79FB\u52A8\u5230Canvas");
        DebugManager.log("\u2705 Card moved to Canvas (normal drag)");
      }
      DebugManager.log("\u2705 Canvas drop completed successfully");
    } catch (error) {
      DebugManager.error("Failed to handle Canvas drop:", error);
      new import_obsidian12.Notice("\u62D6\u62FD\u5230Canvas\u5931\u8D25");
    }
  }
  // 从拖拽事件获取Canvas坐标 - 使用Obsidian内置方法
  getCanvasCoordinatesFromDrop(e, canvasView) {
    DebugManager.log("\u{1F3AF} Getting Canvas coordinates from drop event...");
    try {
      if (canvasView.canvas && typeof canvasView.canvas.posFromEvt === "function") {
        const pos = canvasView.canvas.posFromEvt(e);
        DebugManager.log("\u2705 Using Canvas.posFromEvt:", pos);
        return { x: pos.x, y: pos.y };
      }
      DebugManager.log("\u26A0\uFE0F Canvas.posFromEvt not available, using manual calculation");
      return this.getCanvasCoordinatesManual(e, canvasView);
    } catch (error) {
      DebugManager.error("Error getting Canvas coordinates:", error);
      return { x: e.clientX, y: e.clientY };
    }
  }
  // 手动计算Canvas坐标（备用方法）
  getCanvasCoordinatesManual(e, canvasView) {
    const canvasContainer = canvasView.containerEl.querySelector(".canvas-wrapper") || canvasView.containerEl.querySelector(".canvas-container") || canvasView.containerEl;
    if (!canvasContainer) {
      DebugManager.warn("Canvas container not found, using event coordinates");
      return { x: e.clientX, y: e.clientY };
    }
    const rect = canvasContainer.getBoundingClientRect();
    const relativeX = e.clientX - rect.left;
    const relativeY = e.clientY - rect.top;
    const canvas = canvasView.canvas;
    if (canvas && canvas.tx !== void 0 && canvas.ty !== void 0 && canvas.tZoom !== void 0) {
      return {
        x: (relativeX - canvas.tx) / canvas.tZoom,
        y: (relativeY - canvas.ty) / canvas.tZoom
      };
    }
    return { x: relativeX, y: relativeY };
  }
  // 处理鼠标离开网格容器事件
  handleCardMouseLeave(e) {
    this.clearLongPressTimer();
    if (!this.isDragFromGrid) {
      this.resetCardDragState();
    }
  }
  // 清理长按定时器
  clearLongPressTimer() {
    if (this.longPressTimer) {
      clearTimeout(this.longPressTimer);
      this.longPressTimer = null;
    }
  }
  // 重置卡片拖拽状态
  resetCardDragState() {
    DebugManager.log("Resetting card drag state...");
    this.forceCleanupDragPreview();
    this.hideDragHint();
    if (this.currentDragCard) {
      this.currentDragCard.classList.remove("dragging-from-grid");
    }
    this.currentDragCard = null;
    this.isDragFromGrid = false;
    this.longPressStartTime = 0;
    this.dragStartPosition = { x: 0, y: 0 };
    this.removeGlobalMouseListeners();
    DebugManager.log("Card drag state reset complete");
  }
  // 取消拖拽操作
  cancelDrag() {
    DebugManager.log("Canceling drag operation...");
    this.resetCardDragState();
  }
  // 移除全局鼠标事件监听器
  removeGlobalMouseListeners() {
    DebugManager.log("Removing global mouse listeners...");
    if (this.globalMouseMoveHandler) {
      document.removeEventListener("mousemove", this.globalMouseMoveHandler);
      this.globalMouseMoveHandler = null;
    }
    if (this.globalMouseUpHandler) {
      document.removeEventListener("mouseup", this.globalMouseUpHandler);
      this.globalMouseUpHandler = null;
    }
    window.removeEventListener("blur", this.handleWindowBlur);
    document.removeEventListener("keydown", this.handleDragEscape);
    DebugManager.log("Global mouse listeners removed");
  }
  // 开始卡片拖拽
  startCardDrag(cardElement, e) {
    const nodeId = cardElement.dataset.nodeId;
    if (!nodeId || !this.canvasData)
      return;
    const node = this.canvasData.nodes.find((n) => n.id === nodeId);
    if (!node)
      return;
    DebugManager.log("Starting card drag from grid:", node);
    this.isDragFromGrid = true;
    this.createDragPreview(cardElement, e);
    cardElement.classList.add("dragging-from-grid");
    this.showDragHint(e.ctrlKey);
  }
  // 结束卡片拖拽
  endCardDrag(e) {
    DebugManager.log("\u{1F3C1} Ending card drag at:", e.clientX, e.clientY);
    if (!this.currentDragCard || !this.isDragFromGrid) {
      DebugManager.log("\u274C Invalid drag state - currentDragCard:", !!this.currentDragCard, "isDragFromGrid:", this.isDragFromGrid);
      return;
    }
    const nodeId = this.currentDragCard.dataset.nodeId;
    if (!nodeId || !this.canvasData) {
      DebugManager.log("\u274C Missing nodeId or canvasData - nodeId:", nodeId, "canvasData:", !!this.canvasData);
      return;
    }
    const node = this.canvasData.nodes.find((n) => n.id === nodeId);
    if (!node) {
      DebugManager.log("\u274C Node not found for nodeId:", nodeId);
      return;
    }
    DebugManager.log("\u2705 Found node for drag:", node);
    const canvasView = this.findCanvasViewUnderCursor(e);
    if (canvasView) {
      DebugManager.log("\u{1F3AF} Canvas view found, handling drop...");
      this.handleDropToCanvas(node, e, canvasView);
    } else {
      DebugManager.log("\u274C No Canvas view found under cursor");
      new import_obsidian12.Notice("\u8BF7\u62D6\u62FD\u5230Canvas\u533A\u57DF");
    }
    DebugManager.log("\u{1F9F9} Cleaning up drag state...");
    this.resetCardDragState();
  }
  // 创建拖拽预览
  createDragPreview(cardElement, e) {
    this.forceCleanupDragPreview();
    DebugManager.log("Creating drag preview...");
    this.dragPreviewElement = cardElement.cloneNode(true);
    this.dragPreviewElement.classList.add("drag-preview");
    this.dragPreviewElement.style.cssText = `
			position: fixed !important;
			top: ${e.clientY - 20}px !important;
			left: ${e.clientX - 20}px !important;
			width: ${cardElement.offsetWidth}px !important;
			height: ${cardElement.offsetHeight}px !important;
			opacity: 0.8 !important;
			pointer-events: none !important;
			z-index: var(--layer-popover) !important;
			transform: rotate(5deg) !important;
			box-shadow: 0 5px 15px rgba(0,0,0,0.3) !important;
		`;
    document.body.appendChild(this.dragPreviewElement);
    DebugManager.log("Drag preview created and attached");
  }
  // 强制清理拖拽预览
  forceCleanupDragPreview() {
    DebugManager.log("Force cleaning up drag preview...");
    if (this.dragPreviewElement) {
      try {
        if (this.dragPreviewElement.parentNode) {
          this.dragPreviewElement.parentNode.removeChild(this.dragPreviewElement);
        }
      } catch (error) {
        DebugManager.warn("Error removing drag preview element:", error);
      }
      this.dragPreviewElement = null;
    }
    this.cleanupDragPreview = () => {
    };
    DebugManager.log("Drag preview cleanup complete");
  }
  // 显示拖拽提示
  showDragHint(isCtrlPressed) {
    const hint = document.createElement("div");
    hint.className = "drag-hint";
    hint.textContent = isCtrlPressed ? "\u79FB\u52A8\u5230Canvas\uFF08\u5220\u9664\u539F\u5361\u7247\uFF09" : "\u590D\u5236\u5230Canvas\uFF08\u4FDD\u6301\u539F\u5361\u7247\uFF09";
    hint.style.cssText = `
			position: fixed;
			top: 20px;
			left: 50%;
			transform: translateX(-50%);
			background: var(--background-primary);
			border: 1px solid var(--background-modifier-border);
			border-radius: 6px;
			padding: 8px 16px;
			font-size: 12px;
			color: var(--text-normal);
			z-index: var(--layer-modal)1;
			box-shadow: 0 2px 8px rgba(0,0,0,0.15);
		`;
    document.body.appendChild(hint);
    this.dragHintElement = hint;
  }
  // 隐藏拖拽提示
  hideDragHint() {
    if (this.dragHintElement) {
      this.dragHintElement.remove();
      this.dragHintElement = null;
    }
  }
  // 查找鼠标位置下的Canvas视图
  findCanvasViewUnderCursor(e) {
    DebugManager.log("\u{1F50D} Finding Canvas view under cursor at:", e.clientX, e.clientY);
    const originalDisplay = this.dragPreviewElement?.style.display;
    if (this.dragPreviewElement) {
      this.dragPreviewElement.style.display = "none";
    }
    const elementUnderCursor = document.elementFromPoint(e.clientX, e.clientY);
    DebugManager.log("\u{1F3AF} Element under cursor:", elementUnderCursor);
    if (this.dragPreviewElement && originalDisplay !== void 0) {
      this.dragPreviewElement.style.display = originalDisplay;
    }
    if (!elementUnderCursor) {
      DebugManager.log("\u274C No element found under cursor");
      return null;
    }
    const canvasSelectors = [
      '.workspace-leaf-content[data-type="canvas"]',
      '[data-type="canvas"]',
      ".canvas-wrapper",
      ".canvas-container",
      '.view-content[data-type="canvas"]'
    ];
    let canvasContainer = null;
    for (const selector of canvasSelectors) {
      canvasContainer = elementUnderCursor.closest(selector);
      if (canvasContainer) {
        DebugManager.log("\u2705 Found Canvas container with selector:", selector, canvasContainer);
        break;
      }
    }
    if (!canvasContainer) {
      DebugManager.log("\u274C No Canvas container found. Element classes:", elementUnderCursor.className);
      DebugManager.log("\u274C Element parents:", this.getElementPath(elementUnderCursor));
      return null;
    }
    const canvasLeaves = this.app.workspace.getLeavesOfType("canvas");
    DebugManager.log("\u{1F4CB} Available Canvas leaves:", canvasLeaves.length);
    const leaf = canvasLeaves.find((leaf2) => {
      const containerEl = leaf2.view?.containerEl;
      if (containerEl && containerEl.contains(canvasContainer)) {
        DebugManager.log("\u2705 Found matching Canvas leaf:", leaf2);
        return true;
      }
      return false;
    });
    if (!leaf) {
      DebugManager.log("\u274C No matching Canvas leaf found");
      return null;
    }
    DebugManager.log("\u{1F389} Successfully found Canvas view:", leaf.view);
    return leaf.view;
  }
  // 获取元素路径用于调试
  getElementPath(element) {
    const path = [];
    let current = element;
    for (let i = 0; i < 5 && current; i++) {
      const tag = current.tagName.toLowerCase();
      const className = current.className ? `.${current.className.split(" ").join(".")}` : "";
      const id = current.id ? `#${current.id}` : "";
      path.push(`${tag}${id}${className}`);
      current = current.parentElement;
    }
    return path.join(" > ");
  }
  // 处理拖拽到Canvas的操作
  async handleDropToCanvas(node, e, canvasView) {
    try {
      DebugManager.log("Dropping card to Canvas:", node);
      const rawCoords = this.getCanvasCoordinates(e, canvasView);
      const canvasCoords = this.calibrateCanvasCoordinates(rawCoords, canvasView);
      const newNode = this.createCanvasNodeFromGridCard(node, canvasCoords);
      await this.addNodeToCanvas(newNode, canvasView);
      if (e.ctrlKey) {
        await this.removeNodeFromGrid(node.id);
        new import_obsidian12.Notice("\u5361\u7247\u5DF2\u79FB\u52A8\u5230Canvas");
      } else {
        new import_obsidian12.Notice("\u5361\u7247\u5DF2\u590D\u5236\u5230Canvas");
      }
    } catch (error) {
      DebugManager.error("Failed to drop card to Canvas:", error);
      new import_obsidian12.Notice("\u62D6\u62FD\u5230Canvas\u5931\u8D25");
    }
  }
  // 获取Canvas坐标 - 改进版本，支持多种坐标转换方法
  getCanvasCoordinates(e, canvasView) {
    DebugManager.log("\u{1F3AF} Converting mouse coordinates to Canvas coordinates...");
    DebugManager.log("Mouse position:", { x: e.clientX, y: e.clientY });
    const containerSelectors = [
      ".canvas-wrapper",
      ".canvas-container",
      ".canvas-viewport",
      ".view-content"
    ];
    let canvasContainer = null;
    for (const selector of containerSelectors) {
      canvasContainer = canvasView.containerEl.querySelector(selector);
      if (canvasContainer) {
        DebugManager.log("\u2705 Found Canvas container with selector:", selector);
        break;
      }
    }
    if (!canvasContainer) {
      DebugManager.log("\u274C No Canvas container found, using containerEl directly");
      canvasContainer = canvasView.containerEl;
    }
    const rect = canvasContainer.getBoundingClientRect();
    DebugManager.log("Canvas container rect:", {
      left: rect.left,
      top: rect.top,
      width: rect.width,
      height: rect.height
    });
    const relativeX = e.clientX - rect.left;
    const relativeY = e.clientY - rect.top;
    DebugManager.log("Relative coordinates:", { x: relativeX, y: relativeY });
    const canvas = canvasView.canvas;
    DebugManager.log("Canvas transform info:", {
      tx: canvas?.tx,
      ty: canvas?.ty,
      tZoom: canvas?.tZoom
    });
    if (canvas && canvas.tx !== void 0 && canvas.ty !== void 0 && canvas.tZoom !== void 0) {
      const canvasX = (relativeX - canvas.tx) / canvas.tZoom;
      const canvasY = (relativeY - canvas.ty) / canvas.tZoom;
      DebugManager.log("\u2705 Canvas coordinates calculated:", { x: canvasX, y: canvasY });
      const adjustedX = canvasX - 10;
      const adjustedY = canvasY - 10;
      DebugManager.log("\u{1F527} Adjusted coordinates:", { x: adjustedX, y: adjustedY });
      return { x: adjustedX, y: adjustedY };
    }
    DebugManager.log("\u26A0\uFE0F No transform info, trying alternative method...");
    const canvasElement = canvasContainer.querySelector("canvas");
    if (canvasElement) {
      const canvasRect = canvasElement.getBoundingClientRect();
      const canvasRelativeX = e.clientX - canvasRect.left;
      const canvasRelativeY = e.clientY - canvasRect.top;
      DebugManager.log("Canvas element coordinates:", { x: canvasRelativeX, y: canvasRelativeY });
      return { x: canvasRelativeX, y: canvasRelativeY };
    }
    DebugManager.log("\u{1F4CD} Using relative coordinates as final fallback:", { x: relativeX, y: relativeY });
    return { x: relativeX, y: relativeY };
  }
  // 坐标校准方法 - 根据Canvas状态进行精确校准
  calibrateCanvasCoordinates(coords, canvasView) {
    const canvas = canvasView.canvas;
    let offsetX = 0;
    let offsetY = 0;
    if (canvas?.tZoom) {
      if (canvas.tZoom < 0.5) {
        offsetX = -20;
        offsetY = -20;
      } else if (canvas.tZoom > 1.5) {
        offsetX = -5;
        offsetY = -5;
      } else {
        offsetX = -10;
        offsetY = -10;
      }
    }
    const toolbarElement = canvasView.containerEl.querySelector(".canvas-controls");
    const toolbarHeight = toolbarElement ? toolbarElement.offsetHeight : 0;
    const sidebarWidth = 0;
    const calibratedX = coords.x + offsetX - sidebarWidth;
    const calibratedY = coords.y + offsetY - toolbarHeight;
    DebugManager.log("\u{1F3AF} Coordinate calibration:", {
      original: coords,
      offset: { x: offsetX, y: offsetY },
      toolbar: toolbarHeight,
      calibrated: { x: calibratedX, y: calibratedY }
    });
    return { x: calibratedX, y: calibratedY };
  }
  // 从网格卡片创建Canvas节点
  createCanvasNodeFromGridCard(gridNode, coords) {
    const timestamp = Date.now();
    return {
      ...gridNode,
      id: `node-${timestamp}-from-grid`,
      x: coords.x,
      y: coords.y,
      // 保持原有的宽高，或使用默认值
      width: gridNode.width || 250,
      height: gridNode.height || 100
    };
  }
  // 添加节点到Canvas
  async addNodeToCanvas(node, canvasView) {
    if (!canvasView.canvas || !canvasView.file) {
      throw new Error("Canvas view not available");
    }
    const content = await this.app.vault.read(canvasView.file);
    const canvasData = JSON.parse(content);
    canvasData.nodes.push(node);
    await this.app.vault.modify(canvasView.file, JSON.stringify(canvasData, null, 2));
    if (canvasView.canvas.requestSave) {
      canvasView.canvas.requestSave();
    }
  }
  // 从网格中移除节点
  async removeNodeFromGrid(nodeId) {
    if (!this.canvasData || !this.linkedCanvasFile)
      return;
    DebugManager.log(`\u{1F5D1}\uFE0F Removing node from grid: ${nodeId}`);
    this.canvasData.nodes = this.canvasData.nodes.filter((node) => node.id !== nodeId);
    await this.saveCanvasData();
    if (this.currentGroupView) {
      this.analyzeGroups();
      const groupInfo = this.groupAnalysis.get(this.currentGroupView);
      if (!groupInfo || groupInfo.members.length === 0) {
        DebugManager.log("\u{1F4E4} Group is empty, returning to main view");
        this.exitGroupView();
        new import_obsidian12.Notice("\u5206\u7EC4\u5DF2\u7A7A\uFF0C\u5DF2\u8FD4\u56DE\u4E3B\u89C6\u56FE");
        return;
      } else {
        this.filteredNodes = groupInfo.members;
        DebugManager.log(`\u{1F4CA} Group view updated, ${groupInfo.members.length} members remaining`);
      }
    }
    this.renderGrid().catch((error) => {
      DebugManager.error("Failed to render grid after removing node:", error);
    });
    DebugManager.log("\u2705 Node removed and view refreshed");
  }
  // 设置编辑器拖拽源
  setupEditorDragSource() {
    this.registerDomEvent(document, "dragstart", (e) => {
      const target = e.target;
      if (!target || !(target instanceof HTMLElement)) {
        DebugManager.log("\u274C Invalid drag target");
        return;
      }
      DebugManager.log("\u{1F3AF} Global dragstart event detected, target:", target.tagName, target.className);
      if (this.isInEditor(target)) {
        DebugManager.log("\u2705 Drag detected in editor");
        const selectedText = this.getSelectedText();
        DebugManager.log("\u{1F4DD} Selected text:", selectedText?.substring(0, SEARCH_CONSTANTS.MAX_PREVIEW_LENGTH) + "...");
        if (selectedText && selectedText.trim()) {
          DebugManager.log("\u{1F680} Calling handleEditorDragStart");
          this.handleEditorDragStart(e, selectedText);
        } else {
          DebugManager.log("\u274C No selected text found");
        }
      } else {
        DebugManager.log("\u274C Drag not in editor, target closest cm-editor:", target.closest?.(".cm-editor"));
      }
    });
    this.registerDomEvent(document, "dragend", (e) => {
      DebugManager.log("\u{1F3C1} Global dragend event detected");
      DebugManager.log("\u{1F4CA} Current state - isDragging:", this.isDragging, "dragData exists:", !!this.dragData);
      setTimeout(() => {
        DebugManager.log("\u23F0 Delayed dragend cleanup executing...");
        DebugManager.log("\u{1F4CA} Pre-cleanup state - isDragging:", this.isDragging, "dragData exists:", !!this.dragData);
        if (!this.isSaveOperationInProgress) {
          this.resetDragState();
        } else {
          DebugManager.log("\u26A0\uFE0F Save operation in progress, delaying drag state reset");
          setTimeout(() => {
            this.resetDragState();
          }, 200);
        }
      }, 500);
    });
  }
  // 检查是否在编辑器中
  isInEditor(element) {
    if (!element || typeof element.closest !== "function") {
      return false;
    }
    try {
      return element.closest(".cm-editor") !== null || element.closest(".markdown-source-view") !== null || element.closest(".markdown-preview-view") !== null;
    } catch (error) {
      DebugManager.error("Error checking if element is in editor:", error);
      return false;
    }
  }
  // 获取选中文本（使用Obsidian API）
  getSelectedText() {
    try {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian12.MarkdownView);
      if (!activeView)
        return null;
      const editor = activeView.editor;
      const selection = editor.getSelection();
      return selection.trim() || null;
    } catch (error) {
      DebugManager.error("Failed to get selected text:", error);
      return null;
    }
  }
  // 获取源文件信息（用于创建回链）
  getSourceFileInfo() {
    try {
      DebugManager.log("\u{1F4CD} === getSourceFileInfo DEBUG START ===");
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian12.MarkdownView);
      if (!activeView) {
        DebugManager.log("\u274C No active MarkdownView found");
        return { file: null, path: "", position: null, context: "" };
      }
      const file = activeView.file;
      const editor = activeView.editor;
      if (!file || !editor) {
        DebugManager.log("\u274C No file or editor found");
        return { file: null, path: "", position: null, context: "" };
      }
      DebugManager.log("\u{1F4C1} Active file:", file.path);
      const selections = editor.listSelections();
      const cursor = editor.getCursor();
      const selectedText = editor.getSelection();
      DebugManager.log("\u{1F4DD} Selected text:", `"${selectedText}"`);
      DebugManager.log("\u{1F4CF} Selected text length:", selectedText.length);
      DebugManager.log("\u{1F522} Number of selections:", selections.length);
      DebugManager.log("\u{1F4CD} Cursor position:", cursor);
      selections.forEach((selection, index) => {
        DebugManager.log(`\u{1F4CB} Selection ${index}:`, {
          anchor: selection.anchor,
          head: selection.head,
          // EditorSelection 没有 from/to 方法，使用 anchor/head 代替
          from: selection.anchor,
          to: selection.head
        });
      });
      let position = {
        line: cursor.line,
        ch: cursor.ch,
        endLine: cursor.line,
        endCh: cursor.ch,
        selection: selections.length > 0 ? selections[0] : null
      };
      if (selections.length > 0 && selections[0]) {
        const selection = selections[0];
        DebugManager.log("\u{1F3AF} Processing selection:", selection);
        let startPos, endPos;
        if (selection.anchor.line < selection.head.line || selection.anchor.line === selection.head.line && selection.anchor.ch < selection.head.ch) {
          startPos = selection.anchor;
          endPos = selection.head;
        } else {
          startPos = selection.head;
          endPos = selection.anchor;
        }
        position.line = startPos.line;
        position.ch = startPos.ch;
        position.endLine = endPos.line;
        position.endCh = endPos.ch;
        DebugManager.log("\u{1F4CD} Selection range:", {
          start: { line: position.line, ch: position.ch },
          end: { line: position.endLine, ch: position.endCh }
        });
      } else {
        DebugManager.log("\u{1F4CD} Using cursor position (no selection):", { line: position.line, ch: position.ch });
      }
      const currentLine = editor.getLine(position.line);
      DebugManager.log("\u{1F4C4} Current line content:", `"${currentLine}"`);
      DebugManager.log("\u{1F4CF} Current line length:", currentLine.length);
      if (position.ch > currentLine.length) {
        DebugManager.warn("\u26A0\uFE0F Character position exceeds line length, adjusting...");
        position.ch = Math.min(position.ch, currentLine.length);
      }
      const result = {
        file,
        path: file.path,
        position,
        context: currentLine
      };
      DebugManager.log("\u2705 Source file info result:", result);
      DebugManager.log("\u{1F4CD} === getSourceFileInfo DEBUG END ===");
      return result;
    } catch (error) {
      DebugManager.error("Failed to get source file info:", error);
      return { file: null, path: "", position: null, context: "" };
    }
  }
  // 处理编辑器拖拽开始
  async handleEditorDragStart(e, selectedText) {
    if (!e.dataTransfer)
      return;
    DebugManager.log("\u{1F680} Drag started from editor:", selectedText.substring(0, SEARCH_CONSTANTS.MAX_PREVIEW_LENGTH) + "...");
    const sourceInfo = this.getSourceFileInfo();
    DebugManager.log("\u{1F4CD} Source file info:", sourceInfo);
    e.dataTransfer.setData("text/plain", selectedText);
    e.dataTransfer.setData("application/obsidian-text", selectedText);
    e.dataTransfer.effectAllowed = "copy";
    this.isDragging = true;
    this.dragData = {
      text: selectedText,
      source: "editor",
      timestamp: Date.now(),
      sourceFile: sourceInfo.file,
      sourcePath: sourceInfo.path,
      sourcePosition: sourceInfo.position,
      sourceContext: sourceInfo.context
    };
    DebugManager.log("\u{1F4BE} Drag data info:", {
      hasSourceFile: !!this.dragData.sourceFile,
      sourcePath: this.dragData.sourcePath,
      sourcePosition: this.dragData.sourcePosition,
      textLength: this.dragData.text.length
    });
    this.setDragPreview(e, selectedText);
  }
  // 设置拖拽预览
  setDragPreview(e, text) {
    try {
      const preview = document.createElement("div");
      preview.style.cssText = `
				position: absolute;
				top: -1000px;
				left: -1000px;
				background: var(--background-primary);
				border: 1px solid var(--background-modifier-border);
				border-radius: 6px;
				padding: 8px 12px;
				font-size: 12px;
				color: var(--text-normal);
				max-width: 200px;
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
				box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
			`;
      preview.textContent = text.length > 50 ? text.substring(0, SEARCH_CONSTANTS.MAX_PREVIEW_LENGTH) + "..." : text;
      document.body.appendChild(preview);
      if (e.dataTransfer) {
        e.dataTransfer.setDragImage(preview, 10, 10);
      }
      this.safeSetTimeout(() => {
        if (document.body.contains(preview)) {
          document.body.removeChild(preview);
        }
      }, 0);
    } catch (error) {
      DebugManager.error("Failed to set drag preview:", error);
    }
  }
  // 设置网格视图拖拽目标
  setupGridDropTarget() {
    if (!this.gridContainer)
      return;
    DebugManager.log("Setting up grid drop target...");
    this.registerDomEvent(this.gridContainer, "dragover", (e) => {
      if (this.isDragFromGrid) {
        this.handleGridInternalDragOver(e);
        return;
      }
      const hasTextData = e.dataTransfer?.types.includes("text/plain") || e.dataTransfer?.types.includes("application/obsidian-text");
      if (this.isDragging && this.dragData || hasTextData) {
        e.preventDefault();
        e.dataTransfer.dropEffect = "copy";
        this.showDropIndicator(e);
        DebugManager.log("External drag detected over grid");
      }
    });
    this.registerDomEvent(this.gridContainer, "dragenter", (e) => {
      e.preventDefault();
      const hasTextData = e.dataTransfer?.types.includes("text/plain") || e.dataTransfer?.types.includes("application/obsidian-text");
      if (!this.isDragFromGrid && (this.isDragging && this.dragData || hasTextData)) {
        this.gridContainer.classList.add("drag-over");
        DebugManager.log("External drag entered grid container");
      }
    });
    this.registerDomEvent(this.gridContainer, "dragleave", (e) => {
      if (!this.gridContainer.contains(e.relatedTarget)) {
        this.gridContainer.classList.remove("drag-over");
        this.hideDropIndicator();
        DebugManager.log("Drag left grid container");
      }
    });
    this.registerDomEvent(this.gridContainer, "drop", (e) => {
      e.preventDefault();
      this.gridContainer.classList.remove("drag-over");
      this.hideDropIndicator();
      if (this.isDragFromGrid) {
        DebugManager.log("Processing internal grid card movement");
        this.handleGridInternalDrop(e);
      } else {
        const hasTextData = e.dataTransfer?.types.includes("text/plain") || e.dataTransfer?.types.includes("application/obsidian-text");
        if (this.isDragging && this.dragData || hasTextData) {
          DebugManager.log("Processing external drop in grid container");
          this.handleGridDrop(e);
        } else {
          DebugManager.log("No valid drag data found");
        }
      }
    });
  }
  // 处理网格内拖拽悬停
  handleGridInternalDragOver(e) {
    e.preventDefault();
    const targetElement = e.target;
    const groupCard = targetElement.closest('.canvas-grid-card[data-node-type="group"]');
    if (groupCard && this.currentDragCard && groupCard !== this.currentDragCard) {
      e.dataTransfer.dropEffect = e.ctrlKey ? "copy" : "move";
      groupCard.classList.add("drop-target-group");
      this.clearGroupDropHighlights(groupCard);
    } else {
      this.clearGroupDropHighlights();
      e.dataTransfer.dropEffect = "none";
    }
  }
  // 清除分组放置高亮（保持向后兼容）
  clearGroupDropHighlights(except) {
    const groupCards = this.gridContainer.querySelectorAll('.canvas-grid-card[data-node-type="group"]');
    groupCards.forEach((card) => {
      if (card !== except) {
        card.classList.remove("drop-target-group", "drop-target-active");
      }
    });
  }
  // 处理网格内拖拽放置
  async handleGridInternalDrop(e) {
    this.clearGroupDropHighlights();
    if (!this.currentDragCard) {
      DebugManager.log("No current drag card found");
      return;
    }
    const targetElement = e.target;
    const targetGroupCard = targetElement.closest('.canvas-grid-card[data-node-type="group"]');
    if (targetGroupCard && targetGroupCard !== this.currentDragCard) {
      const sourceNodeId = this.currentDragCard.dataset.nodeId;
      const targetGroupId = targetGroupCard.dataset.nodeId;
      if (sourceNodeId && targetGroupId) {
        const sourceNode = this.canvasData?.nodes.find((n) => n.id === sourceNodeId);
        const targetGroup = this.canvasData?.nodes.find((n) => n.id === targetGroupId);
        if (sourceNode && targetGroup) {
          const isCtrlDrag = e.ctrlKey;
          await this.showMoveToGroupConfirmation(sourceNode, targetGroup, isCtrlDrag);
        }
      }
    } else {
      DebugManager.log("Card dropped outside of groups - reordering not implemented yet");
    }
  }
  // 显示移动到分组的确认弹窗
  async showMoveToGroupConfirmation(sourceNode, targetGroup, isCtrlDrag) {
    return new Promise((resolve) => {
      const modal = new import_obsidian12.Modal(this.app);
      modal.titleEl.textContent = isCtrlDrag ? "\u786E\u8BA4\u590D\u5236\u5361\u7247" : "\u786E\u8BA4\u79FB\u52A8\u5361\u7247";
      const content = modal.contentEl;
      content.empty();
      const sourceInfo = content.createDiv("move-confirmation-source");
      sourceInfo.createEl("h4", { text: "\u6E90\u5361\u7247:" });
      const sourcePreview = sourceInfo.createDiv("card-preview");
      sourcePreview.textContent = this.getNodeDisplayText(sourceNode);
      sourcePreview.className = "card-preview source";
      const arrow = content.createDiv("move-confirmation-arrow");
      arrow.textContent = isCtrlDrag ? "\u{1F4CB} \u590D\u5236\u5230" : "\u27A1\uFE0F \u79FB\u52A8\u5230";
      arrow.className = "move-arrow";
      const targetInfo = content.createDiv("move-confirmation-target");
      targetInfo.createEl("h4", { text: "\u76EE\u6807\u5206\u7EC4:" });
      const targetPreview = targetInfo.createDiv("card-preview");
      targetPreview.textContent = this.getNodeDisplayText(targetGroup);
      targetPreview.className = "card-preview target";
      const description = content.createDiv("move-confirmation-description");
      if (isCtrlDrag) {
        description.textContent = "\u5C06\u590D\u5236\u6B64\u5361\u7247\u7684\u5185\u5BB9\u5230\u76EE\u6807\u5206\u7EC4\u4E2D\uFF0C\u539F\u5361\u7247\u4FDD\u6301\u4E0D\u53D8\u3002";
      } else {
        description.textContent = "\u5C06\u79FB\u52A8\u6B64\u5361\u7247\u5230\u76EE\u6807\u5206\u7EC4\u4E2D\uFF0C\u539F\u4F4D\u7F6E\u7684\u5361\u7247\u5C06\u88AB\u5220\u9664\u3002";
      }
      description.className = "move-description";
      const buttonContainer = content.createDiv("move-confirmation-buttons");
      const confirmBtn = buttonContainer.createEl("button", {
        text: isCtrlDrag ? "\u786E\u8BA4\u590D\u5236" : "\u786E\u8BA4\u79FB\u52A8",
        cls: "mod-cta"
      });
      confirmBtn.addEventListener("click", async () => {
        modal.close();
        await this.executeMoveToGroup(sourceNode, targetGroup, isCtrlDrag);
        resolve();
      });
      const cancelBtn = buttonContainer.createEl("button", { text: "\u53D6\u6D88" });
      cancelBtn.addEventListener("click", () => {
        modal.close();
        resolve();
      });
      modal.open();
    });
  }
  // 获取节点显示文本
  getNodeDisplayText(node) {
    switch (node.type) {
      case "text":
        return node.text ? node.text.length > 50 ? node.text.substring(0, SEARCH_CONSTANTS.MAX_PREVIEW_LENGTH) + "..." : node.text : "\u7A7A\u6587\u672C";
      case "file":
        return node.file ? node.file.split("/").pop() || node.file : "\u672A\u77E5\u6587\u4EF6";
      case "link":
        return node.url ? new URL(node.url).hostname : "\u672A\u77E5\u94FE\u63A5";
      case "group":
        return node.text || "\u672A\u547D\u540D\u5206\u7EC4";
      default:
        return `${node.type} \u8282\u70B9`;
    }
  }
  // 执行移动到分组的操作
  async executeMoveToGroup(sourceNode, targetGroup, isCopy) {
    try {
      if (isCopy) {
        await this.copyNodeToGroup(sourceNode, targetGroup);
        new import_obsidian12.Notice(`\u5361\u7247\u5DF2\u590D\u5236\u5230\u5206\u7EC4"${this.getNodeDisplayText(targetGroup)}"`);
      } else {
        await this.moveNodeToGroup(sourceNode, targetGroup);
        new import_obsidian12.Notice(`\u5361\u7247\u5DF2\u79FB\u52A8\u5230\u5206\u7EC4"${this.getNodeDisplayText(targetGroup)}"`);
      }
      this.renderGrid();
    } catch (error) {
      DebugManager.error("Failed to execute move/copy operation:", error);
      new import_obsidian12.Notice("\u64CD\u4F5C\u5931\u8D25\uFF0C\u8BF7\u91CD\u8BD5");
    }
  }
  // 复制节点到分组
  async copyNodeToGroup(sourceNode, targetGroup) {
    if (!this.canvasData) {
      throw new Error("Canvas data not available");
    }
    const newNode = {
      ...sourceNode,
      id: this.generateUniqueId(),
      // 生成新的ID
      // 可以在这里调整位置，放在分组附近
      x: targetGroup.x + 50,
      y: targetGroup.y + 50
    };
    this.canvasData.nodes.push(newNode);
    await this.saveCanvasData();
  }
  // 移动节点到分组
  async moveNodeToGroup(sourceNode, targetGroup) {
    if (!this.canvasData) {
      throw new Error("Canvas data not available");
    }
    const sourceIndex = this.canvasData.nodes.findIndex((n) => n.id === sourceNode.id);
    if (sourceIndex === -1) {
      throw new Error("Source node not found");
    }
    this.canvasData.nodes[sourceIndex] = {
      ...sourceNode,
      x: targetGroup.x + 50,
      y: targetGroup.y + 50
    };
    await this.saveCanvasData();
  }
  // 生成唯一ID
  generateUniqueId() {
    return "node-" + Date.now() + "-" + Math.random().toString(36).substring(2, 11);
  }
  // 显示拖拽指示器（优化版本）
  showDropIndicator(e) {
    const targetGroupElement = this.findGroupElementUnderCursor(e);
    if (targetGroupElement) {
      this.highlightGroupAsDropTarget(targetGroupElement);
      this.hideGenericDropIndicator();
      return;
    }
    this.clearAllGroupHighlights();
    this.showGenericDropIndicator(e);
  }
  // 🔧 新增：查找鼠标下的分组元素
  findGroupElementUnderCursor(e) {
    const elementUnderCursor = document.elementFromPoint(e.clientX, e.clientY);
    if (elementUnderCursor) {
      return elementUnderCursor.closest('.canvas-grid-card[data-node-type="group"]');
    }
    return null;
  }
  // 🔧 新增：高亮分组作为放置目标
  highlightGroupAsDropTarget(groupElement) {
    this.clearAllGroupHighlights();
    groupElement.classList.add("drop-target-group", "drop-target-active");
    DebugManager.log("\u{1F3AF} Group highlighted as drop target:", groupElement.dataset.nodeId);
  }
  // 🔧 新增：清除所有分组高亮
  clearAllGroupHighlights() {
    const groupCards = this.gridContainer.querySelectorAll('.canvas-grid-card[data-node-type="group"]');
    groupCards.forEach((card) => {
      card.classList.remove("drop-target-group", "drop-target-active");
    });
  }
  // 🔧 新增：显示通用拖拽指示器
  showGenericDropIndicator(e) {
    if (!this.dropIndicator) {
      this.dropIndicator = document.createElement("div");
      this.dropIndicator.className = "drop-indicator generic-drop-indicator";
      this.gridContainer.appendChild(this.dropIndicator);
    }
    const rect = this.gridContainer.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const cols = Math.floor(this.gridContainer.clientWidth / (CARD_CONSTANTS.width + CARD_CONSTANTS.spacing));
    const col = Math.floor(x / (CARD_CONSTANTS.width + CARD_CONSTANTS.spacing));
    const row = Math.floor(y / (CARD_CONSTANTS.height + CARD_CONSTANTS.spacing));
    this.dropIndicator.style.left = `${col * (CARD_CONSTANTS.width + CARD_CONSTANTS.spacing)}px`;
    this.dropIndicator.style.top = `${row * (CARD_CONSTANTS.height + CARD_CONSTANTS.spacing)}px`;
    this.dropIndicator.style.width = `${CARD_CONSTANTS.width}px`;
    this.dropIndicator.style.height = `${CARD_CONSTANTS.height}px`;
    this.dropIndicator.style.display = "block";
  }
  // 🔧 新增：隐藏通用拖拽指示器
  hideGenericDropIndicator() {
    if (this.dropIndicator) {
      this.dropIndicator.style.display = "none";
    }
  }
  // 隐藏拖拽指示器（优化版本）
  hideDropIndicator() {
    this.hideGenericDropIndicator();
    this.clearAllGroupHighlights();
    DebugManager.log("\u{1F504} All drop indicators hidden");
  }
  // 重置拖拽状态
  resetDragState() {
    DebugManager.log("\u{1F9F9} === Resetting drag state ===");
    DebugManager.log("\u{1F4CA} Before reset - isDragging:", this.isDragging, "dragData exists:", !!this.dragData);
    this.isDragging = false;
    this.dragData = null;
    this.gridContainer?.classList.remove("drag-over");
    this.hideDropIndicator();
    DebugManager.log("\u2705 Drag state reset complete");
  }
  // 🔧 新增：提取拖拽数据的统一方法
  extractDroppedData(e) {
    const dataTransfer = e.dataTransfer;
    if (!dataTransfer)
      return null;
    const obsidianText = dataTransfer.getData("application/obsidian-text");
    if (obsidianText && obsidianText.trim()) {
      return {
        type: "text",
        content: obsidianText.trim(),
        sourceFile: this.dragData?.sourceFile,
        sourcePath: this.dragData?.sourcePath,
        sourcePosition: this.dragData?.sourcePosition,
        metadata: {
          sourceUrl: this.dragData?.metadata?.sourceUrl
        }
      };
    }
    const html = dataTransfer.getData("text/html");
    if (html) {
      const urlMatch = html.match(/href=["']([^"']+)["']/);
      if (urlMatch) {
        const tempDiv = document.createElement("div");
        tempDiv.innerHTML = html;
        const textContent = tempDiv.textContent || tempDiv.innerText || "";
        return {
          type: "link",
          content: textContent.trim(),
          sourceUrl: urlMatch[1],
          originalHTML: html
        };
      }
    }
    const url = dataTransfer.getData("text/uri-list");
    if (url && url.trim()) {
      return {
        type: "link",
        content: url.trim(),
        sourceUrl: url.trim()
      };
    }
    const text = dataTransfer.getData("text/plain");
    if (text && text.trim()) {
      try {
        new URL(text.trim());
        return {
          type: "link",
          content: text.trim(),
          sourceUrl: text.trim()
        };
      } catch {
        return {
          type: "text",
          content: text.trim()
        };
      }
    }
    return null;
  }
  // 处理网格拖拽放下
  async handleGridDrop(e) {
    try {
      DebugManager.log("\u{1F3AF} handleGridDrop called, currentGroupView:", this.currentGroupView);
      DebugManager.log("\u{1F3AF} isDragging:", this.isDragging);
      DebugManager.log("\u{1F3AF} dragData exists:", !!this.dragData);
      this.gridContainer.classList.remove("drag-over");
      this.hideDropIndicator();
      const droppedData = this.extractDroppedData(e);
      if (!droppedData) {
        DebugManager.warn("\u274C No valid drop data detected");
        new import_obsidian12.Notice("\u6CA1\u6709\u68C0\u6D4B\u5230\u6709\u6548\u7684\u62D6\u62FD\u5185\u5BB9");
        return;
      }
      DebugManager.log("\u{1F4DD} Dropped data:", {
        type: droppedData.type,
        contentLength: droppedData.content?.length,
        hasSourceInfo: !!(droppedData.sourceFile || droppedData.sourceUrl),
        preview: droppedData.content?.substring(0, SEARCH_CONSTANTS.MAX_PREVIEW_LENGTH) + "..."
      });
      const dragDataInfo = this.dragData || droppedData;
      if (dragDataInfo) {
        DebugManager.log("\u2705 Drag data available:", {
          hasSourceFile: !!(dragDataInfo.sourceFile || dragDataInfo.sourcePath),
          sourcePath: dragDataInfo.sourcePath,
          sourcePosition: dragDataInfo.sourcePosition,
          sourceUrl: dragDataInfo.sourceUrl
        });
      } else {
        DebugManager.warn("\u26A0\uFE0F No drag data available - backlink will not be created");
      }
      if (!this.linkedCanvasFile) {
        new import_obsidian12.Notice("\u8BF7\u5148\u5173\u8054\u4E00\u4E2ACanvas\u6587\u4EF6");
        this.showCanvasSelectionDialog();
        return;
      }
      DebugManager.log("Processing drop with linked canvas:", this.linkedCanvasFile.path);
      if (this.currentGroupView) {
        new import_obsidian12.Notice("\u64CD\u4F5C\u5B8C\u6210", NOTIFICATION_CONSTANTS.SHORT_DURATION);
      } else {
        new import_obsidian12.Notice("\u64CD\u4F5C\u5B8C\u6210", NOTIFICATION_CONSTANTS.SHORT_DURATION);
      }
      let newNode = null;
      await this.saveWithLock(async () => {
        this.startSaveOperation();
        newNode = await this.createNodeFromDroppedData(droppedData, e);
        if (newNode) {
          await this.saveCanvasDataToLinkedFile();
          DebugManager.log("\u2705 \u65B0\u8282\u70B9\u5DF2\u521B\u5EFA\u5E76\u4FDD\u5B58:", newNode.id);
        }
        this.endSaveOperation();
      });
      if (newNode) {
        if (this.currentGroupView) {
          DebugManager.log("Refreshing group view after adding new content");
          this.analyzeGroups();
          this.enterGroupView(this.currentGroupView);
        } else {
          this.renderGrid();
        }
        this.notifyCanvasViewRefresh();
        new import_obsidian12.Notice("\u64CD\u4F5C\u5B8C\u6210", NOTIFICATION_CONSTANTS.MEDIUM_DURATION);
      }
    } catch (error) {
      DebugManager.error("\u62D6\u62FD\u521B\u5EFA\u5361\u7247\u5931\u8D25:", error);
      new import_obsidian12.Notice("\u521B\u5EFA\u5361\u7247\u5931\u8D25\uFF0C\u8BF7\u91CD\u8BD5");
      this.endSaveOperation();
      this.resetDragState();
    }
  }
  // 🔧 新增：从拖拽数据创建Canvas节点
  async createNodeFromDroppedData(droppedData, dropEvent) {
    try {
      DebugManager.log("\u{1F3AF} === createNodeFromDroppedData \u5F00\u59CB ===");
      DebugManager.log("\u{1F4DD} \u62D6\u62FD\u6570\u636E:", {
        type: droppedData.type,
        contentLength: droppedData.content?.length,
        hasSourceUrl: !!droppedData.sourceUrl
      });
      if (droppedData.type === "link") {
        return await this.createLinkNodeFromDroppedData(droppedData, dropEvent);
      } else {
        return await this.createTextNodeFromDroppedData(droppedData, dropEvent);
      }
    } catch (error) {
      DebugManager.error("\u274C createNodeFromDroppedData \u5931\u8D25:", error);
      new import_obsidian12.Notice("\u521B\u5EFA\u5361\u7247\u5931\u8D25");
      return null;
    }
  }
  // 🔧 新增：从拖拽数据创建文本节点
  async createTextNodeFromDroppedData(droppedData, dropEvent) {
    const text = droppedData.content;
    if (!text || !text.trim()) {
      return null;
    }
    let finalText = text.trim();
    if (droppedData.sourceFile || droppedData.sourcePath) {
      const originalDragData = this.dragData;
      this.dragData = droppedData;
      finalText = await this.addBacklinkToText(finalText);
      this.dragData = originalDragData;
    } else if (droppedData.sourceUrl && droppedData.sourceUrl !== text.trim()) {
      finalText += `

\u{1F4CD} \u6765\u6E90: ${droppedData.sourceUrl}`;
    }
    return await this.createNodeFromText(finalText, dropEvent);
  }
  // 🔧 新增：从拖拽数据创建链接节点
  async createLinkNodeFromDroppedData(droppedData, dropEvent) {
    const url = droppedData.sourceUrl || droppedData.content;
    if (!url || !url.trim()) {
      return null;
    }
    const position = this.calculateDropPosition(dropEvent);
    const nodeId = this.generateUniqueId();
    const linkNode = {
      id: nodeId,
      type: "link",
      url: url.trim(),
      x: position.x,
      y: position.y,
      width: 400,
      height: 200
    };
    if (this.canvasData) {
      this.canvasData.nodes.push(linkNode);
    }
    return linkNode;
  }
  // 从文本创建Canvas节点
  async createNodeFromText(text, dropEvent) {
    try {
      DebugManager.log("\u{1F3AF} === createNodeFromText \u5F00\u59CB ===");
      DebugManager.log("\u{1F4DD} \u6587\u672C\u5185\u5BB9:", text.substring(0, 100) + "...");
      DebugManager.log("\u{1F4C1} \u62D6\u62FD\u6570\u636E\u5B58\u5728:", !!this.dragData);
      DebugManager.log("\u{1F4C4} \u6E90\u6587\u4EF6\u5B58\u5728:", !!this.dragData?.sourceFile);
      DebugManager.log("\u{1F4CD} \u6E90\u4F4D\u7F6E\u5B58\u5728:", !!this.dragData?.sourcePosition);
      const contentType = await this.analyzeTextContent(text);
      const dropTarget = this.analyzeDropTarget(dropEvent);
      let newNode;
      if (dropTarget.type === "existing-group") {
        newNode = await this.addToExistingGroup(dropTarget.groupId, contentType, dropTarget.position);
        DebugManager.log("Added to existing group:", dropTarget.groupId);
      } else {
        const { groupNode, contentNode } = this.createGroupedNodes(text, contentType, dropTarget.position);
        if (!this.canvasData) {
          this.canvasData = { nodes: [], edges: [] };
        }
        this.canvasData.nodes.push(groupNode);
        this.canvasData.nodes.push(contentNode);
        newNode = contentNode;
        DebugManager.log("Created new group with content");
      }
      await this.saveCanvasData();
      return newNode;
    } catch (error) {
      DebugManager.error("\u521B\u5EFA\u8282\u70B9\u5931\u8D25:", error);
      return null;
    }
  }
  // 分析文本内容类型（异步版本）
  async analyzeTextContent(text) {
    const trimmedText = text.trim();
    if (this.isURL(trimmedText)) {
      return {
        type: "link",
        content: { url: trimmedText },
        width: GRID_CONSTANTS.CARD_WIDTH,
        height: 100
      };
    }
    if (this.isFileLink(trimmedText)) {
      return {
        type: "file",
        content: { file: trimmedText },
        width: GRID_CONSTANTS.CARD_WIDTH,
        height: GRID_CONSTANTS.CARD_HEIGHT
      };
    }
    const textWithBacklink = await this.addBacklinkToText(trimmedText);
    const lines = textWithBacklink.split("\n").length;
    const estimatedWidth = Math.min(400, Math.max(200, textWithBacklink.length * 8));
    const estimatedHeight = Math.min(300, Math.max(100, lines * 25 + 40));
    return {
      type: "text",
      content: { text: textWithBacklink },
      width: estimatedWidth,
      height: estimatedHeight
    };
  }
  // 检测是否为URL
  isURL(text) {
    if (text.includes("\n") || text.includes("\r")) {
      return false;
    }
    if (text.length > 2e3) {
      return false;
    }
    try {
      new URL(text);
      return true;
    } catch {
      return /^https?:\/\/\S+$/.test(text);
    }
  }
  // 检测是否为文件链接
  isFileLink(text) {
    return /^\[\[.*\]\]$/.test(text) || text.includes(".md") || text.includes(".pdf");
  }
  // 分析拖拽目标
  analyzeDropTarget(dropEvent) {
    if (this.currentGroupView) {
      DebugManager.log("Drop in group view:", this.currentGroupView);
      return {
        type: "existing-group",
        groupId: this.currentGroupView,
        position: this.calculatePositionInGroup(this.currentGroupView, dropEvent)
      };
    }
    const targetGroupId = this.findGroupUnderCursor(dropEvent);
    if (targetGroupId) {
      DebugManager.log("Drop on group card:", targetGroupId);
      return {
        type: "existing-group",
        groupId: targetGroupId,
        position: this.calculatePositionInGroup(targetGroupId, dropEvent)
      };
    }
    DebugManager.log("Drop in empty area, creating new group");
    return {
      type: "new-group",
      position: this.calculateDropPosition(dropEvent)
    };
  }
  // 查找鼠标下的分组
  findGroupUnderCursor(dropEvent) {
    const rect = this.gridContainer.getBoundingClientRect();
    const x = dropEvent.clientX - rect.left;
    const y = dropEvent.clientY - rect.top;
    const elementUnderCursor = document.elementFromPoint(dropEvent.clientX, dropEvent.clientY);
    if (elementUnderCursor) {
      const groupCard = elementUnderCursor.closest('[data-node-type="group"]');
      if (groupCard) {
        return groupCard.dataset.nodeId || null;
      }
    }
    return null;
  }
  // 计算在分组内的位置
  calculatePositionInGroup(groupId, dropEvent) {
    if (!this.canvasData) {
      return { x: 100, y: 100 };
    }
    const groupNode = this.canvasData.nodes.find((n) => n.id === groupId && n.type === "group");
    if (!groupNode) {
      return { x: 100, y: 100 };
    }
    const groupMembers = this.canvasData.nodes.filter(
      (n) => n.type !== "group" && n.x >= groupNode.x && n.y >= groupNode.y && n.x + n.width <= groupNode.x + groupNode.width && n.y + n.height <= groupNode.y + groupNode.height
    );
    const padding = 20;
    if (groupMembers.length === 0) {
      return {
        x: groupNode.x + padding,
        y: groupNode.y + padding + 30
        // 为分组标题留空间
      };
    }
    const maxX = Math.max(...groupMembers.map((n) => n.x + n.width));
    const maxY = Math.max(...groupMembers.map((n) => n.y + n.height));
    const newX = maxX + padding;
    if (newX + 300 <= groupNode.x + groupNode.width - padding) {
      return { x: newX, y: groupMembers[0].y };
    }
    return {
      x: groupNode.x + padding,
      y: maxY + padding
    };
  }
  // 添加到现有分组
  async addToExistingGroup(groupId, contentType, position) {
    const timestamp = Date.now();
    const contentId = `node-${timestamp}-content`;
    const contentNode = {
      id: contentId,
      type: contentType.type,
      x: position.x,
      y: position.y,
      width: contentType.width,
      height: contentType.height,
      ...contentType.content
    };
    if (!this.canvasData) {
      this.canvasData = { nodes: [], edges: [] };
    }
    this.canvasData.nodes.push(contentNode);
    this.expandGroupIfNeeded(groupId, contentNode);
    this.updateGroupAnalysisAfterAdd(groupId, contentNode);
    if (this.currentGroupView === groupId) {
      this.refreshGroupView(groupId);
    }
    return contentNode;
  }
  // 扩展分组大小以容纳新内容
  expandGroupIfNeeded(groupId, newNode) {
    if (!this.canvasData)
      return;
    const groupNode = this.canvasData.nodes.find((n) => n.id === groupId && n.type === "group");
    if (!groupNode)
      return;
    const padding = 20;
    const requiredWidth = newNode.x + newNode.width - groupNode.x + padding;
    const requiredHeight = newNode.y + newNode.height - groupNode.y + padding;
    if (requiredWidth > groupNode.width) {
      groupNode.width = requiredWidth;
    }
    if (requiredHeight > groupNode.height) {
      groupNode.height = requiredHeight;
    }
  }
  // 更新分组分析数据（添加新节点后）
  updateGroupAnalysisAfterAdd(groupId, newNode) {
    const groupInfo = this.groupAnalysis.get(groupId);
    if (groupInfo) {
      groupInfo.members.push(newNode);
      groupInfo.memberCount = groupInfo.members.length;
      this.updateGroupBounds(groupInfo);
      DebugManager.log(`Updated group ${groupId} analysis, new member count: ${groupInfo.memberCount}`);
    } else {
      DebugManager.log(`Group ${groupId} not found in analysis, re-analyzing all groups`);
      this.analyzeGroups();
    }
  }
  // 更新分组边界
  updateGroupBounds(groupInfo) {
    if (groupInfo.members.length === 0)
      return;
    const allNodes = [groupInfo.group, ...groupInfo.members];
    const minX = Math.min(...allNodes.map((n) => n.x));
    const minY = Math.min(...allNodes.map((n) => n.y));
    const maxX = Math.max(...allNodes.map((n) => n.x + n.width));
    const maxY = Math.max(...allNodes.map((n) => n.y + n.height));
    groupInfo.bounds = { minX, minY, maxX, maxY };
  }
  // 刷新分组视图
  refreshGroupView(groupId) {
    DebugManager.log(`Refreshing group view for: ${groupId}`);
    this.analyzeGroups();
    const groupInfo = this.groupAnalysis.get(groupId);
    if (!groupInfo) {
      DebugManager.error(`Group ${groupId} not found after analysis`);
      return;
    }
    this.filteredNodes = [...groupInfo.members];
    this.renderGroupMembers();
    DebugManager.log(`Group view refreshed, showing ${groupInfo.members.length} members`);
  }
  // 创建分组和内容节点
  createGroupedNodes(text, contentType, position) {
    const timestamp = Date.now();
    const groupId = `group-${timestamp}`;
    const contentId = `node-${timestamp}-content`;
    const groupPadding = 40;
    const groupWidth = contentType.width + groupPadding * 2;
    const groupHeight = contentType.height + groupPadding * 2 + 60;
    const groupNode = {
      id: groupId,
      type: "group",
      x: position.x,
      y: position.y,
      width: groupWidth,
      height: groupHeight,
      label: "\u6536\u96C6",
      // 分组标题
      color: "1"
      // 使用红色作为默认分组颜色
    };
    const contentNode = {
      id: contentId,
      type: contentType.type,
      x: position.x + groupPadding,
      y: position.y + groupPadding + 30,
      // 为分组标题留出空间
      width: contentType.width,
      height: contentType.height,
      ...contentType.content
    };
    return { groupNode, contentNode };
  }
  // 计算拖拽放置位置
  calculateDropPosition(dropEvent) {
    if (this.canvasData && this.canvasData.nodes.length > 0) {
      const maxX = Math.max(...this.canvasData.nodes.map((n) => n.x + n.width));
      const maxY = Math.max(...this.canvasData.nodes.map((n) => n.y + n.height));
      const groupSpacing = 50;
      const newX = maxX + groupSpacing;
      const newY = 100;
      const estimatedCanvasWidth = 1200;
      const groupWidth = CARD_CONSTANTS.width + 80;
      if (newX + groupWidth > estimatedCanvasWidth) {
        return {
          x: 100,
          // 从左边开始
          y: maxY + groupSpacing
        };
      }
      return { x: newX, y: newY };
    }
    return { x: 100, y: 100 };
  }
  // 生成唯一节点ID
  generateNodeId() {
    return "node-" + Date.now() + "-" + Math.random().toString(36).substr(2, 9);
  }
  // 块引用ID生成方法已移除（块双链功能已禁用）
  // 拖拽数据快照方法已移除（块双链功能已禁用）
  // 块引用插入方法已移除（块双链功能已禁用）
  // 块引用检测方法已移除（块双链功能已禁用）
  // 用户确认对话框已移除（块双链功能已禁用）
  // 增强的文本处理方法（支持块引用）
  async addBacklinkToText(originalText) {
    DebugManager.log("\u{1F517} === addBacklinkToText called ===");
    DebugManager.log("\u{1F4DD} Original text length:", originalText.length);
    DebugManager.log("\u{1F4DD} Original text preview:", originalText.substring(0, SEARCH_CONSTANTS.MAX_PREVIEW_LENGTH) + "...");
    DebugManager.log("\u{1F4BE} Drag data exists:", !!this.dragData);
    if (this.dragData && this.dragData.sourceFile) {
      const sourceFile = this.dragData.sourceFile;
      const sourceFileName = sourceFile.basename;
      const sourcePath = sourceFile.path;
      const lineNumber = this.dragData.sourcePosition?.line ? this.dragData.sourcePosition.line + 1 : 1;
      DebugManager.log("\u2705 Adding backlink info:", {
        sourceFileName,
        sourcePath,
        lineNumber,
        hasSourceFile: !!sourceFile
      });
      DebugManager.log("\u{1F4DD} Using simple backlink format");
      const backlinkInfo = `

---
\u{1F4CD} \u6765\u6E90: [[${sourceFileName}]] (\u7B2C${lineNumber}\u884C)
\u{1F517} \u8DEF\u5F84: ${sourcePath}`;
      const result = `${originalText}${backlinkInfo}`;
      DebugManager.log("\u{1F389} Simple backlink added successfully, new text length:", result.length);
      return result;
    }
    DebugManager.log("\u274C No drag data or source file, returning original text");
    DebugManager.log("\u274C Drag data details:", {
      hasDragData: !!this.dragData,
      hasSourceFile: this.dragData?.sourceFile ? true : false,
      sourcePath: this.dragData?.sourcePath || "none"
    });
    return originalText;
  }
  // 检查节点是否包含回链信息（支持块引用）
  hasBacklink(node) {
    if (node.type !== "text" || !node.text) {
      return false;
    }
    const blockReferenceFormat = /📍\s*来源:\s*\[\[([^\]]+)#\^([^\]]+)\]\]\s*\(第(\d+)行\)/.test(node.text);
    const simpleLinkFormat = /📍\s*来源:\s*\[\[([^\]]+)\]\]\s*\(第(\d+)行\)/.test(node.text);
    const oldFormat = /---\n来源：.*\s\(行\s\d+\)/.test(node.text);
    DebugManager.log("Checking backlink in node:", {
      blockReferenceFormat,
      simpleLinkFormat,
      oldFormat,
      text: node.text.substring(0, 200)
    });
    return blockReferenceFormat || simpleLinkFormat || oldFormat;
  }
  // 增强的源信息导航（支持块引用）
  async navigateToBacklink(node) {
    if (node.type !== "text" || !node.text) {
      new import_obsidian12.Notice("\u8282\u70B9\u4E0D\u5305\u542B\u6587\u672C\u5185\u5BB9");
      return;
    }
    try {
      DebugManager.log("=== Navigating to Source Info ===");
      DebugManager.log("Node text:", node.text);
      let fileName = null;
      let lineNumber = null;
      let sourcePath = null;
      let blockId = null;
      const blockReferenceMatch = node.text.match(/📍\s*来源:\s*\[\[([^#\]]+)#\^([^\]]+)\]\]\s*\(第(\d+)行\)/);
      if (blockReferenceMatch) {
        fileName = blockReferenceMatch[1];
        blockId = blockReferenceMatch[2];
        lineNumber = parseInt(blockReferenceMatch[3]) - 1;
        DebugManager.log("Found block reference:", { fileName, blockId, lineNumber: lineNumber + 1 });
      } else {
        const simpleLinkMatch = node.text.match(/📍\s*来源:\s*\[\[([^\]]+)\]\]\s*\(第(\d+)行\)/);
        if (simpleLinkMatch) {
          fileName = simpleLinkMatch[1];
          lineNumber = parseInt(simpleLinkMatch[2]) - 1;
          DebugManager.log("Found simple link:", { fileName, lineNumber: lineNumber + 1 });
        } else {
          const oldFormatMatch = node.text.match(/来源：(.*?)\s\(行\s(\d+)\)/);
          if (oldFormatMatch) {
            fileName = oldFormatMatch[1];
            lineNumber = parseInt(oldFormatMatch[2]) - 1;
            DebugManager.log("Found old format:", { fileName, lineNumber: lineNumber + 1 });
          }
        }
      }
      const pathMatch = node.text.match(/🔗\s*路径:\s*(.+)/);
      if (pathMatch) {
        sourcePath = pathMatch[1].trim();
      }
      if (!fileName || lineNumber === null) {
        new import_obsidian12.Notice("\u672A\u627E\u5230\u6709\u6548\u7684\u6E90\u4FE1\u606F");
        return;
      }
      DebugManager.log("Parsed source info:", { fileName, lineNumber: lineNumber + 1, sourcePath, blockId });
      let sourceFile = null;
      if (sourcePath) {
        sourceFile = this.app.vault.getAbstractFileByPath(sourcePath);
      }
      if (!sourceFile) {
        const files = this.app.vault.getMarkdownFiles();
        sourceFile = files.find((f) => f.basename === fileName) || null;
      }
      if (!sourceFile) {
        new import_obsidian12.Notice(`\u6E90\u6587\u4EF6\u4E0D\u5B58\u5728: ${fileName}`);
        return;
      }
      await this.openFileAndNavigate(sourceFile, lineNumber);
    } catch (error) {
      DebugManager.error("Failed to navigate to source:", error);
      new import_obsidian12.Notice("\u8DF3\u8F6C\u5230\u6E90\u6587\u4EF6\u5931\u8D25");
    }
  }
  // 打开文件并导航到指定位置
  async openFileAndNavigate(file, lineNumber) {
    try {
      DebugManager.log(`Opening file: ${file.path}, line: ${lineNumber + 1}`);
      const loadingNotice = new import_obsidian12.Notice("\u6B63\u5728\u6253\u5F00\u6E90\u6587\u4EF6...", 0);
      const leaf = this.app.workspace.getUnpinnedLeaf();
      await leaf.openFile(file);
      await new Promise((resolve) => setTimeout(resolve, 200));
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian12.MarkdownView);
      if (activeView && activeView.editor) {
        const editor = activeView.editor;
        const totalLines = editor.lineCount();
        const validLineNumber = Math.min(Math.max(0, lineNumber), totalLines - 1);
        if (validLineNumber !== lineNumber) {
          DebugManager.warn(`Line number ${lineNumber + 1} out of range, using line ${validLineNumber + 1}`);
        }
        const targetPos = { line: validLineNumber, ch: 0 };
        editor.setCursor(targetPos);
        editor.scrollIntoView({ from: targetPos, to: targetPos }, true);
        const lineText = editor.getLine(validLineNumber);
        const lineEnd = { line: validLineNumber, ch: lineText.length };
        editor.setSelection(targetPos, lineEnd);
        setTimeout(() => {
          try {
            if (editor && editor.getCursor) {
              const cursor = editor.getCursor();
              editor.setCursor(cursor);
            }
          } catch (e) {
            DebugManager.log("Selection cleared automatically");
          }
        }, 3e3);
        loadingNotice.hide();
        new import_obsidian12.Notice(`\u2705 \u5DF2\u8DF3\u8F6C\u5230\u6E90\u6587\u4EF6: ${file.basename} (\u7B2C${validLineNumber + 1}\u884C)`, 4e3);
        DebugManager.log("Successfully navigated to backlink position");
      } else {
        loadingNotice.hide();
        new import_obsidian12.Notice("\u274C \u65E0\u6CD5\u83B7\u53D6\u7F16\u8F91\u5668\u89C6\u56FE\uFF0C\u8BF7\u624B\u52A8\u6253\u5F00\u6587\u4EF6");
        DebugManager.error("No editor view available");
      }
    } catch (error) {
      DebugManager.error("Failed to open file and navigate:", error);
      const errorMessage = error instanceof Error ? error.message : "\u672A\u77E5\u9519\u8BEF";
      new import_obsidian12.Notice(`\u274C \u6253\u5F00\u6587\u4EF6\u5931\u8D25: ${errorMessage}`);
    }
  }
  // 块引用导航方法已移除（块双链功能已禁用）
  // 保存Canvas数据
  async saveCanvasData() {
    if (!this.canvasData)
      return;
    if (this.linkedCanvasFile) {
      await this.saveCanvasDataToLinkedFile();
      return;
    }
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile || activeFile.extension !== "canvas") {
      throw new Error("\u6CA1\u6709\u6D3B\u52A8\u7684Canvas\u6587\u4EF6\u6216\u5173\u8054\u6587\u4EF6");
    }
    try {
      const canvasContent = JSON.stringify(this.canvasData, null, 2);
      await this.app.vault.modify(activeFile, canvasContent);
      DebugManager.log("Canvas data saved to active file successfully");
    } catch (error) {
      DebugManager.error("Failed to save canvas data:", error);
      throw error;
    }
  }
  // 滚动到新创建的卡片
  scrollToNewCard(nodeId) {
    this.safeSetTimeout(() => {
      const cardElement = this.gridContainer?.querySelector(`[data-node-id="${nodeId}"]`);
      if (cardElement) {
        cardElement.scrollIntoView({
          behavior: "smooth",
          block: "center"
        });
        cardElement.classList.add("newly-created");
        this.safeSetTimeout(() => {
          if (cardElement.classList.contains("newly-created")) {
            cardElement.classList.remove("newly-created");
          }
        }, 2e3);
      }
    }, 100);
  }
  // ==================== 关联标签页功能实现 ====================
  // 设置关联Canvas文件
  async setLinkedCanvas(canvasFile) {
    try {
      DebugManager.log("Setting linked canvas file:", canvasFile.path);
      this.linkedCanvasFile = canvasFile;
      this.linkedTabManager.linkCanvasFile(canvasFile, this);
      this.showLoadingState();
      await this.loadCanvasDataFromOfficialView(canvasFile);
      this.initializeSearchAndSort();
      this.updateLinkedCanvasDisplay(canvasFile);
      this.updateActionButtonsVisibility();
      this.renderGrid().catch((error) => {
        DebugManager.error("Failed to render grid after linking canvas:", error);
      });
      new import_obsidian12.Notice("\u64CD\u4F5C\u5B8C\u6210", NOTIFICATION_CONSTANTS.MEDIUM_DURATION);
      DebugManager.log("Canvas file linked and data loaded:", canvasFile.path);
    } catch (error) {
      DebugManager.error("Failed to link canvas file:", error);
      new import_obsidian12.Notice("\u64CD\u4F5C\u5B8C\u6210", NOTIFICATION_CONSTANTS.MEDIUM_DURATION);
      DebugManager.log("Canvas link removed");
    }
  }
  // 获取官方Canvas视图实例
  getOfficialCanvasView(file) {
    try {
      const leaves = this.app.workspace.getLeavesOfType("canvas");
      for (const leaf of leaves) {
        const view = leaf.view;
        if (view.file?.path === file.path) {
          DebugManager.log("\u2705 Found official Canvas view for file:", file.path);
          return view;
        }
      }
      const activeLeaf = this.app.workspace.activeLeaf;
      if (activeLeaf?.view?.getViewType() === "canvas") {
        const activeView = activeLeaf.view;
        if (activeView.file?.path === file.path) {
          DebugManager.log("\u2705 Found active Canvas view for file:", file.path);
          return activeView;
        }
      }
      DebugManager.log("\u274C No official Canvas view found for file:", file.path);
      return null;
    } catch (error) {
      DebugManager.error("Error getting official Canvas view:", error);
      return null;
    }
  }
  // 从官方Canvas视图提取数据
  extractCanvasDataFromView(canvasView) {
    try {
      let canvasData = null;
      if (canvasView.canvas?.data) {
        canvasData = canvasView.canvas.data;
        DebugManager.log("\u2705 Canvas data extracted via canvas.data");
      } else if (canvasView.data) {
        canvasData = canvasView.data;
        DebugManager.log("\u2705 Canvas data extracted via data");
      } else if (canvasView.canvas?.nodes) {
        canvasData = {
          nodes: canvasView.canvas.nodes,
          edges: canvasView.canvas.edges || []
        };
        DebugManager.log("\u2705 Canvas data extracted via canvas.nodes");
      }
      if (canvasData && Array.isArray(canvasData.nodes)) {
        DebugManager.log(`\u2705 Extracted Canvas data with ${canvasData.nodes.length} nodes`);
        return canvasData;
      }
      DebugManager.log("\u274C No valid Canvas data found in view");
      return null;
    } catch (error) {
      DebugManager.error("Error extracting Canvas data from view:", error);
      return null;
    }
  }
  // 从官方Canvas视图或文件加载数据
  async loadCanvasDataFromOfficialView(file) {
    try {
      DebugManager.log("\u{1F504} Loading Canvas data from official view:", file.path);
      const canvasView = this.getOfficialCanvasView(file);
      if (canvasView) {
        const canvasData = this.extractCanvasDataFromView(canvasView);
        if (canvasData) {
          this.canvasData = canvasData;
          DebugManager.log("\u2705 Canvas data loaded from official view");
          return;
        }
      }
      DebugManager.log("\u{1F504} Falling back to file reading");
      await this.loadCanvasDataFromFile(file);
    } catch (error) {
      DebugManager.error("Failed to load Canvas data from official view:", error);
      throw error;
    }
  }
  // 从指定文件加载Canvas数据（回退方案）
  async loadCanvasDataFromFile(file) {
    if (!file) {
      throw new Error("\u6587\u4EF6\u53C2\u6570\u65E0\u6548");
    }
    const fileExists = this.app.vault.getAbstractFileByPath(file.path);
    if (!fileExists) {
      throw new Error(`\u6587\u4EF6\u4E0D\u5B58\u5728: ${file.path}`);
    }
    try {
      DebugManager.log("Loading canvas data from file:", file.path);
      const content = await this.app.vault.read(file);
      if (!content || content.trim() === "") {
        DebugManager.log("Canvas file is empty, creating empty data structure");
        this.canvasData = { nodes: [], edges: [] };
        this.clearDataCache();
        this.renderGrid();
        return;
      }
      let parsedData;
      try {
        parsedData = JSON.parse(content);
      } catch (parseError) {
        throw new Error(`JSON\u683C\u5F0F\u65E0\u6548: ${parseError instanceof Error ? parseError.message : "\u89E3\u6790\u9519\u8BEF"}`);
      }
      const validation = this.dataValidator.validateCanvasData(parsedData);
      if (!validation.isValid) {
        const errorMessage = `Canvas\u6570\u636E\u9A8C\u8BC1\u5931\u8D25:
${validation.errors.map((e) => e.message).join("\n")}`;
        throw new Error(errorMessage);
      }
      if (!Array.isArray(parsedData.edges)) {
        parsedData.edges = [];
      }
      this.canvasData = parsedData;
      this.clearDataCache();
      this.filteredNodes = [...parsedData.nodes];
      this.searchQuery = "";
      if (this.searchInputEl) {
        this.searchInputEl.value = "";
      }
      this.activeColorFilter = null;
      DebugManager.log("Canvas\u6570\u636E\u52A0\u8F7D\u6210\u529F\uFF0C\u8282\u70B9\u6570\u91CF:", parsedData.nodes.length);
      parsedData.nodes.forEach((node) => {
        if (node.color) {
          DebugManager.log("\u8282\u70B9\u989C\u8272\u503C:", node.id, "color:", node.color, "type:", typeof node.color);
        }
      });
      this.renderGrid();
      DebugManager.log("Canvas data loaded and rendered successfully from file:", file.path);
    } catch (error) {
      const errorHandler = ErrorHandler.getInstance();
      errorHandler.handleError(error, `Canvas\u6587\u4EF6\u52A0\u8F7D: ${file.path}`, false);
      throw error;
    }
  }
  // 保存到关联的Canvas文件
  async saveCanvasDataToLinkedFile() {
    if (!this.canvasData) {
      throw new Error("\u6CA1\u6709Canvas\u6570\u636E\u53EF\u4FDD\u5B58");
    }
    if (!this.linkedCanvasFile) {
      throw new Error("\u6CA1\u6709\u5173\u8054\u7684Canvas\u6587\u4EF6");
    }
    const fileExists = this.app.vault.getAbstractFileByPath(this.linkedCanvasFile.path);
    if (!fileExists) {
      throw new Error(`\u5173\u8054\u7684Canvas\u6587\u4EF6\u4E0D\u5B58\u5728: ${this.linkedCanvasFile.path}`);
    }
    try {
      if (!Array.isArray(this.canvasData.nodes)) {
        throw new Error("Canvas\u8282\u70B9\u6570\u636E\u65E0\u6548");
      }
      if (!Array.isArray(this.canvasData.edges)) {
        this.canvasData.edges = [];
      }
      DebugManager.log("Saving canvas data to linked file:", this.linkedCanvasFile.path);
      const backupData = JSON.parse(JSON.stringify(this.canvasData));
      const canvasContent = JSON.stringify(this.canvasData, null, 2);
      try {
        JSON.parse(canvasContent);
      } catch (jsonError) {
        throw new Error("\u751F\u6210\u7684JSON\u683C\u5F0F\u65E0\u6548");
      }
      await this.app.vault.modify(this.linkedCanvasFile, canvasContent);
      DebugManager.log("Canvas data saved successfully to linked file:", this.linkedCanvasFile.path);
    } catch (error) {
      DebugManager.error("Failed to save to linked canvas file:", error);
      const errorMessage = error instanceof Error ? error.message : "\u672A\u77E5\u9519\u8BEF";
      throw new Error(`\u4FDD\u5B58Canvas\u6587\u4EF6\u5931\u8D25: ${errorMessage}`);
    }
  }
  // 显示Canvas文件选择对话框
  showCanvasSelectionDialog() {
    const modal = new CanvasSelectionModal(
      this.app,
      this,
      (file) => {
        this.setLinkedCanvas(file);
      }
    );
    modal.open();
  }
  // 更新关联Canvas显示
  updateLinkedCanvasDisplay(file) {
    if (!this.linkedIndicatorEl)
      return;
    if (file) {
      this.linkedIndicatorEl.textContent = file.basename;
      this.linkedIndicatorEl.removeClass("not-linked");
      this.linkedIndicatorEl.title = `\u5173\u8054\u6587\u4EF6: ${file.path}`;
    } else {
      this.linkedIndicatorEl.textContent = "\u672A\u5173\u8054";
      this.linkedIndicatorEl.addClass("not-linked");
      this.linkedIndicatorEl.title = "\u70B9\u51FB\u5173\u8054Canvas\u6587\u4EF6";
    }
    const mainBtn = this.containerEl.querySelector(".canvas-grid-main-btn");
    if (mainBtn) {
      if (file) {
        mainBtn.title = `\u7F51\u683C\u89C6\u56FE\u83DC\u5355 - \u5DF2\u5173\u8054: ${file.basename}`;
      } else {
        mainBtn.title = "\u7F51\u683C\u89C6\u56FE\u83DC\u5355 - \u672A\u5173\u8054Canvas\u6587\u4EF6";
      }
    }
  }
  // 更新操作按钮可见性
  updateActionButtonsVisibility() {
    const linkBtn = this.containerEl.querySelector(".canvas-grid-action-btn:not(.canvas-grid-unlink-btn)");
    const unlinkBtn = this.containerEl.querySelector(".canvas-grid-unlink-btn");
    if (linkBtn && unlinkBtn) {
      if (this.linkedCanvasFile) {
        linkBtn.style.display = "none";
        unlinkBtn.style.display = "flex";
      } else {
        linkBtn.style.display = "flex";
        unlinkBtn.style.display = "none";
      }
    }
  }
  // 刷新Canvas数据
  async refreshCanvasData() {
    try {
      if (this.linkedCanvasFile) {
        await this.loadCanvasDataFromFile(this.linkedCanvasFile);
        new import_obsidian12.Notice("\u64CD\u4F5C\u5B8C\u6210", NOTIFICATION_CONSTANTS.SHORT_DURATION);
      } else {
        await this.loadActiveCanvas();
      }
      this.initializeSearchAndSort();
      DebugManager.log("\u2705 Canvas data refreshed and sort reapplied");
    } catch (error) {
      DebugManager.error("Failed to refresh canvas data:", error);
      new import_obsidian12.Notice("\u64CD\u4F5C\u5B8C\u6210", NOTIFICATION_CONSTANTS.SHORT_DURATION);
    }
  }
  // 自动关联当前Canvas文件
  async autoLinkCurrentCanvas() {
    try {
      const activeFile = this.app.workspace.getActiveFile();
      if (!activeFile || activeFile.extension !== "canvas") {
        new import_obsidian12.Notice("\u6CA1\u6709\u6D3B\u52A8\u7684Canvas\u6587\u4EF6", NOTIFICATION_CONSTANTS.MEDIUM_DURATION);
        return;
      }
      await this.setLinkedCanvas(activeFile);
      new import_obsidian12.Notice(`\u5DF2\u81EA\u52A8\u5173\u8054Canvas\u6587\u4EF6: ${activeFile.basename}`, NOTIFICATION_CONSTANTS.MEDIUM_DURATION);
      DebugManager.log("Auto-linked canvas file:", activeFile.path);
    } catch (error) {
      DebugManager.error("Failed to auto-link canvas file:", error);
      new import_obsidian12.Notice("\u81EA\u52A8\u5173\u8054Canvas\u6587\u4EF6\u5931\u8D25");
    }
  }
  // ==================== 文件监听事件处理 ====================
  // 关联文件被修改（Canvas兼容模式）
  onLinkedFileModified(file) {
    DebugManager.log("Linked canvas file modified:", file.path);
    if (this.isSaveOperationInProgress) {
      DebugManager.log("Save operation in progress, skipping file change handling");
      return;
    }
    const timeSinceLastSave = Date.now() - this.lastSaveTimestamp;
    if (timeSinceLastSave < 200) {
      DebugManager.log("Recent save detected, skipping file change handling");
      return;
    }
    if (this.updateTimeout) {
      this.safeClearTimeout(this.updateTimeout);
    }
    this.updateTimeout = this.safeSetTimeout(async () => {
      try {
        if (this.isSaveOperationInProgress) {
          DebugManager.log("Save operation started during timeout, skipping update");
          return;
        }
        await this.handleFileChangeWithNewSystem(file);
      } catch (error) {
        DebugManager.error("Failed to sync canvas data:", error);
        new import_obsidian12.Notice("\u540C\u6B65Canvas\u6570\u636E\u5931\u8D25");
      }
    }, 300);
  }
  // 关联文件被删除
  onLinkedFileDeleted() {
    DebugManager.log("Linked canvas file deleted");
    this.linkedCanvasFile = null;
    this.canvasData = null;
    this.renderGrid();
    this.showMessage("\u5173\u8054\u7684Canvas\u6587\u4EF6\u5DF2\u88AB\u5220\u9664\uFF0C\u8BF7\u91CD\u65B0\u5173\u8054");
    this.updateLinkedCanvasDisplay(null);
    this.updateActionButtonsVisibility();
  }
  // 关联文件被重命名
  onLinkedFileRenamed(file) {
    DebugManager.log("Linked canvas file renamed:", file.path);
    this.linkedCanvasFile = file;
    this.updateLinkedCanvasDisplay(file);
    new import_obsidian12.Notice("\u64CD\u4F5C\u5B8C\u6210", NOTIFICATION_CONSTANTS.MEDIUM_DURATION);
  }
  // 通知Canvas视图刷新
  notifyCanvasViewRefresh() {
    if (!this.linkedCanvasFile)
      return;
    const canvasLeaves = this.app.workspace.getLeavesOfType("canvas");
    const targetLeaf = canvasLeaves.find((leaf) => {
      const view = leaf.view;
      return view.file?.path === this.linkedCanvasFile?.path;
    });
    if (targetLeaf) {
      DebugManager.log("Notifying canvas view to refresh");
      const canvasView = targetLeaf.view;
      if (canvasView.requestSave) {
        canvasView.requestSave();
      }
      if (canvasView.requestParse) {
        canvasView.requestParse();
      }
      if (canvasView.load && this.linkedCanvasFile) {
        canvasView.load(this.linkedCanvasFile);
      }
    }
  }
  // ==================== 宽度控制功能 ====================
  // 初始化宽度控制
  initializeWidthControl() {
    const sidebarContainer = this.containerEl.closest(".workspace-leaf");
    if (!sidebarContainer)
      return;
    this.resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        this.handleWidthChange(entry.contentRect.width);
      }
    });
    this.resizeObserver.observe(sidebarContainer);
    const currentWidth = sidebarContainer.getBoundingClientRect().width;
    this.handleWidthChange(currentWidth);
  }
  // 处理宽度变化
  handleWidthChange(width) {
    const sidebarContainer = this.containerEl.closest(".workspace-leaf");
    if (!sidebarContainer)
      return;
    if (width < this.minWidth) {
      if (!this.isWidthLimited) {
        this.setCompactMode(sidebarContainer);
        this.isWidthLimited = true;
      }
    } else {
      if (this.isWidthLimited) {
        this.removeCompactMode(sidebarContainer);
        this.isWidthLimited = false;
      }
    }
  }
  // 设置紧凑模式（不强制固定宽度）
  setCompactMode(container) {
    container.classList.add("canvas-grid-compact-mode");
  }
  // 移除紧凑模式
  removeCompactMode(container) {
    container.classList.remove("canvas-grid-compact-mode");
  }
  // 移除了自动隐藏侧边栏的功能
  // 现在让用户自己决定是否需要隐藏侧边栏
  // 清理宽度控制
  cleanupWidthControl() {
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
      this.resizeObserver = null;
    }
    const sidebarContainer = this.containerEl.closest(".workspace-leaf");
    if (sidebarContainer) {
      this.removeCompactMode(sidebarContainer);
    }
    this.isWidthLimited = false;
  }
  // 视图卸载时清理资源
  onunload() {
    DebugManager.log("Canvas Grid View unloaded");
    if (this.editorStateCoordinator) {
      this.editorStateCoordinator.destroy();
    }
    this.cleanupStateManagers();
    this.cleanupUXIndicators();
    this.cleanupViewDynamicStyles();
  }
  // ==================== 新增：状态管理系统方法 ====================
  /**
   * 🎯 新增：统一数据访问方法 - 获取最新的节点数据
   * 实现数据源优先级策略：编辑状态 > 编辑器状态管理器 > 主数据源
   */
  getLatestNodeData(nodeId) {
    try {
      if (this.currentEditingNode?.id === nodeId) {
        DebugManager.log("\u{1F4CA} \u4ECE\u5F53\u524D\u7F16\u8F91\u72B6\u6001\u83B7\u53D6\u8282\u70B9\u6570\u636E", { nodeId });
        return this.currentEditingNode;
      }
      const editorState = this.editorStateManager.getEditorState(nodeId);
      if (editorState?.isDirty && editorState.currentContent) {
        DebugManager.log("\u{1F4CA} \u4ECE\u7F16\u8F91\u5668\u72B6\u6001\u7BA1\u7406\u5668\u83B7\u53D6\u8282\u70B9\u6570\u636E", { nodeId });
        return editorState.currentContent;
      }
      const node = this.canvasData?.nodes.find((n) => n.id === nodeId) || null;
      if (node) {
        DebugManager.log("\u{1F4CA} \u4ECE\u4E3B\u6570\u636E\u6E90\u83B7\u53D6\u8282\u70B9\u6570\u636E", { nodeId });
      } else {
        DebugManager.warn("\u26A0\uFE0F \u672A\u627E\u5230\u8282\u70B9\u6570\u636E", { nodeId });
      }
      return node;
    } catch (error) {
      DebugManager.error("\u274C \u83B7\u53D6\u8282\u70B9\u6570\u636E\u5931\u8D25", { nodeId, error });
      return null;
    }
  }
  /**
   * 🎯 新增：数据源一致性检查 - 验证所有数据源的数据一致性
   */
  validateDataConsistency(nodeId) {
    const issues = [];
    const recommendations = [];
    try {
      DebugManager.log("\u{1F50D} \u5F00\u59CB\u6570\u636E\u4E00\u81F4\u6027\u68C0\u67E5", { nodeId });
      const currentEditingData = this.currentEditingNode?.id === nodeId ? this.currentEditingNode : null;
      const editorStateData = this.editorStateManager.getEditorState(nodeId)?.currentContent;
      const memoryBufferData = this.memoryBufferManager.getMemoryVersion()?.nodes?.find((n) => n.id === nodeId);
      const mainDataSource = this.canvasData?.nodes.find((n) => n.id === nodeId);
      if (!mainDataSource) {
        issues.push("\u4E3B\u6570\u636E\u6E90\u4E2D\u7F3A\u5C11\u8282\u70B9\u6570\u636E");
        recommendations.push("\u91CD\u65B0\u52A0\u8F7DCanvas\u6570\u636E");
      }
      const texts = [
        currentEditingData?.text,
        editorStateData?.text,
        memoryBufferData?.text,
        mainDataSource?.text
      ].filter((text) => text !== void 0);
      if (texts.length > 1) {
        const uniqueTexts = [...new Set(texts)];
        if (uniqueTexts.length > 1) {
          issues.push(`\u6587\u672C\u5185\u5BB9\u4E0D\u4E00\u81F4\uFF1A\u53D1\u73B0${uniqueTexts.length}\u4E2A\u4E0D\u540C\u7248\u672C`);
          recommendations.push("\u6267\u884C\u6570\u636E\u6E90\u540C\u6B65\u64CD\u4F5C");
          DebugManager.warn("\u26A0\uFE0F \u6587\u672C\u5185\u5BB9\u4E0D\u4E00\u81F4", { nodeId, uniqueTexts });
        }
      }
      const types = [
        currentEditingData?.type,
        editorStateData?.type,
        memoryBufferData?.type,
        mainDataSource?.type
      ].filter((type) => type !== void 0);
      if (types.length > 1) {
        const uniqueTypes = [...new Set(types)];
        if (uniqueTypes.length > 1) {
          issues.push(`\u8282\u70B9\u7C7B\u578B\u4E0D\u4E00\u81F4\uFF1A\u53D1\u73B0${uniqueTypes.length}\u4E2A\u4E0D\u540C\u7C7B\u578B`);
          recommendations.push("\u68C0\u67E5\u8282\u70B9\u7C7B\u578B\u5B9A\u4E49");
        }
      }
      const isConsistent = issues.length === 0;
      DebugManager.log(isConsistent ? "\u2705 \u6570\u636E\u4E00\u81F4\u6027\u68C0\u67E5\u901A\u8FC7" : "\u26A0\uFE0F \u6570\u636E\u4E00\u81F4\u6027\u68C0\u67E5\u53D1\u73B0\u95EE\u9898", {
        nodeId,
        isConsistent,
        issuesCount: issues.length,
        issues
      });
      return { isConsistent, issues, recommendations };
    } catch (error) {
      DebugManager.error("\u274C \u6570\u636E\u4E00\u81F4\u6027\u68C0\u67E5\u5931\u8D25", { nodeId, error });
      return {
        isConsistent: false,
        issues: ["\u6570\u636E\u4E00\u81F4\u6027\u68C0\u67E5\u6267\u884C\u5931\u8D25"],
        recommendations: ["\u91CD\u65B0\u6267\u884C\u68C0\u67E5"]
      };
    }
  }
  /**
   * 🎯 新增：渲染前数据验证 - 确保渲染数据的有效性
   */
  validateRenderData(node, context) {
    try {
      DebugManager.log("\u{1F50D} \u6E32\u67D3\u524D\u6570\u636E\u9A8C\u8BC1", { nodeId: node.id, context });
      if (!node.id) {
        DebugManager.error("\u274C \u8282\u70B9ID\u7F3A\u5931", { context });
        return false;
      }
      if (!node.type) {
        DebugManager.error("\u274C \u8282\u70B9\u7C7B\u578B\u7F3A\u5931", { nodeId: node.id, context });
        return false;
      }
      if (node.type === "text") {
        if (node.text === void 0) {
          DebugManager.warn("\u26A0\uFE0F \u6587\u672C\u8282\u70B9\u5185\u5BB9\u4E3Aundefined", { nodeId: node.id, context });
        }
      } else if (node.type === "link") {
        if (!node.url) {
          DebugManager.error("\u274C \u94FE\u63A5\u8282\u70B9URL\u7F3A\u5931", { nodeId: node.id, context });
          return false;
        }
      }
      if (typeof node.x !== "number" || typeof node.y !== "number") {
        DebugManager.warn("\u26A0\uFE0F \u8282\u70B9\u4F4D\u7F6E\u4FE1\u606F\u5F02\u5E38", {
          nodeId: node.id,
          x: node.x,
          y: node.y,
          context
        });
      }
      DebugManager.log("\u2705 \u6E32\u67D3\u6570\u636E\u9A8C\u8BC1\u901A\u8FC7", { nodeId: node.id, context });
      return true;
    } catch (error) {
      DebugManager.error("\u274C \u6E32\u67D3\u6570\u636E\u9A8C\u8BC1\u5931\u8D25", { nodeId: node.id, context, error });
      return false;
    }
  }
  /**
   * 🎯 新增：同步所有数据源 - 确保数据一致性
   */
  async syncAllDataSources(nodeId, updatedNode) {
    try {
      DebugManager.log("\u{1F504} \u5F00\u59CB\u540C\u6B65\u6240\u6709\u6570\u636E\u6E90", { nodeId, nodeType: updatedNode.type });
      if (this.canvasData?.nodes) {
        const nodeIndex = this.canvasData.nodes.findIndex((n) => n.id === nodeId);
        if (nodeIndex !== -1) {
          this.canvasData.nodes[nodeIndex] = { ...updatedNode };
          DebugManager.log("\u2705 \u4E3B\u6570\u636E\u6E90\u5DF2\u66F4\u65B0", { nodeId });
        } else {
          DebugManager.warn("\u26A0\uFE0F \u4E3B\u6570\u636E\u6E90\u4E2D\u672A\u627E\u5230\u8282\u70B9", { nodeId });
        }
      }
      const changeOperation = {
        id: `update-${nodeId}-${Date.now()}`,
        nodeId,
        type: "update",
        oldValue: this.currentEditingNode,
        newValue: updatedNode,
        timestamp: Date.now(),
        applied: false
      };
      this.memoryBufferManager.applyChange(changeOperation);
      DebugManager.log("\u2705 \u5185\u5B58\u7F13\u51B2\u7BA1\u7406\u5668\u5DF2\u66F4\u65B0", { nodeId });
      this.editorStateManager.updateContent(nodeId, updatedNode);
      DebugManager.log("\u2705 \u7F16\u8F91\u5668\u72B6\u6001\u7BA1\u7406\u5668\u5DF2\u66F4\u65B0", { nodeId });
      setTimeout(async () => {
        try {
          await this.saveCanvasData();
          DebugManager.log("\u2705 Canvas\u6570\u636E\u5DF2\u4FDD\u5B58", { nodeId });
        } catch (error) {
          DebugManager.error("\u274C Canvas\u6570\u636E\u4FDD\u5B58\u5931\u8D25", { nodeId, error });
        }
      }, 100);
      DebugManager.log("\u{1F389} \u6240\u6709\u6570\u636E\u6E90\u540C\u6B65\u5B8C\u6210", { nodeId });
    } catch (error) {
      DebugManager.error("\u274C \u6570\u636E\u6E90\u540C\u6B65\u5931\u8D25", { nodeId, error });
    }
  }
  /**
   * 使用新系统执行保存（Canvas兼容模式 - 增强防重复机制）
   */
  async performSaveWithNewSystem(trigger) {
    try {
      if (this.isSaveOperationInProgress) {
        DebugManager.log("Save operation already in progress, skipping duplicate save");
        return;
      }
      const timeSinceLastSave = Date.now() - this.lastSaveTimestamp;
      if (timeSinceLastSave < 50) {
        DebugManager.log("Save too frequent, skipping (Canvas-compatible mode)");
        return;
      }
      DebugManager.log("Performing save with new system (Canvas-compatible mode), trigger:", trigger);
      const memoryVersion = this.memoryBufferManager.getMemoryVersion();
      if (!memoryVersion) {
        DebugManager.warn("No memory version available for save");
        return;
      }
      if (this.canvasData && JSON.stringify(this.canvasData) === JSON.stringify(memoryVersion)) {
        DebugManager.log("No content changes detected, skipping save (Canvas-compatible mode)");
        return;
      }
      if (this.linkedCanvasFile) {
        await this.saveCanvasDataWithNewSystem(memoryVersion, this.linkedCanvasFile);
      } else {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile && activeFile.extension === "canvas") {
          await this.saveCanvasDataWithNewSystem(memoryVersion, activeFile);
        }
      }
      this.memoryBufferManager.markChangesSaved();
      DebugManager.log("Save completed with new system (Canvas-compatible mode)");
    } catch (error) {
      DebugManager.error("Save failed with new system:", error);
      throw error;
    }
  }
  /**
   * 使用新系统保存Canvas数据到文件（Canvas兼容模式）
   */
  async saveCanvasDataWithNewSystem(canvasData, file) {
    try {
      this.startSaveOperation();
      const content = JSON.stringify(canvasData, null, 2);
      await this.app.vault.modify(file, content);
      this.canvasData = canvasData;
      setTimeout(() => {
        this.endSaveOperation();
      }, 100);
      DebugManager.log("Canvas data saved with new system to:", file.path);
    } catch (error) {
      this.endSaveOperation();
      throw error;
    }
  }
  /**
   * 编辑器状态变化处理
   */
  onEditorStateChanged(nodeId, state) {
    DebugManager.log("Editor state changed for node:", nodeId, "isDirty:", state.isDirty);
    if (state.isDirty) {
      const changeOp = {
        id: `${nodeId}-${Date.now()}`,
        nodeId,
        type: "update",
        oldValue: state.originalContent,
        newValue: state.currentContent,
        timestamp: Date.now(),
        applied: false,
        source: "editor"
      };
      this.memoryBufferManager.applyChange(changeOp);
    }
  }
  /**
   * 显示编辑状态指示器
   */
  showEditingIndicator(nodeId, show) {
    const cardElement = this.gridContainer.querySelector(`[data-node-id="${nodeId}"]`);
    if (!cardElement)
      return;
    const existingIndicator = cardElement.querySelector(".editing-indicator");
    if (show && !existingIndicator) {
      cardElement.classList.add("editing-active");
      const indicator = cardElement.createDiv("editing-indicator");
      indicator.style.cssText = `
					position: absolute;
					top: 4px;
					right: 4px;
					width: 12px;
					height: 12px;
					background: var(--color-orange);
					border-radius: 50%;
					z-index: 10;
					pointer-events: none;
					animation: pulse 1.5s infinite;
				`;
      if (!document.querySelector("#editing-indicator-styles")) {
        const style = document.createElement("style");
        style.id = "editing-indicator-styles";
        style.textContent = `
						@keyframes pulse {
							0% { opacity: 1; transform: scale(1); }
							50% { opacity: 0.7; transform: scale(1.2); }
							100% { opacity: 1; transform: scale(1); }
						}
						.editing-active {
							border: 2px solid var(--color-orange) !important;
							box-shadow: 0 0 8px rgba(255, 165, 0, 0.3) !important;
						}
					`;
        document.head.appendChild(style);
      }
    } else if (!show && existingIndicator) {
      cardElement.classList.remove("editing-active");
      existingIndicator.remove();
    }
  }
  /**
   * 显示未保存变更指示器
   */
  showUnsavedChangesIndicator(show) {
    const existingIndicator = this.containerEl.querySelector(".unsaved-changes-indicator");
    if (show && !existingIndicator) {
      const indicator = this.containerEl.createDiv("unsaved-changes-indicator");
      indicator.textContent = "\u6709\u672A\u4FDD\u5B58\u7684\u53D8\u66F4";
      indicator.style.cssText = `
					position: fixed;
					bottom: 20px;
					right: 20px;
					background: var(--color-orange);
					color: white;
					padding: 8px 16px;
					border-radius: 4px;
					font-size: 14px;
					font-weight: 500;
					z-index: 1000;
					cursor: pointer;
					box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
				`;
      indicator.addEventListener("click", () => {
        this.triggerManualSave();
      });
    } else if (!show && existingIndicator) {
      existingIndicator.remove();
    }
  }
  /**
   * 清理状态管理器
   */
  cleanupStateManagers() {
    if (this.editorStateManager) {
      this.editorStateManager.cleanup();
    }
    if (this.memoryBufferManager) {
      this.memoryBufferManager.cleanup();
    }
    if (this.saveTriggerManager) {
      this.saveTriggerManager.cleanup();
    }
    DebugManager.log("State managers cleaned up");
  }
  /**
   * 触发手动保存
   */
  async triggerManualSave() {
    try {
      this.showSaveStatusIndicator("saving");
      await this.saveTriggerManager.triggerManualSave();
      this.showSaveStatusIndicator("saved");
      DebugManager.log("Manual save completed");
    } catch (error) {
      this.showSaveStatusIndicator("error", "\u4FDD\u5B58\u5931\u8D25");
      DebugManager.error("Manual save failed:", error);
    }
  }
  /**
   * 显示保存状态指示器
   */
  showSaveStatusIndicator(status, message) {
    const existingIndicator = this.containerEl.querySelector(".save-status-indicator");
    if (existingIndicator) {
      existingIndicator.remove();
    }
    const indicator = this.containerEl.createDiv("save-status-indicator");
    indicator.style.cssText = `
				position: fixed;
				top: 20px;
				right: 20px;
				padding: 8px 16px;
				border-radius: 4px;
				font-size: 14px;
				font-weight: 500;
				z-index: 1000;
				transition: all 0.3s ease;
				box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
			`;
    switch (status) {
      case "saving":
        indicator.textContent = message || "\u6B63\u5728\u4FDD\u5B58...";
        indicator.style.backgroundColor = "var(--color-orange)";
        indicator.style.color = "white";
        break;
      case "saved":
        indicator.textContent = message || "\u5DF2\u4FDD\u5B58";
        indicator.style.backgroundColor = "var(--color-green)";
        indicator.style.color = "white";
        break;
      case "error":
        indicator.textContent = message || "\u4FDD\u5B58\u5931\u8D25";
        indicator.style.backgroundColor = "var(--color-red)";
        indicator.style.color = "white";
        break;
    }
    if (status !== "error") {
      setTimeout(() => {
        if (indicator.parentNode) {
          indicator.style.opacity = "0";
          setTimeout(() => {
            indicator.remove();
          }, 300);
        }
      }, status === "saving" ? 0 : 2e3);
    }
  }
  /**
   * 注册键盘快捷键
   */
  registerKeyboardShortcuts() {
    this.addGlobalEventListener(document, "keydown", (e) => {
      const keyEvent = e;
      if ((keyEvent.ctrlKey || keyEvent.metaKey) && keyEvent.key === "s") {
        keyEvent.preventDefault();
        this.triggerManualSave();
      }
    });
    DebugManager.log("Keyboard shortcuts registered");
  }
  /**
   * 启动性能监控
   */
  startPerformanceMonitoring() {
    if (this.performanceManager) {
      try {
        DebugManager.log("\u2705 Performance manager available, monitoring enabled");
      } catch (error) {
        DebugManager.warn("Could not start performance monitoring:", error);
      }
    }
    DebugManager.log("\u2705 Performance monitoring started (unified through PerformanceManager)");
  }
  /**
   * 运行基础系统验证
   */
  runBasicSystemValidation() {
    try {
      if (!this.editorStateManager) {
        DebugManager.error("EditorStateManager not initialized");
        return;
      }
      if (!this.memoryBufferManager) {
        DebugManager.error("MemoryBufferManager not initialized");
        return;
      }
      if (!this.saveTriggerManager) {
        DebugManager.error("SaveTriggerManager not initialized");
        return;
      }
      if (!this.containerEl) {
        DebugManager.error("Container element not found");
        return;
      }
      if (this.canvasData && !this.canvasData.nodes) {
        DebugManager.warn("Canvas data exists but has no nodes");
      }
      DebugManager.log("\u2705 Basic system validation passed");
    } catch (error) {
      DebugManager.error("System validation failed:", error);
    }
  }
  /**
   * 使用新状态管理系统开始编辑
   */
  startEditingWithNewSystem(nodeId, node, cardElement) {
    try {
      const editorState = this.editorStateManager.startEditing(nodeId, {
        nodeType: node.type,
        initialContent: node.text || "",
        editingMode: "text"
      });
      this.showEditingIndicator(nodeId, true);
      DebugManager.log("Started editing with new system:", nodeId);
      return editorState;
    } catch (error) {
      DebugManager.error("Failed to start editing with new system:", error);
      return null;
    }
  }
  /**
   * 使用新状态管理系统停止编辑
   */
  stopEditingWithNewSystem(nodeId, saveChanges) {
    try {
      this.editorStateManager.stopEditing(nodeId, saveChanges);
      this.showEditingIndicator(nodeId, false);
      DebugManager.log("Stopped editing with new system:", nodeId, "saved:", saveChanges);
    } catch (error) {
      DebugManager.error("Failed to stop editing with new system:", error);
    }
  }
  /**
   * 🎯 增强：使用新状态管理系统更新内容 - 确保所有数据源同步
   */
  updateContentWithNewSystem(nodeId, updatedNode) {
    try {
      DebugManager.log("\u{1F504} \u5F00\u59CB\u66F4\u65B0\u5185\u5BB9\uFF08\u65B0\u72B6\u6001\u7BA1\u7406\u7CFB\u7EDF\uFF09", {
        nodeId,
        nodeType: updatedNode.type,
        contentPreview: updatedNode.text?.substring(0, 50) || updatedNode.url?.substring(0, 50) || "N/A"
      });
      if (this.currentEditingNode?.id === nodeId) {
        this.currentEditingNode = { ...updatedNode };
        DebugManager.log("\u2705 \u5F53\u524D\u7F16\u8F91\u72B6\u6001\u5DF2\u66F4\u65B0", { nodeId });
      }
      this.editorStateManager.updateContent(nodeId, updatedNode);
      DebugManager.log("\u2705 \u7F16\u8F91\u5668\u72B6\u6001\u7BA1\u7406\u5668\u5DF2\u66F4\u65B0", { nodeId });
      const changeOperation = {
        id: `change-${nodeId}-${Date.now()}`,
        nodeId,
        type: "update",
        timestamp: Date.now(),
        oldValue: this.canvasData?.nodes.find((n) => n.id === nodeId),
        newValue: updatedNode,
        applied: false
      };
      this.memoryBufferManager.applyChange(changeOperation);
      DebugManager.log("\u2705 \u5185\u5B58\u7F13\u51B2\u533A\u5DF2\u66F4\u65B0", { nodeId });
      if (this.canvasData?.nodes) {
        const nodeIndex = this.canvasData.nodes.findIndex((n) => n.id === nodeId);
        if (nodeIndex !== -1) {
          this.canvasData.nodes[nodeIndex] = { ...updatedNode };
          DebugManager.log("\u2705 \u4E3B\u6570\u636E\u6E90\u5DF2\u66F4\u65B0", { nodeId });
        } else {
          DebugManager.warn("\u26A0\uFE0F \u4E3B\u6570\u636E\u6E90\u4E2D\u672A\u627E\u5230\u8282\u70B9", { nodeId });
        }
      }
      if (this.currentEditingNode?.id !== nodeId) {
        const cardElement = this.gridContainer?.querySelector(`[data-node-id="${nodeId}"]`);
        if (cardElement) {
          const contentDiv = cardElement.querySelector(".card-content");
          if (contentDiv && updatedNode.type === "text") {
            this.renderTextNodeContent(contentDiv, updatedNode);
            DebugManager.log("\u2705 UI\u5B9E\u65F6\u66F4\u65B0\u5B8C\u6210", { nodeId });
          }
        }
      }
      DebugManager.log("\u{1F389} \u5185\u5BB9\u66F4\u65B0\u5B8C\u6210\uFF08\u6240\u6709\u6570\u636E\u6E90\u5DF2\u540C\u6B65\uFF09", { nodeId });
    } catch (error) {
      DebugManager.error("\u274C \u5185\u5BB9\u66F4\u65B0\u5931\u8D25", { nodeId, error });
    }
  }
  /**
   * 使用新状态管理系统处理文件变更
   */
  async handleFileChangeWithNewSystem(file) {
    try {
      if (!this.linkedCanvasFile || file.path !== this.linkedCanvasFile.path) {
        return;
      }
      DebugManager.log("Handling file change with new system:", file.path);
      const content = await this.app.vault.read(file);
      const newCanvasData = JSON.parse(content);
      this.memoryBufferManager.updateFileVersion(newCanvasData);
      if (this.memoryBufferManager.detectConflict()) {
        DebugManager.warn("Conflict detected during file change");
        return;
      }
      if (!this.memoryBufferManager.hasUnsavedChanges()) {
        this.canvasData = newCanvasData;
        this.filteredNodes = newCanvasData.nodes || [];
        await this.renderGrid();
        DebugManager.log("File change processed successfully");
      } else {
        DebugManager.log("File change detected but has unsaved changes, skipping update");
      }
    } catch (error) {
      DebugManager.error("Failed to handle file change with new system:", error);
    }
  }
  /**
   * 清理用户体验指示器
   */
  cleanupUXIndicators() {
    const indicators = this.containerEl.querySelectorAll(
      ".save-status-indicator, .unsaved-changes-indicator, .editing-indicator"
    );
    indicators.forEach((indicator) => indicator.remove());
    DebugManager.log("UX indicators cleaned up");
  }
  /**
   * 清理视图相关的动态样式 - 防止样式泄露
   */
  cleanupViewDynamicStyles() {
    const editingStyleElement = document.querySelector("#editing-indicator-styles");
    if (editingStyleElement) {
      document.head.removeChild(editingStyleElement);
      DebugManager.log("\u{1F3A8} View editing indicator styles cleaned up");
    }
    const viewStyles = document.querySelectorAll('style[id*="canvas-grid-view"]');
    viewStyles.forEach((style) => {
      if (style.parentNode) {
        style.parentNode.removeChild(style);
        DebugManager.log("\u{1F9F9} Removed view dynamic style:", style.id);
      }
    });
  }
  // ==================== Anki同步功能方法 ====================
  // 创建Anki禁用消息
  createAnkiDisabledMessage(container) {
    const disabledMessage = container.createDiv("anki-disabled-message");
    disabledMessage.innerHTML = `
				<div class="anki-disabled-icon">\u{1F512}</div>
				<div class="anki-disabled-text">${this.settings.language === "zh" ? "Anki Connect\u540C\u6B65\u672A\u542F\u7528" : "Anki Connect sync is disabled"}</div>
				<div class="anki-disabled-subtitle">${this.settings.language === "zh" ? "\u8BF7\u5728\u8BBE\u7F6E\u4E2D\u542F\u7528Anki Connect\u529F\u80FD" : "Please enable Anki Connect in settings"}</div>
			`;
    disabledMessage.style.cssText = `
				text-align: center;
				padding: 40px 20px;
				color: var(--text-muted);
			`;
  }
  // 更新Anki同步状态
  updateAnkiSyncStatus(container) {
    const statusContainer = container.createDiv("anki-sync-status-display");
    const lastSyncTime = this.settings.ankiSyncHistory.lastSyncTime;
    const syncedCount = Object.keys(this.settings.ankiSyncHistory.syncedNodes).length;
    const failedCount = this.settings.ankiSyncHistory.failedNodes.length;
    statusContainer.innerHTML = `
				<div class="anki-status-item">
					<span class="anki-status-label">${this.settings.language === "zh" ? "\u4E0A\u6B21\u540C\u6B65:" : "Last sync:"}</span>
					<span class="anki-status-value">${lastSyncTime ? new Date(lastSyncTime).toLocaleString() : this.settings.language === "zh" ? "\u4ECE\u672A\u540C\u6B65" : "Never synced"}</span>
				</div>
				<div class="anki-status-item">
					<span class="anki-status-label">${this.settings.language === "zh" ? "\u5DF2\u540C\u6B65\u5361\u7247:" : "Synced cards:"}</span>
					<span class="anki-status-value">${syncedCount}</span>
				</div>
				${failedCount > 0 ? `
					<div class="anki-status-item anki-status-error">
						<span class="anki-status-label">${this.settings.language === "zh" ? "\u540C\u6B65\u5931\u8D25:" : "Failed:"}</span>
						<span class="anki-status-value">${failedCount}</span>
					</div>
				` : ""}
			`;
    statusContainer.style.cssText = `
				background: var(--background-secondary);
				border-radius: 8px;
				padding: 16px;
				margin-bottom: 16px;
				border: 1px solid var(--background-modifier-border);
			`;
  }
  // 创建颜色同步选项
  createColorSyncOptions(container) {
    const colorOptions = [
      { value: "1", color: "#ff6b6b", name: this.settings.language === "zh" ? "\u7EA2\u8272" : "Red" },
      { value: "2", color: "#ffa726", name: this.settings.language === "zh" ? "\u6A59\u8272" : "Orange" },
      { value: "3", color: "#ffeb3b", name: this.settings.language === "zh" ? "\u9EC4\u8272" : "Yellow" },
      { value: "4", color: "#66bb6a", name: this.settings.language === "zh" ? "\u7EFF\u8272" : "Green" },
      { value: "5", color: "#26c6da", name: this.settings.language === "zh" ? "\u9752\u8272" : "Cyan" },
      { value: "6", color: "#42a5f5", name: this.settings.language === "zh" ? "\u84DD\u8272" : "Blue" },
      { value: "7", color: "#ab47bc", name: this.settings.language === "zh" ? "\u7D2B\u8272" : "Purple" }
    ];
    const colorGrid = container.createDiv("anki-color-sync-grid");
    colorGrid.style.cssText = `
				display: grid;
				grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
				gap: 12px;
				margin: 16px 0;
			`;
    colorOptions.forEach((colorOption) => {
      const isSelected = this.settings.ankiConnect.syncColors.includes(colorOption.value);
      const colorCard = colorGrid.createDiv("anki-color-card");
      colorCard.style.cssText = `
					display: flex;
					align-items: center;
					gap: 8px;
					padding: 8px 12px;
					border: 2px solid ${isSelected ? colorOption.color : "var(--background-modifier-border)"};
					border-radius: 8px;
					background: ${isSelected ? colorOption.color + "10" : "var(--background-primary)"};
					cursor: pointer;
					transition: all 0.2s ease;
				`;
      const colorDot = colorCard.createDiv("anki-color-dot");
      colorDot.style.cssText = `
					width: 16px;
					height: 16px;
					border-radius: 50%;
					background: ${colorOption.color};
					flex-shrink: 0;
				`;
      const colorName = colorCard.createDiv("anki-color-name");
      colorName.textContent = colorOption.name;
      colorName.style.cssText = `
					font-size: 14px;
					color: var(--text-normal);
				`;
      if (isSelected) {
        const checkmark = colorCard.createDiv("anki-color-checkmark");
        checkmark.textContent = "\u2713";
        checkmark.style.cssText = `
						margin-left: auto;
						color: ${colorOption.color};
						font-weight: bold;
						font-size: 14px;
					`;
      }
      colorCard.addEventListener("click", async () => {
        await this.toggleAnkiSyncColor(colorOption.value);
        this.updateColorSyncOptionsDisplay(container);
      });
    });
  }
  // 更新颜色同步选项显示状态
  updateColorSyncOptionsDisplay(container) {
    const colorGrid = container.querySelector(".anki-color-sync-grid");
    if (!colorGrid)
      return;
    while (colorGrid.firstChild) {
      colorGrid.removeChild(colorGrid.firstChild);
    }
    const colorOptions = [
      { value: "1", color: "#ff6b6b", name: this.settings.language === "zh" ? "\u7EA2\u8272" : "Red" },
      { value: "2", color: "#ffa726", name: this.settings.language === "zh" ? "\u6A59\u8272" : "Orange" },
      { value: "3", color: "#ffeb3b", name: this.settings.language === "zh" ? "\u9EC4\u8272" : "Yellow" },
      { value: "4", color: "#66bb6a", name: this.settings.language === "zh" ? "\u7EFF\u8272" : "Green" },
      { value: "5", color: "#26c6da", name: this.settings.language === "zh" ? "\u9752\u8272" : "Cyan" },
      { value: "6", color: "#42a5f5", name: this.settings.language === "zh" ? "\u84DD\u8272" : "Blue" },
      { value: "7", color: "#ab47bc", name: this.settings.language === "zh" ? "\u7D2B\u8272" : "Purple" }
    ];
    colorOptions.forEach((colorOption) => {
      const isSelected = this.settings.ankiConnect.syncColors.includes(colorOption.value);
      const colorCard = colorGrid.createDiv("anki-color-card");
      colorCard.style.cssText = `
					display: flex;
					align-items: center;
					gap: 8px;
					padding: 8px 12px;
					border: 2px solid ${isSelected ? colorOption.color : "var(--background-modifier-border)"};
					border-radius: 8px;
					background: ${isSelected ? colorOption.color + "10" : "var(--background-primary)"};
					cursor: pointer;
					transition: all 0.2s ease;
				`;
      const colorDot = colorCard.createDiv("anki-color-dot");
      colorDot.style.cssText = `
					width: 16px;
					height: 16px;
					border-radius: 50%;
					background: ${colorOption.color};
					flex-shrink: 0;
				`;
      const colorName = colorCard.createDiv("anki-color-name");
      colorName.textContent = colorOption.name;
      colorName.style.cssText = `
					font-size: 14px;
					color: var(--text-normal);
				`;
      if (isSelected) {
        const checkmark = colorCard.createDiv("anki-color-checkmark");
        checkmark.textContent = "\u2713";
        checkmark.style.cssText = `
						margin-left: auto;
						color: ${colorOption.color};
						font-weight: bold;
						font-size: 14px;
					`;
      }
      colorCard.addEventListener("click", async () => {
        await this.toggleAnkiSyncColor(colorOption.value);
        this.updateColorSyncOptionsDisplay(container);
      });
    });
  }
  // 切换Anki同步颜色
  async toggleAnkiSyncColor(colorValue) {
    const currentColors = [...this.settings.ankiConnect.syncColors];
    const isCurrentlySelected = currentColors.includes(colorValue);
    if (isCurrentlySelected) {
      const index = currentColors.indexOf(colorValue);
      if (index > -1) {
        currentColors.splice(index, 1);
      }
    } else {
      currentColors.push(colorValue);
    }
    this.settings.ankiConnect.syncColors = currentColors;
    await this.plugin.saveSettings();
  }
  // 同步所有选中颜色的卡片
  async syncAllSelectedColorCards() {
    if (!this.canvasData || !this.canvasData.nodes) {
      new import_obsidian12.Notice(this.settings.language === "zh" ? "\u6CA1\u6709\u53EF\u540C\u6B65\u7684\u5361\u7247\u6570\u636E" : "No card data to sync");
      return;
    }
    if (this.settings.ankiConnect.syncColors.length === 0) {
      new import_obsidian12.Notice(this.settings.language === "zh" ? "\u8BF7\u5148\u9009\u62E9\u8981\u540C\u6B65\u7684\u989C\u8272" : "Please select colors to sync first");
      return;
    }
    try {
      if (!this.canvasData || !this.canvasData.nodes || this.canvasData.nodes.length === 0) {
        new import_obsidian12.Notice(this.settings.language === "zh" ? "\u6CA1\u6709Canvas\u6570\u636E\u53EF\u4EE5\u540C\u6B65" : "No Canvas data to sync");
        return;
      }
      const validNodes = this.canvasData.nodes.filter((node) => {
        if (!node.id || !node.type)
          return false;
        if (typeof node.x !== "number" || typeof node.y !== "number")
          return false;
        switch (node.type) {
          case "text":
            return !!(node.text && node.text.trim());
          case "file":
            return !!(node.file && node.file.trim());
          case "link":
            return !!(node.url && node.url.trim());
          case "group":
            return !!(node.label && node.label.trim());
          default:
            return !!(node.text || node.file || node.url || node.label);
        }
      });
      console.log(`Canvas\u8282\u70B9\u7EDF\u8BA1: \u603B\u6570=${this.canvasData.nodes.length}, \u6709\u6548=${validNodes.length}`);
      const nodeTypeStats = this.canvasData.nodes.reduce((stats, node) => {
        stats[node.type] = (stats[node.type] || 0) + 1;
        return stats;
      }, {});
      const validNodeTypeStats = validNodes.reduce((stats, node) => {
        stats[node.type] = (stats[node.type] || 0) + 1;
        return stats;
      }, {});
      console.log("\u6240\u6709\u8282\u70B9\u7C7B\u578B\u7EDF\u8BA1:", nodeTypeStats);
      console.log("\u6709\u6548\u8282\u70B9\u7C7B\u578B\u7EDF\u8BA1:", validNodeTypeStats);
      const invalidNodes = this.canvasData.nodes.filter((node) => !validNodes.includes(node));
      if (invalidNodes.length > 0) {
        console.log("\u65E0\u6548\u8282\u70B9\u8BE6\u60C5:", invalidNodes.map((node) => ({
          id: node.id,
          type: node.type,
          hasId: !!node.id,
          hasType: !!node.type,
          hasPosition: typeof node.x === "number" && typeof node.y === "number",
          hasContent: !!(node.text || node.file || node.url || node.label),
          text: node.text?.substring(0, 50),
          file: node.file,
          url: node.url,
          label: node.label
        })));
      }
      if (validNodes.length === 0) {
        new import_obsidian12.Notice(this.settings.language === "zh" ? "\u6CA1\u6709\u6709\u6548\u7684\u8282\u70B9\u53EF\u4EE5\u540C\u6B65" : "No valid nodes to sync");
        return;
      }
      const { AnkiSyncManager: AnkiSyncManager2 } = await Promise.resolve().then(() => (init_AnkiSyncManager(), AnkiSyncManager_exports));
      const syncManager = new AnkiSyncManager2(
        this.app,
        this.settings.ankiConnect,
        this.settings.ankiSyncHistory,
        {
          onProgressUpdate: (progress) => {
            new import_obsidian12.Notice(`${this.settings.language === "zh" ? "\u540C\u6B65\u8FDB\u5EA6:" : "Sync progress:"} ${progress.current}/${progress.total}`);
          },
          onSyncComplete: (result) => {
            const message = this.settings.language === "zh" ? `\u540C\u6B65\u5B8C\u6210\uFF01\u521B\u5EFA ${result.created} \u4E2A\uFF0C\u66F4\u65B0 ${result.updated} \u4E2A\uFF0C\u8DF3\u8FC7 ${result.skipped} \u4E2A` : `Sync completed! Created ${result.created}, updated ${result.updated}, skipped ${result.skipped}`;
            new import_obsidian12.Notice(message);
          },
          onSyncError: (error) => {
            console.error("Anki\u540C\u6B65\u9519\u8BEF:", error);
            new import_obsidian12.Notice(`${this.settings.language === "zh" ? "\u540C\u6B65\u5931\u8D25:" : "Sync failed:"} ${error}`);
          }
        }
      );
      await syncManager.syncColorFilteredCards(this.settings.ankiConnect.syncColors, this.canvasData.nodes, this.linkedCanvasFile || void 0);
    } catch (error) {
      console.error("Anki\u540C\u6B65\u5931\u8D25:", error);
      let errorMessage = this.settings.language === "zh" ? "\u540C\u6B65\u5931\u8D25" : "Sync failed";
      if (error instanceof Error) {
        if (error.message.includes("\u9A8C\u8BC1\u5931\u8D25")) {
          errorMessage = this.settings.language === "zh" ? "\u6570\u636E\u9A8C\u8BC1\u5931\u8D25\uFF0C\u8BF7\u68C0\u67E5Canvas\u8282\u70B9\u5185\u5BB9" : "Data validation failed, please check Canvas node content";
        } else if (error.message.includes("\u8FDE\u63A5")) {
          errorMessage = this.settings.language === "zh" ? "\u65E0\u6CD5\u8FDE\u63A5\u5230Anki\uFF0C\u8BF7\u786E\u4FDDAnki\u6B63\u5728\u8FD0\u884C\u5E76\u542F\u7528\u4E86AnkiConnect\u63D2\u4EF6" : "Cannot connect to Anki, please ensure Anki is running with AnkiConnect plugin enabled";
        } else {
          errorMessage += `: ${error.message}`;
        }
      }
      new import_obsidian12.Notice(errorMessage);
    }
  }
  // 创建同步历史显示
  createSyncHistoryDisplay(container) {
    const historyContainer = container.createDiv("anki-sync-history");
    historyContainer.innerHTML = `
				<h4 class="anki-section-title">${this.settings.language === "zh" ? "\u540C\u6B65\u5386\u53F2" : "Sync History"}</h4>
			`;
    const lastResult = this.settings.ankiSyncHistory.lastSyncResult;
    if (lastResult) {
      const historyContent = historyContainer.createDiv("anki-history-content");
      historyContent.innerHTML = `
					<div class="anki-history-item">
						<span class="anki-history-label">${this.settings.language === "zh" ? "\u6210\u529F\u7387:" : "Success rate:"}</span>
						<span class="anki-history-value">${lastResult.success ? "\u2705" : "\u274C"}</span>
					</div>
					<div class="anki-history-item">
						<span class="anki-history-label">${this.settings.language === "zh" ? "\u5904\u7406\u603B\u6570:" : "Total processed:"}</span>
						<span class="anki-history-value">${lastResult.totalProcessed}</span>
					</div>
					<div class="anki-history-item">
						<span class="anki-history-label">${this.settings.language === "zh" ? "\u8017\u65F6:" : "Duration:"}</span>
						<span class="anki-history-value">${Math.round((lastResult.duration || 0) / 1e3)}s</span>
					</div>
				`;
      historyContent.style.cssText = `
					background: var(--background-secondary);
					border-radius: 6px;
					padding: 12px;
					margin-top: 8px;
					font-size: 13px;
				`;
    } else {
      const noHistory = historyContainer.createDiv("anki-no-history");
      noHistory.textContent = this.settings.language === "zh" ? "\u6682\u65E0\u540C\u6B65\u5386\u53F2" : "No sync history";
      noHistory.style.cssText = `
					color: var(--text-muted);
					font-style: italic;
					text-align: center;
					padding: 20px;
				`;
    }
  }
};
var CanvasGridPlugin = class extends import_obsidian12.Plugin {
  constructor() {
    super(...arguments);
    this.canvasViewButtons = /* @__PURE__ */ new Map();
    // ==================== 拖拽系统样式管理 ====================
    this.dragSystemStyleElement = null;
  }
  async onload() {
    await this.loadSettings();
    i18n.setLanguage(this.settings.language);
    this.protocolHandler = new ProtocolHandler(this.app);
    this.registerObsidianProtocolHandler("canvasgrid-transit", this.handleObsidianProtocol.bind(this));
    MemoryManager.startPeriodicCleanup();
    this.tempFileManager = TempFileManager.getInstance(this.app);
    this.persistentFileManager = PersistentFileManager.getInstance(this.app);
    try {
      await this.persistentFileManager.initialize();
      DebugManager.log("Persistent file manager initialized in plugin");
    } catch (error) {
      DebugManager.error("Failed to initialize persistent file manager in plugin:", error);
    }
    await this.tempFileManager.recoverFromException();
    this.loadDragSystemStyles();
    this.registerView(
      CANVAS_GRID_VIEW_TYPE,
      (leaf) => new CanvasGridView(leaf, this)
    );
    let ribbonIconEl;
    try {
      ribbonIconEl = this.addRibbonIcon("grid", "Canvas\u7F51\u683C\u89C6\u56FE", () => {
        this.activateView();
      });
    } catch (error) {
      try {
        ribbonIconEl = this.addRibbonIcon("layout", "Canvas\u7F51\u683C\u89C6\u56FE", () => {
          this.activateView();
        });
      } catch (error2) {
        try {
          ribbonIconEl = this.addRibbonIcon("table", "Canvas\u7F51\u683C\u89C6\u56FE", () => {
            this.activateView();
          });
        } catch (error3) {
          ribbonIconEl = this.addRibbonIcon("", "Canvas\u7F51\u683C\u89C6\u56FE", () => {
            this.activateView();
          });
          ribbonIconEl.innerHTML = `
						<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
							<rect x="3" y="3" width="7" height="7"/>
							<rect x="14" y="3" width="7" height="7"/>
							<rect x="3" y="14" width="7" height="7"/>
							<rect x="14" y="14" width="7" height="7"/>
						</svg>
					`;
        }
      }
    }
    this.addCommand({
      id: "open-canvas-grid-view",
      name: "\u6253\u5F00Canvas\u7F51\u683C\u89C6\u56FE",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "open-canvas-timeline-view",
      name: "\u6253\u5F00Canvas\u65F6\u95F4\u7EBF\u89C6\u56FE",
      callback: () => {
        this.activateTimelineView();
      }
    });
    this.addCommand({
      id: "time-capsule-collect",
      name: "\u65F6\u95F4\u80F6\u56CA\u6536\u96C6\u5185\u5BB9",
      callback: () => {
        this.collectToTimeCapsule();
      }
    });
    this.addCommand({
      id: "toggle-time-capsule",
      name: "\u5207\u6362\u65F6\u95F4\u80F6\u56CA\u72B6\u6001",
      callback: () => {
        this.toggleTimeCapsule();
      }
    });
    this.addSettingTab(new TabNavigationSettingTab(this.app, this));
    this.registerEvent(
      this.app.workspace.on("layout-change", () => {
        this.addCanvasViewButtons();
      })
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.addCanvasViewButtons();
      })
    );
    this.addCanvasViewButtons();
    DebugManager.log("\u{1F3A8} Canvasgrid Transit Plugin loaded - \u70ED\u91CD\u8F7D\u6D4B\u8BD5\u6210\u529F!");
  }
  async onunload() {
    if (this.editorStateCoordinator) {
      this.editorStateCoordinator.destroy();
    }
    if (this.persistentFileManager) {
      await this.persistentFileManager.cleanup();
    }
    await PersistentFileManager.destroy();
    if (this.tempFileManager) {
      this.tempFileManager.forceCleanup();
    }
    TempFileManager.destroy();
    MemoryManager.cleanup();
    this.removeAllCanvasViewButtons();
    this.cleanupAllDynamicStyles();
    DebugManager.log("Plugin unloaded with enhanced cleanup including persistent file manager");
  }
  /**
   * 处理Obsidian协议请求 - 使用增强的ProtocolHandler
   */
  async handleObsidianProtocol(params) {
    try {
      if (!this.protocolHandler) {
        console.error("ProtocolHandler not initialized");
        new import_obsidian12.Notice("\u534F\u8BAE\u5904\u7406\u5668\u672A\u521D\u59CB\u5316");
        return;
      }
      await this.protocolHandler.handleProtocolRequest(params);
    } catch (error) {
      console.error("\u5904\u7406Obsidian\u534F\u8BAE\u5931\u8D25:", error);
      new import_obsidian12.Notice("\u6253\u5F00Canvas\u6587\u4EF6\u5931\u8D25");
    }
  }
  /**
   * 在Canvas中定位到指定节点
   */
  focusCanvasNode(nodeId, x, y) {
    try {
      const activeLeaf = this.app.workspace.getMostRecentLeaf();
      if (!activeLeaf || activeLeaf.view.getViewType() !== "canvas") {
        return;
      }
      const canvasView = activeLeaf.view;
      if (canvasView.canvas && canvasView.canvas.zoomToFit) {
        canvasView.canvas.setViewport(x - 200, y - 200, 1);
        const node = canvasView.canvas.nodes.get(nodeId);
        if (node && node.nodeEl) {
          node.nodeEl.style.outline = "3px solid var(--interactive-accent)";
          setTimeout(() => {
            if (node.nodeEl) {
              node.nodeEl.style.outline = "";
            }
          }, 2e3);
        }
      }
    } catch (error) {
      console.error("\u5B9A\u4F4DCanvas\u8282\u70B9\u5931\u8D25:", error);
    }
  }
  // 获取活动的网格视图
  getActiveGridView() {
    const leaves = this.app.workspace.getLeavesOfType(CANVAS_GRID_VIEW_TYPE);
    if (leaves.length > 0) {
      return leaves[0].view;
    }
    return null;
  }
  // 为所有Canvas视图添加切换按钮
  addCanvasViewButtons() {
    const leaves = this.app.workspace.getLeavesOfType("canvas");
    leaves.forEach((leaf) => {
      const canvasView = leaf.view;
      if (canvasView && canvasView.canvas && canvasView.containerEl) {
        this.addButtonToCanvasView(canvasView);
      }
    });
  }
  // 为单个Canvas视图添加按钮
  addButtonToCanvasView(canvasView) {
    const containerEl = canvasView.containerEl;
    if (this.canvasViewButtons.has(containerEl)) {
      return;
    }
    DebugManager.log("Adding button to Canvas view");
    DebugManager.log("Container element:", containerEl);
    this.analyzeCanvasDOM(containerEl);
    const menuContainer = this.findCanvasMenuContainer(containerEl);
    if (menuContainer) {
      DebugManager.log("Found Canvas menu container:", menuContainer);
      this.addButtonToCanvasMenu(menuContainer, containerEl);
    } else {
      DebugManager.log("Canvas menu container not found, using fallback");
      this.addButtonToCanvasViewFallback(canvasView);
    }
  }
  // 分析Canvas DOM结构
  analyzeCanvasDOM(containerEl) {
    DebugManager.log("=== Canvas DOM Structure Analysis ===");
    const toolbarSelectors = [
      ".canvas-controls",
      // Canvas控制区域
      ".canvas-toolbar",
      // Canvas工具栏
      ".canvas-menu",
      // Canvas菜单
      ".canvas-control-bar",
      // Canvas控制栏
      ".canvas-actions",
      // Canvas操作区域
      ".canvas-buttons",
      // Canvas按钮区域
      ".canvas-tools",
      // Canvas工具区域
      ".canvas-ui",
      // Canvas UI区域
      ".canvas-interface",
      // Canvas界面区域
      '[class*="canvas"][class*="control"]',
      // 包含canvas和control的类
      '[class*="canvas"][class*="toolbar"]',
      // 包含canvas和toolbar的类
      '[class*="canvas"][class*="menu"]'
      // 包含canvas和menu的类
    ];
    toolbarSelectors.forEach((selector) => {
      const elements = containerEl.querySelectorAll(selector);
      if (elements.length > 0) {
        DebugManager.log(`Found ${elements.length} elements with selector: ${selector}`);
        elements.forEach((el, index) => {
          DebugManager.log(`  [${index}]:`, el.className, el.getAttribute("aria-label"));
          const children = el.children;
          DebugManager.log(`    Children count: ${children.length}`);
          for (let i = 0; i < Math.min(children.length, 5); i++) {
            DebugManager.log(`    Child[${i}]:`, children[i].className, children[i].getAttribute("aria-label"));
          }
        });
      }
    });
    const iconElements = containerEl.querySelectorAll('.clickable-icon, [class*="icon"], [aria-label*="help"], [aria-label*="Help"], [aria-label*="\u5E2E\u52A9"]');
    DebugManager.log(`Found ${iconElements.length} icon elements:`);
    iconElements.forEach((el, index) => {
      DebugManager.log(`  Icon[${index}]:`, el.className, el.getAttribute("aria-label"), el.parentElement?.className);
    });
    const canvasSelectors = [
      ".canvas-wrapper",
      ".canvas-container",
      ".canvas-viewport"
    ];
    canvasSelectors.forEach((selector) => {
      const element = containerEl.querySelector(selector);
      if (element) {
        DebugManager.log(`Found Canvas element: ${selector}`, element);
      }
    });
  }
  // 查找Canvas菜单容器
  findCanvasMenuContainer(containerEl) {
    const toolbarSelectors = [
      ".canvas-controls",
      // Canvas控制区域
      ".canvas-toolbar",
      // Canvas工具栏
      ".canvas-menu",
      // Canvas菜单
      ".canvas-control-bar",
      // Canvas控制栏
      ".canvas-actions",
      // Canvas操作区域
      '[class*="canvas"][class*="control"]',
      // 包含canvas和control的类
      '[class*="canvas"][class*="toolbar"]'
      // 包含canvas和toolbar的类
    ];
    for (const selector of toolbarSelectors) {
      const toolbar = containerEl.querySelector(selector);
      if (toolbar) {
        DebugManager.log(`Found Canvas toolbar with selector: ${selector}`);
        return toolbar;
      }
    }
    const helpButtons = containerEl.querySelectorAll('[aria-label*="help"], [aria-label*="Help"], [aria-label*="\u5E2E\u52A9"], [title*="help"], [title*="Help"], [title*="\u5E2E\u52A9"]');
    for (let i = 0; i < helpButtons.length; i++) {
      const helpButton = helpButtons[i];
      const parent = helpButton.parentElement;
      if (parent && this.isValidToolbarContainer(parent)) {
        DebugManager.log("Found toolbar container via help button:", parent);
        return parent;
      }
    }
    const fallbackSelectors = [
      ".view-actions",
      ".view-header-nav-buttons",
      ".workspace-leaf-header .view-actions",
      ".view-header"
    ];
    for (const selector of fallbackSelectors) {
      const container = containerEl.querySelector(selector);
      if (container) {
        DebugManager.log(`Found fallback menu container with selector: ${selector}`);
        return container;
      }
    }
    return null;
  }
  // 验证是否为有效的工具栏容器
  isValidToolbarContainer(element) {
    const icons = element.querySelectorAll('.clickable-icon, [class*="icon"]');
    return icons.length >= 2;
  }
  // 将按钮添加到Canvas原生菜单中
  addButtonToCanvasMenu(menuContainer, containerEl) {
    const helpButton = this.findHelpButton(menuContainer);
    const gridButton = document.createElement("div");
    gridButton.className = "clickable-icon";
    gridButton.setAttribute("aria-label", "\u5207\u6362\u5230\u7F51\u683C\u89C6\u56FE");
    gridButton.setAttribute("data-tooltip-position", "left");
    gridButton.style.cssText = `
			border: 1px solid var(--background-modifier-border) !important;
			background: var(--background-secondary) !important;
			border-radius: 4px !important;
			box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1) !important;
		`;
    gridButton.innerHTML = `
			<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<rect x="3" y="3" width="7" height="7"/>
				<rect x="14" y="3" width="7" height="7"/>
				<rect x="3" y="14" width="7" height="7"/>
				<rect x="14" y="14" width="7" height="7"/>
			</svg>
		`;
    gridButton.onclick = () => {
      DebugManager.log("Grid button clicked from Canvas toolbar");
      this.activateViewWithAutoLink(containerEl);
    };
    if (helpButton && helpButton.parentElement === menuContainer) {
      const nextSibling = helpButton.nextSibling;
      if (nextSibling) {
        menuContainer.insertBefore(gridButton, nextSibling);
      } else {
        menuContainer.appendChild(gridButton);
      }
      DebugManager.log("Button inserted after help button");
    } else {
      menuContainer.appendChild(gridButton);
      DebugManager.log("Button appended to toolbar end");
    }
    DebugManager.log("Button added to Canvas toolbar successfully");
    this.canvasViewButtons.set(containerEl, gridButton);
  }
  // 查找帮助按钮
  findHelpButton(container) {
    const helpSelectors = [
      '[aria-label*="help"]',
      '[aria-label*="Help"]',
      '[aria-label*="\u5E2E\u52A9"]',
      '[title*="help"]',
      '[title*="Help"]',
      '[title*="\u5E2E\u52A9"]'
    ];
    for (const selector of helpSelectors) {
      const helpButton = container.querySelector(selector);
      if (helpButton) {
        DebugManager.log("Found help button:", helpButton);
        return helpButton;
      }
    }
    return null;
  }
  // 判断是否为垂直工具栏
  isVerticalToolbar(container) {
    const rect = container.getBoundingClientRect();
    return rect.height > rect.width;
  }
  // 回退方案：添加到右上角独立位置
  addButtonToCanvasViewFallback(canvasView) {
    const containerEl = canvasView.containerEl;
    const canvasContainer = containerEl.querySelector(".canvas-wrapper") || containerEl.querySelector(".canvas-container") || containerEl.querySelector(".view-content") || containerEl;
    if (!canvasContainer) {
      DebugManager.log("Canvas container not found for fallback");
      return;
    }
    const buttonContainer = document.createElement("div");
    buttonContainer.style.cssText = `
			position: absolute;
			top: 10px;
			right: 10px;
			z-index: var(--layer-modal);
		`;
    const gridButton = document.createElement("div");
    gridButton.className = "clickable-icon";
    gridButton.setAttribute("aria-label", "\u5207\u6362\u5230\u7F51\u683C\u89C6\u56FE");
    gridButton.setAttribute("data-tooltip-position", "left");
    gridButton.style.cssText = `
			background: var(--background-secondary) !important;
			border: 1px solid var(--background-modifier-border) !important;
			border-radius: 4px !important;
			box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1) !important;
		`;
    gridButton.innerHTML = `
			<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<rect x="3" y="3" width="7" height="7"/>
				<rect x="14" y="3" width="7" height="7"/>
				<rect x="3" y="14" width="7" height="7"/>
				<rect x="14" y="14" width="7" height="7"/>
			</svg>
		`;
    gridButton.onclick = () => {
      DebugManager.log("Grid button clicked from fallback position");
      this.activateViewWithAutoLink(containerEl);
    };
    buttonContainer.appendChild(gridButton);
    canvasContainer.appendChild(buttonContainer);
    DebugManager.log("Fallback button added successfully");
    this.canvasViewButtons.set(containerEl, buttonContainer);
  }
  // 移除所有Canvas视图按钮
  removeAllCanvasViewButtons() {
    this.canvasViewButtons.forEach((button, container) => {
      if (button.parentNode) {
        button.parentNode.removeChild(button);
      }
    });
    this.canvasViewButtons.clear();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async resetSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS);
    await this.saveData(this.settings);
    i18n.setLanguage(this.settings.language);
  }
  /**
   * 加载拖拽系统样式
   */
  loadDragSystemStyles() {
    if (this.dragSystemStyleElement) {
      return;
    }
    const cssContent = this.getDragSystemCSS();
    this.dragSystemStyleElement = document.createElement("style");
    this.dragSystemStyleElement.id = "canvas-grid-drag-system-styles";
    this.dragSystemStyleElement.textContent = cssContent;
    document.head.appendChild(this.dragSystemStyleElement);
    DebugManager.log("\u{1F3A8} Drag system styles loaded");
  }
  /**
   * 卸载拖拽系统样式
   */
  unloadDragSystemStyles() {
    if (this.dragSystemStyleElement) {
      document.head.removeChild(this.dragSystemStyleElement);
      this.dragSystemStyleElement = null;
      DebugManager.log("\u{1F3A8} Drag system styles unloaded");
    }
  }
  /**
   * 卸载编辑指示器样式 - 修复样式泄露问题
   */
  unloadEditingIndicatorStyles() {
    const editingStyleElement = document.querySelector("#editing-indicator-styles");
    if (editingStyleElement) {
      document.head.removeChild(editingStyleElement);
      DebugManager.log("\u{1F3A8} Editing indicator styles unloaded - \u4FEE\u590D\u6837\u5F0F\u6CC4\u9732");
    }
  }
  /**
   * 清理所有动态注入的样式 - 防止样式泄露
   */
  cleanupAllDynamicStyles() {
    this.unloadDragSystemStyles();
    this.unloadEditingIndicatorStyles();
    const dynamicStyles = document.querySelectorAll('style[id^="canvas-grid-"], style[id*="editing-indicator"]');
    dynamicStyles.forEach((style) => {
      if (style.parentNode) {
        style.parentNode.removeChild(style);
        DebugManager.log("\u{1F9F9} Removed dynamic style:", style.id);
      }
    });
  }
  /**
   * 获取拖拽系统CSS内容
   */
  getDragSystemCSS() {
    return `
/* ==================== \u62D6\u62FD\u7CFB\u7EDF\u6837\u5F0F ==================== */

/* \u62D6\u62FD\u9884\u89C8\u6837\u5F0F */
.drag-preview {
    position: fixed;
    pointer-events: none;
    z-index: var(--layer-popover);
    opacity: 0.8;
    transform: rotate(3deg);
    transition: all 0.2s ease;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    border-radius: 8px;
    background: var(--background-primary);
    border: 2px solid var(--interactive-accent);
    max-width: GRID_CONSTANTS.CARD_WIDTHpx;
    min-width: 200px;
    overflow: hidden;
}

.drag-preview.dragging {
    opacity: 0.9;
    transform: rotate(0deg) scale(1.05);
}

.drag-preview-content {
    padding: 12px;
    display: flex;
    align-items: center;
    gap: 8px;
    position: relative;
}

.drag-preview-icon {
    font-size: 20px;
    flex-shrink: 0;
    opacity: 0.8;
}

.drag-preview-text {
    color: var(--text-normal);
    font-size: 14px;
    line-height: 1.4;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    flex: 1;
    min-width: 0;
}

.drag-preview-badge {
    position: absolute;
    top: -2px;
    right: -2px;
    background: var(--interactive-accent);
    color: var(--text-on-accent);
    font-size: 10px;
    font-weight: 600;
    padding: 2px 6px;
    border-radius: 0 6px 0 6px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

/* \u4E0D\u540C\u7C7B\u578B\u7684\u9884\u89C8\u6837\u5F0F */
.drag-preview-text-type { border-color: var(--color-blue); }
.drag-preview-text-type .drag-preview-badge { background: var(--color-blue); }
.drag-preview-file-type { border-color: var(--color-green); }
.drag-preview-file-type .drag-preview-badge { background: var(--color-green); }
.drag-preview-card-type { border-color: var(--color-purple); }
.drag-preview-card-type .drag-preview-badge { background: var(--color-purple); }
.drag-preview-group-type { border-color: var(--color-orange); }
.drag-preview-group-type .drag-preview-badge { background: var(--color-orange); }

/* \u62D6\u62FD\u72B6\u6001\u6837\u5F0F */
.dragging-from-grid {
    opacity: 0.6;
    transform: scale(0.95) rotate(2deg);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    cursor: grabbing !important;
    z-index: var(--layer-modal);
    position: relative;
}

.dragging-from-grid::before {
    content: '';
    position: absolute;
    top: -4px;
    left: -4px;
    right: -4px;
    bottom: -4px;
    background: var(--interactive-accent);
    opacity: 0.2;
    border-radius: inherit;
    pointer-events: none;
    animation: drag-pulse 1.5s ease-in-out infinite;
}

/* \u653E\u7F6E\u76EE\u6807\u6307\u793A\u5668 */
.can-drop {
    position: relative;
    transition: all 0.2s ease;
}

.can-drop::before {
    content: '';
    position: absolute;
    top: -2px;
    left: -2px;
    right: -2px;
    bottom: -2px;
    border: 2px solid var(--interactive-accent);
    border-radius: 8px;
    opacity: 0.6;
    animation: pulse-border 1.5s ease-in-out infinite;
    pointer-events: none;
}

.can-drop.drop-effect-copy::before {
    border-color: var(--color-green);
}

.can-drop.drop-effect-move::before {
    border-color: var(--color-orange);
}

/* \u52A8\u753B\u5B9A\u4E49 */
@keyframes pulse-border {
    0%, 100% { opacity: 0.6; transform: scale(1); }
    50% { opacity: 1; transform: scale(1.02); }
}

@keyframes drag-pulse {
    0%, 100% { opacity: 0.2; transform: scale(1); }
    50% { opacity: 0.4; transform: scale(1.02); }
}

/* \u6DF1\u8272\u4E3B\u9898\u9002\u914D */
.theme-dark .drag-preview {
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
}

/* \u51CF\u5C11\u52A8\u753B\u6A21\u5F0F */
@media (prefers-reduced-motion: reduce) {
    .drag-preview,
    .dragging-from-grid,
    .can-drop {
        transition: none;
        animation: none;
    }

    .can-drop::before {
        animation: none;
    }
}
`;
  }
  // ==================== 时间胶囊功能方法 ====================
  // 收集内容到时间胶囊
  collectToTimeCapsule() {
    const gridView = this.getActiveGridView();
    if (!gridView) {
      new import_obsidian12.Notice("\u8BF7\u5148\u6253\u5F00Canvas\u7F51\u683C\u89C6\u56FE");
      return;
    }
    if (!gridView.isTimeCapsuleActive()) {
      new import_obsidian12.Notice("\u65F6\u95F4\u80F6\u56CA\u672A\u6FC0\u6D3B\uFF0C\u8BF7\u5148\u542F\u52A8\u65F6\u95F4\u80F6\u56CA");
      return;
    }
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian12.MarkdownView);
    if (activeView) {
      const editor = activeView.editor;
      const selectedText = editor.getSelection();
      if (selectedText) {
        gridView.collectToTimeCapsule(selectedText, {
          sourceFile: activeView.file,
          sourcePath: activeView.file?.path || "",
          sourcePosition: {
            line: editor.getCursor("from").line,
            ch: editor.getCursor("from").ch
          }
        });
        new import_obsidian12.Notice("\u5185\u5BB9\u5DF2\u6536\u96C6\u5230\u65F6\u95F4\u80F6\u56CA");
      } else {
        new import_obsidian12.Notice("\u8BF7\u5148\u9009\u62E9\u8981\u6536\u96C6\u7684\u5185\u5BB9");
      }
    } else {
      navigator.clipboard.readText().then((text) => {
        if (text && text.trim()) {
          gridView.collectToTimeCapsule(text.trim(), {
            sourceFile: null,
            sourcePath: "\u526A\u8D34\u677F",
            sourcePosition: null
          });
          new import_obsidian12.Notice("\u526A\u8D34\u677F\u5185\u5BB9\u5DF2\u6536\u96C6\u5230\u65F6\u95F4\u80F6\u56CA");
        } else {
          new import_obsidian12.Notice("\u526A\u8D34\u677F\u4E3A\u7A7A\u6216\u65E0\u53EF\u6536\u96C6\u5185\u5BB9");
        }
      }).catch(() => {
        new import_obsidian12.Notice("\u65E0\u6CD5\u8BBF\u95EE\u526A\u8D34\u677F");
      });
    }
  }
  // 切换时间胶囊状态
  toggleTimeCapsule() {
    const gridView = this.getActiveGridView();
    if (!gridView) {
      new import_obsidian12.Notice("\u8BF7\u5148\u6253\u5F00Canvas\u7F51\u683C\u89C6\u56FE");
      return;
    }
    gridView.toggleTimeCapsule();
  }
  async activateView() {
    const { workspace } = this.app;
    const activeFile = workspace.getActiveFile();
    let leaf = null;
    const leaves = workspace.getLeavesOfType(CANVAS_GRID_VIEW_TYPE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({ type: CANVAS_GRID_VIEW_TYPE, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
      if (activeFile && activeFile.extension === "canvas") {
        const gridView = leaf.view;
        if (gridView && gridView.setLinkedCanvas) {
          try {
            await gridView.setLinkedCanvas(activeFile);
            DebugManager.log("Auto-linked canvas file:", activeFile.path);
          } catch (error) {
            DebugManager.error("Failed to auto-link canvas file:", error);
          }
        }
      }
    }
  }
  // 🆕 激活时间线视图
  async activateTimelineView() {
    const { workspace } = this.app;
    const activeFile = workspace.getActiveFile();
    let leaf = null;
    const leaves = workspace.getLeavesOfType(CANVAS_TIMELINE_VIEW_TYPE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({ type: CANVAS_TIMELINE_VIEW_TYPE, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  // 激活视图并自动关联Canvas文件
  async activateViewWithAutoLink(canvasContainer) {
    const { workspace } = this.app;
    let canvasFile = null;
    const activeFile = workspace.getActiveFile();
    if (activeFile && activeFile.extension === "canvas") {
      canvasFile = activeFile;
    }
    if (!canvasFile) {
      const canvasLeaves = workspace.getLeavesOfType("canvas");
      for (const leaf2 of canvasLeaves) {
        const canvasView = leaf2.view;
        if (canvasView && canvasView.file) {
          canvasFile = canvasView.file;
          break;
        }
      }
    }
    let leaf = null;
    const leaves = workspace.getLeavesOfType(CANVAS_GRID_VIEW_TYPE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({ type: CANVAS_GRID_VIEW_TYPE, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
      if (canvasFile) {
        const gridView = leaf.view;
        if (gridView && gridView.setLinkedCanvas) {
          try {
            await gridView.setLinkedCanvas(canvasFile);
            DebugManager.log("Auto-linked canvas file from button:", canvasFile.path);
          } catch (error) {
            DebugManager.error("Failed to auto-link canvas file from button:", error);
          }
        }
      }
    }
  }
};
var TabNavigationSettingTab = class extends import_obsidian12.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.currentTab = "basic";
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    i18n.setLanguage(this.plugin.settings.language);
    this.createMainContainer(containerEl);
    this.createNavigationBar();
    this.createContentContainer();
    this.showTabContent(this.currentTab);
  }
  createMainContainer(containerEl) {
    const titleContainer = containerEl.createDiv("canvas-grid-title-container");
    titleContainer.style.cssText = `
			display: flex;
			align-items: center;
			margin-bottom: 24px;
			padding-bottom: 16px;
			border-bottom: 2px solid var(--background-modifier-border);
		`;
    const titleIcon = titleContainer.createSpan("canvas-grid-title-icon");
    titleIcon.innerHTML = "\u{1F3AF}";
    titleIcon.style.cssText = `
			font-size: 24px;
			margin-right: 12px;
		`;
    const titleText = titleContainer.createEl("h1", {
      text: "Canvas Grid Transit",
      cls: "canvas-grid-title"
    });
    titleText.style.cssText = `
			margin: 0;
			font-size: 24px;
			font-weight: 600;
			color: var(--text-normal);
		`;
    const versionBadge = titleContainer.createSpan("version-badge");
    versionBadge.textContent = "v0.5.0";
    versionBadge.style.cssText = `
			margin-left: auto;
			background: var(--interactive-accent);
			color: white;
			padding: 4px 8px;
			border-radius: 12px;
			font-size: 12px;
			font-weight: 500;
		`;
  }
  createNavigationBar() {
    this.tabContainer = this.containerEl.createDiv("canvas-grid-nav-container");
    this.tabContainer.style.cssText = `
			display: flex;
			background: var(--background-secondary);
			border-radius: 8px;
			padding: 4px;
			margin-bottom: 24px;
			box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
		`;
    const tabs = [
      { id: "basic", name: this.plugin.settings.language === "zh" ? "\u57FA\u7840\u8BBE\u7F6E" : "Basic Settings", icon: "" },
      { id: "colors", name: this.plugin.settings.language === "zh" ? "\u989C\u8272\u5206\u7C7B" : "Color Categories", icon: "" },
      { id: "anki", name: this.plugin.settings.language === "zh" ? "Anki\u540C\u6B65" : "Anki Sync", icon: "" },
      { id: "about", name: this.plugin.settings.language === "zh" ? "\u5173\u4E8E" : "About", icon: "" }
    ];
    tabs.forEach((tab) => {
      const tabButton = this.tabContainer.createEl("button", {
        cls: "canvas-grid-nav-tab",
        attr: { "data-tab": tab.id }
      });
      tabButton.innerHTML = `
				<span class="tab-icon">${tab.icon}</span>
				<span class="tab-text">${tab.name}</span>
			`;
      tabButton.style.cssText = `
				flex: 1;
				display: flex;
				align-items: center;
				justify-content: center;
				gap: 8px;
				padding: 12px 16px;
				border: none;
				background: transparent;
				color: var(--text-muted);
				border-radius: 6px;
				cursor: pointer;
				transition: all 0.2s ease;
				font-size: 14px;
				font-weight: 500;
			`;
      if (tab.id === this.currentTab) {
        this.setActiveTab(tabButton);
      }
      tabButton.addEventListener("click", () => {
        this.switchTab(tab.id);
      });
    });
  }
  createContentContainer() {
    this.contentContainer = this.containerEl.createDiv("canvas-grid-content-container");
    this.contentContainer.style.cssText = `
			background: var(--background-primary);
			border-radius: 8px;
			padding: 0;
			box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
			min-height: 400px;
			width: 100%;
		`;
  }
  switchTab(tabId) {
    this.currentTab = tabId;
    this.tabContainer.querySelectorAll(".canvas-grid-nav-tab").forEach((tab) => {
      const button = tab;
      if (button.dataset.tab === tabId) {
        this.setActiveTab(button);
      } else {
        this.setInactiveTab(button);
      }
    });
    this.showTabContent(tabId);
  }
  setActiveTab(button) {
    button.style.cssText += `
			background: var(--interactive-accent);
			color: white;
			transform: translateY(-1px);
			box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
		`;
  }
  setInactiveTab(button) {
    button.style.cssText = button.style.cssText.replace(/background:.*?;|color:.*?;|transform:.*?;|box-shadow:.*?;/g, "") + `
			background: transparent;
			color: var(--text-muted);
			transform: none;
			box-shadow: none;
		`;
  }
  showTabContent(tabId) {
    this.contentContainer.empty();
    switch (tabId) {
      case "basic":
        this.renderBasicSettings();
        break;
      case "colors":
        this.renderColorSettings();
        break;
      case "anki":
        this.renderAnkiSettings();
        break;
      case "about":
        this.renderAboutPage();
        break;
    }
  }
  // 基础设置标签页
  renderBasicSettings() {
    const container = this.contentContainer;
    const layoutSection = this.createSettingSection(container, "\u7F51\u683C\u5E03\u5C40\u8BBE\u7F6E", "Grid Layout Settings");
    new import_obsidian12.Setting(layoutSection).setName(this.plugin.settings.language === "zh" ? "\u542F\u7528\u81EA\u52A8\u5E03\u5C40" : "Enable Auto Layout").setDesc(this.plugin.settings.language === "zh" ? "\u81EA\u52A8\u8C03\u6574\u5361\u7247\u5E03\u5C40\u4EE5\u9002\u5E94\u5BB9\u5668\u5BBD\u5EA6" : "Automatically adjust card layout to fit container width").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableAutoLayout).onChange(async (value) => {
      this.plugin.settings.enableAutoLayout = value;
      await this.plugin.saveSettings();
    }));
    const languageSection = this.createSettingSection(container, "\u754C\u9762\u8BED\u8A00", "Interface Language");
    new import_obsidian12.Setting(languageSection).setName(this.plugin.settings.language === "zh" ? "\u754C\u9762\u8BED\u8A00" : "Interface Language").setDesc(this.plugin.settings.language === "zh" ? "\u9009\u62E9\u63D2\u4EF6\u754C\u9762\u663E\u793A\u8BED\u8A00" : "Select the display language for the plugin interface").addDropdown((dropdown) => dropdown.addOption("zh", "\u4E2D\u6587 (\u7B80\u4F53)").addOption("en", "English").setValue(this.plugin.settings.language).onChange(async (value) => {
      this.plugin.settings.language = value;
      await this.plugin.saveSettings();
      this.display();
      this.updateAllGridViews();
    }));
    this.createPinnedCardsSection(container);
  }
  // 颜色分类标签页
  renderColorSettings() {
    const container = this.contentContainer;
    this.createUnifiedColorSection(container);
  }
  // 功能键设置标签页
  renderHotkeysSettings() {
    const container = this.contentContainer;
    this.createSectionTitle(container, "\u2328\uFE0F \u5FEB\u6377\u952E\u8BBE\u7F6E", "Hotkey Settings");
    const hotkeyInfo = container.createDiv("hotkey-info");
    hotkeyInfo.style.cssText = `
			background: var(--background-secondary);
			border-radius: 8px;
			padding: 16px;
			margin-bottom: 24px;
			border-left: 4px solid var(--interactive-accent);
		`;
    hotkeyInfo.createEl("p", {
      text: this.plugin.settings.language === "zh" ? '\u5FEB\u6377\u952E\u53EF\u4EE5\u5728 Obsidian \u8BBE\u7F6E \u2192 \u5FEB\u6377\u952E \u4E2D\u8FDB\u884C\u914D\u7F6E\u3002\u641C\u7D22 "Canvas Grid" \u627E\u5230\u76F8\u5173\u547D\u4EE4\u3002' : 'Hotkeys can be configured in Obsidian Settings \u2192 Hotkeys. Search for "Canvas Grid" to find related commands.',
      cls: "setting-item-description"
    });
    const hotkeyList = container.createDiv("hotkey-list");
    const hotkeys = [
      { command: "Open Canvas Grid View", key: "Ctrl+Shift+G", desc: "\u6253\u5F00Canvas\u7F51\u683C\u89C6\u56FE" },
      { command: "Toggle Grid Layout", key: "\u672A\u8BBE\u7F6E", desc: "\u5207\u6362\u7F51\u683C\u5E03\u5C40\u6A21\u5F0F" },
      { command: "Refresh Grid View", key: "F5", desc: "\u5237\u65B0\u7F51\u683C\u89C6\u56FE" }
    ];
    hotkeys.forEach((hotkey) => {
      const item = hotkeyList.createDiv("hotkey-item");
      item.style.cssText = `
				display: flex;
				justify-content: space-between;
				align-items: center;
				padding: 12px 0;
				border-bottom: 1px solid var(--background-modifier-border);
			`;
      const info = item.createDiv();
      info.createEl("strong", { text: hotkey.command });
      info.createEl("br");
      info.createEl("span", {
        text: this.plugin.settings.language === "zh" ? hotkey.desc : hotkey.command,
        cls: "setting-item-description"
      });
      const keyBadge = item.createSpan("key-badge");
      keyBadge.textContent = hotkey.key;
      keyBadge.style.cssText = `
				background: var(--background-secondary);
				padding: 4px 8px;
				border-radius: 4px;
				font-family: monospace;
				font-size: 12px;
				color: var(--text-muted);
			`;
    });
  }
  // Anki同步设置标签页
  renderAnkiSettings() {
    const container = this.contentContainer;
    const connectionSection = this.createSettingSection(
      container,
      this.plugin.settings.language === "zh" ? "Anki Connect\u8FDE\u63A5" : "Anki Connect Connection",
      this.plugin.settings.language === "zh" ? "Anki Connect Connection" : "Anki Connect Connection"
    );
    new import_obsidian12.Setting(connectionSection).setName(this.plugin.settings.language === "zh" ? "\u542F\u7528Anki Connect\u540C\u6B65" : "Enable Anki Connect Sync").setDesc(this.plugin.settings.language === "zh" ? "\u8FDE\u63A5\u5230Anki\u8FDB\u884C\u5361\u7247\u540C\u6B65" : "Connect to Anki for card synchronization").addToggle((toggle) => toggle.setValue(this.plugin.settings.ankiConnect.enabled).onChange(async (value) => {
      this.plugin.settings.ankiConnect.enabled = value;
      await this.plugin.saveSettings();
      this.refreshAnkiSettings();
    }));
    new import_obsidian12.Setting(connectionSection).setName(this.plugin.settings.language === "zh" ? "API\u5730\u5740" : "API URL").setDesc(this.plugin.settings.language === "zh" ? "Anki Connect\u670D\u52A1\u5730\u5740" : "Anki Connect service URL").addText((text) => text.setPlaceholder("http://localhost:8765").setValue(this.plugin.settings.ankiConnect.apiUrl).onChange(async (value) => {
      this.plugin.settings.ankiConnect.apiUrl = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian12.Setting(connectionSection).setName(this.plugin.settings.language === "zh" ? "API\u5BC6\u94A5\uFF08\u53EF\u9009\uFF09" : "API Key (Optional)").setDesc(this.plugin.settings.language === "zh" ? "\u5982\u679CAnki Connect\u914D\u7F6E\u4E86\u5BC6\u94A5\u9A8C\u8BC1" : "If Anki Connect is configured with key authentication").addText((text) => text.setPlaceholder(this.plugin.settings.language === "zh" ? "\u7559\u7A7A\u8868\u793A\u65E0\u9700\u5BC6\u94A5" : "Leave empty if no key required").setValue(this.plugin.settings.ankiConnect.apiKey || "").onChange(async (value) => {
      this.plugin.settings.ankiConnect.apiKey = value || void 0;
      await this.plugin.saveSettings();
    }));
    new import_obsidian12.Setting(connectionSection).setName(this.plugin.settings.language === "zh" ? "\u8FDE\u63A5\u6D4B\u8BD5" : "Connection Test").setDesc(this.plugin.settings.language === "zh" ? "\u6D4B\u8BD5\u4E0EAnki Connect\u7684\u8FDE\u63A5" : "Test connection to Anki Connect").addButton((button) => button.setButtonText(this.plugin.settings.language === "zh" ? "\u6D4B\u8BD5\u8FDE\u63A5" : "Test Connection").onClick(async () => {
      await this.testAnkiConnection();
    }));
    const syncSection = this.createSettingSection(
      container,
      this.plugin.settings.language === "zh" ? "\u540C\u6B65\u914D\u7F6E" : "Sync Configuration",
      this.plugin.settings.language === "zh" ? "Sync Configuration" : "Sync Configuration"
    );
    const deckSetting = new import_obsidian12.Setting(syncSection).setName(this.plugin.settings.language === "zh" ? "\u9ED8\u8BA4\u724C\u7EC4" : "Default Deck").setDesc(this.plugin.settings.language === "zh" ? "\u5361\u7247\u5C06\u540C\u6B65\u5230\u6B64\u724C\u7EC4" : "Cards will be synced to this deck");
    deckSetting.addText((text) => text.setPlaceholder("Default").setValue(this.plugin.settings.ankiConnect.defaultDeck).onChange(async (value) => {
      this.plugin.settings.ankiConnect.defaultDeck = value;
      await this.plugin.saveSettings();
    }));
    deckSetting.addButton((button) => button.setButtonText(this.plugin.settings.language === "zh" ? "\u5237\u65B0\u724C\u7EC4" : "Refresh Decks").setTooltip(this.plugin.settings.language === "zh" ? "\u4ECEAnki\u83B7\u53D6\u724C\u7EC4\u5217\u8868" : "Get deck list from Anki").onClick(async () => {
      console.log("\u5237\u65B0\u724C\u7EC4\u5217\u8868\u529F\u80FD\u5F85\u5B9E\u73B0");
    }));
    new import_obsidian12.Setting(syncSection).setName(this.plugin.settings.language === "zh" ? "\u5361\u7247\u6A21\u677F" : "Card Template").setDesc(this.plugin.settings.language === "zh" ? "\u4F7F\u7528\u7684Anki\u5361\u7247\u6A21\u677F" : "Anki card template to use").addText((text) => text.setPlaceholder("Basic").setValue(this.plugin.settings.ankiConnect.modelName).onChange(async (value) => {
      this.plugin.settings.ankiConnect.modelName = value;
      await this.plugin.saveSettings();
    }));
    this.createSyncColorSelection(syncSection);
    new import_obsidian12.Setting(syncSection).setName(this.plugin.settings.language === "zh" ? "\u5185\u5BB9\u5206\u9694\u7B26" : "Content Divider").setDesc(this.plugin.settings.language === "zh" ? "\u7528\u4E8E\u5206\u9694\u6B63\u9762\u548C\u80CC\u9762\u5185\u5BB9\u7684\u6807\u8BB0\uFF0C\u5206\u9694\u7B26\u524D\u7684\u5185\u5BB9\u663E\u793A\u5728\u6B63\u9762\uFF0C\u540E\u7684\u5185\u5BB9\u663E\u793A\u5728\u80CC\u9762" : "Marker to separate front and back content. Content before divider shows on front, after shows on back").addText((text) => text.setPlaceholder("---div---").setValue(this.plugin.settings.ankiConnect.contentDivider).onChange(async (value) => {
      if (!value || value.trim().length === 0) {
        value = "---div---";
      }
      this.plugin.settings.ankiConnect.contentDivider = value.trim();
      await this.plugin.saveSettings();
    }));
    new import_obsidian12.Setting(syncSection).setName(this.plugin.settings.language === "zh" ? "\u542F\u7528\u589E\u91CF\u540C\u6B65" : "Enable Incremental Sync").setDesc(this.plugin.settings.language === "zh" ? "\u53EA\u540C\u6B65\u53D8\u66F4\u7684\u5361\u7247\uFF0C\u907F\u514D\u91CD\u590D\u521B\u5EFA" : "Only sync changed cards to avoid duplicates").addToggle((toggle) => toggle.setValue(this.plugin.settings.ankiConnect.enableIncrementalSync).onChange(async (value) => {
      this.plugin.settings.ankiConnect.enableIncrementalSync = value;
      await this.plugin.saveSettings();
    }));
    const advancedSection = this.createSettingSection(
      container,
      this.plugin.settings.language === "zh" ? "\u9AD8\u7EA7\u8BBE\u7F6E" : "Advanced Settings",
      this.plugin.settings.language === "zh" ? "Advanced Settings" : "Advanced Settings"
    );
    new import_obsidian12.Setting(advancedSection).setName(this.plugin.settings.language === "zh" ? "\u6279\u6B21\u5927\u5C0F" : "Batch Size").setDesc(this.plugin.settings.language === "zh" ? "\u6BCF\u6B21\u540C\u6B65\u7684\u5361\u7247\u6570\u91CF" : "Number of cards to sync at once").addSlider((slider) => slider.setLimits(10, 200, 10).setValue(this.plugin.settings.ankiConnect.batchSize).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.ankiConnect.batchSize = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian12.Setting(advancedSection).setName(this.plugin.settings.language === "zh" ? "\u91CD\u8BD5\u6B21\u6570" : "Retry Attempts").setDesc(this.plugin.settings.language === "zh" ? "\u8FDE\u63A5\u5931\u8D25\u65F6\u7684\u91CD\u8BD5\u6B21\u6570" : "Number of retry attempts on connection failure").addSlider((slider) => slider.setLimits(1, 10, 1).setValue(this.plugin.settings.ankiConnect.retryAttempts).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.ankiConnect.retryAttempts = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian12.Setting(advancedSection).setName(this.plugin.settings.language === "zh" ? "\u8D85\u65F6\u65F6\u95F4\uFF08\u79D2\uFF09" : "Timeout (seconds)").setDesc(this.plugin.settings.language === "zh" ? "\u8BF7\u6C42\u8D85\u65F6\u65F6\u95F4" : "Request timeout duration").addSlider((slider) => slider.setLimits(3, 30, 1).setValue(this.plugin.settings.ankiConnect.timeout / 1e3).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.ankiConnect.timeout = value * 1e3;
      await this.plugin.saveSettings();
    }));
  }
  // 关于页面
  renderAboutPage() {
    const container = this.contentContainer;
    const titleSection = container.createDiv("plugin-title-section");
    titleSection.style.cssText = `
			text-align: center;
			margin-bottom: 32px;
		`;
    titleSection.createEl("h1", {
      text: "Canvas Grid Transit",
      attr: { style: "margin: 0 0 8px 0; font-size: 28px; font-weight: 700; color: var(--text-normal);" }
    });
    titleSection.createEl("p", {
      text: `v0.5.1 by Tuanki Team`,
      attr: { style: "margin: 0; color: var(--text-muted); font-size: 14px;" }
    });
    const featuresSection = container.createDiv("main-features-section");
    featuresSection.style.cssText = `
			background: var(--background-secondary);
			border-radius: 12px;
			padding: 24px;
			margin-bottom: 24px;
			border: 1px solid var(--background-modifier-border);
		`;
    featuresSection.createEl("h3", {
      text: this.plugin.settings.language === "zh" ? "\u4E3B\u8981\u529F\u80FD\u4ECB\u7ECD" : "Key Features",
      attr: { style: "margin: 0 0 20px 0; font-size: 18px; font-weight: 600; text-align: center;" }
    });
    const features = this.plugin.settings.language === "zh" ? [
      { icon: "\u{1F3AF}", title: "\u7F51\u683C\u89C6\u56FE", desc: "\u4EE5\u7F51\u683C\u5F62\u5F0F\u5C55\u793ACanvas\u5185\u5BB9\uFF0C\u652F\u6301\u54CD\u5E94\u5F0F\u5E03\u5C40" },
      { icon: "\u{1F517}", title: "\u5757\u5F15\u7528", desc: "\u81EA\u52A8\u521B\u5EFAObsidian\u5757\u94FE\u63A5\uFF0C\u65E0\u7F1D\u96C6\u6210\u7B14\u8BB0\u7CFB\u7EDF" },
      { icon: "\u{1F3A8}", title: "\u989C\u8272\u7BA1\u7406", desc: "\u7EDF\u4E00\u7684\u989C\u8272\u5206\u7C7B\u548C\u7B5B\u9009\uFF0C\u652F\u6301\u81EA\u5B9A\u4E49\u6807\u7B7E" },
      { icon: "\u{1F680}", title: "\u62D6\u62FD\u64CD\u4F5C", desc: "\u76F4\u89C2\u7684\u62D6\u62FD\u4EA4\u4E92\u4F53\u9A8C\uFF0C\u652F\u6301\u6279\u91CF\u64CD\u4F5C" },
      { icon: "\u{1F4CC}", title: "\u7F6E\u9876\u529F\u80FD", desc: "\u91CD\u8981\u5185\u5BB9\u7F6E\u9876\u663E\u793A\uFF0C\u63D0\u9AD8\u5DE5\u4F5C\u6548\u7387" },
      { icon: "\u{1F0CF}", title: "Anki Connect", desc: "\u4E0EAnki\u8BB0\u5FC6\u8F6F\u4EF6\u65E0\u7F1D\u96C6\u6210\uFF0C\u521B\u5EFA\u9AD8\u6548\u5B66\u4E60\u5361\u7247" }
    ] : [
      { icon: "\u{1F3AF}", title: "Grid View", desc: "Display Canvas content in responsive grid format" },
      { icon: "\u{1F517}", title: "Block Reference", desc: "Auto-create Obsidian block links, seamless note integration" },
      { icon: "\u{1F3A8}", title: "Color Management", desc: "Unified color categorization and filtering with custom tags" },
      { icon: "\u{1F680}", title: "Drag Operations", desc: "Intuitive drag and drop interactions with batch operations" },
      { icon: "\u{1F4CC}", title: "Pin Function", desc: "Pin important content for improved productivity" },
      { icon: "\u{1F0CF}", title: "Anki Connect", desc: "Seamless integration with Anki memory software for efficient learning cards" }
    ];
    const featureGrid = featuresSection.createDiv("feature-grid");
    featureGrid.style.cssText = `
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
			gap: 16px;
		`;
    features.forEach((feature) => {
      const featureCard = featureGrid.createDiv("feature-card");
      featureCard.style.cssText = `
				background: var(--background-primary);
				border-radius: 8px;
				padding: 16px;
				text-align: center;
				border: 1px solid var(--background-modifier-border);
				transition: transform 0.2s ease, border-color 0.2s ease;
			`;
      featureCard.addEventListener("mouseenter", () => {
        featureCard.style.transform = "translateY(-2px)";
        featureCard.style.borderColor = "var(--interactive-accent)";
      });
      featureCard.addEventListener("mouseleave", () => {
        featureCard.style.transform = "translateY(0)";
        featureCard.style.borderColor = "var(--background-modifier-border)";
      });
      featureCard.createDiv().innerHTML = feature.icon;
      featureCard.lastElementChild.setAttribute("style", "font-size: 24px; margin-bottom: 8px;");
      featureCard.createEl("h4", {
        text: feature.title,
        attr: { style: "margin: 0 0 6px 0; font-size: 14px; font-weight: 600;" }
      });
      featureCard.createEl("p", {
        text: feature.desc,
        attr: { style: "margin: 0; font-size: 12px; line-height: 1.3; color: var(--text-muted);" }
      });
    });
    this.createActionButtons(container);
  }
  // 创建底部功能按钮
  createActionButtons(container) {
    const buttonSection = container.createDiv("action-buttons-section");
    buttonSection.style.cssText = `
			display: flex;
			gap: 12px;
			justify-content: center;
			flex-wrap: wrap;
			margin-top: 24px;
		`;
    const buttons = [
      {
        icon: "\u{1F419}",
        text: "GitHub",
        action: () => window.open("https://github.com/zhuzhige123/Canvasgrid-Transit", "_blank")
      },
      {
        icon: "\u{1F4E7}",
        text: this.plugin.settings.language === "zh" ? "\u90AE\u7BB1" : "Email",
        action: () => window.open("mailto:tutaoyuan8@outlook.com", "_blank")
      },
      {
        icon: "\u{1F49D}",
        text: this.plugin.settings.language === "zh" ? "\u652F\u6301" : "Support",
        action: () => this.showSupportModal()
      },
      {
        icon: "\u{1F513}",
        text: this.plugin.settings.language === "zh" ? "\u5B8C\u5168\u5F00\u6E90" : "Open Source",
        action: () => this.showOpenSourceModal()
      }
    ];
    buttons.forEach((button) => {
      const buttonEl = buttonSection.createEl("button", {
        cls: "action-button"
      });
      buttonEl.style.cssText = `
				display: flex;
				align-items: center;
				gap: 8px;
				padding: 10px 16px;
				background: var(--background-secondary);
				border: 1px solid var(--background-modifier-border);
				border-radius: 8px;
				color: var(--text-normal);
				cursor: pointer;
				transition: all 0.2s ease;
				font-size: 13px;
				font-weight: 500;
			`;
      buttonEl.innerHTML = `
				<span style="font-size: 16px;">${button.icon}</span>
				<span>${button.text}</span>
			`;
      buttonEl.addEventListener("mouseenter", () => {
        buttonEl.style.background = "var(--interactive-hover)";
        buttonEl.style.borderColor = "var(--interactive-accent)";
        buttonEl.style.transform = "translateY(-1px)";
      });
      buttonEl.addEventListener("mouseleave", () => {
        buttonEl.style.background = "var(--background-secondary)";
        buttonEl.style.borderColor = "var(--background-modifier-border)";
        buttonEl.style.transform = "translateY(0)";
      });
      buttonEl.addEventListener("click", button.action);
    });
  }
  // 显示支持信息弹窗
  showSupportModal() {
    const modal = new import_obsidian12.Modal(this.plugin.app);
    modal.titleEl.setText(this.plugin.settings.language === "zh" ? "\u{1F49D} \u652F\u6301\u6211\u4EEC" : "\u{1F49D} Support Us");
    const content = modal.contentEl;
    content.style.cssText = `
			text-align: center;
			padding: 20px;
		`;
    content.createEl("p", {
      text: this.plugin.settings.language === "zh" ? "\u5982\u679C\u60A8\u559C\u6B22\u8FD9\u4E2A\u63D2\u4EF6\uFF0C\u8BF7\u8003\u8651\u7ED9\u6211\u4EEC\u4E00\u4E2A \u2B50 \u661F\u6807\u652F\u6301\uFF01" : "If you like this plugin, please consider giving us a \u2B50 star!",
      attr: { style: "margin-bottom: 16px; font-size: 14px; line-height: 1.5;" }
    });
    const githubButton = content.createEl("button", {
      text: this.plugin.settings.language === "zh" ? "\u524D\u5F80 GitHub" : "Go to GitHub"
    });
    githubButton.style.cssText = `
			background: var(--interactive-accent);
			color: white;
			border: none;
			padding: 8px 16px;
			border-radius: 6px;
			cursor: pointer;
			font-size: 13px;
		`;
    githubButton.addEventListener("click", () => {
      window.open("https://github.com/zhuzhige123/Canvasgrid-Transit", "_blank");
      modal.close();
    });
    modal.open();
  }
  // 显示开源信息弹窗
  showOpenSourceModal() {
    const modal = new import_obsidian12.Modal(this.plugin.app);
    modal.titleEl.setText(this.plugin.settings.language === "zh" ? "\u{1F513} \u5F00\u6E90\u4FE1\u606F" : "\u{1F513} Open Source Info");
    const content = modal.contentEl;
    content.style.cssText = `
			padding: 20px;
		`;
    content.createEl("p", {
      text: this.plugin.settings.language === "zh" ? "Canvas Grid Transit \u662F\u4E00\u4E2A\u5B8C\u5168\u5F00\u6E90\u7684\u9879\u76EE\uFF0C\u91C7\u7528 MIT \u8BB8\u53EF\u8BC1\u3002" : "Canvas Grid Transit is a fully open source project under MIT License.",
      attr: { style: "margin-bottom: 12px; font-size: 14px;" }
    });
    const features = this.plugin.settings.language === "zh" ? [
      "\u{1F50D} \u4EE3\u7801\u5B8C\u5168\u516C\u5F00\uFF0C\u5B89\u5168\u53EF\u9760",
      "\u{1F91D} \u6B22\u8FCE\u793E\u533A\u8D21\u732E\u548C\u5EFA\u8BAE",
      "\u{1F193} \u6C38\u4E45\u514D\u8D39\uFF0C\u65E0\u4F7F\u7528\u9650\u5236",
      "\u{1F527} \u652F\u6301\u4E2A\u6027\u5316\u4FEE\u6539\u548C\u6269\u5C55"
    ] : [
      "\u{1F50D} Code is fully public and secure",
      "\u{1F91D} Welcome community contributions",
      "\u{1F193} Forever free, no restrictions",
      "\u{1F527} Support customization and extensions"
    ];
    const featureList = content.createEl("ul");
    featureList.style.cssText = `
			margin: 0 0 16px 0;
			padding-left: 20px;
		`;
    features.forEach((feature) => {
      const listItem = featureList.createEl("li");
      listItem.textContent = feature;
      listItem.style.cssText = `
				margin-bottom: 4px;
				font-size: 13px;
			`;
    });
    const githubButton = content.createEl("button", {
      text: this.plugin.settings.language === "zh" ? "\u67E5\u770B\u6E90\u7801" : "View Source Code"
    });
    githubButton.style.cssText = `
			background: var(--interactive-accent);
			color: white;
			border: none;
			padding: 8px 16px;
			border-radius: 6px;
			cursor: pointer;
			font-size: 13px;
		`;
    githubButton.addEventListener("click", () => {
      window.open("https://github.com/zhuzhige123/Canvasgrid-Transit", "_blank");
      modal.close();
    });
    modal.open();
  }
  // 高级设置标签页
  renderAdvancedSettings() {
    const container = this.contentContainer;
    this.createSectionTitle(container, "\u{1F527} \u5F00\u53D1\u8005\u9009\u9879", "Developer Options");
    const warningBox = container.createDiv("warning-box");
    warningBox.style.cssText = `
			background: var(--background-modifier-error);
			border: 1px solid var(--background-modifier-error-border);
			border-radius: 8px;
			padding: 16px;
			margin-bottom: 24px;
		`;
    warningBox.createEl("p", {
      text: this.plugin.settings.language === "zh" ? "\u26A0\uFE0F \u8B66\u544A\uFF1A\u8FD9\u4E9B\u662F\u9AD8\u7EA7\u8BBE\u7F6E\u9009\u9879\uFF0C\u4EC5\u4F9B\u5F00\u53D1\u8005\u548C\u9AD8\u7EA7\u7528\u6237\u4F7F\u7528\u3002\u9519\u8BEF\u7684\u914D\u7F6E\u53EF\u80FD\u5BFC\u81F4\u63D2\u4EF6\u529F\u80FD\u5F02\u5E38\u3002" : "\u26A0\uFE0F Warning: These are advanced settings for developers and power users only. Incorrect configuration may cause plugin malfunction.",
      cls: "setting-item-description"
    });
    new import_obsidian12.Setting(container).setName(this.plugin.settings.language === "zh" ? "\u542F\u7528\u8C03\u8BD5\u6A21\u5F0F" : "Enable Debug Mode").setDesc(this.plugin.settings.language === "zh" ? "\u5728\u63A7\u5236\u53F0\u663E\u793A\u8BE6\u7EC6\u7684\u8C03\u8BD5\u4FE1\u606F" : "Show detailed debug information in console").addToggle((toggle) => toggle.setValue(false).onChange(async (value) => {
      DebugManager.log("Debug mode:", value);
    }));
    new import_obsidian12.Setting(container).setName(this.plugin.settings.language === "zh" ? "\u6027\u80FD\u76D1\u63A7" : "Performance Monitoring").setDesc(this.plugin.settings.language === "zh" ? "\u76D1\u63A7\u63D2\u4EF6\u6027\u80FD\u6307\u6807" : "Monitor plugin performance metrics").addToggle((toggle) => toggle.setValue(false).onChange(async (value) => {
      DebugManager.log("Performance monitoring:", value);
    }));
    const resetSection = container.createDiv("reset-section");
    resetSection.style.cssText = `
			margin-top: 32px;
			padding-top: 24px;
			border-top: 2px solid var(--background-modifier-border);
		`;
    this.createSectionTitle(resetSection, "\u{1F504} \u91CD\u7F6E\u8BBE\u7F6E", "Reset Settings");
    new import_obsidian12.Setting(resetSection).setName(this.plugin.settings.language === "zh" ? "\u91CD\u7F6E\u6240\u6709\u8BBE\u7F6E" : "Reset All Settings").setDesc(this.plugin.settings.language === "zh" ? "\u5C06\u6240\u6709\u8BBE\u7F6E\u6062\u590D\u4E3A\u9ED8\u8BA4\u503C\uFF08\u9700\u8981\u91CD\u542F\u63D2\u4EF6\uFF09" : "Reset all settings to default values (requires plugin restart)").addButton((button) => button.setButtonText(this.plugin.settings.language === "zh" ? "\u91CD\u7F6E" : "Reset").setWarning().onClick(async () => {
      const confirmed = confirm(
        this.plugin.settings.language === "zh" ? "\u786E\u5B9A\u8981\u91CD\u7F6E\u6240\u6709\u8BBE\u7F6E\u5417\uFF1F\u6B64\u64CD\u4F5C\u4E0D\u53EF\u64A4\u9500\u3002" : "Are you sure you want to reset all settings? This action cannot be undone."
      );
      if (confirmed) {
        await this.plugin.resetSettings();
        this.display();
      }
    }));
  }
  // 创建设置区块的辅助方法
  createSettingSection(container, zhTitle, enTitle) {
    const sectionContainer = container.createDiv("canvas-grid-setting-section");
    sectionContainer.style.cssText = `
			margin: 20px 0;
			border: 1px solid var(--background-modifier-border);
			border-radius: 8px;
			background: var(--background-primary);
			overflow: hidden;
			width: 100%;
		`;
    const sectionColor = this.getSectionColor(zhTitle, enTitle);
    const titleContainer = sectionContainer.createDiv("canvas-grid-section-title-container");
    titleContainer.style.cssText = `
			display: flex;
			align-items: center;
			background: var(--background-secondary);
			padding: 16px 24px;
			position: relative;
		`;
    const colorIndicator = titleContainer.createDiv("section-color-indicator");
    colorIndicator.style.cssText = `
			width: 4px;
			height: 20px;
			background: ${sectionColor};
			border-radius: 2px;
			margin-right: 12px;
			flex-shrink: 0;
		`;
    const title = titleContainer.createEl("h3", {
      text: this.plugin.settings.language === "zh" ? zhTitle.replace(/^[🎯🌐📝📌🎨⚙️⌨️ℹ️🔧✨💝🔄]+\s*/, "") : enTitle,
      cls: "canvas-grid-section-title"
    });
    title.style.cssText = `
			margin: 0;
			font-size: 16px;
			font-weight: 600;
			color: var(--text-normal);
		`;
    const contentContainer = sectionContainer.createDiv("canvas-grid-section-content");
    contentContainer.style.cssText = `
			padding: 16px 20px;
		`;
    return contentContainer;
  }
  // 获取设置区块的颜色
  getSectionColor(zhTitle, enTitle) {
    if (zhTitle.includes("\u57FA\u7840\u8BBE\u7F6E") || enTitle.includes("Basic")) {
      return "#42a5f5";
    } else if (zhTitle.includes("\u989C\u8272") || enTitle.includes("Color")) {
      return "#66bb6a";
    } else if (zhTitle.includes("Anki") || enTitle.includes("Anki")) {
      return "#ffa726";
    } else if (zhTitle.includes("\u5173\u4E8E") || enTitle.includes("About")) {
      return "#ab47bc";
    } else if (zhTitle.includes("\u7F6E\u9876") || enTitle.includes("Pinned")) {
      return "#ff6b6b";
    } else if (zhTitle.includes("\u9AD8\u7EA7") || enTitle.includes("Advanced")) {
      return "#26c6da";
    } else {
      return "var(--interactive-accent)";
    }
  }
  // 创建章节标题的辅助方法（保留兼容性）
  createSectionTitle(container, zhTitle, enTitle) {
    const titleContainer = container.createDiv("canvas-grid-section-title-container");
    titleContainer.style.cssText = `
			margin: 24px 0 16px 0;
			display: flex;
			align-items: center;
			background: var(--background-secondary);
			border-radius: 8px;
			padding: 16px 20px;
			border-left: 4px solid var(--interactive-accent);
			border: 1px solid var(--background-modifier-border);
		`;
    const title = titleContainer.createEl("h3", {
      text: this.plugin.settings.language === "zh" ? zhTitle.replace(/^[🎯🌐📝📌🎨⚙️⌨️ℹ️🔧✨💝🔄]+\s*/, "") : enTitle,
      cls: "canvas-grid-section-title"
    });
    title.style.cssText = `
			margin: 0 0 0 12px;
			font-size: 16px;
			font-weight: 600;
			color: var(--text-normal);
		`;
  }
  // 更新所有网格视图的辅助方法
  updateAllGridViews() {
    const leaves = this.app.workspace.getLeavesOfType(CANVAS_GRID_VIEW_TYPE);
    leaves.forEach((leaf) => {
      const view = leaf.view;
      if (view) {
        view.onOpen();
      }
    });
  }
  // 更新所有网格视图的置顶状态
  updateAllGridViewsPinnedStatus() {
    const leaves = this.app.workspace.getLeavesOfType(CANVAS_GRID_VIEW_TYPE);
    leaves.forEach((leaf) => {
      const view = leaf.view;
      if (view && view.refreshPinnedStatus) {
        view.refreshPinnedStatus();
      }
    });
  }
  // 创建拖拽系统设置部分
  createDragSystemSection(containerEl) {
    containerEl.createEl("h3", {
      text: "\u{1F680} " + (this.plugin.settings.language === "zh" ? "\u62D6\u62FD\u7CFB\u7EDF\u8BBE\u7F6E" : "Drag System Settings")
    });
    const descContainer = containerEl.createDiv("drag-system-desc");
    descContainer.style.cssText = `
			background: var(--background-secondary);
			border-radius: 6px;
			padding: 12px;
			margin-bottom: 20px;
			border-left: 3px solid var(--interactive-accent);
		`;
    const descText = descContainer.createEl("p", {
      text: this.plugin.settings.language === "zh" ? "\u65B0\u62D6\u62FD\u7CFB\u7EDF\u63D0\u4F9B\u66F4\u597D\u7684\u6027\u80FD\u548C\u7528\u6237\u4F53\u9A8C\u3002\u5982\u679C\u9047\u5230\u95EE\u9898\uFF0C\u53EF\u4EE5\u5207\u6362\u56DE\u65E7\u7CFB\u7EDF\u3002" : "The new drag system provides better performance and user experience. You can switch back to the legacy system if you encounter issues.",
      cls: "setting-item-description"
    });
    descText.style.cssText = `
			margin: 0;
			color: var(--text-muted);
			font-size: 13px;
			line-height: 1.4;
		`;
  }
  // 创建置顶功能设置部分
  createPinnedCardsSection(containerEl) {
    const pinnedSection = this.createSettingSection(containerEl, "\u7F6E\u9876\u529F\u80FD\u8BBE\u7F6E", "Pinned Cards Settings");
    new import_obsidian12.Setting(pinnedSection).setName(this.plugin.settings.language === "zh" ? "\u542F\u7528\u7F6E\u9876\u529F\u80FD" : "Enable Pinned Cards").setDesc(this.plugin.settings.language === "zh" ? "\u5141\u8BB8\u5C06\u91CD\u8981\u5361\u7247\u7F6E\u9876\u663E\u793A" : "Allow important cards to be pinned at the top").addToggle((toggle) => toggle.setValue(this.plugin.settings.enablePinnedCards).onChange(async (value) => {
      this.plugin.settings.enablePinnedCards = value;
      await this.plugin.saveSettings();
      this.updateAllGridViews();
    }));
    new import_obsidian12.Setting(pinnedSection).setName(this.plugin.settings.language === "zh" ? "\u7F6E\u9876\u6807\u7B7E\u540D\u79F0" : "Pinned Tag Name").setDesc(this.plugin.settings.language === "zh" ? "\u7528\u4E8E\u6807\u8BB0\u7F6E\u9876\u5361\u7247\u7684\u6807\u7B7E\u540D\u79F0" : "Tag name used to mark pinned cards").addText((text) => text.setPlaceholder(this.plugin.settings.language === "zh" ? "#\u7F6E\u9876" : "#pinned").setValue(this.plugin.settings.pinnedTagName).onChange(async (value) => {
      const trimmedValue = value.trim();
      if (trimmedValue && !trimmedValue.startsWith("#")) {
        new import_obsidian12.Notice(this.plugin.settings.language === "zh" ? "\u7F6E\u9876\u6807\u7B7E\u5FC5\u987B\u4EE5 # \u5F00\u5934" : "Pinned tag must start with #");
        return;
      }
      this.plugin.settings.pinnedTagName = trimmedValue || (this.plugin.settings.language === "zh" ? "#\u7F6E\u9876" : "#pinned");
      await this.plugin.saveSettings();
      this.updateAllGridViewsPinnedStatus();
    }));
    new import_obsidian12.Setting(pinnedSection).setName(this.plugin.settings.language === "zh" ? "\u663E\u793A\u7F6E\u9876\u6807\u8BC6" : "Show Pinned Indicator").setDesc(this.plugin.settings.language === "zh" ? "\u5728\u7F6E\u9876\u5361\u7247\u4E0A\u663E\u793A\u89C6\u89C9\u6807\u8BC6" : "Show visual indicator on pinned cards").addToggle((toggle) => toggle.setValue(this.plugin.settings.showPinnedIndicator).onChange(async (value) => {
      this.plugin.settings.showPinnedIndicator = value;
      await this.plugin.saveSettings();
      this.updateAllGridViews();
    }));
  }
  // 创建统一的颜色管理设置部分
  createUnifiedColorSection(containerEl) {
    const colorSection = this.createSettingSection(containerEl, "\u989C\u8272\u7BA1\u7406", "Color Management");
    this.createSelectableColorGrid(colorSection);
    this.createSelectedColorsPreview(colorSection);
  }
  // 创建可选颜色列表
  createSelectableColorGrid(containerEl) {
    const listContainer = containerEl.createDiv("selectable-color-list-container");
    listContainer.style.cssText = `
			background: var(--background-primary);
			border: 1px solid var(--background-modifier-border);
			border-radius: 8px;
			padding: 16px;
			margin-bottom: 20px;
		`;
    const listTitle = listContainer.createEl("h4", {
      text: this.plugin.settings.language === "zh" ? "\u53EF\u9009\u989C\u8272" : "Available Colors",
      cls: "color-list-title"
    });
    listTitle.style.cssText = `
			margin: 0 0 16px 0;
			color: var(--text-normal);
			font-size: 14px;
			font-weight: 600;
		`;
    const colorList = listContainer.createDiv("selectable-color-list");
    colorList.style.cssText = `
			display: flex;
			flex-direction: column;
			gap: 8px;
		`;
    const availableColors = this.getColorOptions();
    availableColors.forEach((colorOption) => {
      this.createSelectableColorListItem(colorList, colorOption);
    });
  }
  // 创建可选择的颜色列表项
  createSelectableColorListItem(container, colorOption) {
    const isSelected = this.plugin.settings.colorFilterColors.includes(colorOption.value);
    const category = this.plugin.settings.colorCategories.find((cat) => cat.color === colorOption.value);
    const listItem = container.createDiv("color-list-item");
    listItem.setAttribute("data-color-value", colorOption.value);
    listItem.style.cssText = `
			display: flex;
			align-items: center;
			padding: 12px 16px;
			border: 1px solid var(--background-modifier-border);
			border-radius: 8px;
			background: var(--background-secondary);
			transition: all 0.2s ease;
			cursor: pointer;
			gap: 16px;
		`;
    const colorDot = listItem.createDiv("color-dot");
    colorDot.style.cssText = `
			width: 20px;
			height: 20px;
			border-radius: 50%;
			background: ${colorOption.color};
			flex-shrink: 0;
			box-shadow: 0 1px 3px ${colorOption.color}40;
		`;
    const contentArea = listItem.createDiv("color-content-area");
    contentArea.style.cssText = `
			flex: 1;
			display: flex;
			flex-direction: column;
			gap: 4px;
		`;
    const nameDisplay = contentArea.createEl("div", {
      text: category ? category.name : colorOption.name,
      cls: "color-name-display"
    });
    nameDisplay.style.cssText = `
			font-size: 14px;
			font-weight: 600;
			color: var(--text-normal);
			cursor: text;
			padding: 2px 4px;
			border-radius: 4px;
			transition: background 0.2s ease;
		`;
    const descDisplay = contentArea.createEl("div", {
      text: category ? category.description : colorOption.desc,
      cls: "color-desc-display"
    });
    descDisplay.style.cssText = `
			font-size: 12px;
			color: var(--text-muted);
			cursor: text;
			padding: 2px 4px;
			border-radius: 4px;
			transition: background 0.2s ease;
			line-height: 1.3;
		`;
    const toggleSwitch = listItem.createDiv("color-toggle-switch");
    toggleSwitch.style.cssText = `
			width: 40px;
			height: 20px;
			border-radius: 10px;
			background: ${isSelected ? colorOption.color : "var(--background-modifier-border)"};
			position: relative;
			cursor: pointer;
			transition: all 0.2s ease;
			flex-shrink: 0;
		`;
    const toggleKnob = toggleSwitch.createDiv("toggle-knob");
    toggleKnob.style.cssText = `
			width: 16px;
			height: 16px;
			border-radius: 50%;
			background: white;
			position: absolute;
			top: 2px;
			left: ${isSelected ? "22px" : "2px"};
			transition: all 0.2s ease;
			box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
		`;
    this.addInlineEditingToColorCard(nameDisplay, descDisplay, colorOption.value);
    const toggleSelection = async (e) => {
      if (e.target.classList.contains("color-name-display") || e.target.classList.contains("color-desc-display")) {
        return;
      }
      if (toggleSwitch.hasClass("processing")) {
        return;
      }
      toggleSwitch.addClass("processing");
      try {
        await this.toggleColorSelection(colorOption.value);
      } catch (error) {
        console.error("Toggle color selection failed:", error);
      } finally {
        toggleSwitch.removeClass("processing");
      }
    };
    listItem.addEventListener("click", toggleSelection);
    toggleSwitch.addEventListener("click", (e) => {
      e.stopPropagation();
      toggleSelection(e);
    });
    listItem.addEventListener("mouseenter", () => {
      listItem.style.borderColor = colorOption.color;
      listItem.style.background = colorOption.color + "08";
    });
    listItem.addEventListener("mouseleave", () => {
      listItem.style.borderColor = "var(--background-modifier-border)";
      listItem.style.background = "var(--background-secondary)";
    });
  }
  // 添加内联编辑功能到颜色卡片
  addInlineEditingToColorCard(nameDisplay, descDisplay, colorValue) {
    nameDisplay.addEventListener("dblclick", () => {
      this.startInlineEdit(nameDisplay, colorValue, "name");
    });
    descDisplay.addEventListener("dblclick", () => {
      this.startInlineEdit(descDisplay, colorValue, "description");
    });
    nameDisplay.addEventListener("mouseenter", () => {
      nameDisplay.style.background = "var(--background-modifier-hover)";
      nameDisplay.title = this.plugin.settings.language === "zh" ? "\u53CC\u51FB\u7F16\u8F91\u540D\u79F0" : "Double-click to edit name";
    });
    nameDisplay.addEventListener("mouseleave", () => {
      nameDisplay.style.background = "transparent";
    });
    descDisplay.addEventListener("mouseenter", () => {
      descDisplay.style.background = "var(--background-modifier-hover)";
      descDisplay.title = this.plugin.settings.language === "zh" ? "\u53CC\u51FB\u7F16\u8F91\u63CF\u8FF0" : "Double-click to edit description";
    });
    descDisplay.addEventListener("mouseleave", () => {
      descDisplay.style.background = "transparent";
    });
  }
  // 开始内联编辑
  startInlineEdit(element, colorValue, field) {
    const currentText = element.textContent || "";
    const input = document.createElement(field === "description" ? "textarea" : "input");
    input.value = currentText;
    input.style.cssText = `
			width: 100%;
			background: var(--background-primary);
			border: 1px solid var(--interactive-accent);
			border-radius: 4px;
			padding: 4px 8px;
			font-size: ${field === "name" ? "14px" : "11px"};
			font-weight: ${field === "name" ? "600" : "normal"};
			color: var(--text-normal);
			text-align: center;
			resize: none;
			${field === "description" ? "min-height: 32px; line-height: 1.3;" : ""}
		`;
    element.style.display = "none";
    element.parentElement?.insertBefore(input, element);
    input.focus();
    input.select();
    const saveEdit = async () => {
      const newValue = input.value.trim();
      element.textContent = newValue;
      element.style.display = "block";
      input.remove();
      await this.updateColorCategory(colorValue, field, newValue);
    };
    const cancelEdit = () => {
      element.style.display = "block";
      input.remove();
    };
    let hasSaved = false;
    const saveEditOnce = () => {
      if (!hasSaved) {
        hasSaved = true;
        saveEdit();
      }
    };
    input.addEventListener("blur", saveEditOnce);
    input.addEventListener("keydown", (e) => {
      const keyEvent = e;
      if (keyEvent.key === "Enter" && !keyEvent.shiftKey) {
        e.preventDefault();
        saveEditOnce();
      } else if (keyEvent.key === "Escape") {
        e.preventDefault();
        cancelEdit();
      }
    });
  }
  // 更新颜色分类
  async updateColorCategory(colorValue, field, newValue) {
    let category = this.plugin.settings.colorCategories.find((cat) => cat.color === colorValue);
    if (!category) {
      const defaultName = this.getDefaultColorName(colorValue);
      category = {
        id: `color-${colorValue}`,
        name: field === "name" ? newValue : defaultName,
        description: field === "description" ? newValue : "",
        color: colorValue
      };
      this.plugin.settings.colorCategories.push(category);
    } else {
      if (field === "name") {
        category.name = newValue;
      } else {
        category.description = newValue;
      }
    }
    await this.plugin.saveSettings();
    this.updateAllGridViews();
  }
  // 切换颜色选择状态
  async toggleColorSelection(colorValue) {
    const currentColors = [...this.plugin.settings.colorFilterColors];
    const isCurrentlySelected = currentColors.includes(colorValue);
    if (isCurrentlySelected) {
      const index = currentColors.indexOf(colorValue);
      if (index > -1) {
        currentColors.splice(index, 1);
      }
    } else {
      if (currentColors.length < 5) {
        currentColors.push(colorValue);
      } else {
        new import_obsidian12.Notice(this.plugin.settings.language === "zh" ? "\u6700\u591A\u53EA\u80FD\u9009\u62E95\u4E2A\u989C\u8272" : "Maximum 5 colors can be selected");
        return;
      }
    }
    this.plugin.settings.colorFilterColors = currentColors;
    await this.plugin.saveSettings();
    this.updateAllGridViews();
    this.updateColorToggleStates();
  }
  // 获取颜色选项配置
  getColorOptions() {
    return [
      { value: "1", color: "#ff6b6b", name: "\u91CD\u8981", desc: "\u91CD\u8981\u5185\u5BB9\u548C\u7D27\u6025\u4E8B\u9879" },
      { value: "2", color: "#ffa726", name: "\u5F85\u529E", desc: "\u5F85\u529E\u4E8B\u9879\u548C\u63D0\u9192" },
      { value: "3", color: "#ffeb3b", name: "\u9EC4\u8272", desc: "\u6CE8\u610F\u4E8B\u9879\u548C\u8B66\u544A" },
      { value: "4", color: "#66bb6a", name: "\u7EFF\u8272", desc: "\u5DF2\u5B8C\u6210\u548C\u786E\u8BA4\u4E8B\u9879" },
      { value: "5", color: "#26c6da", name: "\u6536\u96C6", desc: "\u65F6\u95F4\u80F6\u56CA\u6536\u96C6\u7684\u5185\u5BB9" },
      { value: "6", color: "#42a5f5", name: "\u8BB0\u4E8B", desc: "\u4E00\u822C\u7B14\u8BB0\u548C\u8BB0\u5F55" },
      { value: "7", color: "#ab47bc", name: "\u7075\u611F", desc: "\u521B\u610F\u60F3\u6CD5\u548C\u7075\u611F" }
    ];
  }
  // 更新所有颜色开关的状态
  updateColorToggleStates() {
    const colorItems = this.containerEl.querySelectorAll(".color-list-item");
    const colorOptions = this.getColorOptions();
    colorItems.forEach((item) => {
      const colorValue = item.getAttribute("data-color-value");
      if (colorValue) {
        const isSelected = this.plugin.settings.colorFilterColors.includes(colorValue);
        const toggleSwitch = item.querySelector(".color-toggle-switch");
        const toggleKnob = item.querySelector(".toggle-knob");
        const colorOption = colorOptions.find((opt) => opt.value === colorValue);
        if (toggleSwitch && toggleKnob && colorOption) {
          toggleSwitch.style.background = isSelected ? colorOption.color : "var(--background-modifier-border)";
          toggleKnob.style.left = isSelected ? "22px" : "2px";
          if (isSelected) {
            item.style.borderColor = colorOption.color;
          } else {
            item.style.borderColor = "var(--background-modifier-border)";
          }
        }
      }
    });
    this.updateSelectedColorsPreview();
  }
  // 更新已选择颜色预览区域
  updateSelectedColorsPreview() {
    const statusText = this.containerEl.querySelector(".selected-colors-status");
    if (statusText) {
      statusText.textContent = this.plugin.settings.language === "zh" ? `\u5DF2\u9009\u62E9 ${this.plugin.settings.colorFilterColors.length}/5 \u4E2A\u989C\u8272` : `Selected ${this.plugin.settings.colorFilterColors.length}/5 colors`;
    }
    const sortableContainer = this.containerEl.querySelector(".sortable-preview-container");
    if (sortableContainer) {
      this.renderSortableColorDots(sortableContainer);
    }
  }
  // 创建已选择颜色预览
  createSelectedColorsPreview(containerEl) {
    const previewContainer = containerEl.createDiv("selected-colors-preview");
    previewContainer.style.cssText = `
			background: var(--background-secondary);
			border-radius: 6px;
			padding: 16px;
			margin-bottom: 20px;
		`;
    const previewHeader = previewContainer.createDiv("preview-header");
    previewHeader.style.cssText = `
			display: flex;
			align-items: center;
			justify-content: space-between;
			margin-bottom: 12px;
		`;
    const statusText = previewHeader.createEl("span", {
      text: this.plugin.settings.language === "zh" ? `\u5DF2\u9009\u62E9 ${this.plugin.settings.colorFilterColors.length}/5 \u4E2A\u989C\u8272` : `Selected ${this.plugin.settings.colorFilterColors.length}/5 colors`,
      cls: "selected-colors-status"
    });
    statusText.style.cssText = `
			color: var(--text-muted);
			font-size: 13px;
		`;
    const sortHint = previewHeader.createEl("span", {
      text: this.plugin.settings.language === "zh" ? "\u62D6\u62FD\u8C03\u6574\u987A\u5E8F" : "Drag to reorder",
      cls: "sort-hint"
    });
    sortHint.style.cssText = `
			color: var(--text-muted);
			font-size: 11px;
			font-style: italic;
		`;
    const sortableContainer = previewContainer.createDiv("sortable-preview-container");
    sortableContainer.style.cssText = `
			display: flex;
			gap: 8px;
			flex-wrap: wrap;
			min-height: 40px;
			padding: 8px;
			border: 1px dashed var(--background-modifier-border);
			border-radius: 4px;
			background: var(--background-primary);
		`;
    this.renderSortableColorDots(sortableContainer);
  }
  // 创建颜色选择网格
  createColorSelectionGrid(container) {
    const colorGridContainer = container.createDiv("color-filter-grid-container");
    colorGridContainer.style.cssText = `
			background: var(--background-primary);
			border: 1px solid var(--background-modifier-border);
			border-radius: 8px;
			padding: GRID_CONSTANTS.CARD_SPACINGpx;
			margin-bottom: 16px;
		`;
    const gridTitle = colorGridContainer.createEl("h4", {
      text: this.plugin.settings.language === "zh" ? "\u53EF\u9009\u989C\u8272" : "Available Colors",
      cls: "color-grid-title"
    });
    gridTitle.style.cssText = `
			margin: 0 0 16px 0;
			color: var(--text-normal);
			font-size: 14px;
			font-weight: 600;
		`;
    const colorGrid = colorGridContainer.createDiv("color-filter-grid");
    colorGrid.style.cssText = `
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
			gap: 12px;
		`;
    const availableColors = [
      { value: "1", color: "#ff6b6b", emoji: "\u{1F534}" },
      { value: "2", color: "#ffa726", emoji: "\u{1F7E0}" },
      { value: "3", color: "#ffeb3b", emoji: "\u{1F7E1}" },
      { value: "4", color: "#66bb6a", emoji: "\u{1F7E2}" },
      { value: "5", color: "#26c6da", emoji: "\u{1F535}" },
      { value: "6", color: "#42a5f5", emoji: "\u{1F535}" },
      { value: "7", color: "#ab47bc", emoji: "\u{1F7E3}" }
    ];
    availableColors.forEach((colorOption) => {
      const colorCard = colorGrid.createDiv("color-filter-card");
      const isSelected = this.plugin.settings.colorFilterColors.includes(colorOption.value);
      const category = this.plugin.settings.colorCategories.find((cat) => cat.color === colorOption.value);
      const displayName = category ? category.name : this.getDefaultColorName(colorOption.value);
      const description = category ? category.description : "";
      colorCard.style.cssText = `
				display: flex;
				flex-direction: column;
				align-items: center;
				padding: 16px 12px;
				border: 2px solid ${isSelected ? colorOption.color : "var(--background-modifier-border)"};
				border-radius: 8px;
				cursor: pointer;
				transition: all 0.2s ease;
				background: ${isSelected ? colorOption.color + "10" : "var(--background-secondary)"};
				position: relative;
				min-height: 120px;
			`;
      const colorPreview = colorCard.createDiv("color-preview-large");
      colorPreview.style.cssText = `
				width: 36px;
				height: 36px;
				border-radius: 50%;
				background: ${colorOption.color};
				margin-bottom: 12px;
				box-shadow: 0 2px 8px ${colorOption.color}40;
				border: 2px solid white;
			`;
      const colorName = colorCard.createEl("div", {
        text: displayName,
        cls: "color-card-name"
      });
      colorName.style.cssText = `
				font-size: 13px;
				font-weight: 600;
				color: var(--text-normal);
				text-align: center;
				margin-bottom: 4px;
			`;
      if (description) {
        const colorDesc = colorCard.createEl("div", {
          text: description,
          cls: "color-card-desc"
        });
        colorDesc.style.cssText = `
					font-size: 11px;
					color: var(--text-muted);
					text-align: center;
					line-height: 1.3;
					margin-bottom: 8px;
				`;
      }
      if (isSelected) {
        const checkmark = colorCard.createDiv("color-card-checkmark");
        checkmark.innerHTML = "\u2713";
        checkmark.style.cssText = `
					position: absolute;
					top: 6px;
					right: 6px;
					width: 18px;
					height: 18px;
					background: ${colorOption.color};
					color: white;
					border-radius: 50%;
					display: flex;
					align-items: center;
					justify-content: center;
					font-size: 11px;
					font-weight: bold;
					box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
				`;
      }
      colorCard.addEventListener("click", async () => {
        const currentColors = [...this.plugin.settings.colorFilterColors];
        const isCurrentlySelected = currentColors.includes(colorOption.value);
        if (isCurrentlySelected) {
          const index = currentColors.indexOf(colorOption.value);
          if (index > -1) {
            currentColors.splice(index, 1);
          }
        } else {
          if (currentColors.length < 5) {
            currentColors.push(colorOption.value);
          } else {
            new import_obsidian12.Notice(this.plugin.settings.language === "zh" ? "\u6700\u591A\u53EA\u80FD\u9009\u62E95\u4E2A\u989C\u8272" : "Maximum 5 colors can be selected");
            return;
          }
        }
        this.plugin.settings.colorFilterColors = currentColors;
        await this.plugin.saveSettings();
        this.updateAllGridViews();
        this.display();
      });
      colorCard.addEventListener("mouseenter", () => {
        if (!isSelected) {
          colorCard.style.borderColor = colorOption.color;
          colorCard.style.background = colorOption.color + "08";
          colorCard.style.transform = "translateY(-2px)";
        }
      });
      colorCard.addEventListener("mouseleave", () => {
        if (!isSelected) {
          colorCard.style.borderColor = "var(--background-modifier-border)";
          colorCard.style.background = "var(--background-secondary)";
          colorCard.style.transform = "translateY(0)";
        }
      });
    });
  }
  // 创建可排序的颜色预览
  createSortableColorPreview(container) {
    const statusContainer = container.createDiv("color-filter-status");
    statusContainer.style.cssText = `
			background: var(--background-secondary);
			border-radius: 6px;
			margin-bottom: 20px;
			padding: 16px;
		`;
    const statusHeader = statusContainer.createDiv("status-header");
    statusHeader.style.cssText = `
			display: flex;
			align-items: center;
			justify-content: space-between;
			margin-bottom: 12px;
		`;
    const statusText = statusHeader.createEl("span", {
      text: this.plugin.settings.language === "zh" ? `\u5DF2\u9009\u62E9 ${this.plugin.settings.colorFilterColors.length}/5 \u4E2A\u989C\u8272` : `Selected ${this.plugin.settings.colorFilterColors.length}/5 colors`,
      cls: "color-filter-status-text"
    });
    statusText.style.cssText = `
			color: var(--text-muted);
			font-size: 13px;
		`;
    const sortHint = statusHeader.createEl("span", {
      text: this.plugin.settings.language === "zh" ? "\u62D6\u62FD\u8C03\u6574\u987A\u5E8F" : "Drag to reorder",
      cls: "sort-hint"
    });
    sortHint.style.cssText = `
			color: var(--text-muted);
			font-size: 11px;
			font-style: italic;
		`;
    const sortableContainer = statusContainer.createDiv("sortable-color-container");
    sortableContainer.style.cssText = `
			display: flex;
			gap: 8px;
			flex-wrap: wrap;
			min-height: 40px;
			padding: 8px;
			border: 1px dashed var(--background-modifier-border);
			border-radius: 4px;
			background: var(--background-primary);
		`;
    this.renderSortableColorDots(sortableContainer);
  }
  // 获取默认颜色名称
  getDefaultColorName(colorValue) {
    const colorNames = {
      "1": this.plugin.settings.language === "zh" ? "\u7EA2\u8272" : "Red",
      "2": this.plugin.settings.language === "zh" ? "\u6A59\u8272" : "Orange",
      "3": this.plugin.settings.language === "zh" ? "\u9EC4\u8272" : "Yellow",
      "4": this.plugin.settings.language === "zh" ? "\u7EFF\u8272" : "Green",
      "5": this.plugin.settings.language === "zh" ? "\u9752\u8272" : "Cyan",
      "6": this.plugin.settings.language === "zh" ? "\u84DD\u8272" : "Blue",
      "7": this.plugin.settings.language === "zh" ? "\u7D2B\u8272" : "Purple"
    };
    return colorNames[colorValue] || colorValue;
  }
  // 创建颜色分类列表
  createColorCategoryList(containerEl) {
    const categoryContainer = containerEl.createDiv("color-category-list");
    categoryContainer.style.cssText = `
			background: var(--background-primary);
			border: 1px solid var(--background-modifier-border);
			border-radius: 8px;
			padding: GRID_CONSTANTS.CARD_SPACINGpx;
			margin-bottom: 16px;
		`;
    const listTitle = categoryContainer.createEl("h4", {
      text: this.plugin.settings.language === "zh" ? "\u989C\u8272\u5206\u7C7B\u914D\u7F6E" : "Color Category Configuration",
      cls: "color-category-title"
    });
    listTitle.style.cssText = `
			margin: 0 0 16px 0;
			color: var(--text-normal);
			font-size: 14px;
			font-weight: 600;
		`;
    this.plugin.settings.colorCategories.forEach((category, index) => {
      this.createColorCategoryItem(categoryContainer, category, index);
    });
  }
  // 创建单个颜色分类项
  createColorCategoryItem(container, category, index) {
    const itemContainer = container.createDiv("color-category-item");
    itemContainer.style.cssText = `
			display: flex;
			align-items: center;
			gap: 12px;
			padding: 12px;
			border: 1px solid var(--background-modifier-border);
			border-radius: 6px;
			margin-bottom: 8px;
			background: var(--background-secondary);
		`;
    const colorDot = itemContainer.createDiv("color-category-dot");
    colorDot.style.cssText = `
			width: 24px;
			height: 24px;
			border-radius: 50%;
			background: ${this.getColorValue(category.color)};
			border: 2px solid var(--background-modifier-border);
			flex-shrink: 0;
		`;
    const infoContainer = itemContainer.createDiv("color-category-info");
    infoContainer.style.cssText = `
			flex: 1;
			min-width: 0;
		`;
    const nameEl = infoContainer.createEl("div", {
      text: category.name,
      cls: "color-category-name"
    });
    nameEl.style.cssText = `
			font-weight: 600;
			color: var(--text-normal);
			margin-bottom: 4px;
		`;
    const descEl = infoContainer.createEl("div", {
      text: category.description,
      cls: "color-category-desc"
    });
    descEl.style.cssText = `
			font-size: 12px;
			color: var(--text-muted);
			line-height: 1.3;
		`;
    const editBtn = itemContainer.createEl("button", {
      text: this.plugin.settings.language === "zh" ? "\u7F16\u8F91" : "Edit",
      cls: "mod-cta"
    });
    editBtn.style.cssText = `
			padding: 4px 12px;
			font-size: 12px;
		`;
    editBtn.onclick = () => {
      this.openColorCategoryEditor(category, index);
    };
  }
  // 获取颜色值
  getColorValue(colorId) {
    const colorMap = {
      "1": "#ff6b6b",
      // 红色
      "2": "#ffa726",
      // 橙色
      "3": "#ffeb3b",
      // 黄色
      "4": "#66bb6a",
      // 绿色
      "5": "#26c6da",
      // 青色
      "6": "#42a5f5",
      // 蓝色
      "7": "#ab47bc"
      // 紫色
    };
    return colorMap[colorId] || "#999999";
  }
  // 打开颜色分类编辑器
  openColorCategoryEditor(category, index) {
    new ColorCategoryEditModal(this.app, this.plugin, category, index, () => {
      this.display();
    }).open();
  }
  // 渲染可排序的颜色圆点
  renderSortableColorDots(container) {
    container.empty();
    const colorMap = {
      "1": "#ff6b6b",
      "2": "#ffa726",
      "3": "#ffeb3b",
      "4": "#66bb6a",
      "5": "#26c6da",
      "6": "#42a5f5",
      "7": "#ab47bc"
    };
    const colorNames = {
      "1": this.plugin.settings.language === "zh" ? "\u7EA2\u8272" : "Red",
      "2": this.plugin.settings.language === "zh" ? "\u6A59\u8272" : "Orange",
      "3": this.plugin.settings.language === "zh" ? "\u9EC4\u8272" : "Yellow",
      "4": this.plugin.settings.language === "zh" ? "\u7EFF\u8272" : "Green",
      "5": this.plugin.settings.language === "zh" ? "\u9752\u8272" : "Cyan",
      "6": this.plugin.settings.language === "zh" ? "\u84DD\u8272" : "Blue",
      "7": this.plugin.settings.language === "zh" ? "\u7D2B\u8272" : "Purple"
    };
    this.plugin.settings.colorFilterColors.forEach((colorValue, index) => {
      const colorDot = container.createDiv("sortable-color-dot");
      colorDot.draggable = true;
      colorDot.dataset.colorValue = colorValue;
      colorDot.dataset.index = index.toString();
      colorDot.style.cssText = `
				width: 32px;
				height: 32px;
				border-radius: 50%;
				background: ${colorMap[colorValue]};
				border: 2px solid white;
				box-shadow: 0 2px 8px ${colorMap[colorValue]}40;
				cursor: grab;
				transition: all 0.2s ease;
				position: relative;
				display: flex;
				align-items: center;
				justify-content: center;
			`;
      colorDot.title = colorNames[colorValue] || colorValue;
      colorDot.addEventListener("dragstart", (e) => {
        colorDot.style.cursor = "grabbing";
        colorDot.style.opacity = "0.5";
        e.dataTransfer.setData("text/plain", index.toString());
        e.dataTransfer.effectAllowed = "move";
      });
      colorDot.addEventListener("dragend", () => {
        colorDot.style.cursor = "grab";
        colorDot.style.opacity = "1";
      });
      colorDot.addEventListener("dragover", (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = "move";
      });
      colorDot.addEventListener("drop", async (e) => {
        e.preventDefault();
        const draggedIndex = parseInt(e.dataTransfer.getData("text/plain"));
        const targetIndex = index;
        if (draggedIndex !== targetIndex) {
          const newColors = [...this.plugin.settings.colorFilterColors];
          const draggedColor = newColors.splice(draggedIndex, 1)[0];
          newColors.splice(targetIndex, 0, draggedColor);
          this.plugin.settings.colorFilterColors = newColors;
          await this.plugin.saveSettings();
          this.updateAllGridViews();
          this.renderSortableColorDots(container);
        }
      });
      colorDot.addEventListener("mouseenter", () => {
        colorDot.style.transform = "scale(1.1)";
      });
      colorDot.addEventListener("mouseleave", () => {
        colorDot.style.transform = "scale(1)";
      });
    });
    if (this.plugin.settings.colorFilterColors.length === 0) {
      const emptyHint = container.createDiv("empty-hint");
      emptyHint.textContent = this.plugin.settings.language === "zh" ? "\u8BF7\u5728\u4E0A\u65B9\u9009\u62E9\u989C\u8272" : "Please select colors above";
      emptyHint.style.cssText = `
				color: var(--text-muted);
				font-size: 12px;
				font-style: italic;
				text-align: center;
				padding: 8px;
			`;
    }
  }
  // Anki设置相关辅助方法
  refreshAnkiSettings() {
    if (this.currentTab === "anki") {
      this.contentContainer.empty();
      this.renderAnkiSettings();
    }
  }
  async testAnkiConnection() {
    const config = this.plugin.settings.ankiConnect;
    if (!config.enabled) {
      new import_obsidian12.Notice(this.plugin.settings.language === "zh" ? "\u8BF7\u5148\u542F\u7528Anki Connect\u540C\u6B65" : "Please enable Anki Connect sync first");
      return;
    }
    try {
      const { AnkiConnectManager: AnkiConnectManager2 } = await Promise.resolve().then(() => (init_AnkiConnectManager(), AnkiConnectManager_exports));
      const ankiManager = new AnkiConnectManager2(this.app, config);
      const isConnected = await ankiManager.testConnection();
      if (isConnected) {
        new import_obsidian12.Notice(this.plugin.settings.language === "zh" ? "\u2705 Anki Connect\u8FDE\u63A5\u6210\u529F\uFF01" : "\u2705 Anki Connect connection successful!");
      } else {
        new import_obsidian12.Notice(this.plugin.settings.language === "zh" ? "\u274C \u65E0\u6CD5\u8FDE\u63A5\u5230Anki Connect\uFF0C\u8BF7\u68C0\u67E5Anki\u662F\u5426\u8FD0\u884C\u4E14\u5DF2\u5B89\u88C5AnkiConnect\u63D2\u4EF6" : "\u274C Cannot connect to Anki Connect. Please check if Anki is running with AnkiConnect plugin installed");
      }
    } catch (error) {
      console.error("Anki Connect\u6D4B\u8BD5\u5931\u8D25:", error);
      new import_obsidian12.Notice(this.plugin.settings.language === "zh" ? "\u274C \u8FDE\u63A5\u6D4B\u8BD5\u5931\u8D25\uFF0C\u8BF7\u68C0\u67E5\u8BBE\u7F6E\u548C\u7F51\u7EDC" : "\u274C Connection test failed. Please check settings and network");
    }
  }
  createSyncColorSelection(container) {
    const existingColorSelection = container.querySelector(".anki-sync-color-selection");
    if (existingColorSelection) {
      existingColorSelection.remove();
    }
    const colorSelectionContainer = container.createDiv("anki-sync-color-selection");
    colorSelectionContainer.style.cssText = `
				margin: 16px 0;
				padding: 16px;
				background: var(--background-secondary);
				border-radius: 8px;
				border: 1px solid var(--background-modifier-border);
			`;
    const title = colorSelectionContainer.createEl("h4", {
      text: this.plugin.settings.language === "zh" ? "\u540C\u6B65\u989C\u8272\u9009\u62E9" : "Sync Color Selection",
      cls: "setting-item-name"
    });
    title.style.cssText = `
				margin: 0 0 12px 0;
				font-size: 14px;
				font-weight: 600;
				color: var(--text-normal);
			`;
    const desc = colorSelectionContainer.createEl("p", {
      text: this.plugin.settings.language === "zh" ? "\u9009\u62E9\u8981\u540C\u6B65\u5230Anki\u7684\u5361\u7247\u989C\u8272\u3002\u53EA\u6709\u9009\u4E2D\u989C\u8272\u7684\u5361\u7247\u4F1A\u88AB\u540C\u6B65\u3002" : "Select card colors to sync to Anki. Only cards with selected colors will be synced.",
      cls: "setting-item-description"
    });
    desc.style.cssText = `
				margin: 0 0 16px 0;
				color: var(--text-muted);
				font-size: 13px;
			`;
    const colorGrid = colorSelectionContainer.createDiv("anki-color-grid");
    colorGrid.style.cssText = `
				display: grid;
				grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
				gap: 12px;
			`;
    const availableColors = [
      { value: "1", color: "#ff6b6b", name: this.plugin.settings.language === "zh" ? "\u7EA2\u8272" : "Red" },
      { value: "2", color: "#ffa726", name: this.plugin.settings.language === "zh" ? "\u6A59\u8272" : "Orange" },
      { value: "3", color: "#ffeb3b", name: this.plugin.settings.language === "zh" ? "\u9EC4\u8272" : "Yellow" },
      { value: "4", color: "#66bb6a", name: this.plugin.settings.language === "zh" ? "\u7EFF\u8272" : "Green" },
      { value: "5", color: "#26c6da", name: this.plugin.settings.language === "zh" ? "\u9752\u8272" : "Cyan" },
      { value: "6", color: "#42a5f5", name: this.plugin.settings.language === "zh" ? "\u84DD\u8272" : "Blue" },
      { value: "7", color: "#ab47bc", name: this.plugin.settings.language === "zh" ? "\u7D2B\u8272" : "Purple" }
    ];
    availableColors.forEach((colorOption) => {
      const isSelected = this.plugin.settings.ankiConnect.syncColors.includes(colorOption.value);
      const colorCard = colorGrid.createDiv("anki-color-card");
      colorCard.style.cssText = `
					display: flex;
					align-items: center;
					gap: 8px;
					padding: 8px 12px;
					border: 2px solid ${isSelected ? colorOption.color : "var(--background-modifier-border)"};
					border-radius: 8px;
					background: ${isSelected ? colorOption.color + "10" : "var(--background-primary)"};
					cursor: pointer;
					transition: all 0.2s ease;
				`;
      const colorDot = colorCard.createDiv("color-dot");
      colorDot.style.cssText = `
					width: 16px;
					height: 16px;
					border-radius: 50%;
					background: ${colorOption.color};
					flex-shrink: 0;
				`;
      const colorName = colorCard.createEl("span", {
        text: colorOption.name,
        cls: "color-name"
      });
      colorName.style.cssText = `
					font-size: 12px;
					font-weight: 500;
					color: var(--text-normal);
				`;
      if (isSelected) {
        const checkmark = colorCard.createDiv("checkmark");
        checkmark.innerHTML = "\u2713";
        checkmark.style.cssText = `
						margin-left: auto;
						color: ${colorOption.color};
						font-weight: bold;
						font-size: 14px;
					`;
      }
      colorCard.addEventListener("click", async () => {
        const currentColors = [...this.plugin.settings.ankiConnect.syncColors];
        const isCurrentlySelected = currentColors.includes(colorOption.value);
        if (isCurrentlySelected) {
          const index = currentColors.indexOf(colorOption.value);
          if (index > -1) {
            currentColors.splice(index, 1);
          }
        } else {
          currentColors.push(colorOption.value);
        }
        this.plugin.settings.ankiConnect.syncColors = currentColors;
        await this.plugin.saveSettings();
        this.createSyncColorSelection(container);
      });
      colorCard.addEventListener("mouseenter", () => {
        if (!isSelected) {
          colorCard.style.borderColor = colorOption.color;
          colorCard.style.background = colorOption.color + "08";
        }
      });
      colorCard.addEventListener("mouseleave", () => {
        if (!isSelected) {
          colorCard.style.borderColor = "var(--background-modifier-border)";
          colorCard.style.background = "var(--background-primary)";
        }
      });
    });
  }
};
var ColorCategoryEditModal = class extends import_obsidian12.Modal {
  constructor(app, plugin, category, index, onSave) {
    super(app);
    this.plugin = plugin;
    this.category = category;
    this.index = index;
    this.onSave = onSave;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", {
      text: this.plugin.settings.language === "zh" ? "\u7F16\u8F91\u989C\u8272\u5206\u7C7B" : "Edit Color Category",
      cls: "modal-title"
    });
    const formContainer = contentEl.createDiv("color-category-form");
    formContainer.style.cssText = `
			display: flex;
			flex-direction: column;
			gap: 16px;
			margin: GRID_CONSTANTS.CARD_SPACINGpx 0;
		`;
    const colorPreview = formContainer.createDiv("color-preview-container");
    colorPreview.style.cssText = `
			display: flex;
			align-items: center;
			gap: 12px;
			padding: 12px;
			background: var(--background-secondary);
			border-radius: 6px;
		`;
    const colorDot = colorPreview.createDiv("color-preview-dot");
    colorDot.style.cssText = `
			width: 32px;
			height: 32px;
			border-radius: 50%;
			background: ${this.getColorValue(this.category.color)};
			border: 2px solid var(--background-modifier-border);
			flex-shrink: 0;
		`;
    const colorInfo = colorPreview.createDiv("color-info");
    colorInfo.innerHTML = `
			<div style="font-weight: 600; color: var(--text-normal);">
				${this.plugin.settings.language === "zh" ? "\u989C\u8272" : "Color"}: ${this.getColorName(this.category.color)}
			</div>
			<div style="font-size: 12px; color: var(--text-muted);">
				${this.plugin.settings.language === "zh" ? "\u989C\u8272ID" : "Color ID"}: ${this.category.color}
			</div>
		`;
    const nameContainer = formContainer.createDiv("input-container");
    const nameLabel = nameContainer.createEl("label", {
      text: this.plugin.settings.language === "zh" ? "\u5206\u7C7B\u540D\u79F0:" : "Category Name:",
      cls: "setting-item-name"
    });
    nameLabel.style.cssText = `
			display: block;
			margin-bottom: 6px;
			font-weight: 600;
			color: var(--text-normal);
		`;
    this.nameInput = nameContainer.createEl("input", {
      type: "text",
      value: this.category.name,
      cls: "color-category-name-input"
    });
    this.nameInput.style.cssText = `
			width: 100%;
			padding: 8px 12px;
			border: 1px solid var(--background-modifier-border);
			border-radius: 4px;
			background: var(--background-primary);
			color: var(--text-normal);
			font-size: 14px;
		`;
    const descContainer = formContainer.createDiv("input-container");
    const descLabel = descContainer.createEl("label", {
      text: this.plugin.settings.language === "zh" ? "\u5206\u7C7B\u63CF\u8FF0:" : "Category Description:",
      cls: "setting-item-name"
    });
    descLabel.style.cssText = `
			display: block;
			margin-bottom: 6px;
			font-weight: 600;
			color: var(--text-normal);
		`;
    this.descInput = descContainer.createEl("textarea", {
      value: this.category.description,
      cls: "color-category-desc-input"
    });
    this.descInput.style.cssText = `
			width: 100%;
			min-height: 80px;
			padding: 8px 12px;
			border: 1px solid var(--background-modifier-border);
			border-radius: 4px;
			background: var(--background-primary);
			color: var(--text-normal);
			font-size: 14px;
			resize: vertical;
			font-family: inherit;
		`;
    const buttonContainer = contentEl.createDiv("modal-button-container");
    buttonContainer.style.cssText = `
			display: flex;
			justify-content: flex-end;
			gap: 12px;
			margin-top: 20px;
			padding-top: 16px;
			border-top: 1px solid var(--background-modifier-border);
		`;
    const cancelBtn = buttonContainer.createEl("button", {
      text: this.plugin.settings.language === "zh" ? "\u53D6\u6D88" : "Cancel",
      cls: "mod-cancel"
    });
    cancelBtn.onclick = () => this.close();
    const saveBtn = buttonContainer.createEl("button", {
      text: this.plugin.settings.language === "zh" ? "\u4FDD\u5B58" : "Save",
      cls: "mod-cta"
    });
    saveBtn.onclick = () => this.saveChanges();
    setTimeout(() => {
    }, PERFORMANCE_CONSTANTS.MINIMAL_DELAY);
  }
  getColorValue(colorId) {
    const colorMap = {
      "1": "#ff6b6b",
      // 红色
      "2": "#ffa726",
      // 橙色
      "3": "#ffeb3b",
      // 黄色
      "4": "#66bb6a",
      // 绿色
      "5": "#26c6da",
      // 青色
      "6": "#42a5f5",
      // 蓝色
      "7": "#ab47bc"
      // 紫色
    };
    return colorMap[colorId] || "#999999";
  }
  getColorName(colorId) {
    const colorNames = {
      "1": this.plugin.settings.language === "zh" ? "\u7EA2\u8272" : "Red",
      "2": this.plugin.settings.language === "zh" ? "\u6A59\u8272" : "Orange",
      "3": this.plugin.settings.language === "zh" ? "\u9EC4\u8272" : "Yellow",
      "4": this.plugin.settings.language === "zh" ? "\u7EFF\u8272" : "Green",
      "5": this.plugin.settings.language === "zh" ? "\u9752\u8272" : "Cyan",
      "6": this.plugin.settings.language === "zh" ? "\u84DD\u8272" : "Blue",
      "7": this.plugin.settings.language === "zh" ? "\u7D2B\u8272" : "Purple"
    };
    return colorNames[colorId] || colorId;
  }
  saveChanges() {
    const newName = this.nameInput.value.trim();
    const newDesc = this.descInput.value.trim();
    if (!newName) {
      new import_obsidian12.Notice(this.plugin.settings.language === "zh" ? "\u5206\u7C7B\u540D\u79F0\u4E0D\u80FD\u4E3A\u7A7A" : "Category name cannot be empty");
      this.nameInput.focus();
      return;
    }
    this.plugin.settings.colorCategories[this.index] = {
      ...this.category,
      name: newName,
      description: newDesc
    };
    this.plugin.saveSettings();
    new import_obsidian12.Notice(this.plugin.settings.language === "zh" ? "\u989C\u8272\u5206\u7C7B\u5DF2\u66F4\u65B0" : "Color category updated");
    this.close();
    this.onSave();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var AnkiSyncModal = class extends import_obsidian12.Modal {
  constructor(app, view) {
    super(app);
    this.view = view;
    this.plugin = view.plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", {
      text: this.plugin.settings.language === "zh" ? "Anki\u540C\u6B65" : "Anki Sync",
      cls: "modal-title"
    });
    const mainContainer = contentEl.createDiv("anki-sync-modal-container");
    mainContainer.style.cssText = `
			max-height: 70vh;
			overflow-y: auto;
			padding: 20px 0;
		`;
    const configContainer = mainContainer.createDiv("anki-sync-config");
    this.createSyncConfigSection(configContainer);
    const colorSyncContainer = mainContainer.createDiv("color-sync-container");
    colorSyncContainer.createEl("h4", {
      text: this.plugin.settings.language === "zh" ? "\u989C\u8272\u540C\u6B65\u5230Anki" : "Color Sync to Anki",
      cls: "anki-section-title"
    });
    this.createSimplifiedColorSyncOptions(colorSyncContainer);
    const historyContainer = mainContainer.createDiv("sync-history-container");
    historyContainer.style.cssText = `
			margin-top: 20px;
		`;
    this.createTableSyncHistoryDisplay(historyContainer);
    const buttonContainer = contentEl.createDiv("modal-button-container");
    buttonContainer.style.cssText = `
			display: flex;
			justify-content: flex-end;
			gap: 12px;
			margin-top: 20px;
			padding-top: 16px;
			border-top: 1px solid var(--background-modifier-border);
		`;
    const closeBtn = buttonContainer.createEl("button", {
      text: this.plugin.settings.language === "zh" ? "\u5173\u95ED" : "Close",
      cls: "mod-cancel"
    });
    closeBtn.onclick = () => this.close();
  }
  // 创建同步配置区域
  createSyncConfigSection(container) {
    const configSection = container.createDiv("anki-sync-config-section");
    configSection.style.cssText = `
			background: var(--background-secondary);
			border-radius: 8px;
			padding: 16px;
			margin-bottom: 20px;
			border: 1px solid var(--background-modifier-border);
		`;
    const deckContainer = configSection.createDiv("deck-selection");
    deckContainer.createEl("label", {
      text: this.plugin.settings.language === "zh" ? "\u9009\u62E9\u724C\u7EC4:" : "Select Deck:",
      cls: "anki-config-label"
    });
    const deckSelect = deckContainer.createEl("select", {
      cls: "anki-deck-select"
    });
    deckSelect.style.cssText = `
			width: 100%;
			padding: 8px 12px;
			margin-top: 4px;
			border: 1px solid var(--background-modifier-border);
			border-radius: 4px;
			background: var(--background-primary);
			color: var(--text-normal);
		`;
    this.loadDeckOptions(deckSelect);
    const autoSyncContainer = configSection.createDiv("auto-sync-option");
    autoSyncContainer.style.cssText = `
			display: flex;
			align-items: center;
			gap: 8px;
			margin-top: 12px;
		`;
    const autoSyncCheckbox = autoSyncContainer.createEl("input", {
      type: "checkbox",
      cls: "anki-auto-sync-checkbox"
    });
    autoSyncCheckbox.checked = this.plugin.settings.ankiConnect.enableAutoSync || false;
    autoSyncContainer.createEl("label", {
      text: this.plugin.settings.language === "zh" ? "\u542F\u7528\u81EA\u52A8\u540C\u6B65" : "Enable Auto Sync",
      cls: "anki-config-label"
    });
    const syncButtonContainer = configSection.createDiv("manual-sync-button");
    syncButtonContainer.style.cssText = `
			margin-top: 16px;
			text-align: center;
		`;
    const syncButton = syncButtonContainer.createEl("button", {
      text: this.plugin.settings.language === "zh" ? "\u5F00\u59CB\u540C\u6B65" : "Start Sync",
      cls: "anki-sync-btn mod-cta"
    });
    syncButton.style.cssText = `
			padding: 10px 20px;
			font-size: 14px;
			font-weight: 500;
		`;
    deckSelect.addEventListener("change", (e) => {
      const target = e.target;
      this.plugin.settings.ankiConnect.defaultDeck = target.value;
      this.plugin.saveSettings();
    });
    autoSyncCheckbox.addEventListener("change", (e) => {
      const target = e.target;
      this.plugin.settings.ankiConnect.enableAutoSync = target.checked;
      this.plugin.saveSettings();
    });
    syncButton.addEventListener("click", async () => {
      await this.startManualSync();
    });
  }
  // 加载牌组选项
  async loadDeckOptions(selectElement) {
    try {
      const { AnkiConnectManager: AnkiConnectManager2 } = await Promise.resolve().then(() => (init_AnkiConnectManager(), AnkiConnectManager_exports));
      const ankiManager = new AnkiConnectManager2(this.app, this.plugin.settings.ankiConnect);
      const deckNames = await ankiManager.getDeckNames();
      selectElement.innerHTML = "";
      deckNames.forEach((deckName) => {
        const option = selectElement.createEl("option", {
          value: deckName,
          text: deckName
        });
        if (deckName === this.plugin.settings.ankiConnect.defaultDeck) {
          option.selected = true;
        }
      });
      if (deckNames.length === 0) {
        selectElement.createEl("option", {
          value: "",
          text: this.plugin.settings.language === "zh" ? "\u65E0\u53EF\u7528\u724C\u7EC4" : "No decks available"
        });
      }
    } catch (error) {
      console.error("\u52A0\u8F7D\u724C\u7EC4\u5217\u8868\u5931\u8D25:", error);
      selectElement.createEl("option", {
        value: "",
        text: this.plugin.settings.language === "zh" ? "\u52A0\u8F7D\u5931\u8D25" : "Failed to load"
      });
    }
  }
  // 开始手动同步
  async startManualSync() {
    try {
      if (this.view.syncAllSelectedColorCards) {
        await this.view.syncAllSelectedColorCards();
      }
    } catch (error) {
      console.error("\u624B\u52A8\u540C\u6B65\u5931\u8D25:", error);
      new import_obsidian12.Notice(this.plugin.settings.language === "zh" ? "\u540C\u6B65\u5931\u8D25" : "Sync failed");
    }
  }
  // 创建简化的颜色同步选项
  createSimplifiedColorSyncOptions(container) {
    const colorOptions = [
      { value: "1", color: "#ff6b6b" },
      { value: "2", color: "#ffa726" },
      { value: "3", color: "#ffeb3b" },
      { value: "4", color: "#66bb6a" },
      { value: "5", color: "#26c6da" },
      { value: "6", color: "#42a5f5" },
      { value: "7", color: "#ab47bc" }
    ];
    const colorGrid = container.createDiv("anki-color-sync-grid-simplified");
    colorGrid.style.cssText = `
			display: flex;
			flex-wrap: wrap;
			gap: 12px;
			margin: 16px 0;
			justify-content: center;
		`;
    colorOptions.forEach((colorOption) => {
      const isSelected = this.plugin.settings.ankiConnect.syncColors.includes(colorOption.value);
      const colorItem = colorGrid.createDiv("anki-color-item-simplified");
      colorItem.style.cssText = `
				display: flex;
				align-items: center;
				gap: 8px;
				cursor: pointer;
				padding: 8px;
				border-radius: 6px;
				transition: background-color 0.2s ease;
			`;
      const colorDot = colorItem.createDiv("anki-color-dot");
      colorDot.style.cssText = `
				width: 20px;
				height: 20px;
				border-radius: 50%;
				background-color: ${colorOption.color};
				border: 2px solid ${isSelected ? colorOption.color : "var(--background-modifier-border)"};
				box-shadow: ${isSelected ? `0 0 0 2px ${colorOption.color}40` : "none"};
				transition: all 0.2s ease;
			`;
      const checkIcon = colorItem.createDiv("anki-color-check");
      checkIcon.style.cssText = `
				width: 16px;
				height: 16px;
				display: flex;
				align-items: center;
				justify-content: center;
				font-size: 12px;
				color: ${isSelected ? colorOption.color : "var(--text-muted)"};
				transition: color 0.2s ease;
			`;
      checkIcon.textContent = isSelected ? "\u2713" : "";
      colorItem.addEventListener("click", () => {
        const currentColors = [...this.plugin.settings.ankiConnect.syncColors];
        const colorIndex = currentColors.indexOf(colorOption.value);
        if (colorIndex > -1) {
          currentColors.splice(colorIndex, 1);
          colorDot.style.border = "2px solid var(--background-modifier-border)";
          colorDot.style.boxShadow = "none";
          checkIcon.textContent = "";
          checkIcon.style.color = "var(--text-muted)";
        } else {
          currentColors.push(colorOption.value);
          colorDot.style.border = `2px solid ${colorOption.color}`;
          colorDot.style.boxShadow = `0 0 0 2px ${colorOption.color}40`;
          checkIcon.textContent = "\u2713";
          checkIcon.style.color = colorOption.color;
        }
        this.plugin.settings.ankiConnect.syncColors = currentColors;
        this.plugin.saveSettings();
      });
      colorItem.addEventListener("mouseenter", () => {
        colorItem.style.backgroundColor = "var(--background-modifier-hover)";
      });
      colorItem.addEventListener("mouseleave", () => {
        colorItem.style.backgroundColor = "transparent";
      });
    });
  }
  // 同步所有选中颜色的卡片
  async syncAllSelectedColorCards() {
    if (this.view.syncAllSelectedColorCards) {
      await this.view.syncAllSelectedColorCards();
    }
  }
  // 创建表格式同步历史显示
  createTableSyncHistoryDisplay(container) {
    const historySection = container.createDiv("anki-sync-history-table");
    historySection.createEl("h4", {
      text: this.plugin.settings.language === "zh" ? "\u540C\u6B65\u5386\u53F2" : "Sync History",
      cls: "anki-section-title"
    });
    const tableContainer = historySection.createDiv("sync-history-table-container");
    tableContainer.style.cssText = `
			background: var(--background-secondary);
			border-radius: 8px;
			padding: 16px;
			border: 1px solid var(--background-modifier-border);
			overflow-x: auto;
		`;
    const table = tableContainer.createEl("table", {
      cls: "sync-history-table"
    });
    table.style.cssText = `
			width: 100%;
			border-collapse: collapse;
			font-size: 13px;
		`;
    const thead = table.createEl("thead");
    const headerRow = thead.createEl("tr");
    headerRow.style.cssText = `
			border-bottom: 2px solid var(--background-modifier-border);
		`;
    const headers = this.plugin.settings.language === "zh" ? ["\u65B0\u589E\u5361\u7247", "\u66F4\u65B0\u5361\u7247", "\u8DF3\u8FC7\u5361\u7247", "\u5931\u8D25\u5361\u7247", "\u540C\u6B65\u65F6\u95F4"] : ["New Cards", "Updated", "Skipped", "Failed", "Sync Time"];
    headers.forEach((headerText) => {
      const th = headerRow.createEl("th");
      th.textContent = headerText;
      th.style.cssText = `
				padding: 12px 8px;
				text-align: center;
				font-weight: 600;
				color: var(--text-normal);
				border-right: 1px solid var(--background-modifier-border);
			`;
    });
    const tbody = table.createEl("tbody");
    const lastResult = this.plugin.settings.ankiSyncHistory.lastSyncResult;
    const lastSyncTime = this.plugin.settings.ankiSyncHistory.lastSyncTime;
    if (lastResult && lastSyncTime) {
      const dataRow = tbody.createEl("tr");
      dataRow.style.cssText = `
				border-bottom: 1px solid var(--background-modifier-border);
			`;
      const data = [
        lastResult.created || 0,
        lastResult.updated || 0,
        lastResult.skipped || 0,
        lastResult.errors?.length || 0,
        new Date(lastSyncTime).toLocaleString()
      ];
      data.forEach((cellData, index) => {
        const td = dataRow.createEl("td");
        td.textContent = cellData.toString();
        td.style.cssText = `
					padding: 10px 8px;
					text-align: center;
					color: var(--text-normal);
					border-right: 1px solid var(--background-modifier-border);
				`;
        if (index === 3 && cellData > 0) {
          td.style.color = "var(--text-error)";
          td.style.fontWeight = "600";
        }
      });
    } else {
      const noDataRow = tbody.createEl("tr");
      const noDataCell = noDataRow.createEl("td");
      noDataCell.setAttribute("colspan", "5");
      noDataCell.textContent = this.plugin.settings.language === "zh" ? "\u6682\u65E0\u540C\u6B65\u5386\u53F2" : "No sync history";
      noDataCell.style.cssText = `
				padding: 20px;
				text-align: center;
				color: var(--text-muted);
				font-style: italic;
			`;
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
