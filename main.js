/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  CANVAS_GRID_VIEW_TYPE: () => CANVAS_GRID_VIEW_TYPE,
  CanvasGridView: () => CanvasGridView,
  default: () => CanvasGridPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  enableAutoLayout: true,
  colorFilterColors: ["1", "2", "4", "6", "7"],
  // é»˜è®¤æ˜¾ç¤ºçº¢ã€æ©™ã€ç»¿ã€è“ã€ç´«
  language: "zh",
  // é»˜è®¤ä¸­æ–‡
  enableColorCategories: true,
  // å¯ç”¨é¢œè‰²åˆ†ç±»
  colorCategories: [
    { id: "important", name: "\u91CD\u8981", description: "\u91CD\u8981\u5185\u5BB9\u548C\u7D27\u6025\u4E8B\u9879", color: "1" },
    // çº¢è‰²
    { id: "todo", name: "\u5F85\u529E", description: "\u5F85\u529E\u4E8B\u9879\u548C\u4EFB\u52A1", color: "2" },
    // æ©™è‰²
    { id: "note", name: "\u8BB0\u4E8B", description: "\u4E00\u822C\u7B14\u8BB0\u548C\u8BB0\u5F55", color: "6" },
    // è“è‰²
    { id: "inspiration", name: "\u7075\u611F", description: "\u521B\u610F\u60F3\u6CD5\u548C\u7075\u611F", color: "7" },
    // ç´«è‰²
    { id: "collection", name: "\u6536\u96C6", description: "\u65F6\u95F4\u80F6\u56CA\u6536\u96C6\u7684\u5185\u5BB9", color: "5" }
    // é’è‰²
  ]
};
var CARD_CONSTANTS = {
  width: 300,
  height: 200,
  spacing: 20
};
var CANVAS_GRID_VIEW_TYPE = "canvas-grid-view";
var I18N_TEXTS = {
  zh: {
    // é€šç”¨
    search: "\u641C\u7D22",
    refresh: "\u5237\u65B0",
    settings: "\u8BBE\u7F6E",
    cancel: "\u53D6\u6D88",
    confirm: "\u786E\u8BA4",
    delete: "\u5220\u9664",
    edit: "\u7F16\u8F91",
    save: "\u4FDD\u5B58",
    // ç½‘æ ¼è§†å›¾
    gridView: "\u7F51\u683C\u89C6\u56FE",
    switchToGridView: "\u5207\u6362\u5230\u7F51\u683C\u89C6\u56FE",
    canvasGridView: "Canvasgrid Transit",
    noCanvasData: "\u6CA1\u6709Canvas\u6570\u636E",
    loadingCanvas: "\u52A0\u8F7DCanvas\u4E2D...",
    // èœå•
    refreshData: "\u5237\u65B0\u6570\u636E",
    syncCanvas: "\u540C\u6B65Canvas",
    newCanvasFile: "\u65B0\u5EFACanvas\u6587\u4EF6",
    sortBy: "\u6392\u5E8F\u65B9\u5F0F",
    filterConditions: "\u7B5B\u9009\u6761\u4EF6",
    returnToCanvas: "\u8FD4\u56DECanvas\u767D\u677F",
    // æ’åº
    sortByCreated: "\u521B\u5EFA\u65F6\u95F4",
    sortByModified: "\u4FEE\u6539\u65F6\u95F4",
    sortByTitle: "\u6807\u9898",
    ascending: "\u5347\u5E8F",
    descending: "\u964D\u5E8F",
    // ç­›é€‰
    filterByColor: "\u6309\u989C\u8272\u7B5B\u9009",
    allColors: "\u6240\u6709\u989C\u8272",
    // åˆ†ç»„
    groupView: "\u5206\u7EC4\u89C6\u56FE",
    returnToMainView: "\u8FD4\u56DE\u4E3B\u89C6\u56FE",
    groupMembers: "\u6210\u5458",
    // è®¾ç½®
    gridLayoutSettings: "\u7F51\u683C\u5E03\u5C40\u8BBE\u7F6E",
    enableAutoLayout: "\u542F\u7528\u81EA\u52A8\u5E03\u5C40",
    interfaceLanguage: "\u754C\u9762\u8BED\u8A00",
    colorFilterSettings: "\u989C\u8272\u7B5B\u9009\u5668\u8BBE\u7F6E",
    aboutPlugin: "\u5173\u4E8E\u63D2\u4EF6",
    // å…³äº
    mainFeatures: "\u4E3B\u8981\u529F\u80FD",
    quickStart: "\u5FEB\u901F\u5F00\u59CB",
    thanks: "\u611F\u8C22\u4F7F\u7528",
    feedback: "\u53CD\u9988\u5EFA\u8BAE",
    contact: "\u8054\u7CFB\u4F5C\u8005",
    buyCoffee: "\u8BF7\u559D\u5496\u5561",
    alipaySupport: "\u652F\u4ED8\u5B9D\u652F\u6301",
    githubSponsor: "GitHub\u8D5E\u52A9",
    projectLinks: "\u9879\u76EE\u94FE\u63A5"
  },
  en: {
    // é€šç”¨
    search: "Search",
    refresh: "Refresh",
    settings: "Settings",
    cancel: "Cancel",
    confirm: "Confirm",
    delete: "Delete",
    edit: "Edit",
    save: "Save",
    // ç½‘æ ¼è§†å›¾
    gridView: "Grid View",
    switchToGridView: "Switch to Grid View",
    canvasGridView: "Canvasgrid Transit",
    noCanvasData: "No Canvas Data",
    loadingCanvas: "Loading Canvas...",
    // èœå•
    refreshData: "Refresh Data",
    syncCanvas: "Sync Canvas",
    newCanvasFile: "New Canvas File",
    sortBy: "Sort By",
    filterConditions: "Filter Conditions",
    returnToCanvas: "Return to Canvas",
    // æ’åº
    sortByCreated: "Created Time",
    sortByModified: "Modified Time",
    sortByTitle: "Title",
    ascending: "Ascending",
    descending: "Descending",
    // ç­›é€‰
    filterByColor: "Filter by Color",
    allColors: "All Colors",
    // åˆ†ç»„
    groupView: "Group View",
    returnToMainView: "Return to Main View",
    groupMembers: "Members",
    // è®¾ç½®
    gridLayoutSettings: "Grid Layout Settings",
    enableAutoLayout: "Enable Auto Layout",
    interfaceLanguage: "Interface Language",
    colorFilterSettings: "Color Filter Settings",
    aboutPlugin: "About Plugin",
    // å…³äº
    mainFeatures: "Main Features",
    quickStart: "Quick Start",
    thanks: "Thanks for Using",
    feedback: "Feedback",
    contact: "Contact",
    buyCoffee: "Buy Me a Coffee",
    alipaySupport: "Alipay Support",
    githubSponsor: "GitHub Sponsor",
    projectLinks: "Project Links"
  }
};
var I18nManager = class {
  constructor() {
    this.language = "zh";
  }
  setLanguage(lang) {
    this.language = lang;
  }
  t(key) {
    return I18N_TEXTS[this.language][key] || key;
  }
};
var i18n = new I18nManager();
function hasProperty(obj, prop) {
  return prop in obj;
}
var LinkedTabManager = class {
  constructor(app) {
    this.linkedCanvasFile = null;
    this.gridView = null;
    this.fileWatcherRefs = [];
    this.app = app;
  }
  // å»ºç«‹å…³è”
  linkCanvasFile(canvasFile, gridView) {
    this.unlinkCanvas();
    this.linkedCanvasFile = canvasFile;
    this.gridView = gridView;
    this.registerFileWatcher();
    this.updateGridViewHeader();
    console.log(`Linked canvas file: ${canvasFile.path}`);
  }
  // ç§»é™¤å®˜æ–¹APIå…³è”æ–¹æ³• - æ”¹ä¸ºç®€å•å…³è”
  // æŸ¥æ‰¾Canvasæ–‡ä»¶å¯¹åº”çš„leaf
  findCanvasLeaf(canvasFile) {
    const canvasLeaves = this.app.workspace.getLeavesOfType("canvas");
    return canvasLeaves.find((leaf) => {
      const view = leaf.view;
      return view.file?.path === canvasFile.path;
    }) || null;
  }
  // æŸ¥æ‰¾ç½‘æ ¼è§†å›¾å¯¹åº”çš„leaf
  findGridViewLeaf(gridView) {
    const gridLeaves = this.app.workspace.getLeavesOfType(CANVAS_GRID_VIEW_TYPE);
    return gridLeaves.find((leaf) => leaf.view === gridView) || null;
  }
  // è§£é™¤å…³è”
  unlinkCanvas() {
    this.linkedCanvasFile = null;
    this.gridView = null;
    this.unregisterFileWatcher();
    console.log("Canvas link removed");
  }
  // è·å–å…³è”çš„Canvasæ–‡ä»¶
  getLinkedCanvasFile() {
    return this.linkedCanvasFile;
  }
  // æ£€æŸ¥å…³è”æ˜¯å¦æœ‰æ•ˆ
  isLinked() {
    return this.linkedCanvasFile !== null && this.app.vault.getAbstractFileByPath(this.linkedCanvasFile.path) !== null;
  }
  // æ³¨å†Œæ–‡ä»¶ç›‘å¬å™¨
  registerFileWatcher() {
    if (!this.linkedCanvasFile)
      return;
    console.log("Registering file watchers for:", this.linkedCanvasFile.path);
    const modifyRef = this.app.vault.on("modify", (file) => {
      if (file.path === this.linkedCanvasFile?.path && this.gridView && file instanceof import_obsidian.TFile) {
        this.gridView.onLinkedFileModified(file);
      }
    });
    const deleteRef = this.app.vault.on("delete", (file) => {
      if (file.path === this.linkedCanvasFile?.path && this.gridView) {
        this.gridView.onLinkedFileDeleted();
        this.unlinkCanvas();
      }
    });
    const renameRef = this.app.vault.on("rename", (file, oldPath) => {
      if (oldPath === this.linkedCanvasFile?.path && this.gridView) {
        this.linkedCanvasFile = file;
        this.gridView.onLinkedFileRenamed(file);
      }
    });
    this.fileWatcherRefs = [modifyRef, deleteRef, renameRef];
  }
  // æ³¨é”€æ–‡ä»¶ç›‘å¬å™¨
  unregisterFileWatcher() {
    this.fileWatcherRefs.forEach((ref) => {
      this.app.vault.offref(ref);
    });
    this.fileWatcherRefs = [];
    console.log("File watchers unregistered");
  }
  // æ›´æ–°ç½‘æ ¼è§†å›¾å¤´éƒ¨
  updateGridViewHeader() {
    if (this.gridView && this.linkedCanvasFile) {
      this.gridView.updateLinkedCanvasDisplay(this.linkedCanvasFile);
    }
  }
};
var GroupRenameModal = class extends import_obsidian.Modal {
  constructor(app, currentName, onRename) {
    super(app);
    this.inputEl = null;
    this.currentName = currentName;
    this.onRename = onRename;
  }
  onOpen() {
    this.titleEl.setText("\u91CD\u547D\u540D\u5206\u7EC4");
    this.createContent();
  }
  createContent() {
    const content = this.contentEl;
    content.empty();
    const inputContainer = content.createDiv("group-rename-input-container");
    const label = inputContainer.createEl("label", {
      text: "\u5206\u7EC4\u540D\u79F0:",
      cls: "group-rename-label"
    });
    this.inputEl = inputContainer.createEl("input", {
      type: "text",
      value: this.currentName,
      cls: "group-rename-input"
    });
    this.inputEl.focus();
    this.inputEl.select();
    const buttonContainer = content.createDiv("group-rename-buttons");
    const confirmBtn = buttonContainer.createEl("button", {
      text: "\u786E\u8BA4",
      cls: "mod-cta"
    });
    confirmBtn.onclick = () => this.handleConfirm();
    const cancelBtn = buttonContainer.createEl("button", {
      text: "\u53D6\u6D88"
    });
    cancelBtn.onclick = () => this.close();
    this.inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        this.handleConfirm();
      } else if (e.key === "Escape") {
        this.close();
      }
    });
  }
  handleConfirm() {
    if (!this.inputEl)
      return;
    const newName = this.inputEl.value.trim();
    if (!newName) {
      new import_obsidian.Notice("\u5206\u7EC4\u540D\u79F0\u4E0D\u80FD\u4E3A\u7A7A");
      return;
    }
    if (newName === this.currentName) {
      this.close();
      return;
    }
    this.onRename(newName);
    this.close();
  }
};
var CanvasSelectionModal = class extends import_obsidian.Modal {
  constructor(app, gridView, onSelect) {
    super(app);
    this.gridView = gridView;
    this.onSelect = onSelect;
  }
  onOpen() {
    this.titleEl.setText("\u9009\u62E9\u8981\u5173\u8054\u7684Canvas\u6587\u4EF6");
    this.createContent();
  }
  createContent() {
    const canvasFiles = this.app.vault.getFiles().filter((file) => file.extension === "canvas");
    if (canvasFiles.length === 0) {
      this.createEmptyState();
    } else {
      this.createFileList(canvasFiles);
    }
    this.createActions();
  }
  createEmptyState() {
    const emptyEl = this.contentEl.createDiv("canvas-selection-empty");
    emptyEl.innerHTML = `
			<div class="empty-icon">\u{1F4C4}</div>
			<div class="empty-title">\u6CA1\u6709\u627E\u5230Canvas\u6587\u4EF6</div>
			<div class="empty-desc">\u8BF7\u5148\u521B\u5EFA\u4E00\u4E2ACanvas\u6587\u4EF6\uFF0C\u7136\u540E\u518D\u8FDB\u884C\u5173\u8054</div>
		`;
  }
  createFileList(files) {
    const listEl = this.contentEl.createDiv("canvas-file-list");
    files.forEach((file) => {
      const itemEl = listEl.createDiv("canvas-file-item");
      itemEl.innerHTML = `
				<div class="file-icon">\u{1F3A8}</div>
				<div class="file-info">
					<div class="file-name">${file.basename}</div>
					<div class="file-path">${file.path}</div>
				</div>
				<div class="file-action">
					<button class="select-btn">\u9009\u62E9</button>
				</div>
			`;
      const selectBtn = itemEl.querySelector(".select-btn");
      selectBtn.onclick = () => {
        this.onSelect(file);
        this.close();
      };
    });
  }
  createActions() {
    const actionsEl = this.contentEl.createDiv("canvas-selection-actions");
    const createBtn = actionsEl.createEl("button", {
      cls: "mod-cta",
      text: "\u521B\u5EFA\u65B0Canvas\u6587\u4EF6"
    });
    createBtn.onclick = () => this.createNewCanvas();
    const cancelBtn = actionsEl.createEl("button", {
      text: "\u53D6\u6D88"
    });
    cancelBtn.onclick = () => this.close();
  }
  async createNewCanvas() {
    const fileName = `\u65B0\u5EFACanvas-${Date.now()}.canvas`;
    const initialData = { nodes: [], edges: [] };
    try {
      const newFile = await this.app.vault.create(
        fileName,
        JSON.stringify(initialData, null, 2)
      );
      this.onSelect(newFile);
      this.close();
      new import_obsidian.Notice(`\u5DF2\u521B\u5EFA\u65B0Canvas\u6587\u4EF6: ${newFile.basename}`);
    } catch (error) {
      new import_obsidian.Notice("\u521B\u5EFACanvas\u6587\u4EF6\u5931\u8D25");
      console.error("Failed to create canvas file:", error);
    }
  }
};
var CanvasGridView = class extends import_obsidian.ItemView {
  // å½“å‰æŸ¥çœ‹çš„åˆ†ç»„ID
  constructor(leaf, plugin) {
    super(leaf);
    this.canvasData = null;
    // æ‹–æ‹½ç›¸å…³å±æ€§
    this.isDragging = false;
    this.dragData = null;
    this.dropIndicator = null;
    // é•¿æŒ‰æ‹–æ‹½ç›¸å…³å±æ€§
    this.longPressTimer = null;
    this.longPressStartTime = 0;
    this.longPressThreshold = 500;
    // 500msé•¿æŒ‰é˜ˆå€¼
    this.isDragFromGrid = false;
    this.dragStartPosition = { x: 0, y: 0 };
    this.currentDragCard = null;
    // æ‹–æ‹½é¢„è§ˆç›¸å…³å±æ€§
    this.dragPreviewElement = null;
    // ğŸ”§ ä¿®å¤ï¼šæ–‡ä»¶ä¿®æ”¹ä¿æŠ¤æœºåˆ¶
    this.fileModificationLocks = /* @__PURE__ */ new Set();
    this.linkedCanvasFile = null;
    this.linkedIndicatorEl = null;
    this.updateTimeout = null;
    // æœç´¢å’Œæ’åºç›¸å…³å±æ€§
    this.searchQuery = "";
    this.sortBy = "created";
    this.sortOrder = "desc";
    this.filteredNodes = [];
    this.searchInputEl = null;
    this.statusElements = null;
    // é¢œè‰²ç­›é€‰ç›¸å…³å±æ€§
    this.activeColorFilter = null;
    // å½“å‰æ¿€æ´»çš„é¢œè‰²ç­›é€‰å™¨
    this.colorFilterContainer = null;
    // æ—¶é—´èƒ¶å›Šç›¸å…³å±æ€§
    this.timeCapsuleState = {
      isActive: false,
      startTime: 0,
      duration: 15 * 60 * 1e3,
      // é»˜è®¤15åˆ†é’Ÿ
      remainingTime: 0,
      groupId: null,
      collectedItems: [],
      groupName: ""
    };
    this.timeCapsuleButton = null;
    this.timeCapsuleTimer = null;
    this.timeCapsuleUpdateInterval = null;
    // å®½åº¦æ§åˆ¶ç›¸å…³å±æ€§
    this.resizeObserver = null;
    this.minWidth = 300;
    // æœ€å°å®½åº¦ï¼ˆä¸€å¼ å¡ç‰‡çš„å®½åº¦ï¼‰
    this.isWidthLimited = false;
    // é“¾æ¥é¢„è§ˆç¼“å­˜ - ä½¿ç”¨LRUç¼“å­˜ç­–ç•¥
    this.linkPreviewCache = /* @__PURE__ */ new Map();
    this.previewLoadingUrls = /* @__PURE__ */ new Set();
    this.MAX_CACHE_SIZE = 100;
    // é™åˆ¶ç¼“å­˜å¤§å°
    this.CACHE_TTL = 30 * 60 * 1e3;
    // ç¼“å­˜30åˆ†é’Ÿè¿‡æœŸ
    // æ–‡ä»¶ç›‘å¬å™¨æ§åˆ¶
    this.fileWatcherDisabled = false;
    // äº‹ä»¶ç›‘å¬å™¨æ¸…ç†è¿½è¸ª
    this.globalEventListeners = [];
    // å®šæ—¶å™¨æ¸…ç†è¿½è¸ª
    this.activeTimeouts = /* @__PURE__ */ new Set();
    this.activeIntervals = /* @__PURE__ */ new Set();
    this.cacheCleanupInterval = null;
    // æ¸²æŸ“ç¼“å­˜ - æå‡æ€§èƒ½
    this.renderCache = /* @__PURE__ */ new Map();
    this.MAX_RENDER_CACHE_SIZE = 50;
    // é™åˆ¶ç¼“å­˜å¤§å°
    this.renderCacheAccessCount = /* @__PURE__ */ new Map();
    // ç¼–è¾‘çŠ¶æ€ç®¡ç†
    this.currentEditingCard = null;
    this.currentEditingNode = null;
    this.autoSaveEnabled = true;
    // åˆ†ç»„åŠŸèƒ½ç›¸å…³
    this.groupAnalysis = /* @__PURE__ */ new Map();
    this.currentGroupView = null;
    // äº‹ä»¶å¤„ç†å™¨å¼•ç”¨ï¼Œç”¨äºæ¸…ç†
    this.refreshTimer = null;
    // ç»Ÿä¸€å¤„ç†ç½‘æ ¼ä¸­çš„æ‰€æœ‰ç‚¹å‡»äº‹ä»¶
    this.handleGridClick = (e) => {
      const target = e.target;
      console.log("\u7F51\u683C\u70B9\u51FB\u4E8B\u4EF6:", target.className, target.tagName);
      const toolbarBtn = target.closest(".canvas-card-toolbar-btn");
      if (toolbarBtn) {
        console.log("\u68C0\u6D4B\u5230\u5DE5\u5177\u680F\u6309\u94AE\u70B9\u51FB");
        e.stopPropagation();
        this.handleToolbarButtonClick(toolbarBtn, e);
        return;
      }
      const card = target.closest(".canvas-grid-card");
      if (card && card.dataset.nodeId) {
        console.log("\u68C0\u6D4B\u5230\u5361\u7247\u70B9\u51FB");
        const node = this.canvasData?.nodes.find((n) => n.id === card.dataset.nodeId);
        if (node) {
          this.onCardClick(node, card);
        }
      }
    };
    // å¤„ç†å·¥å…·æ æŒ‰é’®ç‚¹å‡»
    this.handleToolbarButtonClick = (button, e) => {
      console.log("\u5DE5\u5177\u680F\u6309\u94AE\u88AB\u70B9\u51FB:", button.className);
      const card = button.closest(".canvas-grid-card");
      if (!card || !card.dataset.nodeId) {
        console.log("\u672A\u627E\u5230\u5361\u7247\u6216\u8282\u70B9ID");
        return;
      }
      const node = this.canvasData?.nodes.find((n) => n.id === card.dataset.nodeId);
      if (!node) {
        console.log("\u672A\u627E\u5230\u5BF9\u5E94\u7684\u8282\u70B9\u6570\u636E");
        return;
      }
      console.log("\u6267\u884C\u5DE5\u5177\u680F\u64CD\u4F5C\uFF0C\u8282\u70B9:", node.id);
      if (button.classList.contains("canvas-card-toolbar-delete")) {
        console.log("\u6267\u884C\u5220\u9664\u64CD\u4F5C");
        this.deleteCardFromToolbar(card);
      } else if (button.classList.contains("canvas-card-toolbar-color")) {
        console.log("\u6267\u884C\u989C\u8272\u8BBE\u7F6E\u64CD\u4F5C");
        this.showColorPicker(card, node);
      } else {
        console.log("\u672A\u8BC6\u522B\u7684\u6309\u94AE\u7C7B\u578B:", button.className);
      }
    };
    // ä¿ç•™åŸæœ‰çš„å¡ç‰‡ç‚¹å‡»å¤„ç†æ–¹æ³•ï¼ˆç”¨äºå‘åå…¼å®¹ï¼‰
    this.handleCardClick = (e) => {
      const card = e.target.closest(".canvas-grid-card");
      if (card && card.dataset.nodeId) {
        const node = this.canvasData?.nodes.find((n) => n.id === card.dataset.nodeId);
        if (node) {
          this.onCardClick(node, card);
        }
      }
    };
    this.handleCardDoubleClick = (e) => {
      const card = e.target.closest(".canvas-grid-card");
      if (card && card.dataset.nodeId && !card.classList.contains("editing")) {
        const node = this.canvasData?.nodes.find((n) => n.id === card.dataset.nodeId);
        if (node) {
          e.preventDefault();
          e.stopPropagation();
          this.onCardDoubleClick(node, card);
        }
      }
    };
    this.handleKeyDown = (e) => {
      const target = e.target;
      if (target.classList.contains("canvas-card-toolbar-btn") && (e.key === "Enter" || e.key === " ")) {
        e.preventDefault();
        e.stopPropagation();
        this.handleToolbarButtonClick(target, e);
        return;
      }
      const card = target;
      if (card.classList.contains("canvas-grid-card") && (e.key === "Enter" || e.key === " ")) {
        e.preventDefault();
        if (e.key === "Enter") {
          const node = this.canvasData?.nodes.find((n) => n.id === card.dataset.nodeId);
          if (node && !card.classList.contains("editing")) {
            this.onCardDoubleClick(node, card);
          }
        } else {
          card.click();
        }
      }
    };
    // å¤„ç†å³é”®èœå•
    this.handleCardContextMenu = (e) => {
      const target = e.target;
      const card = target.closest(".canvas-grid-card");
      if (card) {
        e.preventDefault();
        this.showContextMenu(card, e.clientX, e.clientY);
      }
    };
    // å¤„ç†æ–‡æ¡£ç‚¹å‡»ï¼Œå…³é—­å³é”®èœå•å’Œé€€å‡ºç¼–è¾‘çŠ¶æ€
    this.handleDocumentClick = (e) => {
      const target = e.target;
      if (!target.closest(".canvas-grid-context-menu")) {
        this.hideContextMenu();
      }
      if (this.currentEditingCard && this.currentEditingNode) {
        const clickedInCurrentCard = target.closest(".canvas-grid-card") === this.currentEditingCard;
        const clickedInEditor = target.closest(".card-editor-container");
        const clickedInGrid = target.closest(".canvas-grid-container");
        if (!clickedInGrid || !clickedInCurrentCard && !clickedInEditor && clickedInGrid) {
          console.log("\u70B9\u51FB\u7F51\u683C\u5916\u6216\u5176\u4ED6\u533A\u57DF\uFF0C\u9000\u51FA\u7F16\u8F91\u72B6\u6001\u5E76\u4FDD\u5B58");
          this.exitCurrentEditingState(true);
        }
      }
    };
    // å…¨å±€é¼ æ ‡äº‹ä»¶ç›‘å¬å™¨å¼•ç”¨
    this.globalMouseMoveHandler = null;
    this.globalMouseUpHandler = null;
    // çª—å£å¤±ç„¦å¤„ç†å™¨
    this.handleWindowBlur = () => {
      setTimeout(() => {
        if (this.isDragFromGrid && !document.hasFocus()) {
          console.log("Window lost focus, canceling drag...");
          this.cancelDrag();
        }
      }, 100);
    };
    // ESCé”®å–æ¶ˆæ‹–æ‹½å¤„ç†å™¨
    this.handleDragEscape = (e) => {
      if (e.key === "Escape" && this.isDragFromGrid) {
        console.log("ESC pressed, canceling drag...");
        this.cancelDrag();
      }
    };
    // æ¸…ç†æ‹–æ‹½é¢„è§ˆçš„å‡½æ•°ï¼ˆä¼šè¢«åŠ¨æ€èµ‹å€¼ï¼Œä¿æŒå‘åå…¼å®¹ï¼‰
    this.cleanupDragPreview = () => {
      this.forceCleanupDragPreview();
    };
    // æ‹–æ‹½æç¤ºå…ƒç´ 
    this.dragHintElement = null;
    this.plugin = plugin;
    this.settings = plugin.settings;
    i18n.setLanguage(plugin.settings.language);
    this.linkedTabManager = new LinkedTabManager(this.app);
  }
  // å®‰å…¨çš„äº‹ä»¶ç›‘å¬å™¨æ·»åŠ æ–¹æ³•
  addGlobalEventListener(element, event, handler, options) {
    element.addEventListener(event, handler, options);
    this.globalEventListeners.push({ element, event, handler, options });
  }
  // å®‰å…¨çš„å®šæ—¶å™¨ç®¡ç†æ–¹æ³•
  safeSetTimeout(callback, delay) {
    const timeoutId = setTimeout(() => {
      this.activeTimeouts.delete(timeoutId);
      callback();
    }, delay);
    this.activeTimeouts.add(timeoutId);
    return timeoutId;
  }
  safeSetInterval(callback, delay) {
    const intervalId = setInterval(callback, delay);
    this.activeIntervals.add(intervalId);
    return intervalId;
  }
  // æ¸…ç†å•ä¸ªå®šæ—¶å™¨
  safeClearTimeout(timeoutId) {
    clearTimeout(timeoutId);
    this.activeTimeouts.delete(timeoutId);
  }
  safeClearInterval(intervalId) {
    clearInterval(intervalId);
    this.activeIntervals.delete(intervalId);
  }
  // æ™ºèƒ½ç¼“å­˜ç®¡ç†æ–¹æ³•
  manageCacheSize() {
    const now = Date.now();
    for (const [key, value] of this.linkPreviewCache.entries()) {
      if (now - value.timestamp > this.CACHE_TTL) {
        this.linkPreviewCache.delete(key);
      }
    }
    if (this.linkPreviewCache.size > this.MAX_CACHE_SIZE) {
      const entries = Array.from(this.linkPreviewCache.entries());
      entries.sort((a, b) => {
        const scoreA = a[1].accessCount * 0.7 + (now - a[1].timestamp) * 0.3;
        const scoreB = b[1].accessCount * 0.7 + (now - b[1].timestamp) * 0.3;
        return scoreA - scoreB;
      });
      const itemsToDelete = entries.slice(0, this.linkPreviewCache.size - this.MAX_CACHE_SIZE);
      itemsToDelete.forEach(([key]) => this.linkPreviewCache.delete(key));
    }
  }
  // æ¸…ç†è¿‡æœŸçš„åŠ è½½çŠ¶æ€
  cleanupLoadingUrls() {
    this.previewLoadingUrls.clear();
  }
  // è·å–ç¼“å­˜é¡¹å¹¶æ›´æ–°è®¿é—®ç»Ÿè®¡
  getCacheItem(url) {
    const item = this.linkPreviewCache.get(url);
    if (item) {
      item.accessCount++;
      item.timestamp = Date.now();
      return item.data;
    }
    return null;
  }
  // è®¾ç½®ç¼“å­˜é¡¹
  setCacheItem(url, data) {
    this.linkPreviewCache.set(url, {
      data,
      timestamp: Date.now(),
      accessCount: 1
    });
    this.manageCacheSize();
  }
  getViewType() {
    return CANVAS_GRID_VIEW_TYPE;
  }
  getDisplayText() {
    return "Canvasgrid Transit";
  }
  getIcon() {
    return "grid";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    if (!container) {
      console.error("Canvasgrid Transit: Container element not found");
      return;
    }
    container.empty();
    this.gridContainer = container.createDiv("canvas-grid-container");
    this.createToolbar(container);
    this.gridContainer.remove();
    this.gridContainer = container.createDiv("canvas-grid-container");
    this.gridContainer.classList.remove("toolbar-hidden");
    this.gridContainer.style.removeProperty("margin-top");
    this.gridContainer.style.removeProperty("height");
    this.setupGridStyles();
    this.setupEventDelegation();
    await this.loadActiveCanvas();
    this.setupDragDropHandlers();
    this.initializeSearchAndSort();
    this.initializeWidthControl();
    this.cacheCleanupInterval = this.safeSetInterval(() => {
      this.manageCacheSize();
      this.cleanupLoadingUrls();
    }, 10 * 60 * 1e3);
  }
  // åˆå§‹åŒ–æœç´¢å’Œæ’åºåŠŸèƒ½
  initializeSearchAndSort() {
    console.log("\u{1F527} Initializing search and sort functionality");
    this.filteredNodes = this.canvasData?.nodes || [];
    this.searchQuery = "";
    this.activeColorFilter = null;
    console.log(`\u{1F4CA} Initialized with ${this.filteredNodes.length} nodes`);
    console.log(`\u{1F504} Default sort: ${this.sortBy} (${this.sortOrder})`);
    this.applySortAndFilter();
  }
  // åˆ›å»ºæ–°çš„å·¥å…·æ å¸ƒå±€
  createToolbar(container) {
    const toolbar = container.createDiv("canvas-grid-toolbar");
    const mainRow = toolbar.createDiv("canvas-grid-toolbar-main-row");
    const leftSection = mainRow.createDiv("canvas-grid-toolbar-left");
    this.createMainMenuButton(leftSection);
    const middleSection = mainRow.createDiv("canvas-grid-toolbar-middle");
    this.createSearchBox(middleSection);
    const rightSection = mainRow.createDiv("canvas-grid-toolbar-right");
    this.createTimeCapsuleButton(rightSection);
    const colorRow = toolbar.createDiv("canvas-grid-toolbar-color-row");
    this.createColorFilter(colorRow);
  }
  // åˆ›å»ºä¸»èœå•æŒ‰é’®
  createMainMenuButton(container) {
    const menuContainer = container.createDiv("canvas-grid-main-menu");
    const mainBtn = menuContainer.createEl("button", {
      cls: "canvas-grid-main-btn canvas-grid-icon-only",
      title: "\u7F51\u683C\u89C6\u56FE\u83DC\u5355"
    });
    const btnContent = mainBtn.createDiv("canvas-grid-main-btn-content");
    const iconEl = btnContent.createDiv("canvas-grid-main-icon");
    iconEl.innerHTML = `
			<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<rect x="3" y="3" width="7" height="7"/>
				<rect x="14" y="3" width="7" height="7"/>
				<rect x="3" y="14" width="7" height="7"/>
				<rect x="14" y="14" width="7" height="7"/>
			</svg>
		`;
    const arrowEl = btnContent.createDiv("canvas-grid-main-arrow");
    arrowEl.innerHTML = `
			<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<polyline points="6,9 12,15 18,9"/>
			</svg>
		`;
    this.linkedIndicatorEl = document.createElement("div");
    this.linkedIndicatorEl.className = "canvas-grid-linked-indicator-hidden";
    this.linkedIndicatorEl.style.display = "none";
    btnContent.appendChild(this.linkedIndicatorEl);
    this.updateLinkedCanvasDisplay(null);
    const mainDropdown = menuContainer.createDiv("canvas-grid-main-dropdown");
    mainDropdown.style.display = "none";
    this.createMainMenuContent(mainDropdown);
    mainBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      const isVisible = mainDropdown.style.display !== "none";
      this.hideAllDropdowns();
      if (!isVisible) {
        mainDropdown.style.display = "block";
        mainBtn.classList.add("active");
      }
    });
    document.addEventListener("click", () => {
      mainDropdown.style.display = "none";
      mainBtn.classList.remove("active");
    });
    mainDropdown.addEventListener("click", (e) => {
      e.stopPropagation();
    });
  }
  // åˆ›å»ºä¸»èœå•å†…å®¹
  createMainMenuContent(container) {
    this.createLinkManagementSection(container);
    this.createDataOperationsSection(container);
    this.createSortFilterSection(container);
    this.createNavigationSection(container);
  }
  // åˆ›å»ºå…³è”ç®¡ç†éƒ¨åˆ†
  createLinkManagementSection(container) {
    const section = container.createDiv("canvas-grid-menu-section");
    const autoLinkItem = section.createDiv("canvas-grid-menu-item");
    autoLinkItem.innerHTML = `
			<svg class="menu-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/>
			</svg>
			<span class="menu-text">\u81EA\u52A8\u5173\u8054\u5F53\u524DCanvas</span>
		`;
    autoLinkItem.addEventListener("click", () => {
      this.autoLinkCurrentCanvas();
      this.hideAllDropdowns();
    });
    const customLinkItem = section.createDiv("canvas-grid-menu-item");
    customLinkItem.innerHTML = `
			<svg class="menu-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
				<path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
			</svg>
			<span class="menu-text">\u9009\u62E9\u5173\u8054Canvas\u6587\u4EF6</span>
		`;
    customLinkItem.addEventListener("click", () => {
      this.showCanvasSelectionDialog();
      this.hideAllDropdowns();
    });
    const unlinkItem = section.createDiv("canvas-grid-menu-item");
    unlinkItem.innerHTML = `
			<svg class="menu-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<path d="M18 6L6 18M6 6l12 12"/>
			</svg>
			<span class="menu-text">\u89E3\u9664\u5173\u8054</span>
		`;
    unlinkItem.addEventListener("click", () => {
      this.unlinkCanvas();
      this.hideAllDropdowns();
    });
  }
  // è§†å›¾è®¾ç½®éƒ¨åˆ†å·²ç§»é™¤ï¼ŒåŠŸèƒ½ç®€åŒ–
  // åˆ›å»ºæ•°æ®æ“ä½œéƒ¨åˆ†
  createDataOperationsSection(container) {
    const section = container.createDiv("canvas-grid-menu-section");
    const syncItem = section.createDiv("canvas-grid-menu-item");
    syncItem.innerHTML = `
			<svg class="menu-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<polyline points="23,4 23,10 17,10"/>
				<polyline points="1,20 1,14 7,14"/>
				<path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"/>
			</svg>
			<span class="menu-text">\u540C\u6B65\u6570\u636E</span>
		`;
    syncItem.addEventListener("click", () => {
      this.syncCanvasData();
      this.hideAllDropdowns();
    });
    const createItem = section.createDiv("canvas-grid-menu-item");
    createItem.innerHTML = `
			<svg class="menu-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
				<polyline points="14,2 14,8 20,8"/>
				<line x1="12" y1="18" x2="12" y2="12"/>
				<line x1="9" y1="15" x2="15" y2="15"/>
			</svg>
			<span class="menu-text">\u65B0\u5EFACanvas\u6587\u4EF6</span>
		`;
    createItem.addEventListener("click", () => {
      this.createNewCanvasFile();
      this.hideAllDropdowns();
    });
  }
  // åˆ›å»ºæ’åºå’Œç­›é€‰éƒ¨åˆ†
  createSortFilterSection(container) {
    const section = container.createDiv("canvas-grid-menu-section");
    i18n.setLanguage(this.settings.language);
    const sortItem = section.createDiv("canvas-grid-menu-item canvas-grid-submenu-item");
    sortItem.innerHTML = `
			<svg class="menu-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<path d="M3 6h18"/>
				<path d="M7 12h10"/>
				<path d="M10 18h4"/>
			</svg>
			<span class="menu-text">${i18n.t("sortBy")}</span>
			<svg class="menu-arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<polyline points="9,18 15,12 9,6"/>
			</svg>
		`;
    const filterItem = section.createDiv("canvas-grid-menu-item canvas-grid-submenu-item");
    filterItem.innerHTML = `
			<svg class="menu-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<polyline points="22,12 18,12 15,21 9,3 6,12 2,12"/>
			</svg>
			<span class="menu-text">\u7B5B\u9009\u6761\u4EF6</span>
			<svg class="menu-arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<polyline points="9,18 15,12 9,6"/>
			</svg>
		`;
    this.addSubmenuEvents(sortItem, "sort");
    this.addSubmenuEvents(filterItem, "filter");
  }
  // æ·»åŠ å­èœå•äº‹ä»¶
  addSubmenuEvents(menuItem, type) {
    menuItem.addEventListener("click", (e) => {
      e.stopPropagation();
      const existingSubmenu = document.querySelector(`.canvas-grid-submenu[data-submenu-type="${type}"]`);
      if (existingSubmenu) {
        this.closeAllSubmenus();
      } else {
        this.showSubmenu(menuItem, type);
      }
    });
  }
  // æ˜¾ç¤ºå­èœå•
  showSubmenu(parentItem, type) {
    this.closeAllSubmenus();
    const submenu = document.createElement("div");
    submenu.className = "canvas-grid-submenu";
    submenu.dataset.submenuType = type;
    switch (type) {
      case "sort":
        this.createSortSubmenu(submenu);
        break;
      case "filter":
        this.createFilterSubmenu(submenu);
        break;
    }
    const rect = parentItem.getBoundingClientRect();
    submenu.style.position = "fixed";
    submenu.style.left = `${rect.right + 8}px`;
    submenu.style.top = `${rect.top}px`;
    submenu.style.zIndex = "1001";
    document.body.appendChild(submenu);
    const closeSubmenu = (e) => {
      if (!submenu.contains(e.target) && !parentItem.contains(e.target)) {
        submenu.remove();
        document.removeEventListener("click", closeSubmenu);
        const index = this.globalEventListeners.findIndex(
          (listener) => listener.element === document && listener.event === "click" && listener.handler === closeSubmenu
        );
        if (index > -1) {
          this.globalEventListeners.splice(index, 1);
        }
      }
    };
    this.safeSetTimeout(() => {
      this.addGlobalEventListener(document, "click", closeSubmenu);
    }, 0);
  }
  // å…³é—­æ‰€æœ‰å­èœå•
  closeAllSubmenus() {
    const existingSubmenus = document.querySelectorAll(".canvas-grid-submenu");
    existingSubmenus.forEach((submenu) => {
      submenu.remove();
    });
  }
  // åˆ›å»ºåˆå¹¶æ’åºå­èœå•ï¼ˆæ’åºæ–¹å¼+é¡ºåºï¼‰
  createSortSubmenu(container) {
    i18n.setLanguage(this.settings.language);
    const sortOptions = [
      { key: "created", label: i18n.t("sortByCreated") },
      { key: "modified", label: i18n.t("sortByModified") },
      { key: "title", label: i18n.t("sortByTitle") }
    ];
    console.log(`\u{1F39B}\uFE0F Creating sort submenu with current sort: ${this.sortBy} (${this.sortOrder})`);
    sortOptions.forEach((option) => {
      const item = container.createDiv("canvas-grid-menu-item");
      const isActive = this.sortBy === option.key;
      const isAsc = this.sortOrder === "asc";
      let statusIcon = "";
      if (isActive) {
        statusIcon = isAsc ? "\u2191" : "\u2193";
      }
      item.innerHTML = `
				<span class="menu-text">${option.label}</span>
				<span class="menu-status">${statusIcon}</span>
			`;
      if (isActive) {
        item.style.backgroundColor = "var(--background-modifier-hover)";
        item.style.fontWeight = "600";
      }
      item.addEventListener("click", () => {
        console.log(`\u{1F504} Sort option clicked: ${option.key} (current: ${this.sortBy})`);
        if (this.sortBy === option.key) {
          this.sortOrder = this.sortOrder === "asc" ? "desc" : "asc";
          console.log(`\u{1F504} Toggled sort order to: ${this.sortOrder}`);
        } else {
          this.sortBy = option.key;
          this.sortOrder = "desc";
          console.log(`\u{1F504} Changed sort to: ${this.sortBy} (${this.sortOrder})`);
        }
        this.applySortAndFilter();
        this.hideAllDropdowns();
        container.parentElement?.remove();
      });
    });
  }
  // åˆ›å»ºç­›é€‰å­èœå•
  createFilterSubmenu(container) {
    const filterOptions = [
      { key: "all", label: "\u663E\u793A\u5168\u90E8" },
      { key: "text", label: "\u4EC5\u6587\u672C\u5361\u7247" },
      { key: "file", label: "\u4EC5\u6587\u4EF6\u5361\u7247" },
      { key: "link", label: "\u4EC5\u94FE\u63A5\u5361\u7247" }
    ];
    filterOptions.forEach((option) => {
      const item = container.createDiv("canvas-grid-menu-item");
      item.innerHTML = `<span class="menu-text">${option.label}</span>`;
      item.addEventListener("click", () => {
        this.applyTypeFilter(option.key);
        this.hideAllDropdowns();
        container.parentElement?.remove();
      });
    });
  }
  // åˆ›å»ºå¯¼èˆªéƒ¨åˆ†
  createNavigationSection(container) {
    const section = container.createDiv("canvas-grid-menu-section");
    const backItem = section.createDiv("canvas-grid-menu-item canvas-grid-menu-back");
    backItem.innerHTML = `
			<svg class="menu-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<line x1="19" y1="12" x2="5" y2="12"/>
				<polyline points="12,19 5,12 12,5"/>
			</svg>
			<span class="menu-text">\u8FD4\u56DECanvas\u767D\u677F</span>
		`;
    backItem.addEventListener("click", () => {
      this.returnToCanvas();
      this.hideAllDropdowns();
    });
  }
  // å¡ç‰‡å¤§å°ç›¸å…³æ–¹æ³•å·²ç§»é™¤
  // åˆ›å»ºæ–°Canvasæ–‡ä»¶
  async createNewCanvasFile() {
    try {
      const fileName = `Canvas-${Date.now()}.canvas`;
      const newFile = await this.app.vault.create(fileName, JSON.stringify({
        nodes: [],
        edges: []
      }));
      await this.setLinkedCanvas(newFile);
      new import_obsidian.Notice(`\u5DF2\u521B\u5EFA\u5E76\u5173\u8054\u65B0Canvas\u6587\u4EF6: ${newFile.basename}`);
    } catch (error) {
      console.error("Failed to create new canvas file:", error);
      new import_obsidian.Notice("\u521B\u5EFACanvas\u6587\u4EF6\u5931\u8D25");
    }
  }
  // åŒæ­¥Canvasæ•°æ®ï¼ˆåˆå¹¶åˆ·æ–°å’ŒåŒæ­¥åŠŸèƒ½ï¼‰
  async syncCanvasData() {
    try {
      if (this.linkedCanvasFile) {
        await this.loadCanvasDataFromFile(this.linkedCanvasFile);
        this.notifyCanvasViewRefresh();
        new import_obsidian.Notice("Canvas\u6570\u636E\u5DF2\u540C\u6B65");
      } else {
        await this.loadActiveCanvas();
        new import_obsidian.Notice("Canvas\u6570\u636E\u5DF2\u5237\u65B0");
      }
    } catch (error) {
      console.error("Failed to sync canvas data:", error);
      const errorMessage = error instanceof Error ? error.message : "\u672A\u77E5\u9519\u8BEF";
      new import_obsidian.Notice(`\u540C\u6B65\u6570\u636E\u5931\u8D25: ${errorMessage}`);
      this.showErrorState(`\u540C\u6B65\u5931\u8D25: ${errorMessage}`);
    }
  }
  // å¯¼å‡ºç½‘æ ¼æ•°æ®
  async exportGridData() {
    if (!this.canvasData) {
      new import_obsidian.Notice("\u6CA1\u6709\u53EF\u5BFC\u51FA\u7684\u6570\u636E");
      return;
    }
    try {
      const exportData = {
        timestamp: Date.now(),
        source: this.linkedCanvasFile?.path || "unknown",
        nodes: this.canvasData.nodes,
        edges: this.canvasData.edges
      };
      const fileName = `grid-export-${Date.now()}.json`;
      await this.app.vault.create(fileName, JSON.stringify(exportData, null, 2));
      new import_obsidian.Notice(`\u6570\u636E\u5DF2\u5BFC\u51FA\u5230: ${fileName}`);
    } catch (error) {
      console.error("Failed to export data:", error);
      new import_obsidian.Notice("\u5BFC\u51FA\u6570\u636E\u5931\u8D25");
    }
  }
  // è¿”å›Canvasç™½æ¿
  returnToCanvas() {
    if (this.linkedCanvasFile) {
      this.app.workspace.openLinkText(this.linkedCanvasFile.path, "", false);
    } else {
      const canvasLeaves = this.app.workspace.getLeavesOfType("canvas");
      if (canvasLeaves.length > 0) {
        this.app.workspace.setActiveLeaf(canvasLeaves[0]);
      } else {
        new import_obsidian.Notice("\u6CA1\u6709\u627E\u5230\u53EF\u8FD4\u56DE\u7684Canvas\u6587\u4EF6");
      }
    }
  }
  // åˆ›å»ºæ“ä½œæŒ‰é’® (å·²æ•´åˆåˆ°ä¸»èœå•ï¼Œä¿ç•™ä»¥é˜²å…¼å®¹æ€§é—®é¢˜)
  createActionButtons(container) {
    return;
    const actionsEl = container.createDiv("canvas-grid-toolbar-actions");
    const officialLinkBtn = actionsEl.createEl("button", {
      cls: "canvas-grid-action-btn canvas-grid-official-link-btn",
      title: "\u4F7F\u7528\u5B98\u65B9\u5173\u8054\u6807\u7B7E\u9875\u529F\u80FD"
    });
    officialLinkBtn.innerHTML = `
			<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<path d="M9 12l2 2 4-4"/>
				<path d="M21 12c-1 0-3-1-3-3s2-3 3-3 3 1 3 3-2 3-3 3"/>
				<path d="M3 12c1 0 3-1 3-3s-2-3-3-3-3 1-3 3 2 3 3 3"/>
				<path d="M13 12h3"/>
				<path d="M8 12h3"/>
			</svg>
		`;
    officialLinkBtn.onclick = () => {
      new import_obsidian.Notice("\u5B98\u65B9\u5173\u8054\u529F\u80FD\u5DF2\u6574\u5408\u5230\u81EA\u52A8\u5173\u8054\u4E2D");
    };
    const linkBtn = actionsEl.createEl("button", {
      cls: "canvas-grid-action-btn",
      title: "\u81EA\u5B9A\u4E49\u5173\u8054Canvas\u6587\u4EF6"
    });
    linkBtn.innerHTML = `
			<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
				<path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
			</svg>
		`;
    linkBtn.onclick = () => this.showCanvasSelectionDialog();
    const unlinkBtn = actionsEl.createEl("button", {
      cls: "canvas-grid-action-btn canvas-grid-unlink-btn",
      title: "\u89E3\u9664\u5173\u8054"
    });
    unlinkBtn.innerHTML = `
			<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<path d="M18 6L6 18M6 6l12 12"/>
			</svg>
		`;
    unlinkBtn.onclick = () => this.unlinkCanvas();
    this.updateActionButtonsVisibility();
  }
  // åˆ›å»ºæœç´¢æ¡†
  createSearchBox(container) {
    const searchContainer = container.createDiv("canvas-grid-search-container");
    this.searchInputEl = searchContainer.createEl("input", {
      cls: "canvas-grid-search-input",
      type: "text",
      placeholder: this.settings.language === "zh" ? "\u641C\u7D22\u5361\u7247\u5185\u5BB9..." : "Search card content..."
    });
    const clearBtn = searchContainer.createDiv("canvas-grid-search-clear");
    clearBtn.innerHTML = `
			<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<line x1="18" y1="6" x2="6" y2="18"/>
				<line x1="6" y1="6" x2="18" y2="18"/>
			</svg>
		`;
    clearBtn.style.display = "none";
    this.searchInputEl.addEventListener("input", (e) => {
      const target = e.target;
      this.searchQuery = target.value.trim();
      if (this.searchQuery) {
        clearBtn.style.display = "flex";
      } else {
        clearBtn.style.display = "none";
      }
      this.performSearch();
    });
    clearBtn.addEventListener("click", () => {
      this.searchInputEl.value = "";
      this.searchQuery = "";
      clearBtn.style.display = "none";
      this.performSearch();
      this.searchInputEl.focus();
    });
    this.searchInputEl.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        this.searchInputEl.blur();
      }
    });
  }
  // åˆ›å»ºæ—¶é—´èƒ¶å›ŠæŒ‰é’®
  createTimeCapsuleButton(container) {
    const buttonContainer = container.createDiv("canvas-grid-time-capsule-container");
    this.timeCapsuleButton = buttonContainer.createEl("button", {
      cls: "canvas-grid-time-capsule-btn",
      title: "\u65F6\u95F4\u80F6\u56CA - \u70B9\u51FB\u5F00\u59CB\u6536\u96C6"
    });
    this.updateTimeCapsuleButton();
    this.timeCapsuleButton.addEventListener("click", () => {
      this.toggleTimeCapsuleInternal();
    });
    let longPressTimer = null;
    this.timeCapsuleButton.addEventListener("mousedown", () => {
      longPressTimer = setTimeout(() => {
        this.showDurationMenu();
      }, 800);
    });
    this.timeCapsuleButton.addEventListener("mouseup", () => {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    });
    this.timeCapsuleButton.addEventListener("mouseleave", () => {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    });
  }
  // åˆ›å»ºé¢œè‰²ç­›é€‰å™¨
  createColorFilter(container) {
    this.colorFilterContainer = container.createDiv("canvas-grid-color-filter");
    const allBtn = this.colorFilterContainer.createDiv("canvas-grid-color-dot all-colors");
    allBtn.title = "\u663E\u793A\u5168\u90E8\u989C\u8272";
    allBtn.classList.add("active");
    allBtn.style.background = "conic-gradient(from 0deg, #ff6b6b 0deg 51.4deg, #ffa726 51.4deg 102.8deg, #ffeb3b 102.8deg 154.2deg, #66bb6a 154.2deg 205.6deg, #26c6da 205.6deg 257deg, #42a5f5 257deg 308.4deg, #ab47bc 308.4deg 360deg)";
    allBtn.addEventListener("click", () => {
      this.setColorFilter(null);
    });
    this.settings.colorFilterColors.forEach((colorValue) => {
      const colorDot = this.colorFilterContainer.createDiv("canvas-grid-color-dot");
      colorDot.dataset.color = colorValue;
      const colorMap = {
        "1": "#ff6b6b",
        // çº¢è‰²
        "2": "#ffa726",
        // æ©™è‰²
        "3": "#ffeb3b",
        // é»„è‰²
        "4": "#66bb6a",
        // ç»¿è‰²
        "5": "#26c6da",
        // é’è‰²
        "6": "#42a5f5",
        // è“è‰²
        "7": "#ab47bc"
        // ç´«è‰²
      };
      const color = colorMap[colorValue];
      if (color) {
        colorDot.style.backgroundColor = color;
        colorDot.style.borderColor = color;
      }
      const colorCategory = this.settings.colorCategories.find((cat) => cat.color === colorValue);
      if (colorCategory) {
        colorDot.title = this.settings.language === "zh" ? `\u7B5B\u9009${colorCategory.name}\u5361\u7247` : `Filter ${colorCategory.name} cards`;
      } else {
        const colorNames = this.settings.language === "zh" ? ["\u7EA2", "\u6A59", "\u9EC4", "\u7EFF", "\u9752", "\u84DD", "\u7D2B"] : ["Red", "Orange", "Yellow", "Green", "Cyan", "Blue", "Purple"];
        const index = parseInt(colorValue) - 1;
        if (index >= 0 && index < colorNames.length) {
          colorDot.title = this.settings.language === "zh" ? `\u7B5B\u9009${colorNames[index]}\u8272\u5361\u7247` : `Filter ${colorNames[index]} cards`;
        }
      }
      colorDot.addEventListener("click", () => {
        this.setColorFilter(colorValue);
      });
    });
  }
  // è®¾ç½®é¢œè‰²ç­›é€‰å™¨ï¼ˆäº’æ–¥é€‰æ‹©ï¼‰
  setColorFilter(color) {
    console.log("\u8BBE\u7F6E\u989C\u8272\u7B5B\u9009\u5668:", color);
    if (this.activeColorFilter === color) {
      this.activeColorFilter = null;
      color = null;
      console.log("\u53D6\u6D88\u5F53\u524D\u989C\u8272\u7B5B\u9009\uFF0C\u56DE\u5230\u663E\u793A\u5168\u90E8");
    } else {
      this.activeColorFilter = color;
    }
    if (this.colorFilterContainer) {
      const dots = this.colorFilterContainer.querySelectorAll(".canvas-grid-color-dot");
      console.log("\u627E\u5230\u989C\u8272\u5706\u70B9\u6570\u91CF:", dots.length);
      dots.forEach((dot) => {
        dot.classList.remove("active");
      });
      if (color === null) {
        const allBtn = this.colorFilterContainer.querySelector(".all-colors");
        if (allBtn) {
          allBtn.classList.add("active");
          console.log('\u6FC0\u6D3B"\u5168\u90E8"\u6309\u94AE');
        }
      } else {
        const targetDot = this.colorFilterContainer.querySelector(`[data-color="${color}"]`);
        if (targetDot) {
          targetDot.classList.add("active");
          console.log("\u6FC0\u6D3B\u989C\u8272\u5706\u70B9:", color);
        }
      }
    }
    console.log("\u6267\u884C\u989C\u8272\u7B5B\u9009\uFF0C\u5F53\u524D\u7B5B\u9009\u989C\u8272:", this.activeColorFilter);
    this.performSearch();
  }
  // ==================== æ—¶é—´èƒ¶å›ŠåŠŸèƒ½æ–¹æ³• ====================
  // æ›´æ–°æ—¶é—´èƒ¶å›ŠæŒ‰é’®æ˜¾ç¤º
  updateTimeCapsuleButton() {
    if (!this.timeCapsuleButton)
      return;
    const state = this.timeCapsuleState;
    if (state.isActive) {
      const minutes = Math.floor(state.remainingTime / 6e4);
      const seconds = Math.floor(state.remainingTime % 6e4 / 1e3);
      const timeText = `${minutes}:${seconds.toString().padStart(2, "0")}`;
      let colorClass = "active";
      if (state.remainingTime < 6e4) {
        colorClass = "warning";
      }
      this.timeCapsuleButton.className = `canvas-grid-time-capsule-btn ${colorClass}`;
      this.timeCapsuleButton.innerHTML = `
				<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
					<path d="M6 2v6h.01L6 8.01 10 12l-4 4-.01.01V22h12v-5.99-.01L18 16l-4-4 4-3.99.01-.01V2H6z"/>
				</svg>
				<span class="time-display">${timeText}</span>
			`;
      this.timeCapsuleButton.title = `\u65F6\u95F4\u80F6\u56CA\u6536\u96C6\u4E2D - \u5269\u4F59 ${timeText}`;
    } else {
      this.timeCapsuleButton.className = "canvas-grid-time-capsule-btn";
      this.timeCapsuleButton.innerHTML = `
				<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
					<path d="M6 2v6h.01L6 8.01 10 12l-4 4-.01.01V22h12v-5.99-.01L18 16l-4-4 4-3.99.01-.01V2H6z"/>
				</svg>
			`;
      this.timeCapsuleButton.title = "\u65F6\u95F4\u80F6\u56CA - \u70B9\u51FB\u5F00\u59CB\u6536\u96C6";
    }
  }
  // åˆ‡æ¢æ—¶é—´èƒ¶å›ŠçŠ¶æ€ï¼ˆç§æœ‰æ–¹æ³•ï¼Œä¾›æŒ‰é’®ç‚¹å‡»ä½¿ç”¨ï¼‰
  toggleTimeCapsuleInternal() {
    if (this.timeCapsuleState.isActive) {
      this.stopTimeCapsule();
    } else {
      this.startTimeCapsule();
    }
  }
  // å¼€å§‹æ—¶é—´èƒ¶å›Š
  startTimeCapsule() {
    const duration = this.timeCapsuleState.duration;
    const now = Date.now();
    const groupName = `\u65F6\u95F4\u80F6\u56CA ${(/* @__PURE__ */ new Date()).toLocaleString("zh-CN", {
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit"
    })}`;
    this.timeCapsuleState = {
      isActive: true,
      startTime: now,
      duration,
      remainingTime: duration,
      groupId: null,
      // ç¨ååˆ›å»ºåˆ†ç»„æ—¶è®¾ç½®
      collectedItems: [],
      groupName
    };
    this.createTimeCapsuleGroup();
    this.startTimeCapsuleTimer();
    this.renderGrid();
    new import_obsidian.Notice(`\u65F6\u95F4\u80F6\u56CA\u5DF2\u542F\u52A8\uFF01\u6536\u96C6\u65F6\u957F\uFF1A${Math.floor(duration / 6e4)}\u5206\u949F`);
    console.log("\u65F6\u95F4\u80F6\u56CA\u5DF2\u542F\u52A8\uFF0C\u7F51\u683C\u89C6\u56FE\u5DF2\u5237\u65B0:", this.timeCapsuleState);
  }
  // åœæ­¢æ—¶é—´èƒ¶å›Š
  stopTimeCapsule() {
    if (this.timeCapsuleTimer) {
      clearTimeout(this.timeCapsuleTimer);
      this.timeCapsuleTimer = null;
    }
    if (this.timeCapsuleUpdateInterval) {
      clearInterval(this.timeCapsuleUpdateInterval);
      this.timeCapsuleUpdateInterval = null;
    }
    const collectedCount = this.timeCapsuleState.collectedItems.length;
    this.timeCapsuleState = {
      isActive: false,
      startTime: 0,
      duration: 15 * 60 * 1e3,
      remainingTime: 0,
      groupId: null,
      collectedItems: [],
      groupName: ""
    };
    this.updateTimeCapsuleButton();
    this.renderGrid();
    new import_obsidian.Notice(`\u65F6\u95F4\u80F6\u56CA\u5DF2\u7ED3\u675F\uFF01\u5171\u6536\u96C6\u4E86 ${collectedCount} \u4E2A\u9879\u76EE`);
    console.log("\u65F6\u95F4\u80F6\u56CA\u5DF2\u505C\u6B62\uFF0C\u7F51\u683C\u89C6\u56FE\u5DF2\u5237\u65B0");
  }
  // å¼€å§‹å€’è®¡æ—¶å®šæ—¶å™¨
  startTimeCapsuleTimer() {
    this.timeCapsuleTimer = setTimeout(() => {
      this.stopTimeCapsule();
    }, this.timeCapsuleState.duration);
    this.timeCapsuleUpdateInterval = setInterval(() => {
      const elapsed = Date.now() - this.timeCapsuleState.startTime;
      this.timeCapsuleState.remainingTime = Math.max(0, this.timeCapsuleState.duration - elapsed);
      this.updateTimeCapsuleButton();
      this.updateTimeCapsuleGroupDisplay();
      if (this.timeCapsuleState.remainingTime <= 0) {
        this.stopTimeCapsule();
      }
    }, 1e3);
  }
  // åˆ›å»ºæ—¶é—´èƒ¶å›Šåˆ†ç»„
  createTimeCapsuleGroup() {
    if (!this.canvasData) {
      console.warn("\u65E0\u6CD5\u521B\u5EFA\u65F6\u95F4\u80F6\u56CA\u5206\u7EC4\uFF1ACanvas\u6570\u636E\u4E0D\u5B58\u5728");
      return;
    }
    const groupId = `time-capsule-${Date.now()}`;
    const timeCapsuleSize = { width: 400, height: 300 };
    const position = this.findSafePositionForTimeCapsule(timeCapsuleSize);
    console.log(`\u{1F3AF} \u65F6\u95F4\u80F6\u56CA\u5206\u7EC4\u4F4D\u7F6E\u8BA1\u7B97\u5B8C\u6210: (${position.x}, ${position.y})`);
    const groupNode = {
      id: groupId,
      type: "group",
      x: position.x,
      y: position.y,
      width: timeCapsuleSize.width,
      height: timeCapsuleSize.height,
      color: "5",
      // é’è‰² - æ—¶é—´èƒ¶å›Šä¸»é¢˜è‰²
      label: this.timeCapsuleState.groupName
    };
    this.canvasData.nodes.push(groupNode);
    this.timeCapsuleState.groupId = groupId;
    this.saveCanvasData();
    console.log("\u65F6\u95F4\u80F6\u56CA\u5206\u7EC4\u5DF2\u521B\u5EFA:", groupId, "\u4F4D\u7F6E:", position);
  }
  // ä¸ºæ—¶é—´èƒ¶å›Šåˆ†ç»„å¯»æ‰¾å®‰å…¨ä½ç½®ï¼Œé¿å…ä¸ç°æœ‰åˆ†ç»„é‡å 
  findSafePositionForTimeCapsule(size) {
    if (!this.canvasData) {
      return { x: 100, y: 100 };
    }
    const existingGroups = this.canvasData.nodes.filter((node) => node.type === "group");
    console.log(`\u{1F4CA} \u68C0\u6D4B\u5230 ${existingGroups.length} \u4E2A\u73B0\u6709\u5206\u7EC4`);
    const candidatePositions = [
      { x: 50, y: 50 },
      // å·¦ä¸Šè§’
      { x: 500, y: 50 },
      // å³ä¸Šè§’
      { x: 50, y: 400 },
      // å·¦ä¸‹è§’
      { x: 500, y: 400 },
      // å³ä¸‹è§’
      { x: 250, y: 50 },
      // é¡¶éƒ¨ä¸­å¤®
      { x: 50, y: 225 },
      // å·¦ä¾§ä¸­å¤®
      { x: 500, y: 225 },
      // å³ä¾§ä¸­å¤®
      { x: 250, y: 400 },
      // åº•éƒ¨ä¸­å¤®
      { x: 800, y: 50 },
      // æ›´å³ä¸Šè§’
      { x: 800, y: 400 }
      // æ›´å³ä¸‹è§’
    ];
    for (const candidate of candidatePositions) {
      if (this.isPositionSafe(candidate, size, existingGroups)) {
        console.log(`\u2705 \u627E\u5230\u5B89\u5168\u4F4D\u7F6E: (${candidate.x}, ${candidate.y})`);
        return candidate;
      }
    }
    const dynamicPosition = this.findDynamicSafePosition(size, existingGroups);
    if (dynamicPosition) {
      console.log(`\u{1F50D} \u52A8\u6001\u627E\u5230\u5B89\u5168\u4F4D\u7F6E: (${dynamicPosition.x}, ${dynamicPosition.y})`);
      return dynamicPosition;
    }
    const fallbackPosition = { x: 1e3, y: 50 };
    console.log(`\u26A0\uFE0F \u4F7F\u7528\u5907\u7528\u4F4D\u7F6E: (${fallbackPosition.x}, ${fallbackPosition.y})`);
    return fallbackPosition;
  }
  // æ£€æŸ¥æŒ‡å®šä½ç½®æ˜¯å¦å®‰å…¨ï¼ˆä¸ä¸ç°æœ‰åˆ†ç»„é‡å ï¼‰
  isPositionSafe(position, size, existingGroups) {
    const newGroupBounds = {
      left: position.x,
      top: position.y,
      right: position.x + size.width,
      bottom: position.y + size.height
    };
    for (const group of existingGroups) {
      const groupBounds = {
        left: group.x,
        top: group.y,
        right: group.x + (group.width || 200),
        bottom: group.y + (group.height || 200)
      };
      const isOverlapping = !(newGroupBounds.right < groupBounds.left || newGroupBounds.left > groupBounds.right || newGroupBounds.bottom < groupBounds.top || newGroupBounds.top > groupBounds.bottom);
      if (isOverlapping) {
        console.log(`\u274C \u4F4D\u7F6E (${position.x}, ${position.y}) \u4E0E\u5206\u7EC4 ${group.id} \u91CD\u53E0`);
        return false;
      }
    }
    return true;
  }
  // åŠ¨æ€å¯»æ‰¾å®‰å…¨ä½ç½®
  findDynamicSafePosition(size, existingGroups) {
    const canvasBounds = this.calculateCanvasBounds(existingGroups);
    const rightSideX = canvasBounds.maxX + 100;
    const testPosition = { x: rightSideX, y: 50 };
    if (this.isPositionSafe(testPosition, size, existingGroups)) {
      return testPosition;
    }
    const bottomY = canvasBounds.maxY + 100;
    const bottomPosition = { x: 50, y: bottomY };
    if (this.isPositionSafe(bottomPosition, size, existingGroups)) {
      return bottomPosition;
    }
    const gridStep = 50;
    for (let x = 50; x <= 1200; x += gridStep) {
      for (let y = 50; y <= 800; y += gridStep) {
        const gridPosition = { x, y };
        if (this.isPositionSafe(gridPosition, size, existingGroups)) {
          return gridPosition;
        }
      }
    }
    return null;
  }
  // è®¡ç®—Canvasçš„ä½¿ç”¨è¾¹ç•Œ
  calculateCanvasBounds(existingGroups) {
    if (existingGroups.length === 0) {
      return { minX: 0, minY: 0, maxX: 0, maxY: 0 };
    }
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    existingGroups.forEach((group) => {
      const left = group.x;
      const top = group.y;
      const right = group.x + (group.width || 200);
      const bottom = group.y + (group.height || 200);
      minX = Math.min(minX, left);
      minY = Math.min(minY, top);
      maxX = Math.max(maxX, right);
      maxY = Math.max(maxY, bottom);
    });
    console.log(`\u{1F4D0} Canvas\u4F7F\u7528\u8FB9\u754C: (${minX}, ${minY}) \u5230 (${maxX}, ${maxY})`);
    return { minX, minY, maxX, maxY };
  }
  // æ›´æ–°æ—¶é—´èƒ¶å›Šåˆ†ç»„æ˜¾ç¤º
  updateTimeCapsuleGroupDisplay() {
    if (!this.timeCapsuleState.isActive || !this.timeCapsuleState.groupId)
      return;
    const groupCard = this.gridContainer.querySelector(`[data-node-id="${this.timeCapsuleState.groupId}"]`);
    if (!groupCard)
      return;
    const countDiv = groupCard.querySelector(".group-member-count");
    if (countDiv) {
      const minutes = Math.floor(this.timeCapsuleState.remainingTime / 6e4);
      const seconds = Math.floor(this.timeCapsuleState.remainingTime % 6e4 / 1e3);
      const timeText = `${minutes}:${seconds.toString().padStart(2, "0")}`;
      const collectedCount = this.timeCapsuleState.collectedItems.length;
      countDiv.innerHTML = `
				<div class="time-capsule-status">
					<span class="collecting-text">\u6536\u96C6\u4E2D</span>
					<span class="countdown-text">${timeText}</span>
				</div>
				<div class="member-count">${collectedCount} \u4E2A\u9879\u76EE</div>
			`;
    }
    if (this.timeCapsuleState.remainingTime < 6e4) {
      groupCard.classList.add("time-capsule-urgent");
    }
  }
  // è·å–æ—¶é—´èƒ¶å›Šæœ€å¤§æ”¶é›†æ•°é‡ï¼ˆåŸºäºæ—¶é•¿ï¼‰
  getMaxCollectionCount() {
    const durationMinutes = Math.floor(this.timeCapsuleState.duration / 6e4);
    return Math.max(10, durationMinutes * 2);
  }
  // æ˜¾ç¤ºæ—¶é•¿é€‰æ‹©èœå•
  showDurationMenu() {
    const menu = document.createElement("div");
    menu.className = "canvas-grid-duration-menu";
    const durations = [
      { label: "5\u5206\u949F", value: 5 * 60 * 1e3 },
      { label: "15\u5206\u949F", value: 15 * 60 * 1e3 },
      { label: "30\u5206\u949F", value: 30 * 60 * 1e3 },
      { label: "1\u5C0F\u65F6", value: 60 * 60 * 1e3 }
    ];
    durations.forEach((duration) => {
      const item = menu.createDiv("duration-menu-item");
      item.textContent = duration.label;
      item.onclick = () => {
        this.timeCapsuleState.duration = duration.value;
        menu.remove();
        new import_obsidian.Notice(`\u65F6\u95F4\u80F6\u56CA\u65F6\u957F\u8BBE\u7F6E\u4E3A\uFF1A${duration.label}`);
      };
    });
    const buttonRect = this.timeCapsuleButton.getBoundingClientRect();
    menu.style.position = "fixed";
    menu.style.top = `${buttonRect.bottom + 5}px`;
    menu.style.left = `${buttonRect.left}px`;
    menu.style.zIndex = "1000";
    document.body.appendChild(menu);
    const closeMenu = (e) => {
      if (!menu.contains(e.target)) {
        menu.remove();
        document.removeEventListener("click", closeMenu);
      }
    };
    setTimeout(() => document.addEventListener("click", closeMenu), 100);
  }
  // æ£€æŸ¥æ—¶é—´èƒ¶å›Šæ˜¯å¦æ¿€æ´»
  isTimeCapsuleActive() {
    return this.timeCapsuleState.isActive;
  }
  // æ”¶é›†å†…å®¹åˆ°æ—¶é—´èƒ¶å›Š
  collectToTimeCapsule(content, sourceInfo) {
    if (!this.timeCapsuleState.isActive || !this.timeCapsuleState.groupId) {
      console.warn("\u65F6\u95F4\u80F6\u56CA\u672A\u6FC0\u6D3B\u6216\u5206\u7EC4\u4E0D\u5B58\u5728");
      return;
    }
    const nodeId = `collected-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
    const timestamp = (/* @__PURE__ */ new Date()).toLocaleTimeString();
    let nodeText = content;
    if (sourceInfo.sourcePath && sourceInfo.sourcePath !== "\u526A\u8D34\u677F") {
      const fileName = sourceInfo.sourcePath.split("/").pop()?.replace(".md", "") || sourceInfo.sourcePath;
      nodeText += `

---
\u{1F4CD} \u6765\u6E90: [[${fileName}]]`;
      if (sourceInfo.sourcePosition) {
        nodeText += ` (\u884C ${sourceInfo.sourcePosition.line + 1})`;
      }
    }
    nodeText += `
\u23F0 \u6536\u96C6\u65F6\u95F4: ${timestamp}`;
    const groupNode = this.canvasData?.nodes.find((n) => n.id === this.timeCapsuleState.groupId);
    if (!groupNode) {
      console.warn("\u627E\u4E0D\u5230\u65F6\u95F4\u80F6\u56CA\u5206\u7EC4");
      return;
    }
    const itemIndex = this.timeCapsuleState.collectedItems.length;
    const nodeX = groupNode.x + 20 + itemIndex % 2 * 180;
    const nodeY = groupNode.y + 50 + Math.floor(itemIndex / 2) * 120;
    const newNode = {
      id: nodeId,
      type: "text",
      x: nodeX,
      y: nodeY,
      width: 160,
      height: 100,
      color: "5",
      // é’è‰²æ ‡è®°ä¸ºæ”¶é›†çš„å†…å®¹
      text: nodeText
    };
    if (this.canvasData) {
      this.canvasData.nodes.push(newNode);
      this.timeCapsuleState.collectedItems.push(nodeId);
      this.saveCanvasData();
      this.renderGrid();
      this.updateTimeCapsuleGroupDisplay();
      new import_obsidian.Notice(`\u5DF2\u6536\u96C6\u5230\u65F6\u95F4\u80F6\u56CA (${this.timeCapsuleState.collectedItems.length}/${this.getMaxCollectionCount()})`);
      console.log("\u5185\u5BB9\u5DF2\u6536\u96C6\u5230\u65F6\u95F4\u80F6\u56CA:", nodeId);
    }
  }
  // å…¬å¼€åˆ‡æ¢æ—¶é—´èƒ¶å›Šæ–¹æ³•
  toggleTimeCapsule() {
    if (this.timeCapsuleState.isActive) {
      this.stopTimeCapsule();
    } else {
      this.startTimeCapsule();
    }
  }
  // æ›´æ–°é¢œè‰²ç­›é€‰å™¨ï¼ˆå…¬å…±æ–¹æ³•ï¼‰
  updateColorFilter() {
    if (this.colorFilterContainer) {
      this.colorFilterContainer.remove();
      this.colorFilterContainer = null;
    }
    const container = this.containerEl.children[1];
    if (!container) {
      console.error("Canvasgrid Transit: Container element not found");
      return;
    }
    const colorRow = container.querySelector(".canvas-grid-toolbar-color-row");
    if (colorRow) {
      this.createColorFilter(colorRow);
    } else {
      console.warn("Canvasgrid Transit: Color row not found, recreating toolbar");
      const toolbar = container.querySelector(".canvas-grid-toolbar");
      if (toolbar) {
        toolbar.remove();
      }
      this.createToolbar(container);
    }
  }
  // è§†å›¾é€‰é¡¹æ–¹æ³•å·²ç§»é™¤ï¼ŒåŠŸèƒ½å·²æ•´åˆåˆ°ä¸»èœå•
  // ==================== æœç´¢å’Œæ’åºåŠŸèƒ½å®ç° ====================
  // æ‰§è¡Œæœç´¢ï¼ˆä¼˜åŒ–ç‰ˆæœ¬ï¼Œå‡å°‘ä¸å¿…è¦çš„é‡æ–°æ¸²æŸ“ï¼‰
  performSearch() {
    if (!this.canvasData) {
      this.filteredNodes = [];
      this.applySortAndFilter();
      return;
    }
    console.log(`\u{1F50D} Performing search with query: "${this.searchQuery}"`);
    const previousFilteredNodes = [...this.filteredNodes];
    let searchResults;
    if (!this.searchQuery || this.searchQuery.trim() === "") {
      searchResults = [...this.canvasData.nodes];
      console.log("\u65E0\u641C\u7D22\u67E5\u8BE2\uFF0C\u4F7F\u7528\u6240\u6709\u8282\u70B9:", searchResults.length);
    } else {
      const query = this.searchQuery.toLowerCase().trim();
      searchResults = this.canvasData.nodes.filter((node) => {
        if (node.text && node.text.toLowerCase().includes(query)) {
          return true;
        }
        if (node.file && node.file.toLowerCase().includes(query)) {
          return true;
        }
        if (node.url && node.url.toLowerCase().includes(query)) {
          return true;
        }
        return false;
      });
      console.log(`\u641C\u7D22 "${query}" \u627E\u5230 ${searchResults.length} \u4E2A\u7ED3\u679C`);
    }
    console.log("\u5E94\u7528\u989C\u8272\u7B5B\u9009\uFF0C\u5F53\u524D\u7B5B\u9009\u989C\u8272:", this.activeColorFilter);
    if (this.activeColorFilter && this.activeColorFilter !== "all") {
      this.filteredNodes = searchResults.filter((node) => {
        const matches = node.color === this.activeColorFilter;
        return matches;
      });
      console.log("\u989C\u8272\u7B5B\u9009\u540E\u8282\u70B9\u6570\u91CF:", this.filteredNodes.length);
    } else {
      this.filteredNodes = searchResults;
      console.log("\u65E0\u989C\u8272\u7B5B\u9009\uFF0C\u4F7F\u7528\u6240\u6709\u641C\u7D22\u7ED3\u679C:", this.filteredNodes.length);
    }
    console.log(`\u{1F4CA} Final filtered nodes: ${this.filteredNodes.length}, applying sort...`);
    this.applySortAndFilter();
  }
  // æ¯”è¾ƒä¸¤ä¸ªæ•°ç»„æ˜¯å¦ç›¸ç­‰ï¼ˆåŸºäºèŠ‚ç‚¹IDï¼‰
  arraysEqual(arr1, arr2) {
    if (arr1.length !== arr2.length)
      return false;
    const ids1 = arr1.map((node) => node.id).sort();
    const ids2 = arr2.map((node) => node.id).sort();
    return ids1.every((id, index) => id === ids2[index]);
  }
  // åº”ç”¨æ’åºå’Œç­›é€‰
  applySortAndFilter() {
    if (!this.filteredNodes || this.filteredNodes.length === 0) {
      this.renderGrid();
      return;
    }
    console.log(`\u{1F504} Applying sort: ${this.sortBy} (${this.sortOrder}) to ${this.filteredNodes.length} nodes`);
    this.filteredNodes.sort((a, b) => {
      let comparison = 0;
      try {
        switch (this.sortBy) {
          case "created":
            const timeA = this.extractTimestamp(a.id);
            const timeB = this.extractTimestamp(b.id);
            comparison = timeA - timeB;
            break;
          case "modified":
            const modA = a.modified || this.extractTimestamp(a.id);
            const modB = b.modified || this.extractTimestamp(b.id);
            comparison = modA - modB;
            break;
          case "title":
            const titleA = this.getNodeTitle(a).toLowerCase();
            const titleB = this.getNodeTitle(b).toLowerCase();
            comparison = titleA.localeCompare(titleB);
            break;
          default:
            const defaultTimeA = this.extractTimestamp(a.id);
            const defaultTimeB = this.extractTimestamp(b.id);
            comparison = defaultTimeA - defaultTimeB;
            break;
        }
      } catch (error) {
        console.error("\u6392\u5E8F\u8FC7\u7A0B\u4E2D\u51FA\u9519:", error);
        comparison = a.id.localeCompare(b.id);
      }
      const result = this.sortOrder === "asc" ? comparison : -comparison;
      return result;
    });
    console.log(`\u2705 Sort completed. First node: ${this.getNodeTitle(this.filteredNodes[0])}`);
    this.renderGrid();
  }
  // æå–æ—¶é—´æˆ³
  extractTimestamp(nodeId) {
    const match = nodeId.match(/(\d{13})/);
    return match ? parseInt(match[1]) : 0;
  }
  // è·å–èŠ‚ç‚¹æ ‡é¢˜
  getNodeTitle(node) {
    if (node.text) {
      return node.text.split("\n")[0].substring(0, 50);
    }
    if (node.file) {
      return node.file;
    }
    if (node.url) {
      return node.url;
    }
    return "Untitled";
  }
  // å¼ºåˆ¶åˆ·æ–°æ’åºï¼ˆç”¨äºæ•°æ®æ›´æ–°åï¼‰
  refreshSort() {
    console.log("\u{1F504} Refreshing sort...");
    if (!this.canvasData) {
      return;
    }
    this.filteredNodes = [...this.canvasData.nodes];
    this.performSearch();
  }
  // åº”ç”¨ç±»å‹ç­›é€‰
  applyTypeFilter(filterType) {
    if (!this.canvasData)
      return;
    if (filterType === "all") {
      this.filteredNodes = [...this.canvasData.nodes];
    } else {
      this.filteredNodes = this.canvasData.nodes.filter((node) => {
        return node.type === filterType;
      });
    }
    if (this.searchQuery) {
      this.performSearch();
    } else {
      this.applySortAndFilter();
    }
  }
  // å¡ç‰‡å¤§å°è°ƒæ•´æ–¹æ³•å·²ç§»é™¤
  // éšè—æ‰€æœ‰ä¸‹æ‹‰èœå•
  hideAllDropdowns() {
    const mainDropdowns = this.containerEl.querySelectorAll(".canvas-grid-main-dropdown");
    mainDropdowns.forEach((dropdown) => {
      dropdown.style.display = "none";
    });
    const buttons = this.containerEl.querySelectorAll(".canvas-grid-main-btn");
    buttons.forEach((btn) => {
      btn.classList.remove("active");
    });
    this.closeAllSubmenus();
  }
  // éšè—ä¸‹æ‹‰èœå•
  hideDropdownMenu(dropdownMenu) {
    dropdownMenu.style.display = "none";
  }
  // åˆ‡æ¢ä¸‹æ‹‰èœå•
  toggleDropdownMenu(dropdownMenu) {
    const isVisible = dropdownMenu.style.display !== "none";
    if (isVisible) {
      dropdownMenu.style.display = "none";
    } else {
      dropdownMenu.style.display = "block";
    }
  }
  // æ˜¾ç¤ºç©ºçŠ¶æ€
  showEmptyState() {
    const emptyEl = this.gridContainer.createDiv("canvas-grid-empty-state");
    emptyEl.innerHTML = `
			<div class="empty-icon">\u{1F4C4}</div>
			<div class="empty-title">\u6CA1\u6709Canvas\u8282\u70B9</div>
			<div class="empty-desc">\u5F53\u524DCanvas\u6587\u4EF6\u4E2D\u6CA1\u6709\u8282\u70B9\uFF0C\u8BF7\u5148\u5728Canvas\u4E2D\u6DFB\u52A0\u4E00\u4E9B\u5185\u5BB9</div>
		`;
  }
  // åˆ›å»ºèœå•åŒºåŸŸ (å·²æ•´åˆåˆ°ä¸»èœå•ï¼Œä¿ç•™ä»¥é˜²å…¼å®¹æ€§é—®é¢˜)
  createMenuSection(container) {
    return;
    const menuSection = container.createDiv("canvas-grid-toolbar-menu");
    const menuBtn = menuSection.createDiv("canvas-grid-menu-btn");
    menuBtn.innerHTML = `
			<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<circle cx="12" cy="12" r="1"/>
				<circle cx="12" cy="5" r="1"/>
				<circle cx="12" cy="19" r="1"/>
			</svg>
		`;
    menuBtn.title = "\u66F4\u591A\u9009\u9879";
    const dropdownMenu = menuSection.createDiv("canvas-grid-dropdown-menu");
    dropdownMenu.style.display = "none";
    const backMenuItem = dropdownMenu.createDiv("canvas-grid-menu-item");
    backMenuItem.innerHTML = `
			<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<path d="m12 19-7-7 7-7"/>
				<path d="m19 12H5"/>
			</svg>
			<span>\u8FD4\u56DECanvas</span>
		`;
    backMenuItem.onclick = () => {
      this.switchToCanvasView();
      this.hideDropdownMenu(dropdownMenu);
    };
    const refreshMenuItem = dropdownMenu.createDiv("canvas-grid-menu-item");
    refreshMenuItem.innerHTML = `
			<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/>
				<path d="M21 3v5h-5"/>
				<path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/>
				<path d="M3 21v-5h5"/>
			</svg>
			<span>\u5237\u65B0</span>
		`;
    refreshMenuItem.onclick = () => {
      this.refreshCanvasData();
      this.hideDropdownMenu(dropdownMenu);
    };
    const settingsMenuItem = dropdownMenu.createDiv("canvas-grid-menu-item");
    settingsMenuItem.innerHTML = `
			<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<circle cx="12" cy="12" r="3"/>
				<path d="m12 1 1.27 2.22 2.22 1.27-1.27 2.22L12 8.5l-1.27-2.22L8.5 5.23l1.27-2.22L12 1"/>
				<path d="m12 15.5 1.27 2.22 2.22 1.27-1.27 2.22L12 22.5l-1.27-2.22L8.5 18.77l1.27-2.22L12 15.5"/>
			</svg>
			<span>\u7F51\u683C\u8BBE\u7F6E</span>
		`;
    settingsMenuItem.onclick = () => {
      this.openGridSettings();
      this.hideDropdownMenu(dropdownMenu);
    };
    menuBtn.onclick = (e) => {
      e.stopPropagation();
      this.toggleDropdownMenu(dropdownMenu);
    };
    document.addEventListener("click", () => {
      this.hideDropdownMenu(dropdownMenu);
    });
  }
  // è®¾ç½®ç½‘æ ¼æ ·å¼ - ä½¿ç”¨CSS Gridè‡ªåŠ¨å¸ƒå±€
  setupGridStyles() {
    this.gridContainer.style.setProperty("--grid-card-spacing", `${CARD_CONSTANTS.spacing}px`);
    this.gridContainer.style.setProperty("--grid-card-min-width", `${CARD_CONSTANTS.width}px`);
    this.gridContainer.style.setProperty("--grid-card-height", `${CARD_CONSTANTS.height}px`);
    this.gridContainer.style.removeProperty("grid-template-columns");
  }
  // è®¾ç½®äº‹ä»¶å§”æ‰˜ï¼Œæå‡æ€§èƒ½
  setupEventDelegation() {
    this.gridContainer.addEventListener("click", this.handleGridClick);
    this.gridContainer.addEventListener("dblclick", this.handleCardDoubleClick);
    this.gridContainer.addEventListener("contextmenu", this.handleCardContextMenu);
    this.gridContainer.addEventListener("keydown", this.handleKeyDown);
    document.addEventListener("click", this.handleDocumentClick);
    this.setupScrollListener();
    this.setupGridCardDragEvents();
  }
  // è®¾ç½®ç½‘æ ¼å¡ç‰‡æ‹–æ‹½äº‹ä»¶ - ä½¿ç”¨HTML5 Drag & Drop API
  setupGridCardDragEvents() {
    this.setupCardDragAttributes();
    this.registerDomEvent(this.gridContainer, "dragstart", this.handleCardDragStart.bind(this));
    this.registerDomEvent(this.gridContainer, "dragend", this.handleCardDragEnd.bind(this));
  }
  // ä¸ºå¡ç‰‡è®¾ç½®æ‹–æ‹½å±æ€§
  setupCardDragAttributes() {
    const cards = this.gridContainer.querySelectorAll(".canvas-grid-card");
    cards.forEach((card) => {
      card.draggable = false;
      card.style.cursor = "grab";
      this.setupCardLongPress(card);
    });
  }
  // è®¾ç½®å¡ç‰‡é•¿æŒ‰æ£€æµ‹
  setupCardLongPress(cardElement) {
    let longPressTimer = null;
    let longPressStartTime = 0;
    const handleMouseDown = (e) => {
      if (e.target.closest(".canvas-card-toolbar")) {
        return;
      }
      longPressStartTime = Date.now();
      longPressTimer = setTimeout(() => {
        cardElement.draggable = true;
        cardElement.style.cursor = "grabbing";
        console.log("\u{1F525} Long press detected, drag enabled");
        cardElement.classList.add("long-press-active");
      }, 500);
    };
    const handleMouseUp = () => {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
      setTimeout(() => {
        cardElement.draggable = false;
        cardElement.style.cursor = "grab";
        cardElement.classList.remove("long-press-active");
      }, 100);
    };
    const handleMouseLeave = () => {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    };
    cardElement.addEventListener("mousedown", handleMouseDown);
    cardElement.addEventListener("mouseup", handleMouseUp);
    cardElement.addEventListener("mouseleave", handleMouseLeave);
  }
  // è®¾ç½®æ»šåŠ¨ç›‘å¬ï¼Œå®ç°åŠŸèƒ½æ è‡ªåŠ¨éšè—/æ˜¾ç¤º
  setupScrollListener() {
    let lastScrollTop = 0;
    let isToolbarHidden = false;
    let scrollTimeout = null;
    const getContainer = () => {
      return this.containerEl.children[1];
    };
    const getToolbar = () => {
      const container = getContainer();
      return container?.querySelector(".canvas-grid-toolbar");
    };
    const showToolbar = () => {
      const toolbar2 = getToolbar();
      const container = getContainer();
      if (toolbar2 && container && isToolbarHidden) {
        toolbar2.style.position = "relative";
        toolbar2.style.transform = "translateY(0)";
        toolbar2.style.opacity = "1";
        toolbar2.style.zIndex = "100";
        this.gridContainer.classList.remove("toolbar-hidden");
        const viewContent = this.containerEl.querySelector(".view-content");
        if (viewContent) {
          viewContent.classList.remove("toolbar-hidden-parent");
        }
        this.gridContainer.style.removeProperty("margin-top");
        this.gridContainer.style.removeProperty("height");
        isToolbarHidden = false;
      }
    };
    const hideToolbar = () => {
      const toolbar2 = getToolbar();
      const container = getContainer();
      if (toolbar2 && container && !isToolbarHidden) {
        const toolbarHeight = toolbar2.offsetHeight;
        toolbar2.style.position = "fixed";
        toolbar2.style.top = "0";
        toolbar2.style.left = "0";
        toolbar2.style.right = "0";
        toolbar2.style.transform = "translateY(-100%)";
        toolbar2.style.opacity = "0";
        toolbar2.style.zIndex = "100";
        this.gridContainer.classList.add("toolbar-hidden");
        const viewContent = this.containerEl.querySelector(".view-content");
        if (viewContent) {
          viewContent.classList.add("toolbar-hidden-parent");
        }
        this.gridContainer.style.marginTop = `-${toolbarHeight}px`;
        isToolbarHidden = true;
      }
    };
    const handleScroll = () => {
      const currentScrollTop = this.gridContainer.scrollTop;
      const scrollDelta = currentScrollTop - lastScrollTop;
      if (scrollTimeout) {
        clearTimeout(scrollTimeout);
      }
      if (Math.abs(scrollDelta) < 5) {
        return;
      }
      if (currentScrollTop < 50) {
        showToolbar();
      } else {
        if (scrollDelta > 0 && !isToolbarHidden) {
          hideToolbar();
        } else if (scrollDelta < 0 && isToolbarHidden) {
          showToolbar();
        }
      }
      scrollTimeout = setTimeout(() => {
        showToolbar();
      }, 2e3);
      lastScrollTop = currentScrollTop;
    };
    this.gridContainer.addEventListener("scroll", handleScroll, { passive: true });
    const toolbar = getToolbar();
    if (toolbar) {
      toolbar.style.transition = "transform 0.3s ease, opacity 0.3s ease";
      toolbar.style.zIndex = "100";
    }
  }
  // åŠ è½½å½“å‰æ´»åŠ¨çš„Canvasæ–‡ä»¶ - ä¼˜åŒ–ç‰ˆæœ¬
  async loadActiveCanvas() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile || activeFile.extension !== "canvas") {
      this.showMessage("\u8BF7\u5148\u6253\u5F00\u4E00\u4E2ACanvas\u6587\u4EF6");
      return;
    }
    this.showLoadingState();
    try {
      const content = await this.app.vault.read(activeFile);
      let parsedData;
      try {
        parsedData = JSON.parse(content);
      } catch (parseError) {
        throw new Error("Canvas\u6587\u4EF6\u683C\u5F0F\u65E0\u6548");
      }
      if (!parsedData.nodes || !Array.isArray(parsedData.nodes)) {
        throw new Error("Canvas\u6587\u4EF6\u7F3A\u5C11\u6709\u6548\u7684\u8282\u70B9\u6570\u636E");
      }
      this.canvasData = parsedData;
      this.initializeSearchAndSort();
      console.log("\u2705 Canvas loaded and sort applied");
    } catch (error) {
      console.error("Canvas\u52A0\u8F7D\u9519\u8BEF:", error);
      this.showErrorState(error instanceof Error ? error.message : "\u672A\u77E5\u9519\u8BEF");
    }
  }
  // æ¸²æŸ“ç½‘æ ¼è§†å›¾ - ä¼˜åŒ–ç‰ˆæœ¬ï¼ˆæ”¯æŒæ‰¹é‡æ¸²æŸ“å’Œåˆ†ç»„æ˜¾ç¤ºï¼‰
  renderGrid() {
    if (!this.gridContainer)
      return;
    this.gridContainer.empty();
    if (this.currentGroupView) {
      this.renderGroupMembers();
      return;
    }
    this.analyzeGroups();
    const nodesToRender = this.searchQuery || this.activeColorFilter ? this.filteredNodes : this.canvasData?.nodes || [];
    console.log("\u6E32\u67D3\u8282\u70B9\u51B3\u7B56:", {
      searchQuery: this.searchQuery,
      activeColorFilter: this.activeColorFilter,
      filteredNodesLength: this.filteredNodes.length,
      nodesToRenderLength: nodesToRender.length,
      groupCount: this.groupAnalysis.size
    });
    if (nodesToRender.length === 0) {
      if (this.searchQuery) {
        this.showNoSearchResults();
      } else {
        this.showEmptyState();
      }
      return;
    }
    const groupNodes = nodesToRender.filter((node) => node.type === "group");
    const regularNodes = nodesToRender.filter((node) => node.type !== "group");
    const itemsToRender = [];
    const sortedGroups = this.getGroupsForGridView();
    sortedGroups.forEach((groupInfo) => {
      if (groupNodes.some((node) => node.id === groupInfo.group.id)) {
        itemsToRender.push({ type: "group", data: groupInfo });
      }
    });
    const ungroupedNodes = this.getUngroupedNodes(regularNodes);
    ungroupedNodes.forEach((node) => {
      itemsToRender.push({ type: "node", data: node });
    });
    this.renderGridItems(itemsToRender);
    this.setupCardDragAttributes();
  }
  // ç«‹å³æ¸²æŸ“ï¼ˆå°é‡æ•°æ®ï¼‰
  renderGridImmediate(nodes) {
    const fragment = document.createDocumentFragment();
    nodes.forEach((node) => {
      const card = this.createCard(node);
      if (this.searchQuery) {
        this.highlightSearchResults(card, this.searchQuery);
      }
      fragment.appendChild(card);
    });
    this.gridContainer.appendChild(fragment);
  }
  // æ‰¹é‡æ¸²æŸ“ï¼ˆå¤§é‡æ•°æ®ï¼‰
  async renderGridBatched(nodes) {
    const batchSize = 20;
    let currentIndex = 0;
    this.showLoadingState();
    const renderBatch = () => {
      const fragment = document.createDocumentFragment();
      const endIndex = Math.min(currentIndex + batchSize, nodes.length);
      for (let i = currentIndex; i < endIndex; i++) {
        const node = nodes[i];
        const card = this.createCard(node);
        if (this.searchQuery) {
          this.highlightSearchResults(card, this.searchQuery);
        }
        fragment.appendChild(card);
      }
      this.gridContainer.appendChild(fragment);
      currentIndex = endIndex;
      if (currentIndex < nodes.length) {
        requestAnimationFrame(renderBatch);
      } else {
        this.hideLoadingState();
      }
    };
    requestAnimationFrame(renderBatch);
  }
  // æ˜¾ç¤ºæ— æœç´¢ç»“æœçŠ¶æ€
  showNoSearchResults() {
    const emptyEl = this.gridContainer.createDiv("canvas-grid-empty-state");
    emptyEl.innerHTML = `
			<div class="empty-icon">\u{1F50D}</div>
			<div class="empty-title">\u672A\u627E\u5230\u5339\u914D\u7684\u5361\u7247</div>
			<div class="empty-desc">\u5C1D\u8BD5\u4F7F\u7528\u4E0D\u540C\u7684\u5173\u952E\u8BCD\u641C\u7D22</div>
			<button class="empty-action" onclick="this.closest('.canvas-grid-view').querySelector('.canvas-grid-search-input').value = ''; this.closest('.canvas-grid-view').querySelector('.canvas-grid-search-input').dispatchEvent(new Event('input'));">\u6E05\u7A7A\u641C\u7D22</button>
		`;
  }
  // é«˜äº®æœç´¢ç»“æœ
  highlightSearchResults(cardEl, query) {
    const textElements = cardEl.querySelectorAll(".canvas-grid-card-content, .canvas-grid-card-title");
    const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")})`, "gi");
    textElements.forEach((el) => {
      const element = el;
      if (element.textContent) {
        element.innerHTML = element.textContent.replace(regex, '<mark class="search-highlight">$1</mark>');
      }
    });
  }
  // ä¿å­˜è®¾ç½®
  async saveSettings() {
    console.log("Settings saved:", this.settings);
  }
  // åˆ›å»ºå•ä¸ªå¡ç‰‡ - å“åº”å¼ç‰ˆæœ¬ï¼ˆå¸¦ç¼“å­˜ä¼˜åŒ–ï¼‰
  createCard(node) {
    const cacheKey = this.generateCardCacheKey(node);
    const cachedCard = this.getRenderCacheItem(cacheKey);
    if (cachedCard) {
      const clonedCard = cachedCard.cloneNode(true);
      this.updateCardEventHandlers(clonedCard, node);
      return clonedCard;
    }
    const card = this.createCardInternal(node);
    this.setRenderCacheItem(cacheKey, card.cloneNode(true));
    return card;
  }
  // å†…éƒ¨åˆ›å»ºå¡ç‰‡æ–¹æ³•
  createCardInternal(node) {
    const card = document.createElement("div");
    card.className = "canvas-grid-card";
    card.style.minHeight = `${CARD_CONSTANTS.height}px`;
    card.dataset.nodeId = node.id;
    card.dataset.nodeType = node.type;
    if (node.color) {
      const normalizedColor = this.normalizeColorValue(node.color);
      if (normalizedColor) {
        const colorStyles = this.getColorStyles(normalizedColor);
        card.dataset.color = normalizedColor;
        card.style.backgroundColor = colorStyles.backgroundColor;
        card.style.borderColor = colorStyles.borderColor;
        card.style.borderWidth = "2px";
      }
    }
    if (node.flag) {
      card.dataset.flag = node.flag.toString();
    }
    card.setAttribute("role", "button");
    card.setAttribute("tabindex", "0");
    card.setAttribute("aria-label", `${node.type}\u8282\u70B9`);
    this.renderCardContent(card, node);
    this.createCardToolbar(card, node);
    return card;
  }
  // ç”Ÿæˆå¡ç‰‡ç¼“å­˜é”®
  generateCardCacheKey(node) {
    const keyData = {
      id: node.id,
      type: node.type,
      color: node.color,
      flag: node.flag,
      // å¯¹äºæ–‡æœ¬èŠ‚ç‚¹ï¼ŒåŒ…å«æ–‡æœ¬å†…å®¹çš„å“ˆå¸Œ
      textHash: node.text ? this.simpleHash(node.text) : null,
      // å¯¹äºæ–‡ä»¶èŠ‚ç‚¹ï¼ŒåŒ…å«æ–‡ä»¶è·¯å¾„
      file: node.file,
      // å¯¹äºé“¾æ¥èŠ‚ç‚¹ï¼ŒåŒ…å«URL
      url: node.url,
      // è®¾ç½®ç›¸å…³
      cardHeight: CARD_CONSTANTS.height
    };
    return JSON.stringify(keyData);
  }
  // ç®€å•å“ˆå¸Œå‡½æ•°
  simpleHash(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return hash;
  }
  // è·å–æ¸²æŸ“ç¼“å­˜é¡¹
  getRenderCacheItem(key) {
    const item = this.renderCache.get(key);
    if (item) {
      const currentCount = this.renderCacheAccessCount.get(key) || 0;
      this.renderCacheAccessCount.set(key, currentCount + 1);
      return item;
    }
    return null;
  }
  // è®¾ç½®æ¸²æŸ“ç¼“å­˜é¡¹
  setRenderCacheItem(key, element) {
    if (this.renderCache.size >= this.MAX_RENDER_CACHE_SIZE) {
      this.cleanupRenderCache();
    }
    this.renderCache.set(key, element);
    this.renderCacheAccessCount.set(key, 1);
  }
  // æ¸…ç†æ¸²æŸ“ç¼“å­˜
  cleanupRenderCache() {
    let minAccess = Infinity;
    let keyToDelete = "";
    for (const [key, count] of this.renderCacheAccessCount.entries()) {
      if (count < minAccess) {
        minAccess = count;
        keyToDelete = key;
      }
    }
    if (keyToDelete) {
      this.renderCache.delete(keyToDelete);
      this.renderCacheAccessCount.delete(keyToDelete);
    }
  }
  // æ›´æ–°å¡ç‰‡äº‹ä»¶å¤„ç†å™¨ï¼ˆç”¨äºç¼“å­˜çš„å¡ç‰‡ï¼‰
  updateCardEventHandlers(card, node) {
    card.dataset.nodeId = node.id;
    card.dataset.nodeType = node.type;
  }
  // æ¸…ç©ºæ¸²æŸ“ç¼“å­˜
  clearRenderCache() {
    this.renderCache.clear();
    this.renderCacheAccessCount.clear();
  }
  // åˆ›å»ºå¡ç‰‡å·¥å…·æ 
  createCardToolbar(card, node) {
    const toolbar = document.createElement("div");
    toolbar.className = "canvas-card-toolbar";
    const deleteBtn = this.createToolbarButton("delete", "\u5220\u9664");
    const colorBtn = this.createToolbarButton("color", "\u8BBE\u7F6E\u989C\u8272");
    toolbar.appendChild(deleteBtn);
    toolbar.appendChild(colorBtn);
    card.appendChild(toolbar);
  }
  // åˆ›å»ºå·¥å…·æ æŒ‰é’®ï¼ˆä½¿ç”¨äº‹ä»¶å§”æ‰˜ï¼Œä¸ç›´æ¥ç»‘å®šonclickï¼‰
  createToolbarButton(type, title, onClick) {
    const button = document.createElement("div");
    button.className = `canvas-card-toolbar-btn canvas-card-toolbar-${type}`;
    button.title = title;
    button.setAttribute("role", "button");
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-label", title);
    const icon = document.createElement("div");
    icon.className = `canvas-card-toolbar-icon canvas-card-toolbar-icon-${type}`;
    button.appendChild(icon);
    return button;
  }
  // ä»å·¥å…·æ åˆ é™¤å¡ç‰‡
  async deleteCardFromToolbar(card) {
    const nodeId = card.dataset.nodeId;
    if (!nodeId)
      return;
    const confirmed = confirm("\u786E\u5B9A\u8981\u5220\u9664\u8FD9\u4E2A\u8282\u70B9\u5417\uFF1F");
    if (!confirmed)
      return;
    try {
      await this.deleteNodeFromCanvas(nodeId);
      card.remove();
      console.log("\u5361\u7247\u5220\u9664\u5B8C\u6210\uFF0CUI\u5DF2\u66F4\u65B0");
    } catch (error) {
      console.error("\u5220\u9664\u5361\u7247\u5931\u8D25:", error);
      new import_obsidian.Notice("\u5220\u9664\u5361\u7247\u5931\u8D25");
    }
  }
  // æ˜¾ç¤ºé¢œè‰²é€‰æ‹©å™¨
  showColorPicker(card, node) {
    const colorPicker = document.createElement("div");
    colorPicker.className = "canvas-color-picker";
    const colors = [
      { name: "\u9ED8\u8BA4", value: "", bgColor: "var(--background-primary)", textColor: "var(--text-normal)" },
      { name: "\u7EA2\u8272", value: "1" },
      { name: "\u6A59\u8272", value: "2" },
      { name: "\u9EC4\u8272", value: "3" },
      { name: "\u7EFF\u8272", value: "4" },
      { name: "\u9752\u8272", value: "5" },
      { name: "\u84DD\u8272", value: "6" },
      { name: "\u7D2B\u8272", value: "7" }
    ];
    colors.forEach((colorOption) => {
      const colorItem = document.createElement("div");
      colorItem.className = "canvas-color-item";
      if (colorOption.value) {
        const pureColorMap = {
          "1": "#ff6b6b",
          // çº¢è‰²
          "2": "#ffa726",
          // æ©™è‰²
          "3": "#ffeb3b",
          // é»„è‰²
          "4": "#66bb6a",
          // ç»¿è‰²
          "5": "#26c6da",
          // é’è‰²
          "6": "#42a5f5",
          // è“è‰²
          "7": "#ab47bc"
          // ç´«è‰²
        };
        const pureColor = pureColorMap[colorOption.value];
        colorItem.style.backgroundColor = pureColor;
        colorItem.style.border = `2px solid ${pureColor}`;
      } else {
        colorItem.style.backgroundColor = "var(--background-secondary)";
        colorItem.style.border = "2px solid var(--background-modifier-border)";
      }
      colorItem.style.borderRadius = "50%";
      colorItem.style.width = "24px";
      colorItem.style.height = "24px";
      colorItem.style.cursor = "pointer";
      colorItem.style.transition = "all 0.2s ease";
      colorItem.addEventListener("mouseenter", () => {
        colorItem.style.transform = "scale(1.1)";
        colorItem.style.boxShadow = "0 2px 8px rgba(0, 0, 0, 0.2)";
      });
      colorItem.addEventListener("mouseleave", () => {
        colorItem.style.transform = "scale(1)";
        colorItem.style.boxShadow = "none";
      });
      colorItem.title = colorOption.name;
      if (node.color === colorOption.value || !node.color && !colorOption.value) {
        colorItem.classList.add("selected");
        colorItem.style.boxShadow = "0 0 0 2px var(--interactive-accent)";
      }
      colorItem.onclick = () => {
        this.setCardColor(card, node, colorOption.value);
        colorPicker.remove();
      };
      colorPicker.appendChild(colorItem);
    });
    const rect = card.getBoundingClientRect();
    colorPicker.style.position = "fixed";
    colorPicker.style.top = `${rect.top - 40}px`;
    colorPicker.style.left = `${rect.left}px`;
    colorPicker.style.zIndex = "10000";
    document.body.appendChild(colorPicker);
    const closeHandler = (e) => {
      const mouseEvent = e;
      if (!colorPicker.contains(mouseEvent.target)) {
        colorPicker.remove();
        document.removeEventListener("click", closeHandler);
        const index = this.globalEventListeners.findIndex(
          (listener) => listener.element === document && listener.event === "click" && listener.handler === closeHandler
        );
        if (index > -1) {
          this.globalEventListeners.splice(index, 1);
        }
      }
    };
    this.safeSetTimeout(() => {
      this.addGlobalEventListener(document, "click", closeHandler);
    }, 0);
  }
  // è®¾ç½®å¡ç‰‡é¢œè‰² - è®¾ç½®èƒŒæ™¯è‰²ã€æ–‡å­—è‰²å’Œè¾¹æ¡†è‰²
  async setCardColor(card, node, color) {
    const normalizedColor = color ? this.normalizeColorValue(color) : null;
    node.color = normalizedColor || void 0;
    if (normalizedColor) {
      const colorStyles = this.getColorStyles(normalizedColor);
      card.dataset.color = normalizedColor;
      card.style.backgroundColor = colorStyles.backgroundColor;
      card.style.borderColor = colorStyles.borderColor;
      card.style.borderWidth = "2px";
      const contentDiv = card.querySelector(".card-content");
      if (contentDiv) {
        contentDiv.style.color = colorStyles.textColor;
      }
    } else {
      delete card.dataset.color;
      card.style.backgroundColor = "";
      card.style.borderColor = "";
      card.style.borderWidth = "";
      const contentDiv = card.querySelector(".card-content");
      if (contentDiv) {
        contentDiv.style.color = "";
      }
    }
    await this.saveNodeToCanvas(node);
  }
  // æ¸²æŸ“å¡ç‰‡å†…å®¹
  renderCardContent(card, node) {
    switch (node.type) {
      case "text":
        this.renderTextNode(card, node);
        break;
      case "file":
        this.renderFileNode(card, node);
        break;
      case "link":
        this.renderLinkNode(card, node);
        break;
      default:
        card.createDiv().textContent = `\u672A\u652F\u6301\u7684\u8282\u70B9\u7C7B\u578B: ${node.type}`;
    }
    if (node.color) {
      const normalizedColor = this.normalizeColorValue(node.color);
      if (normalizedColor) {
        const colorStyles = this.getColorStyles(normalizedColor);
        const contentDiv = card.querySelector(".card-content");
        if (contentDiv) {
          contentDiv.style.color = colorStyles.textColor;
        }
      }
    }
  }
  // æ¸²æŸ“æ–‡æœ¬èŠ‚ç‚¹
  renderTextNode(card, node) {
    const content = card.createDiv("card-content");
    content.style.lineHeight = "1.5";
    this.renderTextNodeContent(content, node);
  }
  // æ¸²æŸ“æ–‡ä»¶èŠ‚ç‚¹
  renderFileNode(card, node) {
    const content = card.createDiv("card-content");
    if (node.file) {
      const fileName = node.file.split("/").pop() || node.file;
      const fileIcon = content.createSpan("file-icon");
      fileIcon.textContent = "\u{1F4C4} ";
      content.createSpan().textContent = fileName;
      if (node.file.includes("#")) {
        const subpath = node.file.split("#")[1];
        const subpathEl = content.createDiv("file-subpath");
        subpathEl.textContent = `#${subpath}`;
        subpathEl.style.color = "var(--text-muted)";
        subpathEl.style.fontSize = "12px";
        subpathEl.style.marginTop = "4px";
      }
    } else {
      content.textContent = "\u65E0\u6548\u7684\u6587\u4EF6\u5F15\u7528";
      content.style.color = "var(--text-error)";
    }
  }
  // æ¸²æŸ“é“¾æ¥èŠ‚ç‚¹
  renderLinkNode(card, node) {
    const content = card.createDiv("card-content link-card-content");
    this.renderLinkNodeWithPreview(content, node);
  }
  // ç®€å•çš„Markdownæ¸²æŸ“
  simpleMarkdownRender(text) {
    return text.replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>").replace(/\*(.*?)\*/g, "<em>$1</em>").replace(/`(.*?)`/g, "<code>$1</code>").replace(/\n/g, "<br>");
  }
  // è·å–èŠ‚ç‚¹é¢œè‰²
  getNodeColor(color) {
    const colorMap = {
      "1": "#ff6b6b",
      // red
      "2": "#ffa726",
      // orange
      "3": "#ffeb3b",
      // yellow
      "4": "#66bb6a",
      // green
      "5": "#26c6da",
      // cyan
      "6": "#42a5f5",
      // blue
      "7": "#ab47bc"
      // purple
    };
    return colorMap[color] || color;
  }
  // è·å–é¢œè‰²çš„èƒŒæ™¯è‰²å’Œæ–‡å­—è‰²ï¼ˆè€ƒè™‘å¯¹æ¯”åº¦ï¼‰
  getColorStyles(color) {
    const colorMap = {
      "1": { backgroundColor: "#ffebee", textColor: "#c62828", borderColor: "#ff6b6b" },
      // red - æµ…çº¢èƒŒæ™¯ï¼Œæ·±çº¢æ–‡å­—
      "2": { backgroundColor: "#fff3e0", textColor: "#e65100", borderColor: "#ffa726" },
      // orange - æµ…æ©™èƒŒæ™¯ï¼Œæ·±æ©™æ–‡å­—
      "3": { backgroundColor: "#fffde7", textColor: "#f57f17", borderColor: "#ffeb3b" },
      // yellow - æµ…é»„èƒŒæ™¯ï¼Œæ·±é»„æ–‡å­—
      "4": { backgroundColor: "#e8f5e8", textColor: "#2e7d32", borderColor: "#66bb6a" },
      // green - æµ…ç»¿èƒŒæ™¯ï¼Œæ·±ç»¿æ–‡å­—
      "5": { backgroundColor: "#e0f2f1", textColor: "#00695c", borderColor: "#26c6da" },
      // cyan - æµ…é’èƒŒæ™¯ï¼Œæ·±é’æ–‡å­—
      "6": { backgroundColor: "#e3f2fd", textColor: "#1565c0", borderColor: "#42a5f5" },
      // blue - æµ…è“èƒŒæ™¯ï¼Œæ·±è“æ–‡å­—
      "7": { backgroundColor: "#f3e5f5", textColor: "#7b1fa2", borderColor: "#ab47bc" }
      // purple - æµ…ç´«èƒŒæ™¯ï¼Œæ·±ç´«æ–‡å­—
    };
    const isDarkTheme = document.body.classList.contains("theme-dark");
    if (isDarkTheme) {
      const darkColorMap = {
        "1": { backgroundColor: "#4a1a1a", textColor: "#ff8a80", borderColor: "#ff6b6b" },
        // red
        "2": { backgroundColor: "#4a2c1a", textColor: "#ffcc80", borderColor: "#ffa726" },
        // orange
        "3": { backgroundColor: "#4a4a1a", textColor: "#fff176", borderColor: "#ffeb3b" },
        // yellow
        "4": { backgroundColor: "#1a4a1a", textColor: "#a5d6a7", borderColor: "#66bb6a" },
        // green
        "5": { backgroundColor: "#1a3a3a", textColor: "#80deea", borderColor: "#26c6da" },
        // cyan
        "6": { backgroundColor: "#1a2a4a", textColor: "#90caf9", borderColor: "#42a5f5" },
        // blue
        "7": { backgroundColor: "#3a1a4a", textColor: "#ce93d8", borderColor: "#ab47bc" }
        // purple
      };
      return darkColorMap[color] || { backgroundColor: "", textColor: "", borderColor: "" };
    }
    return colorMap[color] || { backgroundColor: "", textColor: "", borderColor: "" };
  }
  // æ ‡å‡†åŒ–é¢œè‰²å€¼ - å¤„ç†ä¸åŒçš„é¢œè‰²å€¼æ ¼å¼
  normalizeColorValue(color) {
    if (!color)
      return null;
    if (/^[1-7]$/.test(color)) {
      return color;
    }
    const colorNameMap = {
      "red": "1",
      "orange": "2",
      "yellow": "3",
      "green": "4",
      "cyan": "5",
      "blue": "6",
      "purple": "7"
    };
    const normalizedName = color.toLowerCase();
    return colorNameMap[normalizedName] || null;
  }
  // å¡ç‰‡ç‚¹å‡»äº‹ä»¶
  onCardClick(node, cardElement) {
    if (this.currentEditingCard && this.currentEditingNode) {
      const clickedCard = cardElement || this.gridContainer.querySelector(`[data-node-id="${node.id}"]`);
      if (clickedCard !== this.currentEditingCard) {
        console.log("\u70B9\u51FB\u5176\u4ED6\u5361\u7247\uFF0C\u9000\u51FA\u7F16\u8F91\u72B6\u6001\u5E76\u4FDD\u5B58");
        this.exitCurrentEditingState(true);
      }
    }
    console.log("Card clicked:", node);
  }
  // å¡ç‰‡åŒå‡»äº‹ä»¶ - è¿›å…¥ç¼–è¾‘æ¨¡å¼
  onCardDoubleClick(node, cardElement) {
    if (node.type === "text") {
      this.startTextEditing(node, cardElement);
    } else if (node.type === "link") {
      this.startLinkEditing(node, cardElement);
    }
  }
  // å¼€å§‹æ–‡æœ¬ç¼–è¾‘
  startTextEditing(node, cardElement) {
    if (this.currentEditingCard && this.currentEditingCard !== cardElement) {
      this.exitCurrentEditingState(true);
    }
    const contentDiv = cardElement.querySelector(".card-content");
    if (!contentDiv)
      return;
    this.currentEditingCard = cardElement;
    this.currentEditingNode = node;
    this.autoSaveEnabled = false;
    const originalContent = contentDiv.innerHTML;
    const originalText = node.text || "";
    const editor = this.createTextEditor(originalText, (newText) => {
      this.saveTextNode(node, newText);
      this.exitEditMode(cardElement, contentDiv, newText);
      this.clearEditingState();
    }, () => {
      this.exitEditMode(cardElement, contentDiv, originalText);
      this.clearEditingState();
    }, false);
    this.enterEditMode(cardElement, contentDiv, editor);
  }
  // åˆ›å»ºæ–‡æœ¬ç¼–è¾‘å™¨ - ä½¿ç”¨å¡ç‰‡è¾¹æ¡†å°ºå¯¸
  createTextEditor(text, onSave, onCancel, enableAutoSave = true) {
    const editorContainer = document.createElement("div");
    editorContainer.className = "card-editor-container";
    const textarea = document.createElement("textarea");
    textarea.className = "card-editor-textarea";
    textarea.value = text;
    textarea.style.width = "100%";
    textarea.style.height = "100%";
    textarea.style.minHeight = "calc(100% - 8px)";
    textarea.style.border = "none";
    textarea.style.outline = "none";
    textarea.style.resize = "none";
    textarea.style.padding = "12px";
    textarea.style.margin = "0";
    textarea.style.boxSizing = "border-box";
    textarea.style.fontFamily = "var(--font-text)";
    textarea.style.fontSize = "var(--font-text-size)";
    textarea.style.lineHeight = "1.5";
    textarea.style.background = "transparent";
    textarea.style.color = "var(--text-normal)";
    textarea.style.borderRadius = "inherit";
    let autoSaveTimeout = null;
    const autoSave = () => {
      if (!enableAutoSave)
        return;
      if (autoSaveTimeout) {
        this.safeClearTimeout(autoSaveTimeout);
      }
      autoSaveTimeout = this.safeSetTimeout(() => {
        onSave(textarea.value);
        autoSaveTimeout = null;
      }, 1e3);
    };
    if (enableAutoSave) {
      textarea.addEventListener("input", autoSave);
    }
    textarea.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        e.preventDefault();
        if (autoSaveTimeout) {
          this.safeClearTimeout(autoSaveTimeout);
          autoSaveTimeout = null;
        }
        onSave(textarea.value);
      } else if (e.key === "Enter" && (e.ctrlKey || e.metaKey)) {
        e.preventDefault();
        if (autoSaveTimeout) {
          this.safeClearTimeout(autoSaveTimeout);
          autoSaveTimeout = null;
        }
        onSave(textarea.value);
      }
    });
    textarea.addEventListener("blur", () => {
      if (enableAutoSave) {
        if (autoSaveTimeout) {
          this.safeClearTimeout(autoSaveTimeout);
          autoSaveTimeout = null;
        }
        onSave(textarea.value);
      }
    });
    editorContainer.appendChild(textarea);
    this.safeSetTimeout(() => {
      textarea.focus();
      textarea.select();
    }, 0);
    return editorContainer;
  }
  // æ¸…é™¤ç¼–è¾‘çŠ¶æ€
  clearEditingState() {
    this.currentEditingCard = null;
    this.currentEditingNode = null;
    this.autoSaveEnabled = true;
  }
  // é€€å‡ºå½“å‰ç¼–è¾‘çŠ¶æ€
  exitCurrentEditingState(save = false) {
    if (!this.currentEditingCard || !this.currentEditingNode)
      return;
    const contentDiv = this.currentEditingCard.querySelector(".card-content");
    if (!contentDiv)
      return;
    const editorContainer = this.currentEditingCard.querySelector(".card-editor-container");
    if (!editorContainer)
      return;
    if (save) {
      const textarea = editorContainer.querySelector("textarea");
      const input = editorContainer.querySelector("input");
      if (textarea && this.currentEditingNode.type === "text") {
        this.saveTextNode(this.currentEditingNode, textarea.value);
        this.exitEditMode(this.currentEditingCard, contentDiv, textarea.value);
      } else if (input && this.currentEditingNode.type === "link") {
        this.saveLinkNodeAndRefresh(this.currentEditingNode, input.value, this.currentEditingCard, contentDiv);
      }
    } else {
      if (this.currentEditingNode.type === "text") {
        this.exitEditMode(this.currentEditingCard, contentDiv, this.currentEditingNode.text || "");
      } else if (this.currentEditingNode.type === "link") {
        this.exitEditModeAndRefresh(this.currentEditingCard, contentDiv, this.currentEditingNode);
      }
    }
    this.clearEditingState();
  }
  // ==================== åˆ†ç»„åŠŸèƒ½ç›¸å…³æ–¹æ³• ====================
  // åˆ†æCanvasä¸­çš„åˆ†ç»„å’Œæˆå‘˜å…³ç³»
  analyzeGroups() {
    if (!this.canvasData)
      return;
    this.groupAnalysis.clear();
    const groupNodes = this.canvasData.nodes.filter((node) => node.type === "group");
    groupNodes.forEach((group) => {
      const members = this.findGroupMembers(group);
      const groupInfo = {
        group,
        members,
        memberCount: members.length,
        bounds: this.calculateGroupBounds(group)
      };
      this.groupAnalysis.set(group.id, groupInfo);
    });
    console.log("\u5206\u7EC4\u5206\u6790\u5B8C\u6210:", this.groupAnalysis);
  }
  // æŸ¥æ‰¾åˆ†ç»„å†…çš„æˆå‘˜èŠ‚ç‚¹
  findGroupMembers(group) {
    if (!this.canvasData)
      return [];
    const groupBounds = this.calculateGroupBounds(group);
    const members = [];
    this.canvasData.nodes.forEach((node) => {
      if (node.type !== "group" && node.id !== group.id) {
        if (this.isNodeInsideGroup(node, groupBounds)) {
          members.push(node);
        }
      }
    });
    return members;
  }
  // è®¡ç®—åˆ†ç»„çš„è¾¹ç•Œæ¡†
  calculateGroupBounds(group) {
    return {
      minX: group.x,
      minY: group.y,
      maxX: group.x + group.width,
      maxY: group.y + group.height
    };
  }
  // åˆ¤æ–­èŠ‚ç‚¹æ˜¯å¦åœ¨åˆ†ç»„å†…
  isNodeInsideGroup(node, groupBounds) {
    const nodeCenter = {
      x: node.x + node.width / 2,
      y: node.y + node.height / 2
    };
    return nodeCenter.x >= groupBounds.minX && nodeCenter.x <= groupBounds.maxX && nodeCenter.y >= groupBounds.minY && nodeCenter.y <= groupBounds.maxY;
  }
  // è·å–æ‰€æœ‰åˆ†ç»„ä¿¡æ¯ - æ”¯æŒæ—¶é—´èƒ¶å›Šåˆ†ç»„ç½®é¡¶
  getGroupsForGridView() {
    const groups = Array.from(this.groupAnalysis.values());
    const sortedGroups = groups.sort((a, b) => {
      const aIsActive = this.isActiveTimeCapsuleGroup(a.group.id);
      const bIsActive = this.isActiveTimeCapsuleGroup(b.group.id);
      const aIsHistorical = this.isHistoricalTimeCapsuleGroup(a.group.id);
      const bIsHistorical = this.isHistoricalTimeCapsuleGroup(b.group.id);
      if (aIsActive && !bIsActive)
        return -1;
      if (!aIsActive && bIsActive)
        return 1;
      if (aIsHistorical && !bIsHistorical && !bIsActive)
        return -1;
      if (!aIsHistorical && bIsHistorical && !aIsActive)
        return 1;
      return b.group.id.localeCompare(a.group.id);
    });
    console.log("\u{1F504} Group sorting result:");
    sortedGroups.forEach((group, index) => {
      const isActive = this.isActiveTimeCapsuleGroup(group.group.id);
      const isHistorical = this.isHistoricalTimeCapsuleGroup(group.group.id);
      const type = isActive ? "ACTIVE" : isHistorical ? "HISTORICAL" : "NORMAL";
      console.log(`  ${index + 1}. [${type}] ${group.group.id}`);
    });
    return sortedGroups;
  }
  // åˆ¤æ–­æ˜¯å¦ä¸ºæ—¶é—´èƒ¶å›Šåˆ†ç»„ï¼ˆåŒ…æ‹¬å†å²æ—¶é—´èƒ¶å›Šï¼‰
  isTimeCapsuleGroup(groupId) {
    return groupId.startsWith("time-capsule-");
  }
  // åˆ¤æ–­æ˜¯å¦ä¸ºå½“å‰æ¿€æ´»çš„æ—¶é—´èƒ¶å›Šåˆ†ç»„
  isActiveTimeCapsuleGroup(groupId) {
    return this.timeCapsuleState.isActive && groupId === this.timeCapsuleState.groupId;
  }
  // åˆ¤æ–­æ˜¯å¦ä¸ºå†å²æ—¶é—´èƒ¶å›Šåˆ†ç»„
  isHistoricalTimeCapsuleGroup(groupId) {
    return this.isTimeCapsuleGroup(groupId) && !this.isActiveTimeCapsuleGroup(groupId);
  }
  // è¿›å…¥åˆ†ç»„è§†å›¾
  enterGroupView(groupId) {
    const groupInfo = this.groupAnalysis.get(groupId);
    if (!groupInfo)
      return;
    this.currentGroupView = groupId;
    this.filteredNodes = groupInfo.members;
    this.renderGrid();
    this.updateToolbarForGroupView(groupInfo);
  }
  // é€€å‡ºåˆ†ç»„è§†å›¾ï¼Œè¿”å›ä¸»è§†å›¾
  exitGroupView() {
    this.currentGroupView = null;
    if (this.canvasData) {
      this.filteredNodes = this.canvasData.nodes.filter((node) => node.type !== "group");
    }
    this.renderGrid();
    this.updateToolbarForMainView();
  }
  // æ›´æ–°å·¥å…·æ æ˜¾ç¤ºåˆ†ç»„è§†å›¾ä¿¡æ¯
  updateToolbarForGroupView(groupInfo) {
    this.addGroupViewBackButtonToColorRow();
  }
  // åœ¨é¢œè‰²è¡Œä¸­æ·»åŠ è¿”å›æŒ‰é’®
  addGroupViewBackButtonToColorRow() {
    const toolbar = this.containerEl.querySelector(".canvas-grid-toolbar");
    if (!toolbar)
      return;
    const colorRow = toolbar.querySelector(".canvas-grid-toolbar-color-row");
    if (!colorRow)
      return;
    const existingBackButton = toolbar.querySelector(".group-back-button-toolbar");
    if (existingBackButton) {
      existingBackButton.remove();
    }
    const backButton = document.createElement("button");
    backButton.className = "group-back-button-toolbar";
    backButton.title = this.settings.language === "zh" ? "\u8FD4\u56DE\u4E3B\u89C6\u56FE" : "Back to main view";
    backButton.setAttribute("aria-label", this.settings.language === "zh" ? "\u8FD4\u56DE\u4E3B\u89C6\u56FE" : "Back to main view");
    backButton.innerHTML = `
			<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<polyline points="15,18 9,12 15,6"/>
			</svg>
		`;
    backButton.onclick = () => this.exitGroupView();
    const colorFilter = colorRow.querySelector(".canvas-grid-color-filter");
    if (colorFilter) {
      colorRow.insertBefore(backButton, colorFilter);
    } else {
      colorRow.appendChild(backButton);
    }
  }
  // æ¢å¤ä¸»è§†å›¾å·¥å…·æ 
  updateToolbarForMainView() {
    const toolbar = this.containerEl.querySelector(".canvas-grid-toolbar");
    if (!toolbar)
      return;
    const existingBackButton = toolbar.querySelector(".group-back-button-toolbar");
    if (existingBackButton) {
      existingBackButton.remove();
    }
  }
  // æ¸²æŸ“åˆ†ç»„æˆå‘˜ï¼ˆåœ¨åˆ†ç»„è§†å›¾ä¸­ï¼‰
  renderGroupMembers() {
    if (!this.currentGroupView)
      return;
    const groupInfo = this.groupAnalysis.get(this.currentGroupView);
    if (!groupInfo)
      return;
    if (groupInfo.members.length > 50) {
      this.renderGridBatched(groupInfo.members);
    } else {
      this.renderGridImmediate(groupInfo.members);
    }
    this.setupCardDragAttributes();
    console.log(`\u2705 Group members rendered with drag support: ${groupInfo.members.length} cards`);
  }
  // è·å–æœªåˆ†ç»„çš„èŠ‚ç‚¹
  getUngroupedNodes(nodes) {
    const ungroupedNodes = [];
    nodes.forEach((node) => {
      let isInGroup = false;
      for (const groupInfo of this.groupAnalysis.values()) {
        if (groupInfo.members.some((member) => member.id === node.id)) {
          isInGroup = true;
          break;
        }
      }
      if (!isInGroup) {
        ungroupedNodes.push(node);
      }
    });
    return ungroupedNodes;
  }
  // æ¸²æŸ“ç½‘æ ¼é¡¹ç›®ï¼ˆåˆ†ç»„å¡ç‰‡å’Œæ™®é€šèŠ‚ç‚¹ï¼‰
  renderGridItems(items) {
    const fragment = document.createDocumentFragment();
    items.forEach((item) => {
      let card;
      if (item.type === "group") {
        card = this.createGroupCard(item.data);
      } else {
        card = this.createCard(item.data);
        if (this.searchQuery) {
          this.highlightSearchResults(card, this.searchQuery);
        }
      }
      fragment.appendChild(card);
    });
    this.gridContainer.appendChild(fragment);
  }
  // åˆ›å»ºåˆ†ç»„å¡ç‰‡
  createGroupCard(groupInfo) {
    const card = document.createElement("div");
    const isTimeCapsule = this.isTimeCapsuleGroup(groupInfo.group.id);
    const isActiveTimeCapsule = this.isActiveTimeCapsuleGroup(groupInfo.group.id);
    const isHistoricalTimeCapsule = this.isHistoricalTimeCapsuleGroup(groupInfo.group.id);
    if (isActiveTimeCapsule) {
      card.className = "canvas-grid-card group-card time-capsule-group time-capsule-collecting";
    } else if (isHistoricalTimeCapsule) {
      card.className = "canvas-grid-card group-card time-capsule-group time-capsule-historical";
    } else {
      card.className = "canvas-grid-card group-card";
    }
    card.dataset.nodeId = groupInfo.group.id;
    card.dataset.nodeType = "group";
    card.style.minHeight = `${CARD_CONSTANTS.height}px`;
    if (groupInfo.group.color) {
      const normalizedColor = this.normalizeColorValue(groupInfo.group.color);
      if (normalizedColor) {
        const colorStyles = this.getColorStyles(normalizedColor);
        card.style.backgroundColor = colorStyles.backgroundColor;
        card.style.borderColor = colorStyles.borderColor;
        card.style.color = colorStyles.textColor;
      }
    }
    const contentDiv = card.createDiv("group-card-content");
    const iconDiv = contentDiv.createDiv("group-icon");
    if (isActiveTimeCapsule) {
      iconDiv.innerHTML = `
				<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
					<path d="M6 2v6h.01L6 8.01 10 12l-4 4-.01.01V22h12v-5.99-.01L18 16l-4-4 4-3.99.01-.01V2H6z"/>
				</svg>
			`;
      iconDiv.classList.add("time-capsule-icon", "time-capsule-active");
    } else if (isHistoricalTimeCapsule) {
      iconDiv.innerHTML = `
				<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
					<path d="M6 2v6h.01L6 8.01 10 12l-4 4-.01.01V22h12v-5.99-.01L18 16l-4-4 4-3.99.01-.01V2H6z"/>
				</svg>
			`;
      iconDiv.classList.add("time-capsule-icon", "time-capsule-historical");
    } else {
      iconDiv.innerHTML = `
				<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
					<rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
					<path d="M9 9h6v6H9z"/>
				</svg>
			`;
    }
    const titleDiv = contentDiv.createDiv("group-title");
    titleDiv.textContent = groupInfo.group.label || "\u672A\u547D\u540D\u5206\u7EC4";
    const countDiv = contentDiv.createDiv("group-member-count");
    if (isActiveTimeCapsule) {
      const minutes = Math.floor(this.timeCapsuleState.remainingTime / 6e4);
      const seconds = Math.floor(this.timeCapsuleState.remainingTime % 6e4 / 1e3);
      const timeText = `${minutes}:${seconds.toString().padStart(2, "0")}`;
      countDiv.innerHTML = `
				<div class="time-capsule-status">
					<span class="collecting-text">\u6536\u96C6\u4E2D</span>
					<span class="countdown-text">${timeText}</span>
				</div>
				<div class="member-count">${groupInfo.memberCount} \u4E2A\u9879\u76EE</div>
			`;
    } else if (isHistoricalTimeCapsule) {
      countDiv.innerHTML = `
				<div class="time-capsule-status">
					<span class="completed-text">\u5DF2\u5B8C\u6210</span>
				</div>
				<div class="member-count">${groupInfo.memberCount} \u4E2A\u9879\u76EE</div>
			`;
    } else {
      countDiv.textContent = `${groupInfo.memberCount} \u4E2A\u9879\u76EE`;
    }
    if (groupInfo.members.length > 0) {
      const previewDiv = contentDiv.createDiv("group-members-preview");
      const maxPreview = Math.min(4, groupInfo.members.length);
      for (let i = 0; i < maxPreview; i++) {
        const member = groupInfo.members[i];
        const memberIcon = previewDiv.createDiv("member-icon");
        memberIcon.className = `member-icon ${member.type}-icon`;
        switch (member.type) {
          case "text":
            memberIcon.innerHTML = `<svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>`;
            break;
          case "file":
            memberIcon.innerHTML = `<svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/></svg>`;
            break;
          case "link":
            memberIcon.innerHTML = `<svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/></svg>`;
            break;
        }
      }
      if (groupInfo.members.length > maxPreview) {
        const moreIcon = previewDiv.createDiv("member-icon more-icon");
        moreIcon.textContent = `+${groupInfo.members.length - maxPreview}`;
      }
    }
    const enterButton = contentDiv.createDiv("group-enter-button");
    enterButton.innerHTML = `
			<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<polyline points="9,18 15,12 9,6"/>
			</svg>
		`;
    enterButton.title = "\u67E5\u770B\u5206\u7EC4\u5185\u5BB9";
    card.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.enterGroupView(groupInfo.group.id);
    });
    card.addEventListener("mouseenter", () => {
      card.style.transform = "translateY(-2px)";
      card.style.boxShadow = "0 4px 12px rgba(0, 0, 0, 0.15)";
    });
    card.addEventListener("mouseleave", () => {
      card.style.transform = "translateY(0)";
      card.style.boxShadow = "";
    });
    return card;
  }
  // å¼€å§‹é“¾æ¥ç¼–è¾‘
  startLinkEditing(node, cardElement) {
    if (this.currentEditingCard && this.currentEditingCard !== cardElement) {
      this.exitCurrentEditingState(true);
    }
    const contentDiv = cardElement.querySelector(".card-content");
    if (!contentDiv)
      return;
    this.currentEditingCard = cardElement;
    this.currentEditingNode = node;
    this.autoSaveEnabled = false;
    const originalUrl = node.url || "";
    const editor = this.createLinkEditor(originalUrl, (newUrl) => {
      this.saveLinkNodeAndRefresh(node, newUrl, cardElement, contentDiv);
      this.clearEditingState();
    }, () => {
      this.exitEditModeAndRefresh(cardElement, contentDiv, node);
      this.clearEditingState();
    }, false);
    this.enterEditMode(cardElement, contentDiv, editor);
  }
  // ä¿å­˜é“¾æ¥èŠ‚ç‚¹å¹¶åˆ·æ–°æ˜¾ç¤º
  async saveLinkNodeAndRefresh(node, newUrl, cardElement, contentDiv) {
    node.url = newUrl;
    await this.saveCanvasData();
    this.exitEditModeAndRefresh(cardElement, contentDiv, node);
  }
  // é€€å‡ºç¼–è¾‘æ¨¡å¼å¹¶åˆ·æ–°å†…å®¹
  exitEditModeAndRefresh(cardElement, contentDiv, node) {
    cardElement.classList.remove("editing");
    cardElement.style.zIndex = "";
    cardElement.style.boxShadow = "";
    if (node.url) {
      this.linkPreviewCache.delete(node.url);
    }
    contentDiv.empty();
    contentDiv.removeClass("link-card-content");
    contentDiv.addClass("link-card-content");
    this.renderLinkNodeWithPreview(contentDiv, node);
  }
  // åˆ›å»ºé“¾æ¥ç¼–è¾‘å™¨
  createLinkEditor(url, onSave, onCancel, enableAutoSave = true) {
    const editorContainer = document.createElement("div");
    editorContainer.className = "card-editor-container";
    const input = document.createElement("input");
    input.type = "url";
    input.className = "card-editor-input";
    input.value = url;
    input.placeholder = "\u8F93\u5165URL\u5730\u5740...";
    input.style.width = "100%";
    input.style.padding = "8px";
    input.style.border = "1px solid var(--background-modifier-border)";
    input.style.borderRadius = "4px";
    input.style.background = "var(--background-primary)";
    input.style.color = "var(--text-normal)";
    input.style.fontSize = "var(--font-text-size)";
    let saveTimeout = null;
    const autoSave = () => {
      if (!enableAutoSave)
        return;
      if (saveTimeout) {
        this.safeClearTimeout(saveTimeout);
      }
      saveTimeout = this.safeSetTimeout(() => {
        onSave(input.value);
        saveTimeout = null;
      }, 500);
    };
    if (enableAutoSave) {
      input.addEventListener("input", autoSave);
      input.addEventListener("blur", () => {
        if (saveTimeout) {
          this.safeClearTimeout(saveTimeout);
          saveTimeout = null;
        }
        onSave(input.value);
      });
    }
    input.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        e.preventDefault();
        onCancel();
      } else if (e.key === "Enter") {
        e.preventDefault();
        if (saveTimeout) {
          this.safeClearTimeout(saveTimeout);
          saveTimeout = null;
        }
        onSave(input.value);
      }
    });
    editorContainer.appendChild(input);
    this.safeSetTimeout(() => {
      input.focus();
      input.select();
    }, 0);
    return editorContainer;
  }
  // è¿›å…¥ç¼–è¾‘æ¨¡å¼
  enterEditMode(cardElement, contentDiv, editor) {
    cardElement.classList.add("editing");
    cardElement.style.zIndex = "1000";
    cardElement.style.boxShadow = "0 8px 24px rgba(0,0,0,0.2)";
    cardElement.style.position = "relative";
    contentDiv.style.display = "none";
    const editorContainer = editor.querySelector(".card-editor-container");
    if (editorContainer) {
      editorContainer.style.position = "absolute";
      editorContainer.style.top = "0";
      editorContainer.style.left = "0";
      editorContainer.style.right = "0";
      editorContainer.style.bottom = "0";
      editorContainer.style.width = "100%";
      editorContainer.style.height = "100%";
      editorContainer.style.borderRadius = "inherit";
      editorContainer.style.overflow = "hidden";
    }
    cardElement.appendChild(editor);
  }
  // é€€å‡ºç¼–è¾‘æ¨¡å¼
  exitEditMode(cardElement, contentDiv, newContent) {
    cardElement.classList.remove("editing");
    cardElement.style.zIndex = "";
    cardElement.style.boxShadow = "";
    cardElement.style.position = "";
    const editor = cardElement.querySelector(".card-editor-container");
    if (editor) {
      editor.remove();
    }
    if (newContent !== void 0) {
      contentDiv.innerHTML = this.formatTextContent(newContent);
    }
    contentDiv.style.display = "";
  }
  // æ ¼å¼åŒ–æ–‡æœ¬å†…å®¹
  formatTextContent(text) {
    return text.replace(/\n/g, "<br>");
  }
  // ä¿å­˜æ–‡æœ¬èŠ‚ç‚¹
  async saveTextNode(node, newText) {
    if (!this.canvasData)
      return;
    node.text = newText;
    await this.saveCanvasData();
    this.refreshCard(node);
    new import_obsidian.Notice("\u6587\u672C\u5DF2\u4FDD\u5B58");
  }
  // ä¿å­˜é“¾æ¥èŠ‚ç‚¹
  async saveLinkNode(node, newUrl) {
    if (!this.canvasData)
      return;
    node.url = newUrl;
    await this.saveCanvasData();
    this.refreshCard(node);
    new import_obsidian.Notice("\u94FE\u63A5\u5DF2\u4FDD\u5B58");
  }
  // åˆ·æ–°å•ä¸ªå¡ç‰‡
  refreshCard(node) {
    const cardElement = this.gridContainer.querySelector(`[data-node-id="${node.id}"]`);
    if (!cardElement)
      return;
    const contentDiv = cardElement.querySelector(".card-content");
    if (!contentDiv)
      return;
    contentDiv.innerHTML = "";
    if (node.type === "text") {
      this.renderTextNodeContent(contentDiv, node);
    } else if (node.type === "link") {
      this.renderLinkNodeContent(contentDiv, node);
    }
  }
  // æ¸²æŸ“æ–‡æœ¬èŠ‚ç‚¹å†…å®¹ï¼ˆæå–çš„æ–¹æ³•ï¼‰
  renderTextNodeContent(contentDiv, node) {
    if (node.text) {
      const rendered = this.simpleMarkdownRender(node.text);
      contentDiv.innerHTML = rendered;
    } else {
      contentDiv.textContent = "\u7A7A\u6587\u672C\u8282\u70B9";
      contentDiv.style.color = "var(--text-muted)";
      contentDiv.style.fontStyle = "italic";
    }
  }
  // æ¸²æŸ“å¸¦é¢„è§ˆçš„é“¾æ¥èŠ‚ç‚¹
  async renderLinkNodeWithPreview(contentDiv, node) {
    if (!node.url) {
      contentDiv.textContent = "\u65E0\u6548\u7684\u94FE\u63A5";
      contentDiv.style.color = "var(--text-error)";
      contentDiv.style.fontStyle = "italic";
      return;
    }
    this.renderLinkLoadingState(contentDiv, node.url);
    try {
      const preview = await this.fetchLinkPreview(node.url);
      contentDiv.empty();
      this.renderLinkPreview(contentDiv, preview);
    } catch (error) {
      console.error("Failed to render link preview:", error);
      contentDiv.empty();
      this.renderSimpleLinkFallback(contentDiv, node.url);
    }
  }
  // æ¸²æŸ“é“¾æ¥åŠ è½½çŠ¶æ€
  renderLinkLoadingState(contentDiv, url) {
    contentDiv.empty();
    contentDiv.addClass("link-preview-loading");
    const skeleton = contentDiv.createDiv("link-preview-skeleton");
    const titleSkeleton = skeleton.createDiv("skeleton-title");
    const descSkeleton = skeleton.createDiv("skeleton-description");
    const urlDiv = skeleton.createDiv("skeleton-url");
    urlDiv.textContent = this.formatUrlForDisplay(url);
  }
  // æ¸²æŸ“é“¾æ¥é¢„è§ˆ
  renderLinkPreview(contentDiv, preview) {
    contentDiv.addClass("link-bookmark-card");
    contentDiv.dataset.nodeUrl = preview.url;
    const bookmarkContainer = contentDiv.createDiv("link-bookmark-container");
    const contentArea = bookmarkContainer.createDiv("link-bookmark-content");
    const titleEl = contentArea.createDiv("link-bookmark-title");
    titleEl.textContent = preview.title || this.extractDomainFromUrl(preview.url);
    if (preview.description) {
      const descEl = contentArea.createDiv("link-bookmark-description");
      descEl.textContent = preview.description;
    }
    const footerEl = contentArea.createDiv("link-bookmark-footer");
    const siteInfo = footerEl.createDiv("link-bookmark-site-info");
    if (preview.favicon) {
      const faviconEl = siteInfo.createEl("img", {
        cls: "link-bookmark-favicon",
        attr: {
          src: preview.favicon,
          alt: "Site icon"
        }
      });
      faviconEl.addEventListener("error", () => {
        faviconEl.style.display = "none";
      });
    }
    const siteNameEl = siteInfo.createSpan("link-bookmark-site-name");
    siteNameEl.textContent = preview.siteName || this.extractDomainFromUrl(preview.url);
    const urlEl = footerEl.createDiv("link-bookmark-url");
    urlEl.textContent = this.formatUrlForDisplay(preview.url);
    if (preview.image) {
      const imageContainer = bookmarkContainer.createDiv("link-bookmark-image-container");
      const img = imageContainer.createEl("img", {
        cls: "link-bookmark-image",
        attr: {
          src: preview.image,
          alt: preview.title || "Link preview image"
        }
      });
      img.addEventListener("error", () => {
        imageContainer.style.display = "none";
        bookmarkContainer.classList.add("no-image");
      });
    } else {
      bookmarkContainer.classList.add("no-image");
    }
    bookmarkContainer.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      window.open(preview.url, "_blank");
    });
    bookmarkContainer.style.cursor = "pointer";
    bookmarkContainer.title = `\u6253\u5F00\u94FE\u63A5: ${preview.url}`;
  }
  // ç®€å•é“¾æ¥å›é€€æ˜¾ç¤º
  renderSimpleLinkFallback(contentDiv, url) {
    const linkElement = contentDiv.createEl("a", {
      cls: "external-link simple-link",
      href: url
    });
    const displayText = this.extractDomainFromUrl(url);
    linkElement.textContent = displayText;
    const linkIcon = linkElement.createSpan("external-link-icon");
    linkIcon.innerHTML = `
			<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/>
				<polyline points="15,3 21,3 21,9"/>
				<line x1="10" y1="14" x2="21" y2="3"/>
			</svg>
		`;
    linkElement.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      window.open(url, "_blank");
    });
  }
  // æ¸²æŸ“é“¾æ¥èŠ‚ç‚¹å†…å®¹ï¼ˆç¼–è¾‘æ—¶ä½¿ç”¨çš„ç®€åŒ–ç‰ˆæœ¬ï¼‰
  renderLinkNodeContent(contentDiv, node) {
    if (node.url) {
      this.renderSimpleLinkFallback(contentDiv, node.url);
    } else {
      contentDiv.textContent = "\u65E0\u6548\u7684\u94FE\u63A5";
      contentDiv.style.color = "var(--text-error)";
      contentDiv.style.fontStyle = "italic";
    }
  }
  // æ ¼å¼åŒ–URLç”¨äºæ˜¾ç¤º
  formatUrlForDisplay(url) {
    try {
      const urlObj = new URL(url);
      const domain = urlObj.hostname;
      const path = urlObj.pathname;
      if (url.length > 50) {
        if (path.length > 20) {
          return `${domain}${path.substring(0, 15)}...`;
        } else {
          return `${domain}${path}`;
        }
      }
      return url;
    } catch {
      return url.length > 50 ? url.substring(0, 47) + "..." : url;
    }
  }
  // è·å–é“¾æ¥é¢„è§ˆæ•°æ®
  async fetchLinkPreview(url) {
    const cachedItem = this.getCacheItem(url);
    if (cachedItem) {
      return cachedItem;
    }
    if (this.previewLoadingUrls.has(url)) {
      return { url, isLoading: true };
    }
    this.previewLoadingUrls.add(url);
    try {
      const preview = await this.extractLinkMetadata(url);
      this.setCacheItem(url, preview);
      this.previewLoadingUrls.delete(url);
      return preview;
    } catch (error) {
      console.error("Failed to fetch link preview:", error);
      const errorPreview = {
        url,
        error: "Failed to load preview",
        title: this.extractDomainFromUrl(url)
      };
      this.setCacheItem(url, errorPreview);
      this.previewLoadingUrls.delete(url);
      return errorPreview;
    }
  }
  // æå–é“¾æ¥å…ƒæ•°æ®ï¼ˆä¼˜åŒ–ç‰ˆæœ¬ - å¿«é€Ÿä¹¦ç­¾è§£æï¼‰
  async extractLinkMetadata(url) {
    try {
      const urlObj = new URL(url);
      const basicPreview = {
        url,
        title: this.extractTitleFromUrl(url),
        siteName: this.extractDomainFromUrl(url),
        favicon: `https://www.google.com/s2/favicons?domain=${urlObj.hostname}`,
        isBasic: true
        // æ ‡è®°ä¸ºåŸºç¡€ä¿¡æ¯
      };
      this.fetchDetailedMetadata(url, basicPreview);
      return basicPreview;
    } catch (urlError) {
      return {
        url,
        title: "\u65E0\u6548\u94FE\u63A5",
        siteName: "\u672A\u77E5",
        error: "URL\u683C\u5F0F\u65E0\u6548"
      };
    }
  }
  // ä»URLæå–æ™ºèƒ½æ ‡é¢˜
  extractTitleFromUrl(url) {
    try {
      const urlObj = new URL(url);
      const domain = urlObj.hostname;
      const path = urlObj.pathname;
      if (path && path !== "/") {
        const pathParts = path.split("/").filter((part) => part.length > 0);
        if (pathParts.length > 0) {
          const lastPart = pathParts[pathParts.length - 1];
          const cleanTitle = lastPart.replace(/\.(html|htm|php|asp|jsp)$/i, "").replace(/[-_]/g, " ").replace(/\b\w/g, (l) => l.toUpperCase());
          if (cleanTitle.length > 3) {
            return cleanTitle;
          }
        }
      }
      return this.extractDomainFromUrl(url);
    } catch {
      return this.extractDomainFromUrl(url);
    }
  }
  // å¼‚æ­¥è·å–è¯¦ç»†å…ƒæ•°æ®ï¼ˆä¸é˜»å¡UIï¼‰
  async fetchDetailedMetadata(url, basicPreview) {
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 3e3);
      const apiServices = [
        `https://api.microlink.io/?url=${encodeURIComponent(url)}&timeout=2000`,
        `https://jsonlink.io/api/extract?url=${encodeURIComponent(url)}`
      ];
      let detailedData = null;
      for (const apiUrl of apiServices) {
        try {
          const response = await Promise.race([
            fetch(apiUrl, {
              signal: controller.signal,
              headers: {
                "Accept": "application/json",
                "User-Agent": "Obsidian Canvasgrid Transit Plugin"
              }
            }),
            new Promise(
              (_, reject) => setTimeout(() => reject(new Error("Service timeout")), 2e3)
            )
          ]);
          if (response.ok) {
            const data = await response.json();
            if (this.isValidMetadata(data)) {
              detailedData = data;
              break;
            }
          }
        } catch (serviceError) {
          console.log(`API service failed: ${apiUrl}`, serviceError);
          continue;
        }
      }
      clearTimeout(timeoutId);
      if (detailedData) {
        const enhancedPreview = this.parseMetadataResponse(url, detailedData);
        this.setCacheItem(url, enhancedPreview);
        this.updateBookmarkCard(url, enhancedPreview);
      }
    } catch (error) {
      console.log("\u8BE6\u7EC6\u5143\u6570\u636E\u83B7\u53D6\u5931\u8D25\uFF0C\u4F7F\u7528\u57FA\u7840\u4FE1\u606F:", error);
    }
  }
  // éªŒè¯å…ƒæ•°æ®å“åº”æ˜¯å¦æœ‰æ•ˆ
  isValidMetadata(data) {
    if (!data)
      return false;
    if (data.status === "success" && data.data) {
      return true;
    }
    if (data.title || data.description) {
      return true;
    }
    return false;
  }
  // è§£æä¸åŒAPIæœåŠ¡çš„å“åº”æ ¼å¼
  parseMetadataResponse(url, data) {
    let title = "";
    let description = "";
    let image = "";
    let siteName = "";
    let favicon = "";
    if (data.status === "success" && data.data) {
      title = data.data.title || "";
      description = data.data.description || "";
      image = data.data.image?.url || "";
      siteName = data.data.publisher || "";
      favicon = data.data.logo?.url || "";
    } else if (data.title || data.description) {
      title = data.title || "";
      description = data.description || "";
      image = data.image || "";
      siteName = data.site_name || "";
      favicon = data.favicon || "";
    }
    if (!favicon) {
      try {
        const urlObj = new URL(url);
        favicon = `https://www.google.com/s2/favicons?domain=${urlObj.hostname}`;
      } catch {
        favicon = "";
      }
    }
    return {
      url,
      title: title || this.extractTitleFromUrl(url),
      description: description || "",
      image: image || "",
      siteName: siteName || this.extractDomainFromUrl(url),
      favicon
    };
  }
  // æ›´æ–°ä¹¦ç­¾å¡ç‰‡æ˜¾ç¤ºï¼ˆå½“è·å–åˆ°è¯¦ç»†ä¿¡æ¯æ—¶ï¼‰
  updateBookmarkCard(url, enhancedPreview) {
    const cards = this.gridContainer.querySelectorAll(`[data-node-url="${url}"]`);
    cards.forEach((card) => {
      const bookmarkContainer = card.querySelector(".link-bookmark-container");
      if (bookmarkContainer) {
        const titleEl = bookmarkContainer.querySelector(".link-bookmark-title");
        if (titleEl && enhancedPreview.title) {
          titleEl.textContent = enhancedPreview.title;
        }
        let descEl = bookmarkContainer.querySelector(".link-bookmark-description");
        if (enhancedPreview.description) {
          if (!descEl) {
            const contentArea = bookmarkContainer.querySelector(".link-bookmark-content");
            if (contentArea) {
              descEl = contentArea.createDiv("link-bookmark-description");
            }
          }
          if (descEl) {
            descEl.textContent = enhancedPreview.description;
          }
        }
        const imageArea = bookmarkContainer.querySelector(".link-bookmark-image");
        if (imageArea && enhancedPreview.image) {
          const img = imageArea.querySelector("img");
          if (img) {
            img.src = enhancedPreview.image;
          }
        }
        const faviconEl = bookmarkContainer.querySelector(".link-bookmark-favicon");
        if (faviconEl && enhancedPreview.favicon) {
          const img = faviconEl.querySelector("img");
          if (img) {
            img.src = enhancedPreview.favicon;
          }
        }
      }
    });
  }
  // ä»URLæå–åŸŸå
  extractDomainFromUrl(url) {
    try {
      const urlObj = new URL(url);
      return urlObj.hostname.replace("www.", "");
    } catch {
      return url;
    }
  }
  // æ˜¾ç¤ºæ¶ˆæ¯
  showMessage(message) {
    this.gridContainer.empty();
    const messageEl = this.gridContainer.createDiv("grid-message");
    messageEl.textContent = message;
    messageEl.style.textAlign = "center";
    messageEl.style.color = "var(--text-muted)";
    messageEl.style.marginTop = "50px";
  }
  // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
  showLoadingState() {
    this.gridContainer.empty();
    const loadingEl = this.gridContainer.createDiv("canvas-grid-loading");
    loadingEl.textContent = "\u6B63\u5728\u52A0\u8F7DCanvas\u6570\u636E...";
  }
  // éšè—åŠ è½½çŠ¶æ€
  hideLoadingState() {
    const loadingEl = this.gridContainer.querySelector(".canvas-grid-loading");
    if (loadingEl) {
      loadingEl.remove();
    }
  }
  // æ˜¾ç¤ºé”™è¯¯çŠ¶æ€
  showErrorState(errorMessage) {
    this.gridContainer.empty();
    const errorEl = this.gridContainer.createDiv("canvas-grid-error");
    const titleEl = errorEl.createEl("h3");
    titleEl.textContent = "\u52A0\u8F7D\u5931\u8D25";
    titleEl.style.color = "var(--text-error)";
    const messageEl = errorEl.createEl("p");
    messageEl.textContent = errorMessage;
    messageEl.style.color = "var(--text-muted)";
    const retryBtn = errorEl.createEl("button", {
      text: "\u91CD\u8BD5",
      cls: "mod-cta"
    });
    retryBtn.onclick = () => this.loadActiveCanvas();
    errorEl.style.textAlign = "center";
    errorEl.style.marginTop = "50px";
  }
  // æ‰“å¼€ç½‘æ ¼è®¾ç½®
  openGridSettings() {
    console.log("Open grid settings");
  }
  // åˆ‡æ¢åˆ°Canvasè§†å›¾
  async switchToCanvasView() {
    let targetFile = this.app.workspace.getActiveFile();
    if (!targetFile || targetFile.extension !== "canvas") {
      if (this.linkedCanvasFile) {
        targetFile = this.linkedCanvasFile;
        console.log("Using linked canvas file:", targetFile.path);
      } else {
        new import_obsidian.Notice("\u6CA1\u6709\u5173\u8054\u7684Canvas\u6587\u4EF6\uFF0C\u8BF7\u5148\u5173\u8054\u4E00\u4E2ACanvas\u6587\u4EF6");
        return;
      }
    }
    const targetLeaf = this.findExistingCanvasLeaf(targetFile);
    if (targetLeaf) {
      this.app.workspace.setActiveLeaf(targetLeaf);
      console.log("Activated existing canvas view");
    } else {
      try {
        await this.openCanvasInMainWorkspace(targetFile);
      } catch (error) {
        console.error("Failed to open canvas file:", error);
        new import_obsidian.Notice("\u65E0\u6CD5\u6253\u5F00Canvas\u6587\u4EF6");
      }
    }
  }
  // æŸ¥æ‰¾ç°æœ‰çš„Canvaså¶å­ï¼ˆé¿å…é‡å¤æ‰“å¼€ï¼‰
  findExistingCanvasLeaf(targetFile) {
    const canvasLeaves = this.app.workspace.getLeavesOfType("canvas");
    for (const leaf of canvasLeaves) {
      const view = leaf.view;
      if (view && view.file && view.file.path === targetFile.path) {
        if (this.isLeafInMainWorkspace(leaf)) {
          console.log("Found existing canvas leaf in main workspace");
          return leaf;
        }
      }
    }
    return null;
  }
  // æ£€æŸ¥å¶å­æ˜¯å¦åœ¨ä¸»å·¥ä½œåŒº
  isLeafInMainWorkspace(leaf) {
    let parent = leaf.parent;
    while (parent) {
      if (parent === this.app.workspace.leftSplit || parent === this.app.workspace.rightSplit) {
        return false;
      }
      parent = parent.parent;
    }
    return true;
  }
  // åœ¨ä¸»å·¥ä½œåŒºæ‰“å¼€Canvasæ–‡ä»¶
  async openCanvasInMainWorkspace(targetFile) {
    try {
      const newLeaf = this.app.workspace.getLeaf("tab");
      if (newLeaf && this.isLeafInMainWorkspace(newLeaf)) {
        await newLeaf.openFile(targetFile);
        this.app.workspace.setActiveLeaf(newLeaf);
        console.log("Opened canvas file in new tab in main workspace");
        return;
      }
      const rootLeaf = this.app.workspace.getLeaf(true);
      if (rootLeaf) {
        await rootLeaf.openFile(targetFile);
        this.app.workspace.setActiveLeaf(rootLeaf);
        console.log("Opened canvas file in new leaf in main workspace");
        return;
      }
      throw new Error("\u65E0\u6CD5\u521B\u5EFA\u65B0\u7684\u5DE5\u4F5C\u533A\u53F6\u5B50");
    } catch (error) {
      console.error("Failed to open canvas in main workspace:", error);
      throw error;
    }
  }
  async onClose() {
    if (this.gridContainer) {
      this.gridContainer.removeEventListener("click", this.handleCardClick);
      this.gridContainer.removeEventListener("dblclick", this.handleCardDoubleClick);
      this.gridContainer.removeEventListener("contextmenu", this.handleCardContextMenu);
      this.gridContainer.removeEventListener("keydown", this.handleKeyDown);
    }
    document.removeEventListener("click", this.handleDocumentClick);
    this.removeGlobalMouseListeners();
    this.globalEventListeners.forEach(({ element, event, handler, options }) => {
      try {
        element.removeEventListener(event, handler, options);
      } catch (error) {
        console.warn("Failed to remove event listener:", error);
      }
    });
    this.globalEventListeners.length = 0;
    this.activeTimeouts.forEach((timeoutId) => {
      try {
        clearTimeout(timeoutId);
      } catch (error) {
        console.warn("Failed to clear timeout:", error);
      }
    });
    this.activeTimeouts.clear();
    this.activeIntervals.forEach((intervalId) => {
      try {
        clearInterval(intervalId);
      } catch (error) {
        console.warn("Failed to clear interval:", error);
      }
    });
    this.activeIntervals.clear();
    if (this.refreshTimer) {
      this.safeClearInterval(this.refreshTimer);
      this.refreshTimer = null;
    }
    if (this.cacheCleanupInterval) {
      this.safeClearInterval(this.cacheCleanupInterval);
      this.cacheCleanupInterval = null;
    }
    this.hideContextMenu();
    this.linkPreviewCache.clear();
    this.previewLoadingUrls.clear();
    this.clearRenderCache();
    this.canvasData = null;
    this.searchInputEl = null;
    this.colorFilterContainer = null;
    this.dropIndicator = null;
    this.cleanupWidthControl();
    this.linkedCanvasFile = null;
  }
  // æ˜¾ç¤ºå³é”®èœå•
  showContextMenu(card, x, y) {
    this.hideContextMenu();
    const nodeId = card.dataset.nodeId;
    const nodeType = card.dataset.nodeType;
    if (!nodeId)
      return;
    const menu = document.createElement("div");
    menu.className = "canvas-grid-context-menu";
    if (nodeType === "group") {
      const renameItem = this.createMenuItem("\u91CD\u547D\u540D\u5206\u7EC4", "lucide-edit-3", () => {
        this.renameGroup(nodeId);
        this.hideContextMenu();
      });
      const focusItem = this.createMenuItem("\u805A\u7126\u5206\u7EC4", "lucide-target", () => {
        this.focusNodeInCanvas(nodeId);
        this.hideContextMenu();
      });
      const deleteItem = this.createMenuItem("\u5220\u9664\u5206\u7EC4", "lucide-trash-2", () => {
        this.deleteCard(card);
        this.hideContextMenu();
      });
      menu.appendChild(renameItem);
      menu.appendChild(focusItem);
      menu.appendChild(deleteItem);
    } else {
      const focusItem = this.createMenuItem("\u805A\u7126\u8282\u70B9", "lucide-target", () => {
        this.focusNodeInCanvas(nodeId);
        this.hideContextMenu();
      });
      const editItem = this.createMenuItem("\u7F16\u8F91", "lucide-edit", () => {
        this.editCard(card);
        this.hideContextMenu();
      });
      const deleteItem = this.createMenuItem("\u5220\u9664", "lucide-trash-2", () => {
        this.deleteCard(card);
        this.hideContextMenu();
      });
      menu.appendChild(focusItem);
      menu.appendChild(editItem);
      const node = this.canvasData?.nodes.find((n) => n.id === nodeId);
      if (node) {
        const backlinkItem = this.createMenuItem("\u56DE\u94FE", "lucide-arrow-left", () => {
          this.handleBacklinkNavigation(node);
          this.hideContextMenu();
        });
        menu.appendChild(backlinkItem);
        console.log("Added backlink menu item for node:", nodeId);
      }
      menu.appendChild(deleteItem);
    }
    menu.style.left = `${x}px`;
    menu.style.top = `${y}px`;
    document.body.appendChild(menu);
    this.adjustMenuPosition(menu, x, y);
  }
  // åˆ›å»ºèœå•é¡¹
  createMenuItem(text, iconClass, onClick) {
    const item = document.createElement("div");
    item.className = "canvas-grid-context-menu-item";
    const icon = document.createElement("div");
    icon.className = `canvas-grid-context-menu-icon ${iconClass}`;
    const label = document.createElement("span");
    label.textContent = text;
    item.appendChild(icon);
    item.appendChild(label);
    item.addEventListener("click", onClick);
    return item;
  }
  // è°ƒæ•´èœå•ä½ç½®
  adjustMenuPosition(menu, x, y) {
    const rect = menu.getBoundingClientRect();
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    let adjustedX = x;
    let adjustedY = y;
    if (x + rect.width > viewportWidth) {
      adjustedX = viewportWidth - rect.width - 10;
    }
    if (y + rect.height > viewportHeight) {
      adjustedY = viewportHeight - rect.height - 10;
    }
    menu.style.left = `${adjustedX}px`;
    menu.style.top = `${adjustedY}px`;
  }
  // éšè—å³é”®èœå•
  hideContextMenu() {
    const existingMenu = document.querySelector(".canvas-grid-context-menu");
    if (existingMenu) {
      existingMenu.remove();
    }
  }
  // å¤„ç†å›é“¾åŠŸèƒ½ï¼ˆæ—§ç‰ˆæœ¬ï¼Œä¿ç•™å…¼å®¹æ€§ï¼‰
  async handleBacklink(nodeId) {
    try {
      console.log("Handling backlink for node:", nodeId);
      new import_obsidian.Notice(`\u56DE\u94FE\u529F\u80FD\u5DF2\u89E6\u53D1\uFF0C\u8282\u70B9ID: ${nodeId}`);
    } catch (error) {
      console.error("Failed to handle backlink:", error);
      new import_obsidian.Notice("\u56DE\u94FE\u529F\u80FD\u6267\u884C\u5931\u8D25");
    }
  }
  // æ™ºèƒ½å¤„ç†å›é“¾å¯¼èˆªï¼ˆæ–°ç‰ˆæœ¬ï¼‰
  async handleBacklinkNavigation(node) {
    try {
      console.log("=== Backlink Navigation ===");
      console.log("Node:", node);
      if (this.hasBacklink(node)) {
        console.log("\u2705 Found backlink in node, using navigateToBacklink");
        await this.navigateToBacklink(node);
      } else {
        console.log("\u274C No backlink found, showing alternative options");
        await this.showBacklinkAlternatives(node);
      }
    } catch (error) {
      console.error("Failed to handle backlink navigation:", error);
      new import_obsidian.Notice("\u56DE\u94FE\u5BFC\u822A\u5931\u8D25");
    }
  }
  // æ˜¾ç¤ºå›é“¾æ›¿ä»£é€‰é¡¹
  async showBacklinkAlternatives(node) {
    const modal = new import_obsidian.Modal(this.app);
    modal.titleEl.setText("\u56DE\u94FE\u9009\u9879");
    const content = modal.contentEl;
    content.empty();
    content.createEl("p", { text: "\u8BE5\u8282\u70B9\u6CA1\u6709\u68C0\u6D4B\u5230\u56DE\u94FE\u4FE1\u606F\uFF0C\u8BF7\u9009\u62E9\u64CD\u4F5C\uFF1A" });
    const buttonContainer = content.createDiv("backlink-options-container");
    buttonContainer.style.cssText = `
			display: flex;
			gap: 10px;
			margin-top: 20px;
			justify-content: center;
		`;
    const searchButton = buttonContainer.createEl("button", { text: "\u67E5\u627E\u6E90\u6587\u4EF6" });
    searchButton.onclick = () => {
      modal.close();
      this.searchForSourceFile(node);
    };
    const infoButton = buttonContainer.createEl("button", { text: "\u8282\u70B9\u4FE1\u606F" });
    infoButton.onclick = () => {
      modal.close();
      this.showNodeInfo(node);
    };
    const cancelButton = buttonContainer.createEl("button", { text: "\u53D6\u6D88" });
    cancelButton.onclick = () => {
      modal.close();
    };
    modal.open();
  }
  // æœç´¢å¯èƒ½çš„æºæ–‡ä»¶
  async searchForSourceFile(node) {
    if (node.type !== "text" || !node.text) {
      new import_obsidian.Notice("\u53EA\u80FD\u4E3A\u6587\u672C\u8282\u70B9\u641C\u7D22\u6E90\u6587\u4EF6");
      return;
    }
    const searchText = node.text.split("\n")[0].substring(0, 50);
    new import_obsidian.Notice(`\u6B63\u5728\u641C\u7D22\u5305\u542B "${searchText}" \u7684\u6587\u4EF6...`);
    try {
      this.app.internalPlugins?.getPluginById("global-search")?.instance?.openGlobalSearch?.(searchText);
    } catch (error) {
      console.log("Global search not available, showing manual search notice");
      new import_obsidian.Notice(`\u8BF7\u624B\u52A8\u641C\u7D22: "${searchText}"`);
    }
  }
  // æ˜¾ç¤ºèŠ‚ç‚¹è¯¦ç»†ä¿¡æ¯
  showNodeInfo(node) {
    const info = [
      `\u8282\u70B9ID: ${node.id}`,
      `\u8282\u70B9\u7C7B\u578B: ${node.type}`,
      `\u4F4D\u7F6E: (${node.x}, ${node.y})`,
      `\u5C3A\u5BF8: ${node.width} \xD7 ${node.height}`,
      node.text ? `\u6587\u672C\u957F\u5EA6: ${node.text.length} \u5B57\u7B26` : "\u65E0\u6587\u672C\u5185\u5BB9"
    ];
    new import_obsidian.Notice(info.join("\n"), 5e3);
    console.log("Node Info:", node);
    return Promise.resolve();
  }
  // é‡å‘½ååˆ†ç»„
  async renameGroup(groupId) {
    if (!this.canvasData)
      return;
    const groupNode = this.canvasData.nodes.find((n) => n.id === groupId && n.type === "group");
    if (!groupNode) {
      new import_obsidian.Notice("\u672A\u627E\u5230\u5206\u7EC4\u8282\u70B9");
      return;
    }
    const currentName = groupNode.label || "\u672A\u547D\u540D\u5206\u7EC4";
    const modal = new GroupRenameModal(this.app, currentName, async (newName) => {
      try {
        groupNode.label = newName;
        await this.saveCanvasData();
        const groupInfo = this.groupAnalysis.get(groupId);
        if (groupInfo) {
          groupInfo.group.label = newName;
        }
        this.renderGrid();
        this.notifyCanvasViewRefresh();
        new import_obsidian.Notice(`\u5206\u7EC4\u5DF2\u91CD\u547D\u540D\u4E3A: ${newName}`);
        console.log(`Group ${groupId} renamed to: ${newName}`);
      } catch (error) {
        console.error("Failed to rename group:", error);
        new import_obsidian.Notice("\u91CD\u547D\u540D\u5206\u7EC4\u5931\u8D25");
      }
    });
    modal.open();
  }
  // ç¼–è¾‘å¡ç‰‡
  editCard(card) {
    const nodeId = card.dataset.nodeId;
    if (!nodeId)
      return;
    const node = this.canvasData?.nodes.find((n) => n.id === nodeId);
    if (node && !card.classList.contains("editing")) {
      this.onCardDoubleClick(node, card);
    }
  }
  // åˆ é™¤å¡ç‰‡
  async deleteCard(card) {
    const nodeId = card.dataset.nodeId;
    if (!nodeId)
      return;
    const confirmed = confirm("\u786E\u5B9A\u8981\u5220\u9664\u8FD9\u4E2A\u8282\u70B9\u5417\uFF1F");
    if (!confirmed)
      return;
    try {
      await this.deleteNodeFromCanvas(nodeId);
      card.remove();
      console.log("\u5361\u7247\u5220\u9664\u5B8C\u6210\uFF0CUI\u5DF2\u66F4\u65B0");
    } catch (error) {
      console.error("\u5220\u9664\u5361\u7247\u5931\u8D25:", error);
      new import_obsidian.Notice("\u5220\u9664\u5361\u7247\u5931\u8D25");
    }
  }
  // ä»Canvasæ•°æ®ä¸­åˆ é™¤èŠ‚ç‚¹
  async deleteNodeFromCanvas(nodeId) {
    let targetFile = null;
    if (this.linkedCanvasFile) {
      targetFile = this.linkedCanvasFile;
    } else {
      const activeFile = this.app.workspace.getActiveFile();
      if (activeFile && activeFile.extension === "canvas") {
        targetFile = activeFile;
      }
    }
    if (!targetFile) {
      console.error("\u65E0\u6CD5\u786E\u5B9A\u76EE\u6807Canvas\u6587\u4EF6");
      new import_obsidian.Notice("\u5220\u9664\u5931\u8D25\uFF1A\u65E0\u6CD5\u786E\u5B9A\u76EE\u6807Canvas\u6587\u4EF6");
      return;
    }
    try {
      this.disableFileWatcher();
      const content = await this.app.vault.read(targetFile);
      const canvasData = JSON.parse(content);
      const nodeExists = canvasData.nodes.some((node) => node.id === nodeId);
      if (!nodeExists) {
        console.warn("\u8282\u70B9\u4E0D\u5B58\u5728\uFF0C\u53EF\u80FD\u5DF2\u88AB\u5220\u9664:", nodeId);
        return;
      }
      canvasData.nodes = canvasData.nodes.filter((node) => node.id !== nodeId);
      canvasData.edges = canvasData.edges.filter(
        (edge) => edge.fromNode !== nodeId && edge.toNode !== nodeId
      );
      await this.app.vault.modify(targetFile, JSON.stringify(canvasData, null, 2));
      this.canvasData = canvasData;
      this.filteredNodes = this.filteredNodes.filter((node) => node.id !== nodeId);
      console.log("\u8282\u70B9\u5220\u9664\u5B8C\u6210\uFF0C\u66F4\u65B0\u7B5B\u9009\u7ED3\u679C:", {
        deletedNodeId: nodeId,
        remainingFilteredNodes: this.filteredNodes.length
      });
      this.safeSetTimeout(() => {
        this.enableFileWatcher();
      }, 1e3);
      console.log("\u8282\u70B9\u5220\u9664\u6210\u529F:", nodeId);
      new import_obsidian.Notice("\u8282\u70B9\u5220\u9664\u6210\u529F");
    } catch (error) {
      console.error("\u5220\u9664\u8282\u70B9\u5931\u8D25:", error);
      new import_obsidian.Notice("\u5220\u9664\u8282\u70B9\u5931\u8D25");
      this.enableFileWatcher();
    }
  }
  // ç¦ç”¨æ–‡ä»¶ç›‘å¬å™¨
  disableFileWatcher() {
    this.fileWatcherDisabled = true;
  }
  // å¯ç”¨æ–‡ä»¶ç›‘å¬å™¨
  enableFileWatcher() {
    this.fileWatcherDisabled = false;
  }
  // ä¿å­˜å•ä¸ªèŠ‚ç‚¹åˆ°Canvasæ–‡ä»¶
  async saveNodeToCanvas(node) {
    if (!node || !node.id) {
      throw new Error("\u8282\u70B9\u6570\u636E\u65E0\u6548");
    }
    const canvasFile = this.linkedCanvasFile;
    if (!canvasFile) {
      throw new Error("\u6CA1\u6709\u5173\u8054\u7684Canvas\u6587\u4EF6");
    }
    try {
      console.log("Saving node to canvas:", node.id);
      const content = await this.app.vault.read(canvasFile);
      let canvasData;
      try {
        canvasData = JSON.parse(content);
      } catch (parseError) {
        throw new Error("Canvas\u6587\u4EF6\u683C\u5F0F\u65E0\u6548");
      }
      if (!Array.isArray(canvasData.nodes)) {
        throw new Error("Canvas\u6587\u4EF6\u7F3A\u5C11\u6709\u6548\u7684\u8282\u70B9\u6570\u636E");
      }
      const nodeIndex = canvasData.nodes.findIndex((n) => n.id === node.id);
      if (nodeIndex === -1) {
        throw new Error(`\u8282\u70B9\u4E0D\u5B58\u5728: ${node.id}`);
      }
      canvasData.nodes[nodeIndex] = { ...canvasData.nodes[nodeIndex], ...node };
      const updatedNode = canvasData.nodes[nodeIndex];
      if (!updatedNode.id || !updatedNode.type) {
        throw new Error("\u66F4\u65B0\u540E\u7684\u8282\u70B9\u6570\u636E\u65E0\u6548");
      }
      const jsonContent = JSON.stringify(canvasData, null, 2);
      await this.app.vault.modify(canvasFile, jsonContent);
      console.log("Node saved successfully:", node.id);
    } catch (error) {
      console.error("\u4FDD\u5B58\u8282\u70B9\u5931\u8D25:", error);
      const errorMessage = error instanceof Error ? error.message : "\u672A\u77E5\u9519\u8BEF";
      throw new Error(`\u4FDD\u5B58\u8282\u70B9\u5931\u8D25: ${errorMessage}`);
    }
  }
  // ==================== èšç„¦åŠŸèƒ½å®ç° ====================
  // èšç„¦åˆ°Canvasä¸­çš„æŒ‡å®šèŠ‚ç‚¹
  async focusNodeInCanvas(nodeId) {
    try {
      console.log("=== Starting focus operation for node:", nodeId);
      new import_obsidian.Notice("\u6B63\u5728\u5B9A\u4F4D\u8282\u70B9...", 2e3);
      await this.ensureCanvasView();
      await this.waitForCanvasLoad();
      const canvasView = this.getActiveCanvasView();
      if (!canvasView) {
        new import_obsidian.Notice("\u65E0\u6CD5\u83B7\u53D6Canvas\u89C6\u56FE");
        return false;
      }
      console.log("Canvas view obtained, detecting API...");
      const canvasAPI = this.detectCanvasAPI(canvasView);
      if (!canvasAPI) {
        console.log("Canvas API not available, falling back to simulation");
        return this.focusNodeBySimulation(nodeId);
      }
      const nodeData = this.canvasData?.nodes.find((n) => n.id === nodeId);
      if (!nodeData) {
        new import_obsidian.Notice("\u627E\u4E0D\u5230\u76EE\u6807\u8282\u70B9");
        return false;
      }
      console.log("Node data found:", nodeData);
      console.log("Executing focus operations...");
      const success = await this.executeCanvasFocus(canvasAPI, nodeId, nodeData);
      if (success) {
        new import_obsidian.Notice("\u5DF2\u805A\u7126\u5230\u76EE\u6807\u8282\u70B9", 3e3);
        return true;
      } else {
        console.log("Canvas API focus failed, falling back to simulation");
        return this.focusNodeBySimulation(nodeId);
      }
    } catch (error) {
      console.error("\u805A\u7126\u8282\u70B9\u5931\u8D25:", error);
      new import_obsidian.Notice("\u805A\u7126\u5931\u8D25\uFF0C\u8BF7\u624B\u52A8\u5B9A\u4F4D");
      return false;
    }
  }
  // ç¡®ä¿åˆ‡æ¢åˆ°Canvasè§†å›¾
  async ensureCanvasView() {
    console.log("Ensuring canvas view...");
    if (!this.linkedCanvasFile) {
      new import_obsidian.Notice("\u6CA1\u6709\u5173\u8054\u7684Canvas\u6587\u4EF6\uFF0C\u8BF7\u5148\u5173\u8054\u4E00\u4E2ACanvas\u6587\u4EF6");
      throw new Error("No linked canvas file");
    }
    const targetLeaf = this.findExistingCanvasLeaf(this.linkedCanvasFile);
    if (targetLeaf) {
      console.log("Found existing canvas view, activating...");
      this.app.workspace.setActiveLeaf(targetLeaf);
      await new Promise((resolve) => {
        this.safeSetTimeout(() => resolve(void 0), 300);
      });
      return;
    }
    const activeLeaf = this.app.workspace.activeLeaf;
    if (activeLeaf && activeLeaf.view.getViewType() === "canvas") {
      const canvasView = activeLeaf.view;
      if (canvasView && canvasView.file && canvasView.file.path === this.linkedCanvasFile.path) {
        console.log("Already in correct canvas view");
        return;
      }
    }
    console.log("Creating new canvas view...");
    await this.openCanvasInMainWorkspace(this.linkedCanvasFile);
    await new Promise((resolve) => {
      this.safeSetTimeout(() => resolve(void 0), 800);
    });
    const newActiveLeaf = this.app.workspace.activeLeaf;
    if (newActiveLeaf && newActiveLeaf.view.getViewType() === "canvas") {
      console.log("Successfully switched to canvas view");
    } else {
      console.warn("Failed to switch to canvas view");
      throw new Error("\u65E0\u6CD5\u5207\u6362\u5230Canvas\u89C6\u56FE");
    }
  }
  // æ¢æµ‹Canvasè§†å›¾çš„å¯ç”¨API
  detectCanvasAPI(canvasView) {
    try {
      console.log("Canvas view object:", canvasView);
      if (!canvasView || typeof canvasView !== "object") {
        console.warn("Invalid canvas view object");
        return null;
      }
      console.log("Canvas view properties:", Object.keys(canvasView));
      if (!hasProperty(canvasView, "canvas")) {
        console.warn("Canvas view does not have canvas property");
        return null;
      }
      const canvas = canvasView.canvas;
      console.log("Canvas object:", canvas);
      if (!canvas) {
        console.warn("Canvas object not found in view");
        return null;
      }
      console.log("Canvas properties:", Object.keys(canvas));
      console.log("Canvas methods:", Object.getOwnPropertyNames(Object.getPrototypeOf(canvas)));
      this.exploreCanvasAPI(canvas);
      const apiMethods = this.findCanvasAPIMethods(canvas);
      if (!apiMethods) {
        console.log("No suitable Canvas API methods found");
        return null;
      }
      console.log("Found Canvas API methods:", apiMethods);
      return apiMethods;
    } catch (error) {
      console.error("Failed to detect Canvas API:", error);
      return null;
    }
  }
  // æŸ¥æ‰¾Canvas APIçš„å®é™…æ–¹æ³•
  findCanvasAPIMethods(canvas) {
    const allMethods = this.getAllMethods(canvas);
    console.log("All canvas methods:", allMethods);
    const zoomMethods = allMethods.filter(
      (method) => method.toLowerCase().includes("zoom") || method.toLowerCase().includes("scale") || method.toLowerCase().includes("fit")
    );
    console.log("Zoom methods:", zoomMethods);
    const selectMethods = allMethods.filter(
      (method) => method.toLowerCase().includes("select") || method.toLowerCase().includes("focus") || method.toLowerCase().includes("highlight")
    );
    console.log("Select methods:", selectMethods);
    const nodeMethods = allMethods.filter(
      (method) => method.toLowerCase().includes("node") || method.toLowerCase().includes("element") || method.toLowerCase().includes("item")
    );
    console.log("Node methods:", nodeMethods);
    const panMethods = allMethods.filter(
      (method) => method.toLowerCase().includes("pan") || method.toLowerCase().includes("move") || method.toLowerCase().includes("translate")
    );
    console.log("Pan methods:", panMethods);
    const api = {};
    const zoomToBboxMethod = this.findMethod(canvas, [
      "zoomToBbox",
      "zoomToRect",
      "zoomToArea",
      "fitToRect",
      "focusRect"
    ]);
    if (zoomToBboxMethod) {
      api.zoomToBbox = zoomToBboxMethod;
    }
    const selectMethod = this.findMethod(canvas, [
      "selectNode",
      "selectElement",
      "select",
      "setSelection",
      "addSelection"
    ]);
    if (selectMethod) {
      api.selectNode = selectMethod;
    }
    const deselectMethod = this.findMethod(canvas, [
      "deselectAll",
      "clearSelection",
      "deselect",
      "unselectAll"
    ]);
    if (deselectMethod) {
      api.deselectAll = deselectMethod;
    }
    const getNodeMethod = this.findMethod(canvas, [
      "getNode",
      "getElement",
      "getElementById",
      "findNode"
    ]);
    if (getNodeMethod) {
      api.getNode = getNodeMethod;
    }
    const panMethod = this.findMethod(canvas, [
      "panTo",
      "moveTo",
      "translateTo",
      "setViewport"
    ]);
    if (panMethod) {
      api.panTo = panMethod;
    }
    if (api.zoomToBbox || api.selectNode && api.panMethod) {
      return api;
    }
    return null;
  }
  // æŸ¥æ‰¾æŒ‡å®šåç§°çš„æ–¹æ³•
  findMethod(obj, methodNames) {
    if (!obj || typeof obj !== "object") {
      return null;
    }
    for (const name of methodNames) {
      if (hasProperty(obj, name) && typeof obj[name] === "function") {
        console.log(`Found method: ${name}`);
        return obj[name].bind(obj);
      }
    }
    return null;
  }
  // è·å–å¯¹è±¡çš„æ‰€æœ‰æ–¹æ³•
  getAllMethods(obj) {
    const methods = /* @__PURE__ */ new Set();
    let current = obj;
    while (current && current !== Object.prototype) {
      Object.getOwnPropertyNames(current).forEach((name) => {
        if (typeof obj[name] === "function") {
          methods.add(name);
        }
      });
      current = Object.getPrototypeOf(current);
    }
    return Array.from(methods);
  }
  // æ‰§è¡ŒCanvasèšç„¦æ“ä½œ
  async executeCanvasFocus(canvasAPI, nodeId, nodeData) {
    try {
      if (canvasAPI.deselectAll) {
        console.log("Clearing selection...");
        canvasAPI.deselectAll();
      }
      if (canvasAPI.selectNode) {
        console.log("Selecting node:", nodeId);
        try {
          canvasAPI.selectNode(nodeId);
        } catch (error) {
          console.warn("selectNode failed:", error);
        }
      }
      if (canvasAPI.zoomToBbox) {
        console.log("Zooming to bbox...");
        const bbox = this.calculateOptimalBbox(nodeData);
        console.log("Calculated bbox:", bbox);
        try {
          canvasAPI.zoomToBbox(bbox);
          return true;
        } catch (error) {
          console.warn("zoomToBbox failed:", error);
        }
      }
      if (canvasAPI.panTo) {
        console.log("Using panTo as fallback...");
        const centerX = nodeData.x + nodeData.width / 2;
        const centerY = nodeData.y + nodeData.height / 2;
        try {
          canvasAPI.panTo(centerX, centerY);
          return true;
        } catch (error) {
          console.warn("panTo failed:", error);
        }
      }
      return false;
    } catch (error) {
      console.error("executeCanvasFocus failed:", error);
      return false;
    }
  }
  // æ¢ç´¢Canvas APIçš„å¯ç”¨æ–¹æ³•
  exploreCanvasAPI(canvas) {
    console.log("=== Canvas API Exploration ===");
    const allProps = [];
    let obj = canvas;
    while (obj && obj !== Object.prototype) {
      allProps.push(...Object.getOwnPropertyNames(obj));
      obj = Object.getPrototypeOf(obj);
    }
    const uniqueProps = [...new Set(allProps)];
    const methods = uniqueProps.filter((prop) => {
      try {
        return typeof canvas[prop] === "function";
      } catch {
        return false;
      }
    });
    console.log("All available methods:", methods);
    const focusMethods = methods.filter(
      (method) => method.toLowerCase().includes("zoom") || method.toLowerCase().includes("focus") || method.toLowerCase().includes("select") || method.toLowerCase().includes("center") || method.toLowerCase().includes("pan")
    );
    console.log("Potential focus-related methods:", focusMethods);
  }
  // è·å–å½“å‰æ´»åŠ¨çš„Canvasè§†å›¾
  getActiveCanvasView() {
    console.log("=== Getting Canvas View ===");
    const activeLeaf = this.app.workspace.activeLeaf;
    console.log("Active leaf:", activeLeaf);
    console.log("Active leaf view type:", activeLeaf?.view?.getViewType());
    if (activeLeaf && activeLeaf.view.getViewType() === "canvas") {
      console.log("Found active canvas view");
      return activeLeaf.view;
    }
    const canvasLeaves = this.app.workspace.getLeavesOfType("canvas");
    console.log("Canvas leaves found:", canvasLeaves.length);
    const activeFile = this.app.workspace.getActiveFile();
    console.log("Active file:", activeFile?.path);
    for (const leaf of canvasLeaves) {
      const view = leaf.view;
      console.log("Checking canvas leaf:", view?.file?.path);
      if (view && view.file && activeFile && view.file.path === activeFile.path) {
        console.log("Found matching canvas view");
        return view;
      }
    }
    console.log("No canvas view found");
    return null;
  }
  // ç­‰å¾…Canvasè§†å›¾åŠ è½½å®Œæˆ
  async waitForCanvasLoad() {
    return new Promise((resolve) => {
      this.safeSetTimeout(() => resolve(void 0), 300);
    });
  }
  // è®¡ç®—æœ€ä½³èšç„¦è¾¹ç•Œæ¡†
  calculateOptimalBbox(node) {
    const padding = 100;
    return {
      minX: node.x - padding,
      minY: node.y - padding,
      maxX: node.x + node.width + padding,
      maxY: node.y + node.height + padding
    };
  }
  // æ¨¡æ‹Ÿæ“ä½œèšç„¦èŠ‚ç‚¹ï¼ˆå›é€€æ–¹æ¡ˆï¼‰
  async focusNodeBySimulation(nodeId) {
    try {
      console.log("=== Starting simulation focus ===");
      const nodeData = this.canvasData?.nodes.find((n) => n.id === nodeId);
      if (!nodeData) {
        new import_obsidian.Notice("\u627E\u4E0D\u5230\u76EE\u6807\u8282\u70B9");
        return false;
      }
      console.log("Node data for simulation:", nodeData);
      const canvasView = this.getActiveCanvasView();
      if (!canvasView || !canvasView.containerEl) {
        console.log("Canvas view or container not found");
        return false;
      }
      const canvasSelectors = [
        ".canvas-wrapper",
        ".canvas-container",
        ".canvas-viewport",
        ".canvas",
        '[data-type="canvas"]',
        '.workspace-leaf-content[data-type="canvas"]'
      ];
      let canvasElement = null;
      for (const selector of canvasSelectors) {
        canvasElement = canvasView.containerEl.querySelector(selector);
        if (canvasElement) {
          console.log(`Found canvas element with selector: ${selector}`);
          break;
        }
      }
      if (!canvasElement) {
        console.log("Canvas element not found, trying direct approach");
        canvasElement = canvasView.containerEl;
      }
      if (canvasView.canvas) {
        console.log("Trying direct canvas manipulation...");
        const success = await this.tryDirectCanvasManipulation(canvasView.canvas, nodeId, nodeData);
        if (success) {
          new import_obsidian.Notice("\u5DF2\u805A\u7126\u5230\u76EE\u6807\u8282\u70B9\uFF08\u76F4\u63A5\u64CD\u4F5C\uFF09", 3e3);
          return true;
        }
      }
      const nodeElement = this.findNodeElement(canvasView.containerEl, nodeId);
      if (nodeElement) {
        console.log("Found node element, simulating click...");
        nodeElement.scrollIntoView({ behavior: "smooth", block: "center" });
        nodeElement.click();
        new import_obsidian.Notice("\u5DF2\u805A\u7126\u5230\u76EE\u6807\u8282\u70B9\uFF08\u5143\u7D20\u70B9\u51FB\uFF09", 3e3);
        return true;
      }
      new import_obsidian.Notice("\u805A\u7126\u529F\u80FD\u6682\u4E0D\u53EF\u7528\uFF0C\u8BF7\u624B\u52A8\u5B9A\u4F4D", 3e3);
      return false;
    } catch (error) {
      console.error("\u6A21\u62DF\u805A\u7126\u5931\u8D25:", error);
      new import_obsidian.Notice("\u805A\u7126\u5931\u8D25\uFF0C\u8BF7\u624B\u52A8\u5B9A\u4F4D");
      return false;
    }
  }
  // å°è¯•ç›´æ¥æ“ä½œCanvaså¯¹è±¡
  async tryDirectCanvasManipulation(canvas, nodeId, nodeData) {
    try {
      console.log("Trying direct canvas manipulation...");
      console.log("Canvas object:", canvas);
      if (canvas.nodes && canvas.nodes.has && canvas.nodes.has(nodeId)) {
        console.log("Found node in canvas.nodes");
        const node = canvas.nodes.get(nodeId);
        console.log("Canvas node object:", node);
        if (canvas.selection) {
          console.log("Setting canvas selection...");
          canvas.selection.clear();
          canvas.selection.add(node);
        }
      }
      if (canvas.viewport || canvas.view) {
        const viewport = canvas.viewport || canvas.view;
        console.log("Found viewport:", viewport);
        const centerX = nodeData.x + nodeData.width / 2;
        const centerY = nodeData.y + nodeData.height / 2;
        if (viewport.setCenter) {
          viewport.setCenter(centerX, centerY);
          return true;
        } else if (viewport.panTo) {
          viewport.panTo(centerX, centerY);
          return true;
        } else if (viewport.x !== void 0 && viewport.y !== void 0) {
          viewport.x = -centerX + viewport.width / 2;
          viewport.y = -centerY + viewport.height / 2;
          return true;
        }
      }
      return false;
    } catch (error) {
      console.error("Direct canvas manipulation failed:", error);
      return false;
    }
  }
  // æŸ¥æ‰¾èŠ‚ç‚¹å¯¹åº”çš„DOMå…ƒç´ 
  findNodeElement(container, nodeId) {
    const selectors = [
      `[data-node-id="${nodeId}"]`,
      `[data-id="${nodeId}"]`,
      `#${nodeId}`,
      `.canvas-node[data-id="${nodeId}"]`,
      `.canvas-card[data-id="${nodeId}"]`
    ];
    for (const selector of selectors) {
      const element = container.querySelector(selector);
      if (element) {
        console.log(`Found node element with selector: ${selector}`);
        return element;
      }
    }
    console.log("Node element not found");
    return null;
  }
  // ==================== æ‹–æ‹½åŠŸèƒ½å®ç° ====================
  // è®¾ç½®æ‹–æ‹½å¤„ç†å™¨
  setupDragDropHandlers() {
    console.log("Setting up drag and drop handlers...");
    this.setupEditorDragSource();
    this.setupGridDropTarget();
    this.setupCanvasDropTarget();
  }
  // ==================== ç½‘æ ¼å¡ç‰‡æ‹–æ‹½åˆ°CanvasåŠŸèƒ½ (HTML5 Drag & Drop API) ====================
  /*
   * æ—§çš„é¼ æ ‡äº‹ä»¶å¤„ç†ä»£ç å·²è¢«HTML5 Drag & Drop APIæ›¿ä»£
   * ä¿ç•™æ³¨é‡Šä»¥é˜²éœ€è¦å›é€€
   */
  // å¤„ç†å¡ç‰‡æ‹–æ‹½å¼€å§‹äº‹ä»¶
  handleCardDragStart(e) {
    const cardElement = e.target.closest(".canvas-grid-card");
    if (!cardElement || !cardElement.dataset.nodeId) {
      e.preventDefault();
      return;
    }
    if (e.target.closest(".canvas-card-toolbar")) {
      e.preventDefault();
      return;
    }
    const nodeId = cardElement.dataset.nodeId;
    const node = this.canvasData?.nodes.find((n) => n.id === nodeId);
    if (!node) {
      e.preventDefault();
      return;
    }
    console.log("\u{1F680} Starting card drag with HTML5 API:", node);
    if (e.dataTransfer) {
      e.dataTransfer.setData("text/plain", node.text || "");
      e.dataTransfer.setData("application/json", JSON.stringify({
        type: "canvas-node",
        nodeData: node,
        source: "canvas-grid-view",
        isCtrlDrag: e.ctrlKey
        // è®°å½•æ˜¯å¦æŒ‰ä½Ctrlé”®
      }));
      e.dataTransfer.effectAllowed = e.ctrlKey ? "copy" : "move";
      this.setCardDragPreview(e, cardElement);
    }
    cardElement.classList.add("dragging-from-grid");
    cardElement.style.cursor = "grabbing";
    this.isDragFromGrid = true;
    this.currentDragCard = cardElement;
    console.log("\u2705 Card drag started successfully");
  }
  // å¤„ç†å¡ç‰‡æ‹–æ‹½ç»“æŸäº‹ä»¶
  handleCardDragEnd(e) {
    console.log("\u{1F3C1} Card drag ended");
    if (this.currentDragCard) {
      this.currentDragCard.classList.remove("dragging-from-grid");
      this.currentDragCard.style.cursor = "grab";
    }
    this.isDragFromGrid = false;
    this.currentDragCard = null;
    console.log("\u2705 Card drag cleanup completed");
  }
  // è®¾ç½®å¡ç‰‡æ‹–æ‹½é¢„è§ˆ
  setCardDragPreview(e, cardElement) {
    try {
      const preview = cardElement.cloneNode(true);
      preview.style.cssText = `
				position: absolute;
				top: -1000px;
				left: -1000px;
				width: ${cardElement.offsetWidth}px;
				height: ${cardElement.offsetHeight}px;
				opacity: 0.8;
				transform: rotate(3deg);
				box-shadow: 0 5px 15px rgba(0,0,0,0.3);
				pointer-events: none;
				z-index: 10000;
			`;
      document.body.appendChild(preview);
      if (e.dataTransfer) {
        e.dataTransfer.setDragImage(preview, cardElement.offsetWidth / 2, cardElement.offsetHeight / 2);
      }
      setTimeout(() => {
        if (document.body.contains(preview)) {
          document.body.removeChild(preview);
        }
      }, 0);
    } catch (error) {
      console.error("Failed to set card drag preview:", error);
    }
  }
  // è®¾ç½®Canvasæ‹–æ‹½ç›®æ ‡
  setupCanvasDropTarget() {
    console.log("Setting up Canvas drop target for grid cards...");
    this.registerDomEvent(document, "dragover", (e) => {
      if (this.isDragFromGrid && e.dataTransfer?.types.includes("application/json")) {
        const canvasElement = this.findCanvasElementUnderCursor(e);
        if (canvasElement) {
          e.preventDefault();
          e.dataTransfer.dropEffect = e.ctrlKey ? "copy" : "move";
        }
      }
    });
    this.registerDomEvent(document, "drop", (e) => {
      if (this.isDragFromGrid && e.dataTransfer?.types.includes("application/json")) {
        const canvasView = this.findCanvasViewUnderCursor(e);
        if (canvasView) {
          e.preventDefault();
          this.handleCanvasDropFromGrid(e, canvasView);
        }
      }
    });
  }
  // æŸ¥æ‰¾é¼ æ ‡ä¸‹çš„Canvaså…ƒç´ 
  findCanvasElementUnderCursor(e) {
    const element = document.elementFromPoint(e.clientX, e.clientY);
    if (!element)
      return null;
    const canvasContainer = element.closest('.workspace-leaf-content[data-type="canvas"]');
    return canvasContainer;
  }
  // å¤„ç†Canvasæ¥æ”¶ç½‘æ ¼å¡ç‰‡çš„æ‹–æ‹½
  async handleCanvasDropFromGrid(e, canvasView) {
    try {
      console.log("\u{1F3AF} Handling Canvas drop from grid...");
      const dragDataStr = e.dataTransfer?.getData("application/json");
      if (!dragDataStr) {
        console.error("No drag data found");
        return;
      }
      const dragData = JSON.parse(dragDataStr);
      if (dragData.type !== "canvas-node" || dragData.source !== "canvas-grid-view") {
        console.log("Not a grid card drag, ignoring");
        return;
      }
      const node = dragData.nodeData;
      const isCtrlDrag = dragData.isCtrlDrag || e.ctrlKey;
      console.log("Processing grid card drop:", node, "Ctrl pressed:", isCtrlDrag);
      const canvasCoords = this.getCanvasCoordinatesFromDrop(e, canvasView);
      console.log("Canvas coordinates:", canvasCoords);
      const newNode = this.createCanvasNodeFromGridCard(node, canvasCoords);
      await this.addNodeToCanvas(newNode, canvasView);
      if (isCtrlDrag) {
        new import_obsidian.Notice("\u5361\u7247\u5DF2\u590D\u5236\u5230Canvas");
        console.log("\u2705 Card copied to Canvas (Ctrl+drag)");
      } else {
        await this.removeNodeFromGrid(node.id);
        new import_obsidian.Notice("\u5361\u7247\u5DF2\u79FB\u52A8\u5230Canvas");
        console.log("\u2705 Card moved to Canvas (normal drag)");
      }
      console.log("\u2705 Canvas drop completed successfully");
    } catch (error) {
      console.error("Failed to handle Canvas drop:", error);
      new import_obsidian.Notice("\u62D6\u62FD\u5230Canvas\u5931\u8D25");
    }
  }
  // ä»æ‹–æ‹½äº‹ä»¶è·å–Canvasåæ ‡ - ä½¿ç”¨Obsidianå†…ç½®æ–¹æ³•
  getCanvasCoordinatesFromDrop(e, canvasView) {
    console.log("\u{1F3AF} Getting Canvas coordinates from drop event...");
    try {
      if (canvasView.canvas && typeof canvasView.canvas.posFromEvt === "function") {
        const pos = canvasView.canvas.posFromEvt(e);
        console.log("\u2705 Using Canvas.posFromEvt:", pos);
        return { x: pos.x, y: pos.y };
      }
      console.log("\u26A0\uFE0F Canvas.posFromEvt not available, using manual calculation");
      return this.getCanvasCoordinatesManual(e, canvasView);
    } catch (error) {
      console.error("Error getting Canvas coordinates:", error);
      return { x: e.clientX, y: e.clientY };
    }
  }
  // æ‰‹åŠ¨è®¡ç®—Canvasåæ ‡ï¼ˆå¤‡ç”¨æ–¹æ³•ï¼‰
  getCanvasCoordinatesManual(e, canvasView) {
    const canvasContainer = canvasView.containerEl.querySelector(".canvas-wrapper") || canvasView.containerEl.querySelector(".canvas-container") || canvasView.containerEl;
    if (!canvasContainer) {
      console.warn("Canvas container not found, using event coordinates");
      return { x: e.clientX, y: e.clientY };
    }
    const rect = canvasContainer.getBoundingClientRect();
    const relativeX = e.clientX - rect.left;
    const relativeY = e.clientY - rect.top;
    const canvas = canvasView.canvas;
    if (canvas && canvas.tx !== void 0 && canvas.ty !== void 0 && canvas.tZoom !== void 0) {
      return {
        x: (relativeX - canvas.tx) / canvas.tZoom,
        y: (relativeY - canvas.ty) / canvas.tZoom
      };
    }
    return { x: relativeX, y: relativeY };
  }
  // å¤„ç†å¡ç‰‡é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶ (å·²åºŸå¼ƒ - ä½¿ç”¨HTML5 Drag & Drop API)
  handleCardMouseDown_DEPRECATED(e) {
    const cardElement = e.target.closest(".canvas-grid-card");
    if (!cardElement || !cardElement.dataset.nodeId)
      return;
    if (e.target.closest(".canvas-card-toolbar"))
      return;
    this.longPressStartTime = Date.now();
    this.dragStartPosition = { x: e.clientX, y: e.clientY };
    this.currentDragCard = cardElement;
    this.addGlobalMouseListeners();
    this.longPressTimer = setTimeout(() => {
      this.startCardDrag(cardElement, e);
    }, this.longPressThreshold);
    e.preventDefault();
  }
  // å¤„ç†å¡ç‰‡é¼ æ ‡ç§»åŠ¨äº‹ä»¶ (å·²åºŸå¼ƒ - ä½¿ç”¨HTML5 Drag & Drop API)
  handleCardMouseMove_DEPRECATED(e) {
    if (!this.isDragFromGrid && this.longPressTimer) {
      const deltaX = Math.abs(e.clientX - this.dragStartPosition.x);
      const deltaY = Math.abs(e.clientY - this.dragStartPosition.y);
      const moveDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      if (moveDistance > 10) {
        this.clearLongPressTimer();
      }
    }
    if (this.isDragFromGrid && this.dragPreviewElement) {
      this.dragPreviewElement.style.top = `${e.clientY - 20}px`;
      this.dragPreviewElement.style.left = `${e.clientX - 20}px`;
    }
  }
  // å¤„ç†å¡ç‰‡é¼ æ ‡æŠ¬èµ·äº‹ä»¶ (å·²åºŸå¼ƒ - ä½¿ç”¨HTML5 Drag & Drop API)
  handleCardMouseUp_DEPRECATED(e) {
    this.clearLongPressTimer();
    if (this.isDragFromGrid) {
      this.endCardDrag(e);
    } else {
      this.resetCardDragState();
    }
  }
  // å¤„ç†é¼ æ ‡ç¦»å¼€ç½‘æ ¼å®¹å™¨äº‹ä»¶
  handleCardMouseLeave(e) {
    this.clearLongPressTimer();
    if (!this.isDragFromGrid) {
      this.resetCardDragState();
    }
  }
  // æ¸…ç†é•¿æŒ‰å®šæ—¶å™¨
  clearLongPressTimer() {
    if (this.longPressTimer) {
      clearTimeout(this.longPressTimer);
      this.longPressTimer = null;
    }
  }
  // é‡ç½®å¡ç‰‡æ‹–æ‹½çŠ¶æ€
  resetCardDragState() {
    console.log("Resetting card drag state...");
    this.forceCleanupDragPreview();
    this.hideDragHint();
    if (this.currentDragCard) {
      this.currentDragCard.classList.remove("dragging-from-grid");
    }
    this.currentDragCard = null;
    this.isDragFromGrid = false;
    this.longPressStartTime = 0;
    this.dragStartPosition = { x: 0, y: 0 };
    this.removeGlobalMouseListeners();
    console.log("Card drag state reset complete");
  }
  // æ·»åŠ å…¨å±€é¼ æ ‡äº‹ä»¶ç›‘å¬å™¨
  addGlobalMouseListeners() {
    this.removeGlobalMouseListeners();
    console.log("Adding global mouse listeners...");
    this.globalMouseMoveHandler = (e) => {
      this.handleCardMouseMove_DEPRECATED(e);
    };
    this.globalMouseUpHandler = (e) => {
      this.handleCardMouseUp_DEPRECATED(e);
    };
    document.addEventListener("mousemove", this.globalMouseMoveHandler, { passive: true });
    document.addEventListener("mouseup", this.globalMouseUpHandler);
    document.addEventListener("keydown", this.handleDragEscape);
    setTimeout(() => {
      if (this.isDragFromGrid) {
        window.addEventListener("blur", this.handleWindowBlur);
      }
    }, 200);
    console.log("Global mouse listeners added");
  }
  // å–æ¶ˆæ‹–æ‹½æ“ä½œ
  cancelDrag() {
    console.log("Canceling drag operation...");
    this.resetCardDragState();
  }
  // ç§»é™¤å…¨å±€é¼ æ ‡äº‹ä»¶ç›‘å¬å™¨
  removeGlobalMouseListeners() {
    console.log("Removing global mouse listeners...");
    if (this.globalMouseMoveHandler) {
      document.removeEventListener("mousemove", this.globalMouseMoveHandler);
      this.globalMouseMoveHandler = null;
    }
    if (this.globalMouseUpHandler) {
      document.removeEventListener("mouseup", this.globalMouseUpHandler);
      this.globalMouseUpHandler = null;
    }
    window.removeEventListener("blur", this.handleWindowBlur);
    document.removeEventListener("keydown", this.handleDragEscape);
    console.log("Global mouse listeners removed");
  }
  // å¼€å§‹å¡ç‰‡æ‹–æ‹½
  startCardDrag(cardElement, e) {
    const nodeId = cardElement.dataset.nodeId;
    if (!nodeId || !this.canvasData)
      return;
    const node = this.canvasData.nodes.find((n) => n.id === nodeId);
    if (!node)
      return;
    console.log("Starting card drag from grid:", node);
    this.isDragFromGrid = true;
    this.createDragPreview(cardElement, e);
    cardElement.classList.add("dragging-from-grid");
    this.showDragHint(e.ctrlKey);
  }
  // ç»“æŸå¡ç‰‡æ‹–æ‹½
  endCardDrag(e) {
    console.log("\u{1F3C1} Ending card drag at:", e.clientX, e.clientY);
    if (!this.currentDragCard || !this.isDragFromGrid) {
      console.log("\u274C Invalid drag state - currentDragCard:", !!this.currentDragCard, "isDragFromGrid:", this.isDragFromGrid);
      return;
    }
    const nodeId = this.currentDragCard.dataset.nodeId;
    if (!nodeId || !this.canvasData) {
      console.log("\u274C Missing nodeId or canvasData - nodeId:", nodeId, "canvasData:", !!this.canvasData);
      return;
    }
    const node = this.canvasData.nodes.find((n) => n.id === nodeId);
    if (!node) {
      console.log("\u274C Node not found for nodeId:", nodeId);
      return;
    }
    console.log("\u2705 Found node for drag:", node);
    const canvasView = this.findCanvasViewUnderCursor(e);
    if (canvasView) {
      console.log("\u{1F3AF} Canvas view found, handling drop...");
      this.handleDropToCanvas(node, e, canvasView);
    } else {
      console.log("\u274C No Canvas view found under cursor");
      new import_obsidian.Notice("\u8BF7\u62D6\u62FD\u5230Canvas\u533A\u57DF");
    }
    console.log("\u{1F9F9} Cleaning up drag state...");
    this.resetCardDragState();
  }
  // åˆ›å»ºæ‹–æ‹½é¢„è§ˆ
  createDragPreview(cardElement, e) {
    this.forceCleanupDragPreview();
    console.log("Creating drag preview...");
    this.dragPreviewElement = cardElement.cloneNode(true);
    this.dragPreviewElement.classList.add("drag-preview");
    this.dragPreviewElement.style.cssText = `
			position: fixed !important;
			top: ${e.clientY - 20}px !important;
			left: ${e.clientX - 20}px !important;
			width: ${cardElement.offsetWidth}px !important;
			height: ${cardElement.offsetHeight}px !important;
			opacity: 0.8 !important;
			pointer-events: none !important;
			z-index: 10000 !important;
			transform: rotate(5deg) !important;
			box-shadow: 0 5px 15px rgba(0,0,0,0.3) !important;
		`;
    document.body.appendChild(this.dragPreviewElement);
    console.log("Drag preview created and attached");
  }
  // å¼ºåˆ¶æ¸…ç†æ‹–æ‹½é¢„è§ˆ
  forceCleanupDragPreview() {
    console.log("Force cleaning up drag preview...");
    if (this.dragPreviewElement) {
      try {
        if (this.dragPreviewElement.parentNode) {
          this.dragPreviewElement.parentNode.removeChild(this.dragPreviewElement);
        }
      } catch (error) {
        console.warn("Error removing drag preview element:", error);
      }
      this.dragPreviewElement = null;
    }
    this.cleanupDragPreview = () => {
    };
    console.log("Drag preview cleanup complete");
  }
  // æ˜¾ç¤ºæ‹–æ‹½æç¤º
  showDragHint(isCtrlPressed) {
    const hint = document.createElement("div");
    hint.className = "drag-hint";
    hint.textContent = isCtrlPressed ? "\u79FB\u52A8\u5230Canvas\uFF08\u5220\u9664\u539F\u5361\u7247\uFF09" : "\u590D\u5236\u5230Canvas\uFF08\u4FDD\u6301\u539F\u5361\u7247\uFF09";
    hint.style.cssText = `
			position: fixed;
			top: 20px;
			left: 50%;
			transform: translateX(-50%);
			background: var(--background-primary);
			border: 1px solid var(--background-modifier-border);
			border-radius: 6px;
			padding: 8px 16px;
			font-size: 12px;
			color: var(--text-normal);
			z-index: 10001;
			box-shadow: 0 2px 8px rgba(0,0,0,0.15);
		`;
    document.body.appendChild(hint);
    this.dragHintElement = hint;
  }
  // éšè—æ‹–æ‹½æç¤º
  hideDragHint() {
    if (this.dragHintElement) {
      this.dragHintElement.remove();
      this.dragHintElement = null;
    }
  }
  // æŸ¥æ‰¾é¼ æ ‡ä½ç½®ä¸‹çš„Canvasè§†å›¾
  findCanvasViewUnderCursor(e) {
    console.log("\u{1F50D} Finding Canvas view under cursor at:", e.clientX, e.clientY);
    const originalDisplay = this.dragPreviewElement?.style.display;
    if (this.dragPreviewElement) {
      this.dragPreviewElement.style.display = "none";
    }
    const elementUnderCursor = document.elementFromPoint(e.clientX, e.clientY);
    console.log("\u{1F3AF} Element under cursor:", elementUnderCursor);
    if (this.dragPreviewElement && originalDisplay !== void 0) {
      this.dragPreviewElement.style.display = originalDisplay;
    }
    if (!elementUnderCursor) {
      console.log("\u274C No element found under cursor");
      return null;
    }
    const canvasSelectors = [
      '.workspace-leaf-content[data-type="canvas"]',
      '[data-type="canvas"]',
      ".canvas-wrapper",
      ".canvas-container",
      '.view-content[data-type="canvas"]'
    ];
    let canvasContainer = null;
    for (const selector of canvasSelectors) {
      canvasContainer = elementUnderCursor.closest(selector);
      if (canvasContainer) {
        console.log("\u2705 Found Canvas container with selector:", selector, canvasContainer);
        break;
      }
    }
    if (!canvasContainer) {
      console.log("\u274C No Canvas container found. Element classes:", elementUnderCursor.className);
      console.log("\u274C Element parents:", this.getElementPath(elementUnderCursor));
      return null;
    }
    const canvasLeaves = this.app.workspace.getLeavesOfType("canvas");
    console.log("\u{1F4CB} Available Canvas leaves:", canvasLeaves.length);
    const leaf = canvasLeaves.find((leaf2) => {
      const containerEl = leaf2.view?.containerEl;
      if (containerEl && containerEl.contains(canvasContainer)) {
        console.log("\u2705 Found matching Canvas leaf:", leaf2);
        return true;
      }
      return false;
    });
    if (!leaf) {
      console.log("\u274C No matching Canvas leaf found");
      return null;
    }
    console.log("\u{1F389} Successfully found Canvas view:", leaf.view);
    return leaf.view;
  }
  // è·å–å…ƒç´ è·¯å¾„ç”¨äºè°ƒè¯•
  getElementPath(element) {
    const path = [];
    let current = element;
    for (let i = 0; i < 5 && current; i++) {
      const tag = current.tagName.toLowerCase();
      const className = current.className ? `.${current.className.split(" ").join(".")}` : "";
      const id = current.id ? `#${current.id}` : "";
      path.push(`${tag}${id}${className}`);
      current = current.parentElement;
    }
    return path.join(" > ");
  }
  // å¤„ç†æ‹–æ‹½åˆ°Canvasçš„æ“ä½œ
  async handleDropToCanvas(node, e, canvasView) {
    try {
      console.log("Dropping card to Canvas:", node);
      const rawCoords = this.getCanvasCoordinates(e, canvasView);
      const canvasCoords = this.calibrateCanvasCoordinates(rawCoords, canvasView);
      this.showCoordinateDebugInfo(e, canvasView, canvasCoords);
      const newNode = this.createCanvasNodeFromGridCard(node, canvasCoords);
      await this.addNodeToCanvas(newNode, canvasView);
      if (e.ctrlKey) {
        await this.removeNodeFromGrid(node.id);
        new import_obsidian.Notice("\u5361\u7247\u5DF2\u79FB\u52A8\u5230Canvas");
      } else {
        new import_obsidian.Notice("\u5361\u7247\u5DF2\u590D\u5236\u5230Canvas");
      }
    } catch (error) {
      console.error("Failed to drop card to Canvas:", error);
      new import_obsidian.Notice("\u62D6\u62FD\u5230Canvas\u5931\u8D25");
    }
  }
  // è·å–Canvasåæ ‡ - æ”¹è¿›ç‰ˆæœ¬ï¼Œæ”¯æŒå¤šç§åæ ‡è½¬æ¢æ–¹æ³•
  getCanvasCoordinates(e, canvasView) {
    console.log("\u{1F3AF} Converting mouse coordinates to Canvas coordinates...");
    console.log("Mouse position:", { x: e.clientX, y: e.clientY });
    const containerSelectors = [
      ".canvas-wrapper",
      ".canvas-container",
      ".canvas-viewport",
      ".view-content"
    ];
    let canvasContainer = null;
    for (const selector of containerSelectors) {
      canvasContainer = canvasView.containerEl.querySelector(selector);
      if (canvasContainer) {
        console.log("\u2705 Found Canvas container with selector:", selector);
        break;
      }
    }
    if (!canvasContainer) {
      console.log("\u274C No Canvas container found, using containerEl directly");
      canvasContainer = canvasView.containerEl;
    }
    const rect = canvasContainer.getBoundingClientRect();
    console.log("Canvas container rect:", {
      left: rect.left,
      top: rect.top,
      width: rect.width,
      height: rect.height
    });
    const relativeX = e.clientX - rect.left;
    const relativeY = e.clientY - rect.top;
    console.log("Relative coordinates:", { x: relativeX, y: relativeY });
    const canvas = canvasView.canvas;
    console.log("Canvas transform info:", {
      tx: canvas?.tx,
      ty: canvas?.ty,
      tZoom: canvas?.tZoom
    });
    if (canvas && canvas.tx !== void 0 && canvas.ty !== void 0 && canvas.tZoom !== void 0) {
      const canvasX = (relativeX - canvas.tx) / canvas.tZoom;
      const canvasY = (relativeY - canvas.ty) / canvas.tZoom;
      console.log("\u2705 Canvas coordinates calculated:", { x: canvasX, y: canvasY });
      const adjustedX = canvasX - 10;
      const adjustedY = canvasY - 10;
      console.log("\u{1F527} Adjusted coordinates:", { x: adjustedX, y: adjustedY });
      return { x: adjustedX, y: adjustedY };
    }
    console.log("\u26A0\uFE0F No transform info, trying alternative method...");
    const canvasElement = canvasContainer.querySelector("canvas");
    if (canvasElement) {
      const canvasRect = canvasElement.getBoundingClientRect();
      const canvasRelativeX = e.clientX - canvasRect.left;
      const canvasRelativeY = e.clientY - canvasRect.top;
      console.log("Canvas element coordinates:", { x: canvasRelativeX, y: canvasRelativeY });
      return { x: canvasRelativeX, y: canvasRelativeY };
    }
    console.log("\u{1F4CD} Using relative coordinates as final fallback:", { x: relativeX, y: relativeY });
    return { x: relativeX, y: relativeY };
  }
  // åæ ‡æ ¡å‡†æ–¹æ³• - æ ¹æ®CanvasçŠ¶æ€è¿›è¡Œç²¾ç¡®æ ¡å‡†
  calibrateCanvasCoordinates(coords, canvasView) {
    const canvas = canvasView.canvas;
    let offsetX = 0;
    let offsetY = 0;
    if (canvas?.tZoom) {
      if (canvas.tZoom < 0.5) {
        offsetX = -20;
        offsetY = -20;
      } else if (canvas.tZoom > 1.5) {
        offsetX = -5;
        offsetY = -5;
      } else {
        offsetX = -10;
        offsetY = -10;
      }
    }
    const toolbarElement = canvasView.containerEl.querySelector(".canvas-controls");
    const toolbarHeight = toolbarElement ? toolbarElement.offsetHeight : 0;
    const sidebarWidth = 0;
    const calibratedX = coords.x + offsetX - sidebarWidth;
    const calibratedY = coords.y + offsetY - toolbarHeight;
    console.log("\u{1F3AF} Coordinate calibration:", {
      original: coords,
      offset: { x: offsetX, y: offsetY },
      toolbar: toolbarHeight,
      calibrated: { x: calibratedX, y: calibratedY }
    });
    return { x: calibratedX, y: calibratedY };
  }
  // å®æ—¶åæ ‡æµ‹è¯• - åœ¨Canvasä¸Šæ˜¾ç¤ºåæ ‡ä¿¡æ¯ï¼ˆè°ƒè¯•ç”¨ï¼‰
  showCoordinateDebugInfo(e, canvasView, coords) {
    let debugElement = document.getElementById("canvas-coord-debug");
    if (!debugElement) {
      debugElement = document.createElement("div");
      debugElement.id = "canvas-coord-debug";
      debugElement.style.cssText = `
				position: fixed;
				top: 10px;
				right: 10px;
				background: rgba(0, 0, 0, 0.8);
				color: white;
				padding: 10px;
				border-radius: 5px;
				font-family: monospace;
				font-size: 12px;
				z-index: 10001;
				pointer-events: none;
			`;
      document.body.appendChild(debugElement);
    }
    const canvas = canvasView.canvas;
    debugElement.innerHTML = `
			<div><strong>\u5750\u6807\u8C03\u8BD5\u4FE1\u606F</strong></div>
			<div>\u9F20\u6807\u4F4D\u7F6E: ${e.clientX}, ${e.clientY}</div>
			<div>Canvas\u5750\u6807: ${coords.x.toFixed(1)}, ${coords.y.toFixed(1)}</div>
			<div>\u7F29\u653E: ${canvas?.tZoom?.toFixed(2) || "N/A"}</div>
			<div>\u5E73\u79FB: ${canvas?.tx?.toFixed(1) || "N/A"}, ${canvas?.ty?.toFixed(1) || "N/A"}</div>
		`;
    setTimeout(() => {
      if (debugElement && debugElement.parentNode) {
        debugElement.parentNode.removeChild(debugElement);
      }
    }, 3e3);
  }
  // ä»ç½‘æ ¼å¡ç‰‡åˆ›å»ºCanvasèŠ‚ç‚¹
  createCanvasNodeFromGridCard(gridNode, coords) {
    const timestamp = Date.now();
    return {
      ...gridNode,
      id: `node-${timestamp}-from-grid`,
      x: coords.x,
      y: coords.y,
      // ä¿æŒåŸæœ‰çš„å®½é«˜ï¼Œæˆ–ä½¿ç”¨é»˜è®¤å€¼
      width: gridNode.width || 250,
      height: gridNode.height || 100
    };
  }
  // æ·»åŠ èŠ‚ç‚¹åˆ°Canvas
  async addNodeToCanvas(node, canvasView) {
    if (!canvasView.canvas || !canvasView.file) {
      throw new Error("Canvas view not available");
    }
    const content = await this.app.vault.read(canvasView.file);
    const canvasData = JSON.parse(content);
    canvasData.nodes.push(node);
    await this.app.vault.modify(canvasView.file, JSON.stringify(canvasData, null, 2));
    if (canvasView.canvas.requestSave) {
      canvasView.canvas.requestSave();
    }
  }
  // ä»ç½‘æ ¼ä¸­ç§»é™¤èŠ‚ç‚¹
  async removeNodeFromGrid(nodeId) {
    if (!this.canvasData || !this.linkedCanvasFile)
      return;
    console.log(`\u{1F5D1}\uFE0F Removing node from grid: ${nodeId}`);
    this.canvasData.nodes = this.canvasData.nodes.filter((node) => node.id !== nodeId);
    await this.saveCanvasData();
    if (this.currentGroupView) {
      this.analyzeGroups();
      const groupInfo = this.groupAnalysis.get(this.currentGroupView);
      if (!groupInfo || groupInfo.members.length === 0) {
        console.log("\u{1F4E4} Group is empty, returning to main view");
        this.exitGroupView();
        new import_obsidian.Notice("\u5206\u7EC4\u5DF2\u7A7A\uFF0C\u5DF2\u8FD4\u56DE\u4E3B\u89C6\u56FE");
        return;
      } else {
        this.filteredNodes = groupInfo.members;
        console.log(`\u{1F4CA} Group view updated, ${groupInfo.members.length} members remaining`);
      }
    }
    this.renderGrid();
    console.log("\u2705 Node removed and view refreshed");
  }
  // è®¾ç½®ç¼–è¾‘å™¨æ‹–æ‹½æº
  setupEditorDragSource() {
    this.registerDomEvent(document, "dragstart", (e) => {
      const target = e.target;
      if (this.isInEditor(target)) {
        const selectedText = this.getSelectedText();
        if (selectedText && selectedText.trim()) {
          this.handleEditorDragStart(e, selectedText);
        }
      }
    });
    this.registerDomEvent(document, "dragend", (e) => {
      this.resetDragState();
    });
  }
  // æ£€æŸ¥æ˜¯å¦åœ¨ç¼–è¾‘å™¨ä¸­
  isInEditor(element) {
    if (!element || typeof element.closest !== "function") {
      return false;
    }
    try {
      return element.closest(".cm-editor") !== null || element.closest(".markdown-source-view") !== null || element.closest(".markdown-preview-view") !== null;
    } catch (error) {
      console.error("Error checking if element is in editor:", error);
      return false;
    }
  }
  // è·å–é€‰ä¸­æ–‡æœ¬ï¼ˆä½¿ç”¨Obsidian APIï¼‰
  getSelectedText() {
    try {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (!activeView)
        return null;
      const editor = activeView.editor;
      const selection = editor.getSelection();
      return selection.trim() || null;
    } catch (error) {
      console.error("Failed to get selected text:", error);
      return null;
    }
  }
  // è·å–æºæ–‡ä»¶ä¿¡æ¯ï¼ˆç”¨äºåˆ›å»ºå›é“¾ï¼‰
  getSourceFileInfo() {
    try {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (!activeView) {
        return { file: null, path: "", position: null, context: "" };
      }
      const file = activeView.file;
      const editor = activeView.editor;
      const selections = editor.listSelections();
      const cursor = editor.getCursor();
      const currentLine = editor.getLine(cursor.line);
      let position = {
        line: cursor.line,
        ch: cursor.ch,
        selection: selections.length > 0 ? selections[0] : null
      };
      if (selections.length > 0 && selections[0]) {
        position.line = selections[0].anchor.line;
        position.ch = selections[0].anchor.ch;
      }
      return {
        file,
        path: file ? file.path : "",
        position,
        context: currentLine
      };
    } catch (error) {
      console.error("Failed to get source file info:", error);
      return { file: null, path: "", position: null, context: "" };
    }
  }
  // å¤„ç†ç¼–è¾‘å™¨æ‹–æ‹½å¼€å§‹
  handleEditorDragStart(e, selectedText) {
    if (!e.dataTransfer)
      return;
    console.log("Drag started from editor:", selectedText);
    const sourceInfo = this.getSourceFileInfo();
    e.dataTransfer.setData("text/plain", selectedText);
    e.dataTransfer.setData("application/obsidian-text", selectedText);
    e.dataTransfer.effectAllowed = "copy";
    this.isDragging = true;
    this.dragData = {
      text: selectedText,
      source: "editor",
      timestamp: Date.now(),
      sourceFile: sourceInfo.file,
      sourcePath: sourceInfo.path,
      sourcePosition: sourceInfo.position,
      sourceContext: sourceInfo.context
    };
    console.log("Drag data with backlink info:", this.dragData);
    this.setDragPreview(e, selectedText);
  }
  // è®¾ç½®æ‹–æ‹½é¢„è§ˆ
  setDragPreview(e, text) {
    try {
      const preview = document.createElement("div");
      preview.style.cssText = `
				position: absolute;
				top: -1000px;
				left: -1000px;
				background: var(--background-primary);
				border: 1px solid var(--background-modifier-border);
				border-radius: 6px;
				padding: 8px 12px;
				font-size: 12px;
				color: var(--text-normal);
				max-width: 200px;
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
				box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
			`;
      preview.textContent = text.length > 50 ? text.substring(0, 50) + "..." : text;
      document.body.appendChild(preview);
      if (e.dataTransfer) {
        e.dataTransfer.setDragImage(preview, 10, 10);
      }
      this.safeSetTimeout(() => {
        if (document.body.contains(preview)) {
          document.body.removeChild(preview);
        }
      }, 0);
    } catch (error) {
      console.error("Failed to set drag preview:", error);
    }
  }
  // è®¾ç½®ç½‘æ ¼è§†å›¾æ‹–æ‹½ç›®æ ‡
  setupGridDropTarget() {
    if (!this.gridContainer)
      return;
    console.log("Setting up grid drop target...");
    this.registerDomEvent(this.gridContainer, "dragover", (e) => {
      e.preventDefault();
      if (this.isDragging && this.dragData) {
        e.dataTransfer.dropEffect = "copy";
        this.showDropIndicator(e);
      }
    });
    this.registerDomEvent(this.gridContainer, "dragenter", (e) => {
      e.preventDefault();
      if (this.isDragging) {
        this.gridContainer.classList.add("drag-over");
        console.log("Drag entered grid container");
      }
    });
    this.registerDomEvent(this.gridContainer, "dragleave", (e) => {
      if (!this.gridContainer.contains(e.relatedTarget)) {
        this.gridContainer.classList.remove("drag-over");
        this.hideDropIndicator();
        console.log("Drag left grid container");
      }
    });
    this.registerDomEvent(this.gridContainer, "drop", (e) => {
      e.preventDefault();
      console.log("Drop event received");
      this.handleGridDrop(e);
    });
  }
  // æ˜¾ç¤ºæ‹–æ‹½æŒ‡ç¤ºå™¨
  showDropIndicator(e) {
    if (!this.dropIndicator) {
      this.dropIndicator = document.createElement("div");
      this.dropIndicator.className = "drop-indicator";
      this.gridContainer.appendChild(this.dropIndicator);
    }
    const rect = this.gridContainer.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const cols = Math.floor(this.gridContainer.clientWidth / (CARD_CONSTANTS.width + CARD_CONSTANTS.spacing));
    const col = Math.floor(x / (CARD_CONSTANTS.width + CARD_CONSTANTS.spacing));
    const row = Math.floor(y / (CARD_CONSTANTS.height + CARD_CONSTANTS.spacing));
    this.dropIndicator.style.left = `${col * (CARD_CONSTANTS.width + CARD_CONSTANTS.spacing)}px`;
    this.dropIndicator.style.top = `${row * (CARD_CONSTANTS.height + CARD_CONSTANTS.spacing)}px`;
    this.dropIndicator.style.width = `${CARD_CONSTANTS.width}px`;
    this.dropIndicator.style.height = `${CARD_CONSTANTS.height}px`;
    this.dropIndicator.style.display = "block";
  }
  // éšè—æ‹–æ‹½æŒ‡ç¤ºå™¨
  hideDropIndicator() {
    if (this.dropIndicator) {
      this.dropIndicator.style.display = "none";
    }
  }
  // é‡ç½®æ‹–æ‹½çŠ¶æ€
  resetDragState() {
    this.isDragging = false;
    this.dragData = null;
    this.gridContainer?.classList.remove("drag-over");
    this.hideDropIndicator();
    console.log("Drag state reset");
  }
  // å¤„ç†ç½‘æ ¼æ‹–æ‹½æ”¾ä¸‹
  async handleGridDrop(e) {
    try {
      this.gridContainer.classList.remove("drag-over");
      this.hideDropIndicator();
      const droppedText = e.dataTransfer?.getData("application/obsidian-text") || e.dataTransfer?.getData("text/plain");
      if (!droppedText || !droppedText.trim()) {
        new import_obsidian.Notice("\u6CA1\u6709\u68C0\u6D4B\u5230\u6709\u6548\u7684\u6587\u672C\u5185\u5BB9");
        return;
      }
      if (!this.linkedCanvasFile) {
        new import_obsidian.Notice("\u8BF7\u5148\u5173\u8054\u4E00\u4E2ACanvas\u6587\u4EF6");
        this.showCanvasSelectionDialog();
        return;
      }
      console.log("Processing drop with linked canvas:", this.linkedCanvasFile.path);
      new import_obsidian.Notice("\u6B63\u5728\u521B\u5EFA\u65B0\u5361\u7247...", 2e3);
      this.disableFileWatcher();
      const newNode = await this.createNodeFromText(droppedText, e);
      if (newNode) {
        await this.saveCanvasDataToLinkedFile();
        this.renderGrid();
        this.notifyCanvasViewRefresh();
        this.scrollToNewCard(newNode.id);
        new import_obsidian.Notice("\u65B0\u5361\u7247\u521B\u5EFA\u6210\u529F\uFF01", 3e3);
      }
      this.safeSetTimeout(() => {
        this.enableFileWatcher();
      }, 1e3);
      this.resetDragState();
    } catch (error) {
      console.error("\u62D6\u62FD\u521B\u5EFA\u5361\u7247\u5931\u8D25:", error);
      new import_obsidian.Notice("\u521B\u5EFA\u5361\u7247\u5931\u8D25\uFF0C\u8BF7\u91CD\u8BD5");
      this.enableFileWatcher();
      this.resetDragState();
    }
  }
  // ä»æ–‡æœ¬åˆ›å»ºCanvasèŠ‚ç‚¹
  async createNodeFromText(text, dropEvent) {
    try {
      const contentType = await this.analyzeTextContent(text);
      const dropTarget = this.analyzeDropTarget(dropEvent);
      let newNode;
      if (dropTarget.type === "existing-group") {
        newNode = await this.addToExistingGroup(dropTarget.groupId, contentType, dropTarget.position);
        console.log("Added to existing group:", dropTarget.groupId);
      } else {
        const { groupNode, contentNode } = this.createGroupedNodes(text, contentType, dropTarget.position);
        if (!this.canvasData) {
          this.canvasData = { nodes: [], edges: [] };
        }
        this.canvasData.nodes.push(groupNode);
        this.canvasData.nodes.push(contentNode);
        newNode = contentNode;
        console.log("Created new group with content");
      }
      await this.saveCanvasData();
      return newNode;
    } catch (error) {
      console.error("\u521B\u5EFA\u8282\u70B9\u5931\u8D25:", error);
      return null;
    }
  }
  // åˆ†ææ–‡æœ¬å†…å®¹ç±»å‹ï¼ˆå¼‚æ­¥ç‰ˆæœ¬ï¼‰
  async analyzeTextContent(text) {
    const trimmedText = text.trim();
    if (this.isURL(trimmedText)) {
      return {
        type: "link",
        content: { url: trimmedText },
        width: 300,
        height: 100
      };
    }
    if (this.isFileLink(trimmedText)) {
      return {
        type: "file",
        content: { file: trimmedText },
        width: 300,
        height: 200
      };
    }
    const textWithBacklink = await this.addBacklinkToText(trimmedText);
    const lines = textWithBacklink.split("\n").length;
    const estimatedWidth = Math.min(400, Math.max(200, textWithBacklink.length * 8));
    const estimatedHeight = Math.min(300, Math.max(100, lines * 25 + 40));
    return {
      type: "text",
      content: { text: textWithBacklink },
      width: estimatedWidth,
      height: estimatedHeight
    };
  }
  // æ£€æµ‹æ˜¯å¦ä¸ºURL
  isURL(text) {
    try {
      new URL(text);
      return true;
    } catch {
      return /^https?:\/\//.test(text);
    }
  }
  // æ£€æµ‹æ˜¯å¦ä¸ºæ–‡ä»¶é“¾æ¥
  isFileLink(text) {
    return /^\[\[.*\]\]$/.test(text) || text.includes(".md") || text.includes(".pdf");
  }
  // åˆ†ææ‹–æ‹½ç›®æ ‡
  analyzeDropTarget(dropEvent) {
    if (this.currentGroupView) {
      console.log("Drop in group view:", this.currentGroupView);
      return {
        type: "existing-group",
        groupId: this.currentGroupView,
        position: this.calculatePositionInGroup(this.currentGroupView, dropEvent)
      };
    }
    const targetGroupId = this.findGroupUnderCursor(dropEvent);
    if (targetGroupId) {
      console.log("Drop on group card:", targetGroupId);
      return {
        type: "existing-group",
        groupId: targetGroupId,
        position: this.calculatePositionInGroup(targetGroupId, dropEvent)
      };
    }
    console.log("Drop in empty area, creating new group");
    return {
      type: "new-group",
      position: this.calculateDropPosition(dropEvent)
    };
  }
  // æŸ¥æ‰¾é¼ æ ‡ä¸‹çš„åˆ†ç»„
  findGroupUnderCursor(dropEvent) {
    const rect = this.gridContainer.getBoundingClientRect();
    const x = dropEvent.clientX - rect.left;
    const y = dropEvent.clientY - rect.top;
    const elementUnderCursor = document.elementFromPoint(dropEvent.clientX, dropEvent.clientY);
    if (elementUnderCursor) {
      const groupCard = elementUnderCursor.closest('[data-node-type="group"]');
      if (groupCard) {
        return groupCard.dataset.nodeId || null;
      }
    }
    return null;
  }
  // è®¡ç®—åœ¨åˆ†ç»„å†…çš„ä½ç½®
  calculatePositionInGroup(groupId, dropEvent) {
    if (!this.canvasData) {
      return { x: 100, y: 100 };
    }
    const groupNode = this.canvasData.nodes.find((n) => n.id === groupId && n.type === "group");
    if (!groupNode) {
      return { x: 100, y: 100 };
    }
    const groupMembers = this.canvasData.nodes.filter(
      (n) => n.type !== "group" && n.x >= groupNode.x && n.y >= groupNode.y && n.x + n.width <= groupNode.x + groupNode.width && n.y + n.height <= groupNode.y + groupNode.height
    );
    const padding = 20;
    if (groupMembers.length === 0) {
      return {
        x: groupNode.x + padding,
        y: groupNode.y + padding + 30
        // ä¸ºåˆ†ç»„æ ‡é¢˜ç•™ç©ºé—´
      };
    }
    const maxX = Math.max(...groupMembers.map((n) => n.x + n.width));
    const maxY = Math.max(...groupMembers.map((n) => n.y + n.height));
    const newX = maxX + padding;
    if (newX + 300 <= groupNode.x + groupNode.width - padding) {
      return { x: newX, y: groupMembers[0].y };
    }
    return {
      x: groupNode.x + padding,
      y: maxY + padding
    };
  }
  // æ·»åŠ åˆ°ç°æœ‰åˆ†ç»„
  async addToExistingGroup(groupId, contentType, position) {
    const timestamp = Date.now();
    const contentId = `node-${timestamp}-content`;
    const contentNode = {
      id: contentId,
      type: contentType.type,
      x: position.x,
      y: position.y,
      width: contentType.width,
      height: contentType.height,
      ...contentType.content
    };
    if (!this.canvasData) {
      this.canvasData = { nodes: [], edges: [] };
    }
    this.canvasData.nodes.push(contentNode);
    this.expandGroupIfNeeded(groupId, contentNode);
    this.updateGroupAnalysisAfterAdd(groupId, contentNode);
    if (this.currentGroupView === groupId) {
      this.refreshGroupView(groupId);
    }
    return contentNode;
  }
  // æ‰©å±•åˆ†ç»„å¤§å°ä»¥å®¹çº³æ–°å†…å®¹
  expandGroupIfNeeded(groupId, newNode) {
    if (!this.canvasData)
      return;
    const groupNode = this.canvasData.nodes.find((n) => n.id === groupId && n.type === "group");
    if (!groupNode)
      return;
    const padding = 20;
    const requiredWidth = newNode.x + newNode.width - groupNode.x + padding;
    const requiredHeight = newNode.y + newNode.height - groupNode.y + padding;
    if (requiredWidth > groupNode.width) {
      groupNode.width = requiredWidth;
    }
    if (requiredHeight > groupNode.height) {
      groupNode.height = requiredHeight;
    }
  }
  // æ›´æ–°åˆ†ç»„åˆ†ææ•°æ®ï¼ˆæ·»åŠ æ–°èŠ‚ç‚¹åï¼‰
  updateGroupAnalysisAfterAdd(groupId, newNode) {
    const groupInfo = this.groupAnalysis.get(groupId);
    if (groupInfo) {
      groupInfo.members.push(newNode);
      groupInfo.memberCount = groupInfo.members.length;
      this.updateGroupBounds(groupInfo);
      console.log(`Updated group ${groupId} analysis, new member count: ${groupInfo.memberCount}`);
    } else {
      console.log(`Group ${groupId} not found in analysis, re-analyzing all groups`);
      this.analyzeGroups();
    }
  }
  // æ›´æ–°åˆ†ç»„è¾¹ç•Œ
  updateGroupBounds(groupInfo) {
    if (groupInfo.members.length === 0)
      return;
    const allNodes = [groupInfo.group, ...groupInfo.members];
    const minX = Math.min(...allNodes.map((n) => n.x));
    const minY = Math.min(...allNodes.map((n) => n.y));
    const maxX = Math.max(...allNodes.map((n) => n.x + n.width));
    const maxY = Math.max(...allNodes.map((n) => n.y + n.height));
    groupInfo.bounds = { minX, minY, maxX, maxY };
  }
  // åˆ·æ–°åˆ†ç»„è§†å›¾
  refreshGroupView(groupId) {
    console.log(`Refreshing group view for: ${groupId}`);
    this.analyzeGroups();
    const groupInfo = this.groupAnalysis.get(groupId);
    if (!groupInfo) {
      console.error(`Group ${groupId} not found after analysis`);
      return;
    }
    this.filteredNodes = [...groupInfo.members];
    this.renderGroupMembers();
    console.log(`Group view refreshed, showing ${groupInfo.members.length} members`);
  }
  // åˆ›å»ºåˆ†ç»„å’Œå†…å®¹èŠ‚ç‚¹
  createGroupedNodes(text, contentType, position) {
    const timestamp = Date.now();
    const groupId = `group-${timestamp}`;
    const contentId = `node-${timestamp}-content`;
    const groupPadding = 40;
    const groupWidth = contentType.width + groupPadding * 2;
    const groupHeight = contentType.height + groupPadding * 2 + 60;
    const groupNode = {
      id: groupId,
      type: "group",
      x: position.x,
      y: position.y,
      width: groupWidth,
      height: groupHeight,
      label: "\u6536\u96C6",
      // åˆ†ç»„æ ‡é¢˜
      color: "1"
      // ä½¿ç”¨çº¢è‰²ä½œä¸ºé»˜è®¤åˆ†ç»„é¢œè‰²
    };
    const contentNode = {
      id: contentId,
      type: contentType.type,
      x: position.x + groupPadding,
      y: position.y + groupPadding + 30,
      // ä¸ºåˆ†ç»„æ ‡é¢˜ç•™å‡ºç©ºé—´
      width: contentType.width,
      height: contentType.height,
      ...contentType.content
    };
    return { groupNode, contentNode };
  }
  // è®¡ç®—æ‹–æ‹½æ”¾ç½®ä½ç½®
  calculateDropPosition(dropEvent) {
    if (this.canvasData && this.canvasData.nodes.length > 0) {
      const maxX = Math.max(...this.canvasData.nodes.map((n) => n.x + n.width));
      const maxY = Math.max(...this.canvasData.nodes.map((n) => n.y + n.height));
      const groupSpacing = 50;
      const newX = maxX + groupSpacing;
      const newY = 100;
      const estimatedCanvasWidth = 1200;
      const groupWidth = CARD_CONSTANTS.width + 80;
      if (newX + groupWidth > estimatedCanvasWidth) {
        return {
          x: 100,
          // ä»å·¦è¾¹å¼€å§‹
          y: maxY + groupSpacing
        };
      }
      return { x: newX, y: newY };
    }
    return { x: 100, y: 100 };
  }
  // ç”Ÿæˆå”¯ä¸€èŠ‚ç‚¹ID
  generateNodeId() {
    return "node-" + Date.now() + "-" + Math.random().toString(36).substr(2, 9);
  }
  // ç”Ÿæˆå”¯ä¸€çš„å—å¼•ç”¨ID
  generateBlockId() {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substr(2, 6);
    return `canvas-${timestamp}-${random}`;
  }
  // ğŸ”§ ä¿®å¤ï¼šåˆ›å»º dragData çš„å®‰å…¨å¿«ç…§ï¼Œé¿å…ç«æ€æ¡ä»¶
  createDragDataSnapshot() {
    try {
      if (!this.dragData) {
        console.log("No dragData to snapshot");
        return null;
      }
      if (!this.dragData.sourceFile) {
        console.log("No sourceFile in dragData");
        return null;
      }
      if (!this.dragData.sourcePosition) {
        console.log("No sourcePosition in dragData");
        return null;
      }
      const snapshot = {
        sourceFile: this.dragData.sourceFile,
        sourcePosition: {
          line: this.dragData.sourcePosition.line,
          ch: this.dragData.sourcePosition.ch
        },
        sourcePath: this.dragData.sourcePath || "",
        sourceContext: this.dragData.sourceContext || ""
      };
      console.log("\u2705 Created dragData snapshot:", snapshot);
      return snapshot;
    } catch (error) {
      console.error("Failed to create dragData snapshot:", error);
      return null;
    }
  }
  // åœ¨æºæ–‡ä»¶ä¸­æ’å…¥å—å¼•ç”¨ï¼ˆä¿®å¤ç‰ˆæœ¬ï¼šæ·»åŠ æ–‡ä»¶é”ä¿æŠ¤ï¼‰
  async insertBlockReference(file, position, blockId) {
    const filePath = file.path;
    try {
      console.log("=== Inserting Block Reference (Protected) ===");
      console.log("File:", filePath);
      console.log("Position:", position);
      console.log("Block ID:", blockId);
      if (this.fileModificationLocks.has(filePath)) {
        console.log("\u274C File is currently being modified, skipping");
        new import_obsidian.Notice("\u6E90\u6587\u4EF6\u6B63\u5728\u88AB\u4FEE\u6539\uFF0C\u8BF7\u7A0D\u540E\u91CD\u8BD5");
        return false;
      }
      this.fileModificationLocks.add(filePath);
      if (!file || !position || typeof position.line !== "number") {
        console.error("Invalid input parameters");
        return false;
      }
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      if (position.line < 0 || position.line >= lines.length) {
        console.error("Line number out of range:", position.line, "max:", lines.length - 1);
        return false;
      }
      const targetLine = lines[position.line];
      if (this.hasExistingBlockReference(targetLine)) {
        console.log("Line already has block reference, skipping");
        return false;
      }
      lines[position.line] = `${targetLine} ^${blockId}`;
      const newContent = lines.join("\n");
      await this.app.vault.modify(file, newContent);
      console.log("\u2705 Block reference inserted successfully");
      new import_obsidian.Notice("\u5DF2\u5728\u6E90\u6587\u4EF6\u4E2D\u6DFB\u52A0\u5757\u5F15\u7528");
      return true;
    } catch (error) {
      console.error("Failed to insert block reference:", error);
      const errorMessage = error instanceof Error ? error.message : "\u672A\u77E5\u9519\u8BEF";
      new import_obsidian.Notice("\u63D2\u5165\u5757\u5F15\u7528\u5931\u8D25\uFF1A" + errorMessage);
      return false;
    } finally {
      this.fileModificationLocks.delete(filePath);
      console.log("Released file lock for:", filePath);
    }
  }
  // ğŸ”§ ä¿®å¤ï¼šæ”¹è¿›çš„å—å¼•ç”¨æ£€æµ‹æ–¹æ³•
  hasExistingBlockReference(line) {
    if (!line || typeof line !== "string") {
      return false;
    }
    const blockRefPattern = /\s\^[a-zA-Z0-9\-_]+$/;
    return blockRefPattern.test(line);
  }
  // ğŸ”§ ä¿®å¤ï¼šç”¨æˆ·ç¡®è®¤æœºåˆ¶
  async confirmBlockReferenceInsertion(file) {
    return new Promise((resolve) => {
      const modal = new import_obsidian.Modal(this.app);
      modal.titleEl.setText("\u786E\u8BA4\u4FEE\u6539\u6E90\u6587\u4EF6");
      const content = modal.contentEl;
      content.empty();
      content.createEl("p", {
        text: "\u4E3A\u4E86\u521B\u5EFA\u7CBE\u786E\u7684\u56DE\u94FE\uFF0C\u9700\u8981\u5728\u6E90\u6587\u4EF6\u4E2D\u6DFB\u52A0\u5757\u5F15\u7528\u6807\u8BB0\u3002"
      });
      content.createEl("p", {
        text: `\u6587\u4EF6\uFF1A${file.basename}`,
        cls: "canvas-grid-file-info"
      });
      content.createEl("p", {
        text: "\u8FD9\u5C06\u5728\u62D6\u62FD\u7684\u6587\u672C\u884C\u672B\u5C3E\u6DFB\u52A0\u4E00\u4E2A\u5757\u5F15\u7528ID\uFF08\u5982\uFF1A^canvas-123456\uFF09",
        cls: "canvas-grid-detail-info"
      });
      const buttonContainer = content.createDiv("canvas-grid-confirm-buttons");
      buttonContainer.style.cssText = `
				display: flex;
				gap: 10px;
				margin-top: 20px;
				justify-content: center;
			`;
      const confirmButton = buttonContainer.createEl("button", { text: "\u786E\u8BA4\u4FEE\u6539" });
      confirmButton.style.cssText = `
				background-color: var(--interactive-accent);
				color: var(--text-on-accent);
				border: none;
				padding: 8px 16px;
				border-radius: 4px;
				cursor: pointer;
			`;
      confirmButton.onclick = () => {
        modal.close();
        resolve(true);
      };
      const cancelButton = buttonContainer.createEl("button", { text: "\u53D6\u6D88\uFF08\u4F7F\u7528\u884C\u53F7\uFF09" });
      cancelButton.style.cssText = `
				background-color: var(--background-modifier-border);
				color: var(--text-normal);
				border: none;
				padding: 8px 16px;
				border-radius: 4px;
				cursor: pointer;
			`;
      cancelButton.onclick = () => {
        modal.close();
        resolve(false);
      };
      confirmButton.focus();
      modal.open();
    });
  }
  // åœ¨æ–‡æœ¬ä¸­æ·»åŠ å›é“¾ï¼ˆä¿®å¤ç‰ˆæœ¬ï¼šè§£å†³ç«æ€æ¡ä»¶ï¼‰
  async addBacklinkToText(originalText) {
    console.log("=== addBacklinkToText called (Fixed Version) ===");
    console.log("Original text:", originalText);
    console.log("Drag data:", this.dragData);
    const dragDataSnapshot = this.createDragDataSnapshot();
    if (!dragDataSnapshot) {
      console.log("\u274C No valid dragData snapshot available");
      return originalText;
    }
    try {
      const blockId = this.generateBlockId();
      console.log("Generated block ID:", blockId);
      const userConfirmed = await this.confirmBlockReferenceInsertion(dragDataSnapshot.sourceFile);
      if (!userConfirmed) {
        console.log("User declined block reference insertion, using fallback");
        const sourceFileName2 = dragDataSnapshot.sourceFile.basename;
        const lineNumber = dragDataSnapshot.sourcePosition.line + 1;
        const backlink2 = `[[${sourceFileName2}#^L${lineNumber}]]`;
        return `${originalText}

---
\u6765\u6E90\uFF1A${backlink2}`;
      }
      const insertSuccess = await this.insertBlockReference(
        dragDataSnapshot.sourceFile,
        dragDataSnapshot.sourcePosition,
        blockId
      );
      if (!insertSuccess) {
        console.log("\u274C Failed to insert block reference, using fallback");
        const sourceFileName2 = dragDataSnapshot.sourceFile.basename;
        const lineNumber = dragDataSnapshot.sourcePosition.line + 1;
        const backlink2 = `[[${sourceFileName2}#^L${lineNumber}]]`;
        return `${originalText}

---
\u6765\u6E90\uFF1A${backlink2}`;
      }
      const sourceFileName = dragDataSnapshot.sourceFile.basename;
      const backlink = `[[${sourceFileName}#^${blockId}]]`;
      const textWithBacklink = `${originalText}

---
\u6765\u6E90\uFF1A${backlink}`;
      console.log("\u2705 Successfully added block reference backlink:", backlink);
      console.log("Final text with backlink:", textWithBacklink);
      return textWithBacklink;
    } catch (error) {
      console.error("Error in addBacklinkToText:", error);
      new import_obsidian.Notice("\u521B\u5EFA\u56DE\u94FE\u65F6\u53D1\u751F\u9519\u8BEF\uFF0C\u5DF2\u4F7F\u7528\u539F\u59CB\u6587\u672C");
      return originalText;
    }
  }
  // æ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦åŒ…å«å›é“¾ï¼ˆæ”¯æŒå—å¼•ç”¨å’Œè¡Œå·æ ¼å¼ï¼‰
  hasBacklink(node) {
    if (node.type !== "text" || !node.text) {
      return false;
    }
    return /---\næ¥æºï¼š\[\[.*#\^(canvas-\d+-\w+|L\d+)\]\]/.test(node.text);
  }
  // ä»èŠ‚ç‚¹å›é“¾è·³è½¬åˆ°æºä½ç½®ï¼ˆæ”¯æŒå—å¼•ç”¨ï¼‰
  async navigateToBacklink(node) {
    if (node.type !== "text" || !node.text) {
      new import_obsidian.Notice("\u8282\u70B9\u4E0D\u5305\u542B\u6587\u672C\u5185\u5BB9");
      return;
    }
    try {
      console.log("=== Navigating to Backlink ===");
      console.log("Node text:", node.text);
      const backlinkMatch = node.text.match(/æ¥æºï¼š\[\[(.*)#\^(canvas-\d+-\w+|L\d+)\]\]/);
      if (!backlinkMatch) {
        new import_obsidian.Notice("\u672A\u627E\u5230\u6709\u6548\u7684\u56DE\u94FE\u4FE1\u606F");
        return;
      }
      const fileName = backlinkMatch[1];
      const reference = backlinkMatch[2];
      console.log("Parsed backlink:", fileName, "reference:", reference);
      const files = this.app.vault.getMarkdownFiles();
      const sourceFile = files.find((f) => f.basename === fileName);
      if (!sourceFile) {
        new import_obsidian.Notice(`\u6E90\u6587\u4EF6\u4E0D\u5B58\u5728: ${fileName}`);
        return;
      }
      if (reference.startsWith("canvas-")) {
        await this.openFileAndNavigateToBlock(sourceFile, reference);
      } else if (reference.startsWith("L")) {
        const lineNumber = parseInt(reference.substring(1)) - 1;
        await this.openFileAndNavigate(sourceFile, lineNumber);
      } else {
        new import_obsidian.Notice("\u4E0D\u652F\u6301\u7684\u56DE\u94FE\u683C\u5F0F");
      }
    } catch (error) {
      console.error("Failed to navigate to backlink:", error);
      new import_obsidian.Notice("\u8DF3\u8F6C\u5230\u6E90\u6587\u4EF6\u5931\u8D25");
    }
  }
  // æ‰“å¼€æ–‡ä»¶å¹¶å¯¼èˆªåˆ°æŒ‡å®šä½ç½®
  async openFileAndNavigate(file, lineNumber) {
    try {
      const leaf = this.app.workspace.getUnpinnedLeaf();
      await leaf.openFile(file);
      await new Promise((resolve) => setTimeout(resolve, 100));
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (activeView && activeView.editor) {
        const editor = activeView.editor;
        const targetPos = { line: lineNumber, ch: 0 };
        editor.setCursor(targetPos);
        editor.scrollIntoView({ from: targetPos, to: targetPos }, true);
        const lineText = editor.getLine(lineNumber);
        const lineEnd = { line: lineNumber, ch: lineText.length };
        editor.setSelection(targetPos, lineEnd);
        setTimeout(() => {
          try {
            const cursor = editor.getCursor();
            editor.setCursor(cursor);
          } catch (e) {
          }
        }, 3e3);
        new import_obsidian.Notice(`\u5DF2\u8DF3\u8F6C\u5230\u6E90\u6587\u4EF6: ${file.basename} (\u7B2C${lineNumber + 1}\u884C)`);
        console.log("Successfully navigated to backlink position");
      } else {
        new import_obsidian.Notice("\u65E0\u6CD5\u83B7\u53D6\u7F16\u8F91\u5668\u89C6\u56FE");
      }
    } catch (error) {
      console.error("Failed to open file and navigate:", error);
      new import_obsidian.Notice("\u6253\u5F00\u6587\u4EF6\u5931\u8D25");
    }
  }
  // æ‰“å¼€æ–‡ä»¶å¹¶å¯¼èˆªåˆ°æŒ‡å®šçš„å—å¼•ç”¨
  async openFileAndNavigateToBlock(file, blockId) {
    try {
      console.log("=== Opening file and navigating to block ===");
      console.log("File:", file.path);
      console.log("Block ID:", blockId);
      const leaf = this.app.workspace.getUnpinnedLeaf();
      await leaf.openFile(file);
      await new Promise((resolve) => setTimeout(resolve, 100));
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (activeView && activeView.editor) {
        const editor = activeView.editor;
        const content = editor.getValue();
        const lines = content.split("\n");
        let targetLine = -1;
        for (let i = 0; i < lines.length; i++) {
          if (lines[i].includes(`^${blockId}`)) {
            targetLine = i;
            break;
          }
        }
        if (targetLine >= 0) {
          const targetPos = { line: targetLine, ch: 0 };
          editor.setCursor(targetPos);
          editor.scrollIntoView({ from: targetPos, to: targetPos }, true);
          const lineText = lines[targetLine];
          const lineEnd = { line: targetLine, ch: lineText.length };
          editor.setSelection(targetPos, lineEnd);
          setTimeout(() => {
            try {
              const cursor = editor.getCursor();
              editor.setCursor(cursor);
            } catch (e) {
            }
          }, 3e3);
          new import_obsidian.Notice(`\u5DF2\u8DF3\u8F6C\u5230\u5757\u5F15\u7528: ${file.basename}`);
          console.log("Successfully navigated to block reference");
        } else {
          new import_obsidian.Notice(`\u672A\u627E\u5230\u5757\u5F15\u7528: ^${blockId}`);
          console.log("Block reference not found:", blockId);
        }
      } else {
        new import_obsidian.Notice("\u65E0\u6CD5\u83B7\u53D6\u7F16\u8F91\u5668\u89C6\u56FE");
      }
    } catch (error) {
      console.error("Failed to open file and navigate to block:", error);
      new import_obsidian.Notice("\u8DF3\u8F6C\u5230\u5757\u5F15\u7528\u5931\u8D25");
    }
  }
  // ä¿å­˜Canvasæ•°æ®
  async saveCanvasData() {
    if (!this.canvasData)
      return;
    if (this.linkedCanvasFile) {
      await this.saveCanvasDataToLinkedFile();
      return;
    }
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile || activeFile.extension !== "canvas") {
      throw new Error("\u6CA1\u6709\u6D3B\u52A8\u7684Canvas\u6587\u4EF6\u6216\u5173\u8054\u6587\u4EF6");
    }
    try {
      const canvasContent = JSON.stringify(this.canvasData, null, 2);
      await this.app.vault.modify(activeFile, canvasContent);
      console.log("Canvas data saved to active file successfully");
    } catch (error) {
      console.error("Failed to save canvas data:", error);
      throw error;
    }
  }
  // æ»šåŠ¨åˆ°æ–°åˆ›å»ºçš„å¡ç‰‡
  scrollToNewCard(nodeId) {
    this.safeSetTimeout(() => {
      const cardElement = this.gridContainer?.querySelector(`[data-node-id="${nodeId}"]`);
      if (cardElement) {
        cardElement.scrollIntoView({
          behavior: "smooth",
          block: "center"
        });
        cardElement.classList.add("newly-created");
        this.safeSetTimeout(() => {
          if (cardElement.classList.contains("newly-created")) {
            cardElement.classList.remove("newly-created");
          }
        }, 2e3);
      }
    }, 100);
  }
  // ==================== å…³è”æ ‡ç­¾é¡µåŠŸèƒ½å®ç° ====================
  // è®¾ç½®å…³è”Canvasæ–‡ä»¶
  async setLinkedCanvas(canvasFile) {
    try {
      console.log("Setting linked canvas file:", canvasFile.path);
      this.linkedCanvasFile = canvasFile;
      this.linkedTabManager.linkCanvasFile(canvasFile, this);
      this.showLoadingState();
      await this.loadCanvasDataFromFile(canvasFile);
      this.initializeSearchAndSort();
      this.updateLinkedCanvasDisplay(canvasFile);
      this.updateActionButtonsVisibility();
      this.renderGrid();
      new import_obsidian.Notice(`\u5DF2\u5173\u8054Canvas\u6587\u4EF6: ${canvasFile.basename}`, 3e3);
      console.log("Canvas file linked and data loaded:", canvasFile.path);
    } catch (error) {
      console.error("Failed to link canvas file:", error);
      new import_obsidian.Notice("\u5173\u8054Canvas\u6587\u4EF6\u5931\u8D25");
      this.showErrorState(error instanceof Error ? error.message : "\u672A\u77E5\u9519\u8BEF");
    }
  }
  // è·å–å…³è”çš„Canvasæ–‡ä»¶
  getLinkedCanvas() {
    return this.linkedCanvasFile;
  }
  // è§£é™¤å…³è”
  unlinkCanvas() {
    if (this.linkedCanvasFile) {
      const fileName = this.linkedCanvasFile.basename;
      this.linkedCanvasFile = null;
      this.linkedTabManager.unlinkCanvas();
      this.canvasData = null;
      this.renderGrid();
      this.updateLinkedCanvasDisplay(null);
      this.updateActionButtonsVisibility();
      new import_obsidian.Notice(`\u5DF2\u89E3\u9664\u4E0E ${fileName} \u7684\u5173\u8054`, 3e3);
      console.log("Canvas link removed");
    }
  }
  // ä»æŒ‡å®šæ–‡ä»¶åŠ è½½Canvasæ•°æ®
  async loadCanvasDataFromFile(file) {
    if (!file) {
      throw new Error("\u6587\u4EF6\u53C2\u6570\u65E0\u6548");
    }
    const fileExists = this.app.vault.getAbstractFileByPath(file.path);
    if (!fileExists) {
      throw new Error(`\u6587\u4EF6\u4E0D\u5B58\u5728: ${file.path}`);
    }
    try {
      console.log("Loading canvas data from file:", file.path);
      const content = await this.app.vault.read(file);
      if (!content || content.trim() === "") {
        console.log("Canvas file is empty, creating empty data structure");
        this.canvasData = { nodes: [], edges: [] };
        this.clearRenderCache();
        this.renderGrid();
        return;
      }
      let parsedData;
      try {
        parsedData = JSON.parse(content);
      } catch (parseError) {
        throw new Error(`JSON\u683C\u5F0F\u65E0\u6548: ${parseError instanceof Error ? parseError.message : "\u89E3\u6790\u9519\u8BEF"}`);
      }
      if (!parsedData || typeof parsedData !== "object") {
        throw new Error("Canvas\u6570\u636E\u683C\u5F0F\u65E0\u6548");
      }
      if (!Array.isArray(parsedData.nodes)) {
        throw new Error("Canvas\u6587\u4EF6\u7F3A\u5C11\u6709\u6548\u7684\u8282\u70B9\u6570\u636E");
      }
      if (!Array.isArray(parsedData.edges)) {
        parsedData.edges = [];
      }
      this.canvasData = parsedData;
      this.clearRenderCache();
      this.filteredNodes = [...parsedData.nodes];
      this.searchQuery = "";
      if (this.searchInputEl) {
        this.searchInputEl.value = "";
      }
      this.activeColorFilter = null;
      console.log("Canvas\u6570\u636E\u52A0\u8F7D\u6210\u529F\uFF0C\u8282\u70B9\u6570\u91CF:", parsedData.nodes.length);
      parsedData.nodes.forEach((node) => {
        if (node.color) {
          console.log("\u8282\u70B9\u989C\u8272\u503C:", node.id, "color:", node.color, "type:", typeof node.color);
        }
      });
      this.renderGrid();
      console.log("Canvas data loaded and rendered successfully from file:", file.path);
    } catch (error) {
      console.error("Failed to load canvas data from file:", error);
      const errorMessage = error instanceof Error ? error.message : "\u672A\u77E5\u9519\u8BEF";
      throw new Error(`\u52A0\u8F7DCanvas\u6587\u4EF6\u5931\u8D25: ${errorMessage}`);
    }
  }
  // ä¿å­˜åˆ°å…³è”çš„Canvasæ–‡ä»¶
  async saveCanvasDataToLinkedFile() {
    if (!this.canvasData) {
      throw new Error("\u6CA1\u6709Canvas\u6570\u636E\u53EF\u4FDD\u5B58");
    }
    if (!this.linkedCanvasFile) {
      throw new Error("\u6CA1\u6709\u5173\u8054\u7684Canvas\u6587\u4EF6");
    }
    const fileExists = this.app.vault.getAbstractFileByPath(this.linkedCanvasFile.path);
    if (!fileExists) {
      throw new Error(`\u5173\u8054\u7684Canvas\u6587\u4EF6\u4E0D\u5B58\u5728: ${this.linkedCanvasFile.path}`);
    }
    try {
      if (!Array.isArray(this.canvasData.nodes)) {
        throw new Error("Canvas\u8282\u70B9\u6570\u636E\u65E0\u6548");
      }
      if (!Array.isArray(this.canvasData.edges)) {
        this.canvasData.edges = [];
      }
      console.log("Saving canvas data to linked file:", this.linkedCanvasFile.path);
      const backupData = JSON.parse(JSON.stringify(this.canvasData));
      const canvasContent = JSON.stringify(this.canvasData, null, 2);
      try {
        JSON.parse(canvasContent);
      } catch (jsonError) {
        throw new Error("\u751F\u6210\u7684JSON\u683C\u5F0F\u65E0\u6548");
      }
      await this.app.vault.modify(this.linkedCanvasFile, canvasContent);
      console.log("Canvas data saved successfully to linked file:", this.linkedCanvasFile.path);
    } catch (error) {
      console.error("Failed to save to linked canvas file:", error);
      const errorMessage = error instanceof Error ? error.message : "\u672A\u77E5\u9519\u8BEF";
      throw new Error(`\u4FDD\u5B58Canvas\u6587\u4EF6\u5931\u8D25: ${errorMessage}`);
    }
  }
  // æ˜¾ç¤ºCanvasæ–‡ä»¶é€‰æ‹©å¯¹è¯æ¡†
  showCanvasSelectionDialog() {
    const modal = new CanvasSelectionModal(
      this.app,
      this,
      (file) => {
        this.setLinkedCanvas(file);
      }
    );
    modal.open();
  }
  // æ›´æ–°å…³è”Canvasæ˜¾ç¤º
  updateLinkedCanvasDisplay(file) {
    if (!this.linkedIndicatorEl)
      return;
    if (file) {
      this.linkedIndicatorEl.textContent = file.basename;
      this.linkedIndicatorEl.removeClass("not-linked");
      this.linkedIndicatorEl.title = `\u5173\u8054\u6587\u4EF6: ${file.path}`;
    } else {
      this.linkedIndicatorEl.textContent = "\u672A\u5173\u8054";
      this.linkedIndicatorEl.addClass("not-linked");
      this.linkedIndicatorEl.title = "\u70B9\u51FB\u5173\u8054Canvas\u6587\u4EF6";
    }
    const mainBtn = this.containerEl.querySelector(".canvas-grid-main-btn");
    if (mainBtn) {
      if (file) {
        mainBtn.title = `\u7F51\u683C\u89C6\u56FE\u83DC\u5355 - \u5DF2\u5173\u8054: ${file.basename}`;
      } else {
        mainBtn.title = "\u7F51\u683C\u89C6\u56FE\u83DC\u5355 - \u672A\u5173\u8054Canvas\u6587\u4EF6";
      }
    }
  }
  // æ›´æ–°æ“ä½œæŒ‰é’®å¯è§æ€§
  updateActionButtonsVisibility() {
    const linkBtn = this.containerEl.querySelector(".canvas-grid-action-btn:not(.canvas-grid-unlink-btn)");
    const unlinkBtn = this.containerEl.querySelector(".canvas-grid-unlink-btn");
    if (linkBtn && unlinkBtn) {
      if (this.linkedCanvasFile) {
        linkBtn.style.display = "none";
        unlinkBtn.style.display = "flex";
      } else {
        linkBtn.style.display = "flex";
        unlinkBtn.style.display = "none";
      }
    }
  }
  // åˆ·æ–°Canvasæ•°æ®
  async refreshCanvasData() {
    try {
      if (this.linkedCanvasFile) {
        await this.loadCanvasDataFromFile(this.linkedCanvasFile);
        new import_obsidian.Notice("Canvas\u6570\u636E\u5DF2\u5237\u65B0", 2e3);
      } else {
        await this.loadActiveCanvas();
      }
      this.initializeSearchAndSort();
      console.log("\u2705 Canvas data refreshed and sort reapplied");
    } catch (error) {
      console.error("Failed to refresh canvas data:", error);
      new import_obsidian.Notice("\u5237\u65B0\u6570\u636E\u5931\u8D25", 2e3);
    }
  }
  // è‡ªåŠ¨å…³è”å½“å‰Canvasæ–‡ä»¶
  async autoLinkCurrentCanvas() {
    try {
      const activeFile = this.app.workspace.getActiveFile();
      if (!activeFile || activeFile.extension !== "canvas") {
        new import_obsidian.Notice("\u8BF7\u5148\u6253\u5F00\u4E00\u4E2ACanvas\u6587\u4EF6");
        return;
      }
      await this.setLinkedCanvas(activeFile);
      new import_obsidian.Notice(`\u5DF2\u81EA\u52A8\u5173\u8054Canvas\u6587\u4EF6: ${activeFile.basename}`, 3e3);
      console.log("Auto-linked canvas file:", activeFile.path);
    } catch (error) {
      console.error("Failed to auto-link canvas file:", error);
      new import_obsidian.Notice("\u81EA\u52A8\u5173\u8054Canvas\u6587\u4EF6\u5931\u8D25");
    }
  }
  // ==================== æ–‡ä»¶ç›‘å¬äº‹ä»¶å¤„ç† ====================
  // å…³è”æ–‡ä»¶è¢«ä¿®æ”¹
  onLinkedFileModified(file) {
    console.log("Linked canvas file modified:", file.path);
    if (this.fileWatcherDisabled) {
      console.log("File watcher disabled, skipping update");
      return;
    }
    if (this.updateTimeout) {
      this.safeClearTimeout(this.updateTimeout);
    }
    this.updateTimeout = this.safeSetTimeout(async () => {
      try {
        if (this.fileWatcherDisabled) {
          console.log("File watcher disabled during timeout, skipping update");
          return;
        }
        await this.loadCanvasDataFromFile(file);
        new import_obsidian.Notice("Canvas\u6570\u636E\u5DF2\u540C\u6B65\u66F4\u65B0", 2e3);
      } catch (error) {
        console.error("Failed to sync canvas data:", error);
        new import_obsidian.Notice("\u540C\u6B65Canvas\u6570\u636E\u5931\u8D25");
      }
    }, 500);
  }
  // å…³è”æ–‡ä»¶è¢«åˆ é™¤
  onLinkedFileDeleted() {
    console.log("Linked canvas file deleted");
    this.linkedCanvasFile = null;
    this.canvasData = null;
    this.renderGrid();
    this.showMessage("\u5173\u8054\u7684Canvas\u6587\u4EF6\u5DF2\u88AB\u5220\u9664\uFF0C\u8BF7\u91CD\u65B0\u5173\u8054");
    this.updateLinkedCanvasDisplay(null);
    this.updateActionButtonsVisibility();
  }
  // å…³è”æ–‡ä»¶è¢«é‡å‘½å
  onLinkedFileRenamed(file) {
    console.log("Linked canvas file renamed:", file.path);
    this.linkedCanvasFile = file;
    this.updateLinkedCanvasDisplay(file);
    new import_obsidian.Notice(`\u5173\u8054\u6587\u4EF6\u5DF2\u91CD\u547D\u540D\u4E3A: ${file.basename}`, 3e3);
  }
  // é€šçŸ¥Canvasè§†å›¾åˆ·æ–°
  notifyCanvasViewRefresh() {
    if (!this.linkedCanvasFile)
      return;
    const canvasLeaves = this.app.workspace.getLeavesOfType("canvas");
    const targetLeaf = canvasLeaves.find((leaf) => {
      const view = leaf.view;
      return view.file?.path === this.linkedCanvasFile?.path;
    });
    if (targetLeaf) {
      console.log("Notifying canvas view to refresh");
      const canvasView = targetLeaf.view;
      if (canvasView.requestSave) {
        canvasView.requestSave();
      }
      if (canvasView.requestParse) {
        canvasView.requestParse();
      }
      if (canvasView.load && this.linkedCanvasFile) {
        canvasView.load(this.linkedCanvasFile);
      }
    }
  }
  // ==================== å®½åº¦æ§åˆ¶åŠŸèƒ½ ====================
  // åˆå§‹åŒ–å®½åº¦æ§åˆ¶
  initializeWidthControl() {
    const sidebarContainer = this.containerEl.closest(".workspace-leaf");
    if (!sidebarContainer)
      return;
    this.resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        this.handleWidthChange(entry.contentRect.width);
      }
    });
    this.resizeObserver.observe(sidebarContainer);
    const currentWidth = sidebarContainer.getBoundingClientRect().width;
    this.handleWidthChange(currentWidth);
  }
  // å¤„ç†å®½åº¦å˜åŒ–
  handleWidthChange(width) {
    const sidebarContainer = this.containerEl.closest(".workspace-leaf");
    if (!sidebarContainer)
      return;
    if (width < this.minWidth) {
      if (!this.isWidthLimited) {
        this.setCompactMode(sidebarContainer);
        this.isWidthLimited = true;
      }
    } else {
      if (this.isWidthLimited) {
        this.removeCompactMode(sidebarContainer);
        this.isWidthLimited = false;
      }
    }
  }
  // è®¾ç½®ç´§å‡‘æ¨¡å¼ï¼ˆä¸å¼ºåˆ¶å›ºå®šå®½åº¦ï¼‰
  setCompactMode(container) {
    container.classList.add("canvas-grid-compact-mode");
  }
  // ç§»é™¤ç´§å‡‘æ¨¡å¼
  removeCompactMode(container) {
    container.classList.remove("canvas-grid-compact-mode");
  }
  // ç§»é™¤äº†è‡ªåŠ¨éšè—ä¾§è¾¹æ çš„åŠŸèƒ½
  // ç°åœ¨è®©ç”¨æˆ·è‡ªå·±å†³å®šæ˜¯å¦éœ€è¦éšè—ä¾§è¾¹æ 
  // æ¸…ç†å®½åº¦æ§åˆ¶
  cleanupWidthControl() {
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
      this.resizeObserver = null;
    }
    const sidebarContainer = this.containerEl.closest(".workspace-leaf");
    if (sidebarContainer) {
      this.removeCompactMode(sidebarContainer);
    }
    this.isWidthLimited = false;
  }
};
var CanvasGridPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.canvasViewButtons = /* @__PURE__ */ new Map();
  }
  async onload() {
    await this.loadSettings();
    i18n.setLanguage(this.settings.language);
    this.registerView(
      CANVAS_GRID_VIEW_TYPE,
      (leaf) => new CanvasGridView(leaf, this)
    );
    let ribbonIconEl;
    try {
      ribbonIconEl = this.addRibbonIcon("grid", "Canvas\u7F51\u683C\u89C6\u56FE", (evt) => {
        this.activateView();
      });
    } catch (error) {
      try {
        ribbonIconEl = this.addRibbonIcon("layout", "Canvas\u7F51\u683C\u89C6\u56FE", (evt) => {
          this.activateView();
        });
      } catch (error2) {
        try {
          ribbonIconEl = this.addRibbonIcon("table", "Canvas\u7F51\u683C\u89C6\u56FE", (evt) => {
            this.activateView();
          });
        } catch (error3) {
          ribbonIconEl = this.addRibbonIcon("", "Canvas\u7F51\u683C\u89C6\u56FE", (evt) => {
            this.activateView();
          });
          ribbonIconEl.innerHTML = `
						<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
							<rect x="3" y="3" width="7" height="7"/>
							<rect x="14" y="3" width="7" height="7"/>
							<rect x="3" y="14" width="7" height="7"/>
							<rect x="14" y="14" width="7" height="7"/>
						</svg>
					`;
        }
      }
    }
    this.addCommand({
      id: "open-canvas-grid-view",
      name: "\u6253\u5F00Canvas\u7F51\u683C\u89C6\u56FE",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "time-capsule-collect",
      name: "\u65F6\u95F4\u80F6\u56CA\u6536\u96C6\u5185\u5BB9",
      hotkeys: [{ modifiers: ["Ctrl", "Shift"], key: "c" }],
      callback: () => {
        this.collectToTimeCapsule();
      }
    });
    this.addCommand({
      id: "toggle-time-capsule",
      name: "\u5207\u6362\u65F6\u95F4\u80F6\u56CA\u72B6\u6001",
      hotkeys: [{ modifiers: ["Ctrl", "Shift"], key: "t" }],
      callback: () => {
        this.toggleTimeCapsule();
      }
    });
    this.addSettingTab(new CanvasGridSettingTab(this.app, this));
    this.registerEvent(
      this.app.workspace.on("layout-change", () => {
        this.addCanvasViewButtons();
      })
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.addCanvasViewButtons();
      })
    );
    this.addCanvasViewButtons();
    console.log("\u{1F3A8} Canvasgrid Transit Plugin loaded - \u70ED\u91CD\u8F7D\u6D4B\u8BD5\u6210\u529F!");
  }
  onunload() {
    this.removeAllCanvasViewButtons();
  }
  // è·å–æ´»åŠ¨çš„ç½‘æ ¼è§†å›¾
  getActiveGridView() {
    const leaves = this.app.workspace.getLeavesOfType(CANVAS_GRID_VIEW_TYPE);
    if (leaves.length > 0) {
      return leaves[0].view;
    }
    return null;
  }
  // ä¸ºæ‰€æœ‰Canvasè§†å›¾æ·»åŠ åˆ‡æ¢æŒ‰é’®
  addCanvasViewButtons() {
    const leaves = this.app.workspace.getLeavesOfType("canvas");
    leaves.forEach((leaf) => {
      const canvasView = leaf.view;
      if (canvasView && canvasView.canvas && canvasView.containerEl) {
        this.addButtonToCanvasView(canvasView);
      }
    });
  }
  // ä¸ºå•ä¸ªCanvasè§†å›¾æ·»åŠ æŒ‰é’®
  addButtonToCanvasView(canvasView) {
    const containerEl = canvasView.containerEl;
    if (this.canvasViewButtons.has(containerEl)) {
      return;
    }
    console.log("Adding button to Canvas view");
    console.log("Container element:", containerEl);
    this.analyzeCanvasDOM(containerEl);
    const menuContainer = this.findCanvasMenuContainer(containerEl);
    if (menuContainer) {
      console.log("Found Canvas menu container:", menuContainer);
      this.addButtonToCanvasMenu(menuContainer, containerEl);
    } else {
      console.log("Canvas menu container not found, using fallback");
      this.addButtonToCanvasViewFallback(canvasView);
    }
  }
  // åˆ†æCanvas DOMç»“æ„
  analyzeCanvasDOM(containerEl) {
    console.log("=== Canvas DOM Structure Analysis ===");
    const toolbarSelectors = [
      ".canvas-controls",
      // Canvasæ§åˆ¶åŒºåŸŸ
      ".canvas-toolbar",
      // Canvaså·¥å…·æ 
      ".canvas-menu",
      // Canvasèœå•
      ".canvas-control-bar",
      // Canvasæ§åˆ¶æ 
      ".canvas-actions",
      // Canvasæ“ä½œåŒºåŸŸ
      ".canvas-buttons",
      // CanvasæŒ‰é’®åŒºåŸŸ
      ".canvas-tools",
      // Canvaså·¥å…·åŒºåŸŸ
      ".canvas-ui",
      // Canvas UIåŒºåŸŸ
      ".canvas-interface",
      // Canvasç•Œé¢åŒºåŸŸ
      '[class*="canvas"][class*="control"]',
      // åŒ…å«canvaså’Œcontrolçš„ç±»
      '[class*="canvas"][class*="toolbar"]',
      // åŒ…å«canvaså’Œtoolbarçš„ç±»
      '[class*="canvas"][class*="menu"]'
      // åŒ…å«canvaså’Œmenuçš„ç±»
    ];
    toolbarSelectors.forEach((selector) => {
      const elements = containerEl.querySelectorAll(selector);
      if (elements.length > 0) {
        console.log(`Found ${elements.length} elements with selector: ${selector}`);
        elements.forEach((el, index) => {
          console.log(`  [${index}]:`, el.className, el.getAttribute("aria-label"));
          const children = el.children;
          console.log(`    Children count: ${children.length}`);
          for (let i = 0; i < Math.min(children.length, 5); i++) {
            console.log(`    Child[${i}]:`, children[i].className, children[i].getAttribute("aria-label"));
          }
        });
      }
    });
    const iconElements = containerEl.querySelectorAll('.clickable-icon, [class*="icon"], [aria-label*="help"], [aria-label*="Help"], [aria-label*="\u5E2E\u52A9"]');
    console.log(`Found ${iconElements.length} icon elements:`);
    iconElements.forEach((el, index) => {
      console.log(`  Icon[${index}]:`, el.className, el.getAttribute("aria-label"), el.parentElement?.className);
    });
    const canvasSelectors = [
      ".canvas-wrapper",
      ".canvas-container",
      ".canvas-viewport"
    ];
    canvasSelectors.forEach((selector) => {
      const element = containerEl.querySelector(selector);
      if (element) {
        console.log(`Found Canvas element: ${selector}`, element);
      }
    });
  }
  // æŸ¥æ‰¾Canvasèœå•å®¹å™¨
  findCanvasMenuContainer(containerEl) {
    const toolbarSelectors = [
      ".canvas-controls",
      // Canvasæ§åˆ¶åŒºåŸŸ
      ".canvas-toolbar",
      // Canvaså·¥å…·æ 
      ".canvas-menu",
      // Canvasèœå•
      ".canvas-control-bar",
      // Canvasæ§åˆ¶æ 
      ".canvas-actions",
      // Canvasæ“ä½œåŒºåŸŸ
      '[class*="canvas"][class*="control"]',
      // åŒ…å«canvaså’Œcontrolçš„ç±»
      '[class*="canvas"][class*="toolbar"]'
      // åŒ…å«canvaså’Œtoolbarçš„ç±»
    ];
    for (const selector of toolbarSelectors) {
      const toolbar = containerEl.querySelector(selector);
      if (toolbar) {
        console.log(`Found Canvas toolbar with selector: ${selector}`);
        return toolbar;
      }
    }
    const helpButtons = containerEl.querySelectorAll('[aria-label*="help"], [aria-label*="Help"], [aria-label*="\u5E2E\u52A9"], [title*="help"], [title*="Help"], [title*="\u5E2E\u52A9"]');
    for (let i = 0; i < helpButtons.length; i++) {
      const helpButton = helpButtons[i];
      const parent = helpButton.parentElement;
      if (parent && this.isValidToolbarContainer(parent)) {
        console.log("Found toolbar container via help button:", parent);
        return parent;
      }
    }
    const fallbackSelectors = [
      ".view-actions",
      ".view-header-nav-buttons",
      ".workspace-leaf-header .view-actions",
      ".view-header"
    ];
    for (const selector of fallbackSelectors) {
      const container = containerEl.querySelector(selector);
      if (container) {
        console.log(`Found fallback menu container with selector: ${selector}`);
        return container;
      }
    }
    return null;
  }
  // éªŒè¯æ˜¯å¦ä¸ºæœ‰æ•ˆçš„å·¥å…·æ å®¹å™¨
  isValidToolbarContainer(element) {
    const icons = element.querySelectorAll('.clickable-icon, [class*="icon"]');
    return icons.length >= 2;
  }
  // å°†æŒ‰é’®æ·»åŠ åˆ°CanvasåŸç”Ÿèœå•ä¸­
  addButtonToCanvasMenu(menuContainer, containerEl) {
    const helpButton = this.findHelpButton(menuContainer);
    const gridButton = document.createElement("div");
    gridButton.className = "clickable-icon";
    gridButton.setAttribute("aria-label", "\u5207\u6362\u5230\u7F51\u683C\u89C6\u56FE");
    gridButton.setAttribute("data-tooltip-position", "left");
    gridButton.style.cssText = `
			border: 1px solid var(--background-modifier-border) !important;
			background: var(--background-secondary) !important;
			border-radius: 4px !important;
			box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1) !important;
		`;
    gridButton.innerHTML = `
			<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<rect x="3" y="3" width="7" height="7"/>
				<rect x="14" y="3" width="7" height="7"/>
				<rect x="3" y="14" width="7" height="7"/>
				<rect x="14" y="14" width="7" height="7"/>
			</svg>
		`;
    gridButton.onclick = () => {
      console.log("Grid button clicked from Canvas toolbar");
      this.activateViewWithAutoLink(containerEl);
    };
    if (helpButton && helpButton.parentElement === menuContainer) {
      const nextSibling = helpButton.nextSibling;
      if (nextSibling) {
        menuContainer.insertBefore(gridButton, nextSibling);
      } else {
        menuContainer.appendChild(gridButton);
      }
      console.log("Button inserted after help button");
    } else {
      menuContainer.appendChild(gridButton);
      console.log("Button appended to toolbar end");
    }
    console.log("Button added to Canvas toolbar successfully");
    this.canvasViewButtons.set(containerEl, gridButton);
  }
  // æŸ¥æ‰¾å¸®åŠ©æŒ‰é’®
  findHelpButton(container) {
    const helpSelectors = [
      '[aria-label*="help"]',
      '[aria-label*="Help"]',
      '[aria-label*="\u5E2E\u52A9"]',
      '[title*="help"]',
      '[title*="Help"]',
      '[title*="\u5E2E\u52A9"]'
    ];
    for (const selector of helpSelectors) {
      const helpButton = container.querySelector(selector);
      if (helpButton) {
        console.log("Found help button:", helpButton);
        return helpButton;
      }
    }
    return null;
  }
  // åˆ¤æ–­æ˜¯å¦ä¸ºå‚ç›´å·¥å…·æ 
  isVerticalToolbar(container) {
    const rect = container.getBoundingClientRect();
    return rect.height > rect.width;
  }
  // å›é€€æ–¹æ¡ˆï¼šæ·»åŠ åˆ°å³ä¸Šè§’ç‹¬ç«‹ä½ç½®
  addButtonToCanvasViewFallback(canvasView) {
    const containerEl = canvasView.containerEl;
    const canvasContainer = containerEl.querySelector(".canvas-wrapper") || containerEl.querySelector(".canvas-container") || containerEl.querySelector(".view-content") || containerEl;
    if (!canvasContainer) {
      console.log("Canvas container not found for fallback");
      return;
    }
    const buttonContainer = document.createElement("div");
    buttonContainer.style.cssText = `
			position: absolute;
			top: 10px;
			right: 10px;
			z-index: 1000;
		`;
    const gridButton = document.createElement("div");
    gridButton.className = "clickable-icon";
    gridButton.setAttribute("aria-label", "\u5207\u6362\u5230\u7F51\u683C\u89C6\u56FE");
    gridButton.setAttribute("data-tooltip-position", "left");
    gridButton.style.cssText = `
			background: var(--background-secondary) !important;
			border: 1px solid var(--background-modifier-border) !important;
			border-radius: 4px !important;
			box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1) !important;
		`;
    gridButton.innerHTML = `
			<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<rect x="3" y="3" width="7" height="7"/>
				<rect x="14" y="3" width="7" height="7"/>
				<rect x="3" y="14" width="7" height="7"/>
				<rect x="14" y="14" width="7" height="7"/>
			</svg>
		`;
    gridButton.onclick = () => {
      console.log("Grid button clicked from fallback position");
      this.activateViewWithAutoLink(containerEl);
    };
    buttonContainer.appendChild(gridButton);
    canvasContainer.appendChild(buttonContainer);
    console.log("Fallback button added successfully");
    this.canvasViewButtons.set(containerEl, buttonContainer);
  }
  // ç§»é™¤æ‰€æœ‰Canvasè§†å›¾æŒ‰é’®
  removeAllCanvasViewButtons() {
    this.canvasViewButtons.forEach((button, container) => {
      if (button.parentNode) {
        button.parentNode.removeChild(button);
      }
    });
    this.canvasViewButtons.clear();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // ==================== æ—¶é—´èƒ¶å›ŠåŠŸèƒ½æ–¹æ³• ====================
  // æ”¶é›†å†…å®¹åˆ°æ—¶é—´èƒ¶å›Š
  collectToTimeCapsule() {
    const gridView = this.getActiveGridView();
    if (!gridView) {
      new import_obsidian.Notice("\u8BF7\u5148\u6253\u5F00Canvas\u7F51\u683C\u89C6\u56FE");
      return;
    }
    if (!gridView.isTimeCapsuleActive()) {
      new import_obsidian.Notice("\u65F6\u95F4\u80F6\u56CA\u672A\u6FC0\u6D3B\uFF0C\u8BF7\u5148\u542F\u52A8\u65F6\u95F4\u80F6\u56CA");
      return;
    }
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (activeView) {
      const editor = activeView.editor;
      const selectedText = editor.getSelection();
      if (selectedText) {
        gridView.collectToTimeCapsule(selectedText, {
          sourceFile: activeView.file,
          sourcePath: activeView.file?.path || "",
          sourcePosition: {
            line: editor.getCursor("from").line,
            ch: editor.getCursor("from").ch
          }
        });
        new import_obsidian.Notice("\u5185\u5BB9\u5DF2\u6536\u96C6\u5230\u65F6\u95F4\u80F6\u56CA");
      } else {
        new import_obsidian.Notice("\u8BF7\u5148\u9009\u62E9\u8981\u6536\u96C6\u7684\u5185\u5BB9");
      }
    } else {
      navigator.clipboard.readText().then((text) => {
        if (text && text.trim()) {
          gridView.collectToTimeCapsule(text.trim(), {
            sourceFile: null,
            sourcePath: "\u526A\u8D34\u677F",
            sourcePosition: null
          });
          new import_obsidian.Notice("\u526A\u8D34\u677F\u5185\u5BB9\u5DF2\u6536\u96C6\u5230\u65F6\u95F4\u80F6\u56CA");
        } else {
          new import_obsidian.Notice("\u526A\u8D34\u677F\u4E3A\u7A7A\u6216\u65E0\u53EF\u6536\u96C6\u5185\u5BB9");
        }
      }).catch(() => {
        new import_obsidian.Notice("\u65E0\u6CD5\u8BBF\u95EE\u526A\u8D34\u677F");
      });
    }
  }
  // åˆ‡æ¢æ—¶é—´èƒ¶å›ŠçŠ¶æ€
  toggleTimeCapsule() {
    const gridView = this.getActiveGridView();
    if (!gridView) {
      new import_obsidian.Notice("\u8BF7\u5148\u6253\u5F00Canvas\u7F51\u683C\u89C6\u56FE");
      return;
    }
    gridView.toggleTimeCapsule();
  }
  async activateView() {
    const { workspace } = this.app;
    const activeFile = workspace.getActiveFile();
    let leaf = null;
    const leaves = workspace.getLeavesOfType(CANVAS_GRID_VIEW_TYPE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({ type: CANVAS_GRID_VIEW_TYPE, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
      if (activeFile && activeFile.extension === "canvas") {
        const gridView = leaf.view;
        if (gridView && gridView.setLinkedCanvas) {
          try {
            await gridView.setLinkedCanvas(activeFile);
            console.log("Auto-linked canvas file:", activeFile.path);
          } catch (error) {
            console.error("Failed to auto-link canvas file:", error);
          }
        }
      }
    }
  }
  // æ¿€æ´»è§†å›¾å¹¶è‡ªåŠ¨å…³è”Canvasæ–‡ä»¶
  async activateViewWithAutoLink(canvasContainer) {
    const { workspace } = this.app;
    let canvasFile = null;
    const activeFile = workspace.getActiveFile();
    if (activeFile && activeFile.extension === "canvas") {
      canvasFile = activeFile;
    }
    if (!canvasFile) {
      const canvasLeaves = workspace.getLeavesOfType("canvas");
      for (const leaf2 of canvasLeaves) {
        const canvasView = leaf2.view;
        if (canvasView && canvasView.file) {
          canvasFile = canvasView.file;
          break;
        }
      }
    }
    let leaf = null;
    const leaves = workspace.getLeavesOfType(CANVAS_GRID_VIEW_TYPE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({ type: CANVAS_GRID_VIEW_TYPE, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
      if (canvasFile) {
        const gridView = leaf.view;
        if (gridView && gridView.setLinkedCanvas) {
          try {
            await gridView.setLinkedCanvas(canvasFile);
            console.log("Auto-linked canvas file from button:", canvasFile.path);
          } catch (error) {
            console.error("Failed to auto-link canvas file from button:", error);
          }
        }
      }
    }
  }
};
var CanvasGridSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    i18n.setLanguage(this.plugin.settings.language);
    containerEl.createEl("h3", { text: i18n.t("gridLayoutSettings") });
    containerEl.createEl("p", {
      text: this.plugin.settings.language === "zh" ? "\u7F51\u683C\u5E03\u5C40\u4F7F\u7528\u56FA\u5B9A\u7684\u5361\u7247\u5C3A\u5BF8\u548C\u95F4\u8DDD\uFF0C\u81EA\u52A8\u9002\u5E94\u5C4F\u5E55\u5BBD\u5EA6\u3002" : "Grid layout uses fixed card dimensions and spacing, automatically adapting to screen width.",
      cls: "setting-item-description"
    });
    new import_obsidian.Setting(containerEl).setName(i18n.t("enableAutoLayout")).setDesc(this.plugin.settings.language === "zh" ? "\u81EA\u52A8\u8C03\u6574\u5361\u7247\u5E03\u5C40\u4EE5\u9002\u5E94\u5C4F\u5E55\uFF08\u63A8\u8350\u5F00\u542F\uFF09" : "Automatically adjust card layout to fit screen (recommended)").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableAutoLayout).onChange(async (value) => {
      this.plugin.settings.enableAutoLayout = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "\u{1F310} " + i18n.t("interfaceLanguage") });
    new import_obsidian.Setting(containerEl).setName(i18n.t("interfaceLanguage")).setDesc(this.plugin.settings.language === "zh" ? "\u9009\u62E9\u63D2\u4EF6\u754C\u9762\u663E\u793A\u8BED\u8A00" : "Select plugin interface display language").addDropdown((dropdown) => dropdown.addOption("zh", "\u4E2D\u6587 (\u7B80\u4F53)").addOption("en", "English").setValue(this.plugin.settings.language).onChange(async (value) => {
      this.plugin.settings.language = value;
      await this.plugin.saveSettings();
      this.display();
      this.updateAllGridViews();
    }));
    this.createUnifiedColorSection(containerEl);
    this.createAboutSection(containerEl);
  }
  // åˆ›å»ºç»Ÿä¸€çš„é¢œè‰²ç®¡ç†è®¾ç½®éƒ¨åˆ†
  createUnifiedColorSection(containerEl) {
    containerEl.createEl("h3", {
      text: "\u{1F3A8} " + (this.plugin.settings.language === "zh" ? "\u989C\u8272\u7BA1\u7406" : "Color Management")
    });
    const descContainer = containerEl.createDiv("unified-color-desc");
    descContainer.style.cssText = `
			background: var(--background-secondary);
			border-radius: 6px;
			padding: 12px;
			margin-bottom: 20px;
			border-left: 3px solid var(--interactive-accent);
		`;
    const descText = descContainer.createEl("p", {
      text: this.plugin.settings.language === "zh" ? "\u9009\u62E9\u8981\u5728\u989C\u8272\u7B5B\u9009\u5668\u4E2D\u663E\u793A\u7684\u989C\u8272\uFF08\u6700\u591A5\u4E2A\uFF09\u3002\u8FD9\u4E9B\u989C\u8272\u5C06\u663E\u793A\u4E3A\u641C\u7D22\u6846\u4E0B\u65B9\u7684\u7B5B\u9009\u5706\u70B9\u3002\u5728\u4E0B\u65B9\u9884\u89C8\u533A\u57DF\u53EF\u4EE5\u62D6\u62FD\u8C03\u6574\u989C\u8272\u663E\u793A\u987A\u5E8F\u3002" : "Select colors to display in the color filter (up to 5). These colors will appear as filter dots below the search box. Drag colors in the preview area to reorder them.",
      cls: "setting-item-description"
    });
    descText.style.cssText = `
			margin: 0;
			color: var(--text-muted);
			font-size: 13px;
			line-height: 1.4;
		`;
    this.createSelectableColorGrid(containerEl);
    this.createSelectedColorsPreview(containerEl);
  }
  // åˆ›å»ºå¯é€‰é¢œè‰²ç½‘æ ¼
  createSelectableColorGrid(containerEl) {
    const gridContainer = containerEl.createDiv("selectable-color-grid-container");
    gridContainer.style.cssText = `
			background: var(--background-primary);
			border: 1px solid var(--background-modifier-border);
			border-radius: 8px;
			padding: 20px;
			margin-bottom: 20px;
		`;
    const gridTitle = gridContainer.createEl("h4", {
      text: this.plugin.settings.language === "zh" ? "\u53EF\u9009\u989C\u8272" : "Available Colors",
      cls: "color-grid-title"
    });
    gridTitle.style.cssText = `
			margin: 0 0 16px 0;
			color: var(--text-normal);
			font-size: 14px;
			font-weight: 600;
		`;
    const colorGrid = gridContainer.createDiv("selectable-color-grid");
    colorGrid.style.cssText = `
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
			gap: 16px;
		`;
    const availableColors = [
      { value: "1", color: "#ff6b6b" },
      { value: "2", color: "#ffa726" },
      { value: "3", color: "#ffeb3b" },
      { value: "4", color: "#66bb6a" },
      { value: "5", color: "#26c6da" },
      { value: "6", color: "#42a5f5" },
      { value: "7", color: "#ab47bc" }
    ];
    availableColors.forEach((colorOption) => {
      this.createSelectableColorCard(colorGrid, colorOption);
    });
  }
  // åˆ›å»ºå¯é€‰æ‹©çš„é¢œè‰²å¡ç‰‡
  createSelectableColorCard(container, colorOption) {
    const isSelected = this.plugin.settings.colorFilterColors.includes(colorOption.value);
    const category = this.plugin.settings.colorCategories.find((cat) => cat.color === colorOption.value);
    const colorCard = container.createDiv("selectable-color-card");
    colorCard.style.cssText = `
			display: flex;
			flex-direction: column;
			align-items: center;
			padding: 20px 16px;
			border: 2px solid ${isSelected ? colorOption.color : "var(--background-modifier-border)"};
			border-radius: 8px;
			cursor: pointer;
			transition: all 0.2s ease;
			background: var(--background-secondary);
			position: relative;
			min-height: 140px;
		`;
    if (isSelected) {
      const checkmark = colorCard.createDiv("color-card-checkmark");
      checkmark.innerHTML = "\u2713";
      checkmark.style.cssText = `
				position: absolute;
				top: 8px;
				right: 8px;
				width: 20px;
				height: 20px;
				background: ${colorOption.color};
				color: white;
				border-radius: 50%;
				display: flex;
				align-items: center;
				justify-content: center;
				font-size: 12px;
				font-weight: bold;
				box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
			`;
    }
    const colorDot = colorCard.createDiv("color-dot");
    colorDot.style.cssText = `
			width: 40px;
			height: 40px;
			border-radius: 50%;
			background: ${colorOption.color};
			margin-bottom: 16px;
			box-shadow: 0 2px 8px ${colorOption.color}40;
			border: 3px solid white;
		`;
    const nameContainer = colorCard.createDiv("color-name-container");
    nameContainer.style.cssText = `
			width: 100%;
			text-align: center;
			margin-bottom: 8px;
		`;
    const nameDisplay = nameContainer.createEl("div", {
      text: category ? category.name : this.getDefaultColorName(colorOption.value),
      cls: "color-name-display"
    });
    nameDisplay.style.cssText = `
			font-size: 14px;
			font-weight: 600;
			color: var(--text-normal);
			cursor: text;
			padding: 4px 8px;
			border-radius: 4px;
			transition: background 0.2s ease;
		`;
    const descContainer = colorCard.createDiv("color-desc-container");
    descContainer.style.cssText = `
			width: 100%;
			text-align: center;
		`;
    const descDisplay = descContainer.createEl("div", {
      text: category ? category.description : "",
      cls: "color-desc-display"
    });
    descDisplay.style.cssText = `
			font-size: 11px;
			color: var(--text-muted);
			cursor: text;
			padding: 4px 8px;
			border-radius: 4px;
			transition: background 0.2s ease;
			min-height: 16px;
			line-height: 1.3;
		`;
    this.addInlineEditingToColorCard(nameDisplay, descDisplay, colorOption.value);
    colorCard.addEventListener("click", (e) => {
      if (e.target.classList.contains("color-name-display") || e.target.classList.contains("color-desc-display")) {
        return;
      }
      this.toggleColorSelection(colorOption.value);
    });
    colorCard.addEventListener("mouseenter", () => {
      if (!isSelected) {
        colorCard.style.borderColor = colorOption.color;
        colorCard.style.transform = "translateY(-2px)";
      }
    });
    colorCard.addEventListener("mouseleave", () => {
      if (!isSelected) {
        colorCard.style.borderColor = "var(--background-modifier-border)";
        colorCard.style.transform = "translateY(0)";
      }
    });
  }
  // æ·»åŠ å†…è”ç¼–è¾‘åŠŸèƒ½åˆ°é¢œè‰²å¡ç‰‡
  addInlineEditingToColorCard(nameDisplay, descDisplay, colorValue) {
    nameDisplay.addEventListener("dblclick", () => {
      this.startInlineEdit(nameDisplay, colorValue, "name");
    });
    descDisplay.addEventListener("dblclick", () => {
      this.startInlineEdit(descDisplay, colorValue, "description");
    });
    nameDisplay.addEventListener("mouseenter", () => {
      nameDisplay.style.background = "var(--background-modifier-hover)";
      nameDisplay.title = this.plugin.settings.language === "zh" ? "\u53CC\u51FB\u7F16\u8F91\u540D\u79F0" : "Double-click to edit name";
    });
    nameDisplay.addEventListener("mouseleave", () => {
      nameDisplay.style.background = "transparent";
    });
    descDisplay.addEventListener("mouseenter", () => {
      descDisplay.style.background = "var(--background-modifier-hover)";
      descDisplay.title = this.plugin.settings.language === "zh" ? "\u53CC\u51FB\u7F16\u8F91\u63CF\u8FF0" : "Double-click to edit description";
    });
    descDisplay.addEventListener("mouseleave", () => {
      descDisplay.style.background = "transparent";
    });
  }
  // å¼€å§‹å†…è”ç¼–è¾‘
  startInlineEdit(element, colorValue, field) {
    const currentText = element.textContent || "";
    const input = document.createElement(field === "description" ? "textarea" : "input");
    input.value = currentText;
    input.style.cssText = `
			width: 100%;
			background: var(--background-primary);
			border: 1px solid var(--interactive-accent);
			border-radius: 4px;
			padding: 4px 8px;
			font-size: ${field === "name" ? "14px" : "11px"};
			font-weight: ${field === "name" ? "600" : "normal"};
			color: var(--text-normal);
			text-align: center;
			resize: none;
			${field === "description" ? "min-height: 32px; line-height: 1.3;" : ""}
		`;
    element.style.display = "none";
    element.parentElement?.insertBefore(input, element);
    input.focus();
    input.select();
    const saveEdit = async () => {
      const newValue = input.value.trim();
      element.textContent = newValue;
      element.style.display = "block";
      input.remove();
      await this.updateColorCategory(colorValue, field, newValue);
    };
    const cancelEdit = () => {
      element.style.display = "block";
      input.remove();
    };
    input.addEventListener("blur", saveEdit);
    input.addEventListener("keydown", (e) => {
      const keyEvent = e;
      if (keyEvent.key === "Enter" && !keyEvent.shiftKey) {
        e.preventDefault();
        saveEdit();
      } else if (keyEvent.key === "Escape") {
        e.preventDefault();
        cancelEdit();
      }
    });
  }
  // æ›´æ–°é¢œè‰²åˆ†ç±»
  async updateColorCategory(colorValue, field, newValue) {
    let category = this.plugin.settings.colorCategories.find((cat) => cat.color === colorValue);
    if (!category) {
      const defaultName = this.getDefaultColorName(colorValue);
      category = {
        id: `color-${colorValue}`,
        name: field === "name" ? newValue : defaultName,
        description: field === "description" ? newValue : "",
        color: colorValue
      };
      this.plugin.settings.colorCategories.push(category);
    } else {
      if (field === "name") {
        category.name = newValue;
      } else {
        category.description = newValue;
      }
    }
    await this.plugin.saveSettings();
    this.updateAllGridViews();
  }
  // åˆ‡æ¢é¢œè‰²é€‰æ‹©çŠ¶æ€
  async toggleColorSelection(colorValue) {
    const currentColors = [...this.plugin.settings.colorFilterColors];
    const isCurrentlySelected = currentColors.includes(colorValue);
    if (isCurrentlySelected) {
      const index = currentColors.indexOf(colorValue);
      if (index > -1) {
        currentColors.splice(index, 1);
      }
    } else {
      if (currentColors.length < 5) {
        currentColors.push(colorValue);
      } else {
        new import_obsidian.Notice(this.plugin.settings.language === "zh" ? "\u6700\u591A\u53EA\u80FD\u9009\u62E95\u4E2A\u989C\u8272" : "Maximum 5 colors can be selected");
        return;
      }
    }
    this.plugin.settings.colorFilterColors = currentColors;
    await this.plugin.saveSettings();
    this.updateAllGridViews();
    this.display();
  }
  // åˆ›å»ºå·²é€‰æ‹©é¢œè‰²é¢„è§ˆ
  createSelectedColorsPreview(containerEl) {
    const previewContainer = containerEl.createDiv("selected-colors-preview");
    previewContainer.style.cssText = `
			background: var(--background-secondary);
			border-radius: 6px;
			padding: 16px;
			margin-bottom: 20px;
		`;
    const previewHeader = previewContainer.createDiv("preview-header");
    previewHeader.style.cssText = `
			display: flex;
			align-items: center;
			justify-content: space-between;
			margin-bottom: 12px;
		`;
    const statusText = previewHeader.createEl("span", {
      text: this.plugin.settings.language === "zh" ? `\u5DF2\u9009\u62E9 ${this.plugin.settings.colorFilterColors.length}/5 \u4E2A\u989C\u8272` : `Selected ${this.plugin.settings.colorFilterColors.length}/5 colors`,
      cls: "selected-colors-status"
    });
    statusText.style.cssText = `
			color: var(--text-muted);
			font-size: 13px;
		`;
    const sortHint = previewHeader.createEl("span", {
      text: this.plugin.settings.language === "zh" ? "\u62D6\u62FD\u8C03\u6574\u987A\u5E8F" : "Drag to reorder",
      cls: "sort-hint"
    });
    sortHint.style.cssText = `
			color: var(--text-muted);
			font-size: 11px;
			font-style: italic;
		`;
    const sortableContainer = previewContainer.createDiv("sortable-preview-container");
    sortableContainer.style.cssText = `
			display: flex;
			gap: 8px;
			flex-wrap: wrap;
			min-height: 40px;
			padding: 8px;
			border: 1px dashed var(--background-modifier-border);
			border-radius: 4px;
			background: var(--background-primary);
		`;
    this.renderSortableColorDots(sortableContainer);
  }
  // åˆ›å»ºé¢œè‰²é€‰æ‹©ç½‘æ ¼
  createColorSelectionGrid(container) {
    const colorGridContainer = container.createDiv("color-filter-grid-container");
    colorGridContainer.style.cssText = `
			background: var(--background-primary);
			border: 1px solid var(--background-modifier-border);
			border-radius: 8px;
			padding: 20px;
			margin-bottom: 16px;
		`;
    const gridTitle = colorGridContainer.createEl("h4", {
      text: this.plugin.settings.language === "zh" ? "\u53EF\u9009\u989C\u8272" : "Available Colors",
      cls: "color-grid-title"
    });
    gridTitle.style.cssText = `
			margin: 0 0 16px 0;
			color: var(--text-normal);
			font-size: 14px;
			font-weight: 600;
		`;
    const colorGrid = colorGridContainer.createDiv("color-filter-grid");
    colorGrid.style.cssText = `
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
			gap: 12px;
		`;
    const availableColors = [
      { value: "1", color: "#ff6b6b", emoji: "\u{1F534}" },
      { value: "2", color: "#ffa726", emoji: "\u{1F7E0}" },
      { value: "3", color: "#ffeb3b", emoji: "\u{1F7E1}" },
      { value: "4", color: "#66bb6a", emoji: "\u{1F7E2}" },
      { value: "5", color: "#26c6da", emoji: "\u{1F535}" },
      { value: "6", color: "#42a5f5", emoji: "\u{1F535}" },
      { value: "7", color: "#ab47bc", emoji: "\u{1F7E3}" }
    ];
    availableColors.forEach((colorOption) => {
      const colorCard = colorGrid.createDiv("color-filter-card");
      const isSelected = this.plugin.settings.colorFilterColors.includes(colorOption.value);
      const category = this.plugin.settings.colorCategories.find((cat) => cat.color === colorOption.value);
      const displayName = category ? category.name : this.getDefaultColorName(colorOption.value);
      const description = category ? category.description : "";
      colorCard.style.cssText = `
				display: flex;
				flex-direction: column;
				align-items: center;
				padding: 16px 12px;
				border: 2px solid ${isSelected ? colorOption.color : "var(--background-modifier-border)"};
				border-radius: 8px;
				cursor: pointer;
				transition: all 0.2s ease;
				background: ${isSelected ? colorOption.color + "10" : "var(--background-secondary)"};
				position: relative;
				min-height: 120px;
			`;
      const colorPreview = colorCard.createDiv("color-preview-large");
      colorPreview.style.cssText = `
				width: 36px;
				height: 36px;
				border-radius: 50%;
				background: ${colorOption.color};
				margin-bottom: 12px;
				box-shadow: 0 2px 8px ${colorOption.color}40;
				border: 2px solid white;
			`;
      const colorName = colorCard.createEl("div", {
        text: displayName,
        cls: "color-card-name"
      });
      colorName.style.cssText = `
				font-size: 13px;
				font-weight: 600;
				color: var(--text-normal);
				text-align: center;
				margin-bottom: 4px;
			`;
      if (description) {
        const colorDesc = colorCard.createEl("div", {
          text: description,
          cls: "color-card-desc"
        });
        colorDesc.style.cssText = `
					font-size: 11px;
					color: var(--text-muted);
					text-align: center;
					line-height: 1.3;
					margin-bottom: 8px;
				`;
      }
      if (isSelected) {
        const checkmark = colorCard.createDiv("color-card-checkmark");
        checkmark.innerHTML = "\u2713";
        checkmark.style.cssText = `
					position: absolute;
					top: 6px;
					right: 6px;
					width: 18px;
					height: 18px;
					background: ${colorOption.color};
					color: white;
					border-radius: 50%;
					display: flex;
					align-items: center;
					justify-content: center;
					font-size: 11px;
					font-weight: bold;
					box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
				`;
      }
      colorCard.addEventListener("click", async () => {
        const currentColors = [...this.plugin.settings.colorFilterColors];
        const isCurrentlySelected = currentColors.includes(colorOption.value);
        if (isCurrentlySelected) {
          const index = currentColors.indexOf(colorOption.value);
          if (index > -1) {
            currentColors.splice(index, 1);
          }
        } else {
          if (currentColors.length < 5) {
            currentColors.push(colorOption.value);
          } else {
            new import_obsidian.Notice(this.plugin.settings.language === "zh" ? "\u6700\u591A\u53EA\u80FD\u9009\u62E95\u4E2A\u989C\u8272" : "Maximum 5 colors can be selected");
            return;
          }
        }
        this.plugin.settings.colorFilterColors = currentColors;
        await this.plugin.saveSettings();
        this.updateAllGridViews();
        this.display();
      });
      colorCard.addEventListener("mouseenter", () => {
        if (!isSelected) {
          colorCard.style.borderColor = colorOption.color;
          colorCard.style.background = colorOption.color + "08";
          colorCard.style.transform = "translateY(-2px)";
        }
      });
      colorCard.addEventListener("mouseleave", () => {
        if (!isSelected) {
          colorCard.style.borderColor = "var(--background-modifier-border)";
          colorCard.style.background = "var(--background-secondary)";
          colorCard.style.transform = "translateY(0)";
        }
      });
    });
  }
  // åˆ›å»ºå¯æ’åºçš„é¢œè‰²é¢„è§ˆ
  createSortableColorPreview(container) {
    const statusContainer = container.createDiv("color-filter-status");
    statusContainer.style.cssText = `
			background: var(--background-secondary);
			border-radius: 6px;
			margin-bottom: 20px;
			padding: 16px;
		`;
    const statusHeader = statusContainer.createDiv("status-header");
    statusHeader.style.cssText = `
			display: flex;
			align-items: center;
			justify-content: space-between;
			margin-bottom: 12px;
		`;
    const statusText = statusHeader.createEl("span", {
      text: this.plugin.settings.language === "zh" ? `\u5DF2\u9009\u62E9 ${this.plugin.settings.colorFilterColors.length}/5 \u4E2A\u989C\u8272` : `Selected ${this.plugin.settings.colorFilterColors.length}/5 colors`,
      cls: "color-filter-status-text"
    });
    statusText.style.cssText = `
			color: var(--text-muted);
			font-size: 13px;
		`;
    const sortHint = statusHeader.createEl("span", {
      text: this.plugin.settings.language === "zh" ? "\u62D6\u62FD\u8C03\u6574\u987A\u5E8F" : "Drag to reorder",
      cls: "sort-hint"
    });
    sortHint.style.cssText = `
			color: var(--text-muted);
			font-size: 11px;
			font-style: italic;
		`;
    const sortableContainer = statusContainer.createDiv("sortable-color-container");
    sortableContainer.style.cssText = `
			display: flex;
			gap: 8px;
			flex-wrap: wrap;
			min-height: 40px;
			padding: 8px;
			border: 1px dashed var(--background-modifier-border);
			border-radius: 4px;
			background: var(--background-primary);
		`;
    this.renderSortableColorDots(sortableContainer);
  }
  // è·å–é»˜è®¤é¢œè‰²åç§°
  getDefaultColorName(colorValue) {
    const colorNames = {
      "1": this.plugin.settings.language === "zh" ? "\u7EA2\u8272" : "Red",
      "2": this.plugin.settings.language === "zh" ? "\u6A59\u8272" : "Orange",
      "3": this.plugin.settings.language === "zh" ? "\u9EC4\u8272" : "Yellow",
      "4": this.plugin.settings.language === "zh" ? "\u7EFF\u8272" : "Green",
      "5": this.plugin.settings.language === "zh" ? "\u9752\u8272" : "Cyan",
      "6": this.plugin.settings.language === "zh" ? "\u84DD\u8272" : "Blue",
      "7": this.plugin.settings.language === "zh" ? "\u7D2B\u8272" : "Purple"
    };
    return colorNames[colorValue] || colorValue;
  }
  // åˆ›å»ºé¢œè‰²åˆ†ç±»åˆ—è¡¨
  createColorCategoryList(containerEl) {
    const categoryContainer = containerEl.createDiv("color-category-list");
    categoryContainer.style.cssText = `
			background: var(--background-primary);
			border: 1px solid var(--background-modifier-border);
			border-radius: 8px;
			padding: 20px;
			margin-bottom: 16px;
		`;
    const listTitle = categoryContainer.createEl("h4", {
      text: this.plugin.settings.language === "zh" ? "\u989C\u8272\u5206\u7C7B\u914D\u7F6E" : "Color Category Configuration",
      cls: "color-category-title"
    });
    listTitle.style.cssText = `
			margin: 0 0 16px 0;
			color: var(--text-normal);
			font-size: 14px;
			font-weight: 600;
		`;
    this.plugin.settings.colorCategories.forEach((category, index) => {
      this.createColorCategoryItem(categoryContainer, category, index);
    });
  }
  // åˆ›å»ºå•ä¸ªé¢œè‰²åˆ†ç±»é¡¹
  createColorCategoryItem(container, category, index) {
    const itemContainer = container.createDiv("color-category-item");
    itemContainer.style.cssText = `
			display: flex;
			align-items: center;
			gap: 12px;
			padding: 12px;
			border: 1px solid var(--background-modifier-border);
			border-radius: 6px;
			margin-bottom: 8px;
			background: var(--background-secondary);
		`;
    const colorDot = itemContainer.createDiv("color-category-dot");
    colorDot.style.cssText = `
			width: 24px;
			height: 24px;
			border-radius: 50%;
			background: ${this.getColorValue(category.color)};
			border: 2px solid var(--background-modifier-border);
			flex-shrink: 0;
		`;
    const infoContainer = itemContainer.createDiv("color-category-info");
    infoContainer.style.cssText = `
			flex: 1;
			min-width: 0;
		`;
    const nameEl = infoContainer.createEl("div", {
      text: category.name,
      cls: "color-category-name"
    });
    nameEl.style.cssText = `
			font-weight: 600;
			color: var(--text-normal);
			margin-bottom: 4px;
		`;
    const descEl = infoContainer.createEl("div", {
      text: category.description,
      cls: "color-category-desc"
    });
    descEl.style.cssText = `
			font-size: 12px;
			color: var(--text-muted);
			line-height: 1.3;
		`;
    const editBtn = itemContainer.createEl("button", {
      text: this.plugin.settings.language === "zh" ? "\u7F16\u8F91" : "Edit",
      cls: "mod-cta"
    });
    editBtn.style.cssText = `
			padding: 4px 12px;
			font-size: 12px;
		`;
    editBtn.onclick = () => {
      this.openColorCategoryEditor(category, index);
    };
  }
  // è·å–é¢œè‰²å€¼
  getColorValue(colorId) {
    const colorMap = {
      "1": "#ff6b6b",
      // çº¢è‰²
      "2": "#ffa726",
      // æ©™è‰²
      "3": "#ffeb3b",
      // é»„è‰²
      "4": "#66bb6a",
      // ç»¿è‰²
      "5": "#26c6da",
      // é’è‰²
      "6": "#42a5f5",
      // è“è‰²
      "7": "#ab47bc"
      // ç´«è‰²
    };
    return colorMap[colorId] || "#999999";
  }
  // æ‰“å¼€é¢œè‰²åˆ†ç±»ç¼–è¾‘å™¨
  openColorCategoryEditor(category, index) {
    new ColorCategoryEditModal(this.app, this.plugin, category, index, () => {
      this.display();
    }).open();
  }
  // æ¸²æŸ“å¯æ’åºçš„é¢œè‰²åœ†ç‚¹
  renderSortableColorDots(container) {
    container.empty();
    const colorMap = {
      "1": "#ff6b6b",
      "2": "#ffa726",
      "3": "#ffeb3b",
      "4": "#66bb6a",
      "5": "#26c6da",
      "6": "#42a5f5",
      "7": "#ab47bc"
    };
    const colorNames = {
      "1": this.plugin.settings.language === "zh" ? "\u7EA2\u8272" : "Red",
      "2": this.plugin.settings.language === "zh" ? "\u6A59\u8272" : "Orange",
      "3": this.plugin.settings.language === "zh" ? "\u9EC4\u8272" : "Yellow",
      "4": this.plugin.settings.language === "zh" ? "\u7EFF\u8272" : "Green",
      "5": this.plugin.settings.language === "zh" ? "\u9752\u8272" : "Cyan",
      "6": this.plugin.settings.language === "zh" ? "\u84DD\u8272" : "Blue",
      "7": this.plugin.settings.language === "zh" ? "\u7D2B\u8272" : "Purple"
    };
    this.plugin.settings.colorFilterColors.forEach((colorValue, index) => {
      const colorDot = container.createDiv("sortable-color-dot");
      colorDot.draggable = true;
      colorDot.dataset.colorValue = colorValue;
      colorDot.dataset.index = index.toString();
      colorDot.style.cssText = `
				width: 32px;
				height: 32px;
				border-radius: 50%;
				background: ${colorMap[colorValue]};
				border: 2px solid white;
				box-shadow: 0 2px 8px ${colorMap[colorValue]}40;
				cursor: grab;
				transition: all 0.2s ease;
				position: relative;
				display: flex;
				align-items: center;
				justify-content: center;
			`;
      colorDot.title = colorNames[colorValue] || colorValue;
      colorDot.addEventListener("dragstart", (e) => {
        colorDot.style.cursor = "grabbing";
        colorDot.style.opacity = "0.5";
        e.dataTransfer.setData("text/plain", index.toString());
        e.dataTransfer.effectAllowed = "move";
      });
      colorDot.addEventListener("dragend", () => {
        colorDot.style.cursor = "grab";
        colorDot.style.opacity = "1";
      });
      colorDot.addEventListener("dragover", (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = "move";
      });
      colorDot.addEventListener("drop", async (e) => {
        e.preventDefault();
        const draggedIndex = parseInt(e.dataTransfer.getData("text/plain"));
        const targetIndex = index;
        if (draggedIndex !== targetIndex) {
          const newColors = [...this.plugin.settings.colorFilterColors];
          const draggedColor = newColors.splice(draggedIndex, 1)[0];
          newColors.splice(targetIndex, 0, draggedColor);
          this.plugin.settings.colorFilterColors = newColors;
          await this.plugin.saveSettings();
          this.updateAllGridViews();
          this.renderSortableColorDots(container);
        }
      });
      colorDot.addEventListener("mouseenter", () => {
        colorDot.style.transform = "scale(1.1)";
      });
      colorDot.addEventListener("mouseleave", () => {
        colorDot.style.transform = "scale(1)";
      });
    });
    if (this.plugin.settings.colorFilterColors.length === 0) {
      const emptyHint = container.createDiv("empty-hint");
      emptyHint.textContent = this.plugin.settings.language === "zh" ? "\u8BF7\u5728\u4E0A\u65B9\u9009\u62E9\u989C\u8272" : "Please select colors above";
      emptyHint.style.cssText = `
				color: var(--text-muted);
				font-size: 12px;
				font-style: italic;
				text-align: center;
				padding: 8px;
			`;
    }
  }
  // åˆ›å»ºå…³äºæ’ä»¶éƒ¨åˆ†
  createAboutSection(containerEl) {
    const separator = containerEl.createEl("hr");
    separator.style.cssText = `
			border: none;
			border-top: 1px solid var(--background-modifier-border);
			margin: 32px 0 24px 0;
		`;
    const titleEl = containerEl.createEl("h2", {
      text: this.plugin.settings.language === "zh" ? "\u{1F3A8} \u5173\u4E8E Canvasgrid Transit" : "\u{1F3A8} About Canvasgrid Transit",
      cls: "plugin-intro-title"
    });
    titleEl.style.cssText = `
			color: var(--interactive-accent);
			margin-bottom: 8px;
			font-size: 24px;
			font-weight: 600;
		`;
    const versionEl = containerEl.createEl("div", {
      text: "v0.5.1",
      cls: "plugin-intro-version"
    });
    versionEl.style.cssText = `
			color: var(--text-muted);
			font-size: 12px;
			margin-bottom: 16px;
			font-weight: 500;
		`;
    const descEl = containerEl.createEl("p", {
      text: this.plugin.settings.language === "zh" ? "\u4E3A Obsidian Canvas \u63D0\u4F9B\u5F3A\u5927\u7684\u7F51\u683C\u5361\u7247\u89C6\u56FE\uFF0C\u96C6\u6210\u667A\u80FD\u641C\u7D22\u3001\u989C\u8272\u7B5B\u9009\u3001\u5206\u7EC4\u7BA1\u7406\u3001\u65F6\u95F4\u80F6\u56CA\u6536\u96C6\u3001\u5FEB\u901F\u4E66\u7B7E\u89E3\u6790\u7B49\u521B\u65B0\u529F\u80FD\uFF0C\u8BA9\u60A8\u7684\u77E5\u8BC6\u7BA1\u7406\u66F4\u52A0\u9AD8\u6548\u4FBF\u6377\u3002" : "Powerful grid card view for Obsidian Canvas with intelligent search, color filtering, group management, time capsule collection, fast bookmark parsing and other innovative features for efficient knowledge management.",
      cls: "plugin-intro-desc"
    });
    descEl.style.cssText = `
			color: var(--text-normal);
			font-size: 14px;
			line-height: 1.5;
			margin-bottom: 20px;
		`;
    const featuresContainer = containerEl.createDiv("plugin-intro-features");
    featuresContainer.style.cssText = `
			background: var(--background-secondary);
			border-radius: 8px;
			padding: 16px;
			margin-bottom: 24px;
			border: 1px solid var(--background-modifier-border);
		`;
    const featuresTitle = featuresContainer.createEl("h4", {
      text: "\u2728 " + i18n.t("mainFeatures"),
      cls: "plugin-intro-features-title"
    });
    featuresTitle.style.cssText = `
			color: var(--text-normal);
			margin-bottom: 12px;
			font-size: 14px;
			font-weight: 600;
		`;
    const featuresList = this.plugin.settings.language === "zh" ? [
      "\u{1F50D} \u667A\u80FD\u641C\u7D22 - \u652F\u6301\u5185\u5BB9\u3001\u6587\u4EF6\u540D\u3001URL\u5168\u6587\u641C\u7D22",
      "\u{1F3A8} \u989C\u8272\u7B5B\u9009 - \u53EF\u914D\u7F6E\u989C\u8272\u5206\u7C7B\u548C\u4E00\u952E\u7B5B\u9009",
      "\u{1F4F1} \u54CD\u5E94\u5F0F\u5E03\u5C40 - \u81EA\u9002\u5E94\u5C4F\u5E55\u5BBD\u5EA6\u7684\u7F51\u683C\u5E03\u5C40",
      "\u{1F5C2}\uFE0F \u5206\u7EC4\u7BA1\u7406 - Canvas\u5206\u7EC4\u7684\u5361\u7247\u5316\u663E\u793A\u548C\u7F16\u8F91",
      "\u23F0 \u65F6\u95F4\u80F6\u56CA - \u521B\u65B0\u7684\u5185\u5BB9\u6536\u96C6\u548C\u65F6\u95F4\u7BA1\u7406\u529F\u80FD",
      "\u{1F517} \u5FEB\u901F\u4E66\u7B7E - \u7F51\u9875\u94FE\u63A5\u7684\u77AC\u95F4\u89E3\u6790\u548C\u7F8E\u89C2\u5C55\u793A",
      "\u270F\uFE0F \u5B9E\u65F6\u7F16\u8F91 - \u76F4\u63A5\u5728\u7F51\u683C\u89C6\u56FE\u4E2D\u7F16\u8F91\u5361\u7247\u5185\u5BB9",
      "\u{1F3AF} \u7CBE\u51C6\u5B9A\u4F4D - \u4E00\u952E\u805A\u7126\u5230Canvas\u4E2D\u7684\u5177\u4F53\u8282\u70B9",
      "\u{1F504} \u53CC\u5411\u540C\u6B65 - \u4E0ECanvas\u767D\u677F\u7684\u5B9E\u65F6\u6570\u636E\u540C\u6B65",
      "\u{1F310} \u591A\u8BED\u8A00 - \u652F\u6301\u4E2D\u6587\u548C\u82F1\u6587\u754C\u9762\u5207\u6362"
    ] : [
      "\u{1F50D} Smart Search - Full-text search for content, filenames, and URLs",
      "\u{1F3A8} Color Filtering - Configurable color categories and one-click filtering",
      "\u{1F4F1} Responsive Layout - Grid layout that adapts to screen width",
      "\u{1F5C2}\uFE0F Group Management - Card-based display and editing of Canvas groups",
      "\u23F0 Time Capsule - Innovative content collection and time management",
      "\u{1F517} Fast Bookmarks - Instant parsing and beautiful display of web links",
      "\u270F\uFE0F Real-time Editing - Direct card content editing in grid view",
      "\u{1F3AF} Precise Navigation - One-click focus to specific Canvas nodes",
      "\u{1F504} Bidirectional Sync - Real-time data sync with Canvas whiteboard",
      "\u{1F310} Multi-language - Support for Chinese and English interface"
    ];
    featuresList.forEach((feature) => {
      const featureItem = featuresContainer.createEl("div", {
        text: feature,
        cls: "plugin-intro-feature-item"
      });
      featureItem.style.cssText = `
				color: var(--text-muted);
				font-size: 13px;
				margin-bottom: 6px;
				padding-left: 8px;
			`;
    });
    this.createSupportSection(containerEl);
  }
  // åˆ›å»ºæ„Ÿè°¢å’Œæ”¯æŒéƒ¨åˆ†
  createSupportSection(containerEl) {
    const thanksContainer = containerEl.createDiv("plugin-thanks-section");
    thanksContainer.style.cssText = `
			background: linear-gradient(135deg, var(--interactive-accent)20, var(--interactive-accent)10);
			border-radius: 12px;
			padding: 20px;
			margin-bottom: 20px;
			border: 1px solid var(--interactive-accent)40;
		`;
    const thanksTitle = thanksContainer.createEl("h4", {
      text: "\u{1F49D} " + i18n.t("thanks"),
      cls: "plugin-thanks-title"
    });
    thanksTitle.style.cssText = `
			color: var(--interactive-accent);
			margin-bottom: 12px;
			font-size: 16px;
			font-weight: 600;
		`;
    const thanksText = thanksContainer.createEl("p", {
      text: this.plugin.settings.language === "zh" ? "\u611F\u8C22\u60A8\u9009\u62E9 Canvasgrid Transit\uFF01\u8FD9\u4E2A\u63D2\u4EF6\u878D\u5408\u4E86\u521B\u65B0\u7684\u65F6\u95F4\u80F6\u56CA\u3001\u667A\u80FD\u4E66\u7B7E\u89E3\u6790\u3001\u5206\u7EC4\u7BA1\u7406\u7B49\u529F\u80FD\uFF0C\u81F4\u529B\u4E8E\u63D0\u5347\u60A8\u7684\u77E5\u8BC6\u7BA1\u7406\u4F53\u9A8C\u3002\u60A8\u7684\u6BCF\u4E00\u4E2A\u53CD\u9988\u90FD\u662F\u6211\u4EEC\u524D\u8FDB\u7684\u52A8\u529B\uFF01" : "Thank you for choosing Canvasgrid Transit! This plugin integrates innovative features like time capsule, intelligent bookmark parsing, and group management to enhance your knowledge management experience. Every feedback from you is our driving force!",
      cls: "plugin-thanks-text"
    });
    const specialThanks = thanksContainer.createEl("div", {
      cls: "plugin-special-thanks"
    });
    specialThanks.style.cssText = `
			margin-top: 16px;
			padding: 12px;
			background: var(--background-secondary);
			border-radius: 6px;
			border-left: 3px solid var(--interactive-accent);
		`;
    const obsidianThanks = specialThanks.createEl("p", {
      text: this.plugin.settings.language === "zh" ? "\u{1F64F} \u7279\u522B\u611F\u8C22 Obsidian \u56E2\u961F\u521B\u9020\u4E86\u5982\u6B64\u4F18\u79C0\u7684\u77E5\u8BC6\u7BA1\u7406\u5E73\u53F0\uFF0C\u4E3A\u6211\u4EEC\u7684\u521B\u65B0\u63D0\u4F9B\u4E86\u65E0\u9650\u53EF\u80FD\u3002" : "\u{1F64F} Special thanks to the Obsidian team for creating such an excellent knowledge management platform, providing infinite possibilities for our innovation.",
      cls: "plugin-obsidian-thanks"
    });
    obsidianThanks.style.cssText = `
			color: var(--text-muted);
			font-size: 12px;
			margin-bottom: 8px;
			font-style: italic;
		`;
    const designInspiration = specialThanks.createEl("p", {
      text: this.plugin.settings.language === "zh" ? "\u23F0 \u65F6\u95F4\u80F6\u56CA\u529F\u80FD\u7684\u8BBE\u8BA1\u7075\u611F\u6765\u6E90\u4E8E\u9524\u5B50\u79D1\u6280 Smartisan \u7684\u65F6\u95F4\u80F6\u56CA\uFF0C\u81F4\u656C\u7ECF\u5178\u7684\u521B\u65B0\u8BBE\u8BA1\u7406\u5FF5\u3002" : "\u23F0 The time capsule feature design is inspired by Smartisan's time capsule from Hammer Technology, paying tribute to classic innovative design concepts.",
      cls: "plugin-design-inspiration"
    });
    designInspiration.style.cssText = `
			color: var(--text-muted);
			font-size: 12px;
			margin: 0;
			font-style: italic;
		`;
    thanksText.style.cssText = `
			color: var(--text-normal);
			font-size: 14px;
			line-height: 1.5;
			margin-bottom: 16px;
		`;
    const supportButtons = thanksContainer.createDiv("plugin-support-buttons");
    supportButtons.style.cssText = `
			display: flex;
			gap: 12px;
			flex-wrap: wrap;
		`;
    const feedbackBtn = supportButtons.createEl("button", {
      text: "\u{1F4AC} " + i18n.t("feedback"),
      cls: "plugin-support-btn"
    });
    feedbackBtn.style.cssText = `
			background: var(--interactive-accent);
			color: white;
			border: none;
			padding: 8px 16px;
			border-radius: 6px;
			font-size: 13px;
			cursor: pointer;
			transition: all 0.2s ease;
			font-weight: 500;
		`;
    feedbackBtn.onmouseover = () => {
      feedbackBtn.style.background = "var(--interactive-accent-hover)";
      feedbackBtn.style.transform = "translateY(-1px)";
    };
    feedbackBtn.onmouseout = () => {
      feedbackBtn.style.background = "var(--interactive-accent)";
      feedbackBtn.style.transform = "translateY(0)";
    };
    feedbackBtn.onclick = () => {
      window.open("https://github.com/zhuzhige123/Canvasgrid-Transit", "_blank");
    };
    const contactBtn = supportButtons.createEl("button", {
      text: "\u{1F4E7} " + i18n.t("contact"),
      cls: "plugin-support-btn"
    });
    contactBtn.style.cssText = `
			background: var(--background-modifier-border);
			color: var(--text-normal);
			border: 1px solid var(--background-modifier-border);
			padding: 8px 16px;
			border-radius: 6px;
			font-size: 13px;
			cursor: pointer;
			transition: all 0.2s ease;
			font-weight: 500;
		`;
    contactBtn.onmouseover = () => {
      contactBtn.style.background = "var(--background-modifier-hover)";
      contactBtn.style.transform = "translateY(-1px)";
    };
    contactBtn.onmouseout = () => {
      contactBtn.style.background = "var(--background-modifier-border)";
      contactBtn.style.transform = "translateY(0)";
    };
    contactBtn.onclick = () => {
      window.open("mailto:tutaoyuan8@outlook.com", "_blank");
    };
    const coffeeBtn = supportButtons.createEl("button", {
      text: "\u2615 " + i18n.t("buyCoffee"),
      cls: "plugin-support-btn"
    });
    coffeeBtn.style.cssText = `
			background: linear-gradient(135deg, #ff6b6b, #ffa726);
			color: white;
			border: none;
			padding: 8px 16px;
			border-radius: 6px;
			font-size: 13px;
			cursor: pointer;
			transition: all 0.2s ease;
			font-weight: 500;
		`;
    coffeeBtn.onmouseover = () => {
      coffeeBtn.style.transform = "translateY(-1px) scale(1.05)";
      coffeeBtn.style.boxShadow = "0 4px 12px rgba(255, 107, 107, 0.3)";
    };
    coffeeBtn.onmouseout = () => {
      coffeeBtn.style.transform = "translateY(0) scale(1)";
      coffeeBtn.style.boxShadow = "none";
    };
    coffeeBtn.onclick = () => {
      window.open("https://buymeacoffee.com/canvasgrid", "_blank");
    };
    const alipayBtn = supportButtons.createEl("button", {
      text: "\u{1F499} " + i18n.t("alipaySupport"),
      cls: "plugin-support-btn"
    });
    alipayBtn.style.cssText = `
			background: linear-gradient(135deg, #1677ff, #00a6fb);
			color: white;
			border: none;
			padding: 8px 16px;
			border-radius: 6px;
			font-size: 13px;
			cursor: pointer;
			transition: all 0.2s ease;
			font-weight: 500;
		`;
    alipayBtn.onmouseover = () => {
      alipayBtn.style.transform = "translateY(-1px) scale(1.05)";
      alipayBtn.style.boxShadow = "0 4px 12px rgba(22, 119, 255, 0.3)";
    };
    alipayBtn.onmouseout = () => {
      alipayBtn.style.transform = "translateY(0) scale(1)";
      alipayBtn.style.boxShadow = "none";
    };
    alipayBtn.onclick = () => {
      window.open("https://github.com/zhuzhige123/Canvasgrid-Transit/blob/main/SUPPORT.md#-\u652F\u4ED8\u5B9D", "_blank");
    };
    const sponsorBtn = supportButtons.createEl("button", {
      text: "\u2B50 " + i18n.t("githubSponsor"),
      cls: "plugin-support-btn"
    });
    sponsorBtn.style.cssText = `
			background: linear-gradient(135deg, #6366f1, #8b5cf6);
			color: white;
			border: none;
			padding: 8px 16px;
			border-radius: 6px;
			font-size: 13px;
			cursor: pointer;
			transition: all 0.2s ease;
			font-weight: 500;
		`;
    sponsorBtn.onmouseover = () => {
      sponsorBtn.style.transform = "translateY(-1px) scale(1.05)";
      sponsorBtn.style.boxShadow = "0 4px 12px rgba(99, 102, 241, 0.3)";
    };
    sponsorBtn.onmouseout = () => {
      sponsorBtn.style.transform = "translateY(0) scale(1)";
      sponsorBtn.style.boxShadow = "none";
    };
    sponsorBtn.onclick = () => {
      window.open("https://github.com/zhuzhige123/Canvasgrid-Transit", "_blank");
    };
    const projectInfo = containerEl.createDiv("plugin-project-info");
    projectInfo.style.cssText = `
			background: var(--background-secondary);
			border-radius: 8px;
			padding: 16px;
			margin-bottom: 20px;
			border: 1px solid var(--background-modifier-border);
		`;
    const projectTitle = projectInfo.createEl("h4", {
      text: "\u{1F517} " + i18n.t("projectLinks"),
      cls: "plugin-project-title"
    });
    projectTitle.style.cssText = `
			color: var(--text-normal);
			margin-bottom: 12px;
			font-size: 14px;
			font-weight: 600;
		`;
    const projectLinks = this.plugin.settings.language === "zh" ? [
      { text: "\u{1F4DA} \u4F7F\u7528\u6587\u6863", url: "https://github.com/zhuzhige123/Canvasgrid-Transit/blob/main/README.md" },
      { text: "\u{1F41B} \u95EE\u9898\u62A5\u544A", url: "https://github.com/zhuzhige123/Canvasgrid-Transit/issues" },
      { text: "\u2B50 GitHub \u4ED3\u5E93", url: "https://github.com/zhuzhige123/Canvasgrid-Transit" },
      { text: "\u{1F3A8} \u66F4\u65B0\u65E5\u5FD7", url: "https://github.com/zhuzhige123/Canvasgrid-Transit/releases" }
    ] : [
      { text: "\u{1F4DA} Documentation", url: "https://github.com/zhuzhige123/Canvasgrid-Transit/blob/main/README.md" },
      { text: "\u{1F41B} Bug Reports", url: "https://github.com/zhuzhige123/Canvasgrid-Transit/issues" },
      { text: "\u2B50 GitHub Repository", url: "https://github.com/zhuzhige123/Canvasgrid-Transit" },
      { text: "\u{1F3A8} Changelog", url: "https://github.com/zhuzhige123/Canvasgrid-Transit/releases" }
    ];
    projectLinks.forEach((link) => {
      const linkItem = projectInfo.createEl("div", {
        cls: "plugin-project-link"
      });
      linkItem.style.cssText = `
				display: flex;
				align-items: center;
				padding: 6px 0;
				cursor: pointer;
				transition: color 0.2s ease;
				color: var(--text-muted);
				font-size: 13px;
			`;
      linkItem.textContent = link.text;
      linkItem.onmouseover = () => {
        linkItem.style.color = "var(--interactive-accent)";
      };
      linkItem.onmouseout = () => {
        linkItem.style.color = "var(--text-muted)";
      };
      linkItem.onclick = () => {
        window.open(link.url, "_blank");
      };
    });
    const copyrightEl = containerEl.createEl("div", {
      text: this.plugin.settings.language === "zh" ? "\xA9 2025 Canvasgrid Transit v0.5.1 - \u7528 \u2764\uFE0F \u4E3A Obsidian \u77E5\u8BC6\u7BA1\u7406\u793E\u533A\u7CBE\u5FC3\u6253\u9020" : "\xA9 2025 Canvasgrid Transit v0.5.1 - Crafted with \u2764\uFE0F for Obsidian knowledge management community",
      cls: "plugin-copyright"
    });
    copyrightEl.style.cssText = `
			text-align: center;
			color: var(--text-muted);
			font-size: 12px;
			margin-top: 20px;
			padding-top: 16px;
			border-top: 1px solid var(--background-modifier-border);
		`;
  }
  // æ›´æ–°æ‰€æœ‰ç½‘æ ¼è§†å›¾çš„æ ·å¼
  updateAllGridViews() {
    const gridLeaves = this.plugin.app.workspace.getLeavesOfType(CANVAS_GRID_VIEW_TYPE);
    gridLeaves.forEach((leaf) => {
      const view = leaf.view;
      if (view) {
        if (view.setupGridStyles) {
          view.setupGridStyles();
        }
        view.updateColorFilter();
      }
    });
  }
};
var ColorCategoryEditModal = class extends import_obsidian.Modal {
  constructor(app, plugin, category, index, onSave) {
    super(app);
    this.plugin = plugin;
    this.category = category;
    this.index = index;
    this.onSave = onSave;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", {
      text: this.plugin.settings.language === "zh" ? "\u7F16\u8F91\u989C\u8272\u5206\u7C7B" : "Edit Color Category",
      cls: "modal-title"
    });
    const formContainer = contentEl.createDiv("color-category-form");
    formContainer.style.cssText = `
			display: flex;
			flex-direction: column;
			gap: 16px;
			margin: 20px 0;
		`;
    const colorPreview = formContainer.createDiv("color-preview-container");
    colorPreview.style.cssText = `
			display: flex;
			align-items: center;
			gap: 12px;
			padding: 12px;
			background: var(--background-secondary);
			border-radius: 6px;
		`;
    const colorDot = colorPreview.createDiv("color-preview-dot");
    colorDot.style.cssText = `
			width: 32px;
			height: 32px;
			border-radius: 50%;
			background: ${this.getColorValue(this.category.color)};
			border: 2px solid var(--background-modifier-border);
			flex-shrink: 0;
		`;
    const colorInfo = colorPreview.createDiv("color-info");
    colorInfo.innerHTML = `
			<div style="font-weight: 600; color: var(--text-normal);">
				${this.plugin.settings.language === "zh" ? "\u989C\u8272" : "Color"}: ${this.getColorName(this.category.color)}
			</div>
			<div style="font-size: 12px; color: var(--text-muted);">
				${this.plugin.settings.language === "zh" ? "\u989C\u8272ID" : "Color ID"}: ${this.category.color}
			</div>
		`;
    const nameContainer = formContainer.createDiv("input-container");
    const nameLabel = nameContainer.createEl("label", {
      text: this.plugin.settings.language === "zh" ? "\u5206\u7C7B\u540D\u79F0:" : "Category Name:",
      cls: "setting-item-name"
    });
    nameLabel.style.cssText = `
			display: block;
			margin-bottom: 6px;
			font-weight: 600;
			color: var(--text-normal);
		`;
    this.nameInput = nameContainer.createEl("input", {
      type: "text",
      value: this.category.name,
      cls: "color-category-name-input"
    });
    this.nameInput.style.cssText = `
			width: 100%;
			padding: 8px 12px;
			border: 1px solid var(--background-modifier-border);
			border-radius: 4px;
			background: var(--background-primary);
			color: var(--text-normal);
			font-size: 14px;
		`;
    const descContainer = formContainer.createDiv("input-container");
    const descLabel = descContainer.createEl("label", {
      text: this.plugin.settings.language === "zh" ? "\u5206\u7C7B\u63CF\u8FF0:" : "Category Description:",
      cls: "setting-item-name"
    });
    descLabel.style.cssText = `
			display: block;
			margin-bottom: 6px;
			font-weight: 600;
			color: var(--text-normal);
		`;
    this.descInput = descContainer.createEl("textarea", {
      value: this.category.description,
      cls: "color-category-desc-input"
    });
    this.descInput.style.cssText = `
			width: 100%;
			min-height: 80px;
			padding: 8px 12px;
			border: 1px solid var(--background-modifier-border);
			border-radius: 4px;
			background: var(--background-primary);
			color: var(--text-normal);
			font-size: 14px;
			resize: vertical;
			font-family: inherit;
		`;
    const buttonContainer = contentEl.createDiv("modal-button-container");
    buttonContainer.style.cssText = `
			display: flex;
			justify-content: flex-end;
			gap: 12px;
			margin-top: 20px;
			padding-top: 16px;
			border-top: 1px solid var(--background-modifier-border);
		`;
    const cancelBtn = buttonContainer.createEl("button", {
      text: this.plugin.settings.language === "zh" ? "\u53D6\u6D88" : "Cancel",
      cls: "mod-cancel"
    });
    cancelBtn.onclick = () => this.close();
    const saveBtn = buttonContainer.createEl("button", {
      text: this.plugin.settings.language === "zh" ? "\u4FDD\u5B58" : "Save",
      cls: "mod-cta"
    });
    saveBtn.onclick = () => this.saveChanges();
    setTimeout(() => {
      this.nameInput.focus();
      this.nameInput.select();
    }, 100);
  }
  getColorValue(colorId) {
    const colorMap = {
      "1": "#ff6b6b",
      // çº¢è‰²
      "2": "#ffa726",
      // æ©™è‰²
      "3": "#ffeb3b",
      // é»„è‰²
      "4": "#66bb6a",
      // ç»¿è‰²
      "5": "#26c6da",
      // é’è‰²
      "6": "#42a5f5",
      // è“è‰²
      "7": "#ab47bc"
      // ç´«è‰²
    };
    return colorMap[colorId] || "#999999";
  }
  getColorName(colorId) {
    const colorNames = {
      "1": this.plugin.settings.language === "zh" ? "\u7EA2\u8272" : "Red",
      "2": this.plugin.settings.language === "zh" ? "\u6A59\u8272" : "Orange",
      "3": this.plugin.settings.language === "zh" ? "\u9EC4\u8272" : "Yellow",
      "4": this.plugin.settings.language === "zh" ? "\u7EFF\u8272" : "Green",
      "5": this.plugin.settings.language === "zh" ? "\u9752\u8272" : "Cyan",
      "6": this.plugin.settings.language === "zh" ? "\u84DD\u8272" : "Blue",
      "7": this.plugin.settings.language === "zh" ? "\u7D2B\u8272" : "Purple"
    };
    return colorNames[colorId] || colorId;
  }
  saveChanges() {
    const newName = this.nameInput.value.trim();
    const newDesc = this.descInput.value.trim();
    if (!newName) {
      new import_obsidian.Notice(this.plugin.settings.language === "zh" ? "\u5206\u7C7B\u540D\u79F0\u4E0D\u80FD\u4E3A\u7A7A" : "Category name cannot be empty");
      this.nameInput.focus();
      return;
    }
    this.plugin.settings.colorCategories[this.index] = {
      ...this.category,
      name: newName,
      description: newDesc
    };
    this.plugin.saveSettings();
    new import_obsidian.Notice(this.plugin.settings.language === "zh" ? "\u989C\u8272\u5206\u7C7B\u5DF2\u66F4\u65B0" : "Color category updated");
    this.close();
    this.onSave();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
