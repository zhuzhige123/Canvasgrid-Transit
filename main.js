/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  CANVAS_GRID_VIEW_TYPE: () => CANVAS_GRID_VIEW_TYPE,
  CanvasGridView: () => CanvasGridView,
  default: () => CanvasGridPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  enableAutoLayout: true,
  colorFilterColors: ["1", "2", "4", "6", "7"],
  // 默认显示红、橙、绿、蓝、紫
  language: "zh",
  // 默认中文
  enableColorCategories: true,
  // 启用颜色分类
  colorCategories: [
    { id: "important", name: "\u91CD\u8981", description: "\u91CD\u8981\u5185\u5BB9\u548C\u7D27\u6025\u4E8B\u9879", color: "1" },
    // 红色
    { id: "todo", name: "\u5F85\u529E", description: "\u5F85\u529E\u4E8B\u9879\u548C\u4EFB\u52A1", color: "2" },
    // 橙色
    { id: "note", name: "\u8BB0\u4E8B", description: "\u4E00\u822C\u7B14\u8BB0\u548C\u8BB0\u5F55", color: "6" },
    // 蓝色
    { id: "inspiration", name: "\u7075\u611F", description: "\u521B\u610F\u60F3\u6CD5\u548C\u7075\u611F", color: "7" },
    // 紫色
    { id: "collection", name: "\u6536\u96C6", description: "\u65F6\u95F4\u80F6\u56CA\u6536\u96C6\u7684\u5185\u5BB9", color: "5" }
    // 青色
  ]
};
var CARD_CONSTANTS = {
  width: 300,
  height: 200,
  spacing: 20
};
var CANVAS_GRID_VIEW_TYPE = "canvas-grid-view";
var I18N_TEXTS = {
  zh: {
    // 通用
    search: "\u641C\u7D22",
    refresh: "\u5237\u65B0",
    settings: "\u8BBE\u7F6E",
    cancel: "\u53D6\u6D88",
    confirm: "\u786E\u8BA4",
    delete: "\u5220\u9664",
    edit: "\u7F16\u8F91",
    save: "\u4FDD\u5B58",
    // 网格视图
    gridView: "\u7F51\u683C\u89C6\u56FE",
    switchToGridView: "\u5207\u6362\u5230\u7F51\u683C\u89C6\u56FE",
    canvasGridView: "Canvasgrid Transit",
    noCanvasData: "\u6CA1\u6709Canvas\u6570\u636E",
    loadingCanvas: "\u52A0\u8F7DCanvas\u4E2D...",
    // 菜单
    refreshData: "\u5237\u65B0\u6570\u636E",
    syncCanvas: "\u540C\u6B65Canvas",
    newCanvasFile: "\u65B0\u5EFACanvas\u6587\u4EF6",
    sortBy: "\u6392\u5E8F\u65B9\u5F0F",
    filterConditions: "\u7B5B\u9009\u6761\u4EF6",
    returnToCanvas: "\u8FD4\u56DECanvas\u767D\u677F",
    // 排序
    sortByCreated: "\u521B\u5EFA\u65F6\u95F4",
    sortByModified: "\u4FEE\u6539\u65F6\u95F4",
    sortByTitle: "\u6807\u9898",
    ascending: "\u5347\u5E8F",
    descending: "\u964D\u5E8F",
    // 筛选
    filterByColor: "\u6309\u989C\u8272\u7B5B\u9009",
    allColors: "\u6240\u6709\u989C\u8272",
    // 分组
    groupView: "\u5206\u7EC4\u89C6\u56FE",
    returnToMainView: "\u8FD4\u56DE\u4E3B\u89C6\u56FE",
    groupMembers: "\u6210\u5458",
    // 设置
    gridLayoutSettings: "\u7F51\u683C\u5E03\u5C40\u8BBE\u7F6E",
    enableAutoLayout: "\u542F\u7528\u81EA\u52A8\u5E03\u5C40",
    interfaceLanguage: "\u754C\u9762\u8BED\u8A00",
    colorFilterSettings: "\u989C\u8272\u7B5B\u9009\u5668\u8BBE\u7F6E",
    aboutPlugin: "\u5173\u4E8E\u63D2\u4EF6",
    // 关于
    mainFeatures: "\u4E3B\u8981\u529F\u80FD",
    quickStart: "\u5FEB\u901F\u5F00\u59CB",
    thanks: "\u611F\u8C22\u4F7F\u7528",
    feedback: "\u53CD\u9988\u5EFA\u8BAE",
    contact: "\u8054\u7CFB\u4F5C\u8005",
    buyCoffee: "\u8BF7\u559D\u5496\u5561",
    alipaySupport: "\u652F\u4ED8\u5B9D\u652F\u6301",
    githubSponsor: "GitHub\u8D5E\u52A9",
    projectLinks: "\u9879\u76EE\u94FE\u63A5"
  },
  en: {
    // 通用
    search: "Search",
    refresh: "Refresh",
    settings: "Settings",
    cancel: "Cancel",
    confirm: "Confirm",
    delete: "Delete",
    edit: "Edit",
    save: "Save",
    // 网格视图
    gridView: "Grid View",
    switchToGridView: "Switch to Grid View",
    canvasGridView: "Canvasgrid Transit",
    noCanvasData: "No Canvas Data",
    loadingCanvas: "Loading Canvas...",
    // 菜单
    refreshData: "Refresh Data",
    syncCanvas: "Sync Canvas",
    newCanvasFile: "New Canvas File",
    sortBy: "Sort By",
    filterConditions: "Filter Conditions",
    returnToCanvas: "Return to Canvas",
    // 排序
    sortByCreated: "Created Time",
    sortByModified: "Modified Time",
    sortByTitle: "Title",
    ascending: "Ascending",
    descending: "Descending",
    // 筛选
    filterByColor: "Filter by Color",
    allColors: "All Colors",
    // 分组
    groupView: "Group View",
    returnToMainView: "Return to Main View",
    groupMembers: "Members",
    // 设置
    gridLayoutSettings: "Grid Layout Settings",
    enableAutoLayout: "Enable Auto Layout",
    interfaceLanguage: "Interface Language",
    colorFilterSettings: "Color Filter Settings",
    aboutPlugin: "About Plugin",
    // 关于
    mainFeatures: "Main Features",
    quickStart: "Quick Start",
    thanks: "Thanks for Using",
    feedback: "Feedback",
    contact: "Contact",
    buyCoffee: "Buy Me a Coffee",
    alipaySupport: "Alipay Support",
    githubSponsor: "GitHub Sponsor",
    projectLinks: "Project Links"
  }
};
var I18nManager = class {
  constructor() {
    this.language = "zh";
  }
  setLanguage(lang) {
    this.language = lang;
  }
  t(key) {
    return I18N_TEXTS[this.language][key] || key;
  }
};
var i18n = new I18nManager();
function hasProperty(obj, prop) {
  return prop in obj;
}
var LinkedTabManager = class {
  constructor(app) {
    this.linkedCanvasFile = null;
    this.gridView = null;
    this.fileWatcherRefs = [];
    this.app = app;
  }
  // 建立关联
  linkCanvasFile(canvasFile, gridView) {
    this.unlinkCanvas();
    this.linkedCanvasFile = canvasFile;
    this.gridView = gridView;
    this.registerFileWatcher();
    this.updateGridViewHeader();
    console.log(`Linked canvas file: ${canvasFile.path}`);
  }
  // 移除官方API关联方法 - 改为简单关联
  // 查找Canvas文件对应的leaf
  findCanvasLeaf(canvasFile) {
    const canvasLeaves = this.app.workspace.getLeavesOfType("canvas");
    return canvasLeaves.find((leaf) => {
      const view = leaf.view;
      return view.file?.path === canvasFile.path;
    }) || null;
  }
  // 查找网格视图对应的leaf
  findGridViewLeaf(gridView) {
    const gridLeaves = this.app.workspace.getLeavesOfType(CANVAS_GRID_VIEW_TYPE);
    return gridLeaves.find((leaf) => leaf.view === gridView) || null;
  }
  // 解除关联
  unlinkCanvas() {
    this.linkedCanvasFile = null;
    this.gridView = null;
    this.unregisterFileWatcher();
    console.log("Canvas link removed");
  }
  // 获取关联的Canvas文件
  getLinkedCanvasFile() {
    return this.linkedCanvasFile;
  }
  // 检查关联是否有效
  isLinked() {
    return this.linkedCanvasFile !== null && this.app.vault.getAbstractFileByPath(this.linkedCanvasFile.path) !== null;
  }
  // 注册文件监听器
  registerFileWatcher() {
    if (!this.linkedCanvasFile)
      return;
    console.log("Registering file watchers for:", this.linkedCanvasFile.path);
    const modifyRef = this.app.vault.on("modify", (file) => {
      if (file.path === this.linkedCanvasFile?.path && this.gridView && file instanceof import_obsidian.TFile) {
        this.gridView.onLinkedFileModified(file);
      }
    });
    const deleteRef = this.app.vault.on("delete", (file) => {
      if (file.path === this.linkedCanvasFile?.path && this.gridView) {
        this.gridView.onLinkedFileDeleted();
        this.unlinkCanvas();
      }
    });
    const renameRef = this.app.vault.on("rename", (file, oldPath) => {
      if (oldPath === this.linkedCanvasFile?.path && this.gridView) {
        this.linkedCanvasFile = file;
        this.gridView.onLinkedFileRenamed(file);
      }
    });
    this.fileWatcherRefs = [modifyRef, deleteRef, renameRef];
  }
  // 注销文件监听器
  unregisterFileWatcher() {
    this.fileWatcherRefs.forEach((ref) => {
      this.app.vault.offref(ref);
    });
    this.fileWatcherRefs = [];
    console.log("File watchers unregistered");
  }
  // 更新网格视图头部
  updateGridViewHeader() {
    if (this.gridView && this.linkedCanvasFile) {
      this.gridView.updateLinkedCanvasDisplay(this.linkedCanvasFile);
    }
  }
};
var GroupRenameModal = class extends import_obsidian.Modal {
  constructor(app, currentName, onRename) {
    super(app);
    this.inputEl = null;
    this.currentName = currentName;
    this.onRename = onRename;
  }
  onOpen() {
    this.titleEl.setText("\u91CD\u547D\u540D\u5206\u7EC4");
    this.createContent();
  }
  createContent() {
    const content = this.contentEl;
    content.empty();
    const inputContainer = content.createDiv("group-rename-input-container");
    const label = inputContainer.createEl("label", {
      text: "\u5206\u7EC4\u540D\u79F0:",
      cls: "group-rename-label"
    });
    this.inputEl = inputContainer.createEl("input", {
      type: "text",
      value: this.currentName,
      cls: "group-rename-input"
    });
    this.inputEl.focus();
    this.inputEl.select();
    const buttonContainer = content.createDiv("group-rename-buttons");
    const confirmBtn = buttonContainer.createEl("button", {
      text: "\u786E\u8BA4",
      cls: "mod-cta"
    });
    confirmBtn.onclick = () => this.handleConfirm();
    const cancelBtn = buttonContainer.createEl("button", {
      text: "\u53D6\u6D88"
    });
    cancelBtn.onclick = () => this.close();
    this.inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        this.handleConfirm();
      } else if (e.key === "Escape") {
        this.close();
      }
    });
  }
  handleConfirm() {
    if (!this.inputEl)
      return;
    const newName = this.inputEl.value.trim();
    if (!newName) {
      new import_obsidian.Notice("\u5206\u7EC4\u540D\u79F0\u4E0D\u80FD\u4E3A\u7A7A");
      return;
    }
    if (newName === this.currentName) {
      this.close();
      return;
    }
    this.onRename(newName);
    this.close();
  }
};
var CanvasSelectionModal = class extends import_obsidian.Modal {
  constructor(app, gridView, onSelect) {
    super(app);
    this.gridView = gridView;
    this.onSelect = onSelect;
  }
  onOpen() {
    this.titleEl.setText("\u9009\u62E9\u8981\u5173\u8054\u7684Canvas\u6587\u4EF6");
    this.createContent();
  }
  createContent() {
    const canvasFiles = this.app.vault.getFiles().filter((file) => file.extension === "canvas");
    if (canvasFiles.length === 0) {
      this.createEmptyState();
    } else {
      this.createFileList(canvasFiles);
    }
    this.createActions();
  }
  createEmptyState() {
    const emptyEl = this.contentEl.createDiv("canvas-selection-empty");
    emptyEl.innerHTML = `
			<div class="empty-icon">\u{1F4C4}</div>
			<div class="empty-title">\u6CA1\u6709\u627E\u5230Canvas\u6587\u4EF6</div>
			<div class="empty-desc">\u8BF7\u5148\u521B\u5EFA\u4E00\u4E2ACanvas\u6587\u4EF6\uFF0C\u7136\u540E\u518D\u8FDB\u884C\u5173\u8054</div>
		`;
  }
  createFileList(files) {
    const listEl = this.contentEl.createDiv("canvas-file-list");
    files.forEach((file) => {
      const itemEl = listEl.createDiv("canvas-file-item");
      itemEl.innerHTML = `
				<div class="file-icon">\u{1F3A8}</div>
				<div class="file-info">
					<div class="file-name">${file.basename}</div>
					<div class="file-path">${file.path}</div>
				</div>
				<div class="file-action">
					<button class="select-btn">\u9009\u62E9</button>
				</div>
			`;
      const selectBtn = itemEl.querySelector(".select-btn");
      selectBtn.onclick = () => {
        this.onSelect(file);
        this.close();
      };
    });
  }
  createActions() {
    const actionsEl = this.contentEl.createDiv("canvas-selection-actions");
    const createBtn = actionsEl.createEl("button", {
      cls: "mod-cta",
      text: "\u521B\u5EFA\u65B0Canvas\u6587\u4EF6"
    });
    createBtn.onclick = () => this.createNewCanvas();
    const cancelBtn = actionsEl.createEl("button", {
      text: "\u53D6\u6D88"
    });
    cancelBtn.onclick = () => this.close();
  }
  async createNewCanvas() {
    const fileName = `\u65B0\u5EFACanvas-${Date.now()}.canvas`;
    const initialData = { nodes: [], edges: [] };
    try {
      const newFile = await this.app.vault.create(
        fileName,
        JSON.stringify(initialData, null, 2)
      );
      this.onSelect(newFile);
      this.close();
      new import_obsidian.Notice(`\u5DF2\u521B\u5EFA\u65B0Canvas\u6587\u4EF6: ${newFile.basename}`);
    } catch (error) {
      new import_obsidian.Notice("\u521B\u5EFACanvas\u6587\u4EF6\u5931\u8D25");
      console.error("Failed to create canvas file:", error);
    }
  }
};
var CanvasGridView = class extends import_obsidian.ItemView {
  // 当前查看的分组ID
  constructor(leaf, plugin) {
    super(leaf);
    this.canvasData = null;
    // 拖拽相关属性
    this.isDragging = false;
    this.dragData = null;
    this.dropIndicator = null;
    // 长按拖拽相关属性
    this.longPressTimer = null;
    this.longPressStartTime = 0;
    this.longPressThreshold = 500;
    // 500ms长按阈值
    this.isDragFromGrid = false;
    this.dragStartPosition = { x: 0, y: 0 };
    this.currentDragCard = null;
    // 拖拽预览相关属性
    this.dragPreviewElement = null;
    // 🔧 修复：文件修改保护机制
    this.fileModificationLocks = /* @__PURE__ */ new Set();
    this.linkedCanvasFile = null;
    this.linkedIndicatorEl = null;
    this.updateTimeout = null;
    // 搜索和排序相关属性
    this.searchQuery = "";
    this.sortBy = "created";
    this.sortOrder = "desc";
    this.filteredNodes = [];
    this.searchInputEl = null;
    this.statusElements = null;
    // 颜色筛选相关属性
    this.activeColorFilter = null;
    // 当前激活的颜色筛选器
    this.colorFilterContainer = null;
    // 时间胶囊相关属性
    this.timeCapsuleState = {
      isActive: false,
      startTime: 0,
      duration: 15 * 60 * 1e3,
      // 默认15分钟
      remainingTime: 0,
      groupId: null,
      collectedItems: [],
      groupName: ""
    };
    this.timeCapsuleButton = null;
    this.timeCapsuleTimer = null;
    this.timeCapsuleUpdateInterval = null;
    // 宽度控制相关属性
    this.resizeObserver = null;
    this.minWidth = 300;
    // 最小宽度（一张卡片的宽度）
    this.isWidthLimited = false;
    // 链接预览缓存 - 使用LRU缓存策略
    this.linkPreviewCache = /* @__PURE__ */ new Map();
    this.previewLoadingUrls = /* @__PURE__ */ new Set();
    this.MAX_CACHE_SIZE = 100;
    // 限制缓存大小
    this.CACHE_TTL = 30 * 60 * 1e3;
    // 缓存30分钟过期
    // 文件监听器控制
    this.fileWatcherDisabled = false;
    // 事件监听器清理追踪
    this.globalEventListeners = [];
    // 定时器清理追踪
    this.activeTimeouts = /* @__PURE__ */ new Set();
    this.activeIntervals = /* @__PURE__ */ new Set();
    this.cacheCleanupInterval = null;
    // 渲染缓存 - 提升性能
    this.renderCache = /* @__PURE__ */ new Map();
    this.MAX_RENDER_CACHE_SIZE = 50;
    // 限制缓存大小
    this.renderCacheAccessCount = /* @__PURE__ */ new Map();
    // 编辑状态管理
    this.currentEditingCard = null;
    this.currentEditingNode = null;
    this.autoSaveEnabled = true;
    // 分组功能相关
    this.groupAnalysis = /* @__PURE__ */ new Map();
    this.currentGroupView = null;
    // 事件处理器引用，用于清理
    this.refreshTimer = null;
    // 统一处理网格中的所有点击事件
    this.handleGridClick = (e) => {
      const target = e.target;
      console.log("\u7F51\u683C\u70B9\u51FB\u4E8B\u4EF6:", target.className, target.tagName);
      const toolbarBtn = target.closest(".canvas-card-toolbar-btn");
      if (toolbarBtn) {
        console.log("\u68C0\u6D4B\u5230\u5DE5\u5177\u680F\u6309\u94AE\u70B9\u51FB");
        e.stopPropagation();
        this.handleToolbarButtonClick(toolbarBtn, e);
        return;
      }
      const card = target.closest(".canvas-grid-card");
      if (card && card.dataset.nodeId) {
        console.log("\u68C0\u6D4B\u5230\u5361\u7247\u70B9\u51FB");
        const node = this.canvasData?.nodes.find((n) => n.id === card.dataset.nodeId);
        if (node) {
          this.onCardClick(node, card);
        }
      }
    };
    // 处理工具栏按钮点击
    this.handleToolbarButtonClick = (button, e) => {
      console.log("\u5DE5\u5177\u680F\u6309\u94AE\u88AB\u70B9\u51FB:", button.className);
      const card = button.closest(".canvas-grid-card");
      if (!card || !card.dataset.nodeId) {
        console.log("\u672A\u627E\u5230\u5361\u7247\u6216\u8282\u70B9ID");
        return;
      }
      const node = this.canvasData?.nodes.find((n) => n.id === card.dataset.nodeId);
      if (!node) {
        console.log("\u672A\u627E\u5230\u5BF9\u5E94\u7684\u8282\u70B9\u6570\u636E");
        return;
      }
      console.log("\u6267\u884C\u5DE5\u5177\u680F\u64CD\u4F5C\uFF0C\u8282\u70B9:", node.id);
      if (button.classList.contains("canvas-card-toolbar-delete")) {
        console.log("\u6267\u884C\u5220\u9664\u64CD\u4F5C");
        this.deleteCardFromToolbar(card);
      } else if (button.classList.contains("canvas-card-toolbar-color")) {
        console.log("\u6267\u884C\u989C\u8272\u8BBE\u7F6E\u64CD\u4F5C");
        this.showColorPicker(card, node);
      } else {
        console.log("\u672A\u8BC6\u522B\u7684\u6309\u94AE\u7C7B\u578B:", button.className);
      }
    };
    // 保留原有的卡片点击处理方法（用于向后兼容）
    this.handleCardClick = (e) => {
      const card = e.target.closest(".canvas-grid-card");
      if (card && card.dataset.nodeId) {
        const node = this.canvasData?.nodes.find((n) => n.id === card.dataset.nodeId);
        if (node) {
          this.onCardClick(node, card);
        }
      }
    };
    this.handleCardDoubleClick = (e) => {
      const card = e.target.closest(".canvas-grid-card");
      if (card && card.dataset.nodeId && !card.classList.contains("editing")) {
        const node = this.canvasData?.nodes.find((n) => n.id === card.dataset.nodeId);
        if (node) {
          e.preventDefault();
          e.stopPropagation();
          this.onCardDoubleClick(node, card);
        }
      }
    };
    this.handleKeyDown = (e) => {
      const target = e.target;
      if (target.classList.contains("canvas-card-toolbar-btn") && (e.key === "Enter" || e.key === " ")) {
        e.preventDefault();
        e.stopPropagation();
        this.handleToolbarButtonClick(target, e);
        return;
      }
      const card = target;
      if (card.classList.contains("canvas-grid-card") && (e.key === "Enter" || e.key === " ")) {
        e.preventDefault();
        if (e.key === "Enter") {
          const node = this.canvasData?.nodes.find((n) => n.id === card.dataset.nodeId);
          if (node && !card.classList.contains("editing")) {
            this.onCardDoubleClick(node, card);
          }
        } else {
          card.click();
        }
      }
    };
    // 处理右键菜单
    this.handleCardContextMenu = (e) => {
      const target = e.target;
      const card = target.closest(".canvas-grid-card");
      if (card) {
        e.preventDefault();
        this.showContextMenu(card, e.clientX, e.clientY);
      }
    };
    // 处理文档点击，关闭右键菜单和退出编辑状态
    this.handleDocumentClick = (e) => {
      const target = e.target;
      if (!target.closest(".canvas-grid-context-menu")) {
        this.hideContextMenu();
      }
      if (this.currentEditingCard && this.currentEditingNode) {
        const clickedInCurrentCard = target.closest(".canvas-grid-card") === this.currentEditingCard;
        const clickedInEditor = target.closest(".card-editor-container");
        const clickedInGrid = target.closest(".canvas-grid-container");
        if (!clickedInGrid || !clickedInCurrentCard && !clickedInEditor && clickedInGrid) {
          console.log("\u70B9\u51FB\u7F51\u683C\u5916\u6216\u5176\u4ED6\u533A\u57DF\uFF0C\u9000\u51FA\u7F16\u8F91\u72B6\u6001\u5E76\u4FDD\u5B58");
          this.exitCurrentEditingState(true);
        }
      }
    };
    // 全局鼠标事件监听器引用
    this.globalMouseMoveHandler = null;
    this.globalMouseUpHandler = null;
    // 窗口失焦处理器
    this.handleWindowBlur = () => {
      setTimeout(() => {
        if (this.isDragFromGrid && !document.hasFocus()) {
          console.log("Window lost focus, canceling drag...");
          this.cancelDrag();
        }
      }, 100);
    };
    // ESC键取消拖拽处理器
    this.handleDragEscape = (e) => {
      if (e.key === "Escape" && this.isDragFromGrid) {
        console.log("ESC pressed, canceling drag...");
        this.cancelDrag();
      }
    };
    // 清理拖拽预览的函数（会被动态赋值，保持向后兼容）
    this.cleanupDragPreview = () => {
      this.forceCleanupDragPreview();
    };
    // 拖拽提示元素
    this.dragHintElement = null;
    this.plugin = plugin;
    this.settings = plugin.settings;
    i18n.setLanguage(plugin.settings.language);
    this.linkedTabManager = new LinkedTabManager(this.app);
  }
  // 安全的事件监听器添加方法
  addGlobalEventListener(element, event, handler, options) {
    element.addEventListener(event, handler, options);
    this.globalEventListeners.push({ element, event, handler, options });
  }
  // 安全的定时器管理方法
  safeSetTimeout(callback, delay) {
    const timeoutId = setTimeout(() => {
      this.activeTimeouts.delete(timeoutId);
      callback();
    }, delay);
    this.activeTimeouts.add(timeoutId);
    return timeoutId;
  }
  safeSetInterval(callback, delay) {
    const intervalId = setInterval(callback, delay);
    this.activeIntervals.add(intervalId);
    return intervalId;
  }
  // 清理单个定时器
  safeClearTimeout(timeoutId) {
    clearTimeout(timeoutId);
    this.activeTimeouts.delete(timeoutId);
  }
  safeClearInterval(intervalId) {
    clearInterval(intervalId);
    this.activeIntervals.delete(intervalId);
  }
  // 智能缓存管理方法
  manageCacheSize() {
    const now = Date.now();
    for (const [key, value] of this.linkPreviewCache.entries()) {
      if (now - value.timestamp > this.CACHE_TTL) {
        this.linkPreviewCache.delete(key);
      }
    }
    if (this.linkPreviewCache.size > this.MAX_CACHE_SIZE) {
      const entries = Array.from(this.linkPreviewCache.entries());
      entries.sort((a, b) => {
        const scoreA = a[1].accessCount * 0.7 + (now - a[1].timestamp) * 0.3;
        const scoreB = b[1].accessCount * 0.7 + (now - b[1].timestamp) * 0.3;
        return scoreA - scoreB;
      });
      const itemsToDelete = entries.slice(0, this.linkPreviewCache.size - this.MAX_CACHE_SIZE);
      itemsToDelete.forEach(([key]) => this.linkPreviewCache.delete(key));
    }
  }
  // 清理过期的加载状态
  cleanupLoadingUrls() {
    this.previewLoadingUrls.clear();
  }
  // 获取缓存项并更新访问统计
  getCacheItem(url) {
    const item = this.linkPreviewCache.get(url);
    if (item) {
      item.accessCount++;
      item.timestamp = Date.now();
      return item.data;
    }
    return null;
  }
  // 设置缓存项
  setCacheItem(url, data) {
    this.linkPreviewCache.set(url, {
      data,
      timestamp: Date.now(),
      accessCount: 1
    });
    this.manageCacheSize();
  }
  getViewType() {
    return CANVAS_GRID_VIEW_TYPE;
  }
  getDisplayText() {
    return "Canvasgrid Transit";
  }
  getIcon() {
    return "grid";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    if (!container) {
      console.error("Canvasgrid Transit: Container element not found");
      return;
    }
    container.empty();
    this.gridContainer = container.createDiv("canvas-grid-container");
    this.createToolbar(container);
    this.gridContainer.remove();
    this.gridContainer = container.createDiv("canvas-grid-container");
    this.gridContainer.classList.remove("toolbar-hidden");
    this.gridContainer.style.removeProperty("margin-top");
    this.gridContainer.style.removeProperty("height");
    this.setupGridStyles();
    this.setupEventDelegation();
    await this.loadActiveCanvas();
    this.setupDragDropHandlers();
    this.initializeSearchAndSort();
    this.initializeWidthControl();
    this.cacheCleanupInterval = this.safeSetInterval(() => {
      this.manageCacheSize();
      this.cleanupLoadingUrls();
    }, 10 * 60 * 1e3);
  }
  // 初始化搜索和排序功能
  initializeSearchAndSort() {
    console.log("\u{1F527} Initializing search and sort functionality");
    this.filteredNodes = this.canvasData?.nodes || [];
    this.searchQuery = "";
    this.activeColorFilter = null;
    console.log(`\u{1F4CA} Initialized with ${this.filteredNodes.length} nodes`);
    console.log(`\u{1F504} Default sort: ${this.sortBy} (${this.sortOrder})`);
    this.applySortAndFilter();
  }
  // 创建新的工具栏布局
  createToolbar(container) {
    const toolbar = container.createDiv("canvas-grid-toolbar");
    const mainRow = toolbar.createDiv("canvas-grid-toolbar-main-row");
    const leftSection = mainRow.createDiv("canvas-grid-toolbar-left");
    this.createMainMenuButton(leftSection);
    const middleSection = mainRow.createDiv("canvas-grid-toolbar-middle");
    this.createSearchBox(middleSection);
    const rightSection = mainRow.createDiv("canvas-grid-toolbar-right");
    this.createTimeCapsuleButton(rightSection);
    const colorRow = toolbar.createDiv("canvas-grid-toolbar-color-row");
    this.createColorFilter(colorRow);
  }
  // 创建主菜单按钮
  createMainMenuButton(container) {
    const menuContainer = container.createDiv("canvas-grid-main-menu");
    const mainBtn = menuContainer.createEl("button", {
      cls: "canvas-grid-main-btn canvas-grid-icon-only",
      title: "\u7F51\u683C\u89C6\u56FE\u83DC\u5355"
    });
    const btnContent = mainBtn.createDiv("canvas-grid-main-btn-content");
    const iconEl = btnContent.createDiv("canvas-grid-main-icon");
    iconEl.innerHTML = `
			<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<rect x="3" y="3" width="7" height="7"/>
				<rect x="14" y="3" width="7" height="7"/>
				<rect x="3" y="14" width="7" height="7"/>
				<rect x="14" y="14" width="7" height="7"/>
			</svg>
		`;
    const arrowEl = btnContent.createDiv("canvas-grid-main-arrow");
    arrowEl.innerHTML = `
			<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<polyline points="6,9 12,15 18,9"/>
			</svg>
		`;
    this.linkedIndicatorEl = document.createElement("div");
    this.linkedIndicatorEl.className = "canvas-grid-linked-indicator-hidden";
    this.linkedIndicatorEl.style.display = "none";
    btnContent.appendChild(this.linkedIndicatorEl);
    this.updateLinkedCanvasDisplay(null);
    const mainDropdown = menuContainer.createDiv("canvas-grid-main-dropdown");
    mainDropdown.style.display = "none";
    this.createMainMenuContent(mainDropdown);
    mainBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      const isVisible = mainDropdown.style.display !== "none";
      this.hideAllDropdowns();
      if (!isVisible) {
        mainDropdown.style.display = "block";
        mainBtn.classList.add("active");
      }
    });
    document.addEventListener("click", () => {
      mainDropdown.style.display = "none";
      mainBtn.classList.remove("active");
    });
    mainDropdown.addEventListener("click", (e) => {
      e.stopPropagation();
    });
  }
  // 创建主菜单内容
  createMainMenuContent(container) {
    this.createLinkManagementSection(container);
    this.createDataOperationsSection(container);
    this.createSortFilterSection(container);
    this.createNavigationSection(container);
  }
  // 创建关联管理部分
  createLinkManagementSection(container) {
    const section = container.createDiv("canvas-grid-menu-section");
    const autoLinkItem = section.createDiv("canvas-grid-menu-item");
    autoLinkItem.innerHTML = `
			<svg class="menu-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/>
			</svg>
			<span class="menu-text">\u81EA\u52A8\u5173\u8054\u5F53\u524DCanvas</span>
		`;
    autoLinkItem.addEventListener("click", () => {
      this.autoLinkCurrentCanvas();
      this.hideAllDropdowns();
    });
    const customLinkItem = section.createDiv("canvas-grid-menu-item");
    customLinkItem.innerHTML = `
			<svg class="menu-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
				<path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
			</svg>
			<span class="menu-text">\u9009\u62E9\u5173\u8054Canvas\u6587\u4EF6</span>
		`;
    customLinkItem.addEventListener("click", () => {
      this.showCanvasSelectionDialog();
      this.hideAllDropdowns();
    });
    const unlinkItem = section.createDiv("canvas-grid-menu-item");
    unlinkItem.innerHTML = `
			<svg class="menu-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<path d="M18 6L6 18M6 6l12 12"/>
			</svg>
			<span class="menu-text">\u89E3\u9664\u5173\u8054</span>
		`;
    unlinkItem.addEventListener("click", () => {
      this.unlinkCanvas();
      this.hideAllDropdowns();
    });
  }
  // 视图设置部分已移除，功能简化
  // 创建数据操作部分
  createDataOperationsSection(container) {
    const section = container.createDiv("canvas-grid-menu-section");
    const syncItem = section.createDiv("canvas-grid-menu-item");
    syncItem.innerHTML = `
			<svg class="menu-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<polyline points="23,4 23,10 17,10"/>
				<polyline points="1,20 1,14 7,14"/>
				<path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"/>
			</svg>
			<span class="menu-text">\u540C\u6B65\u6570\u636E</span>
		`;
    syncItem.addEventListener("click", () => {
      this.syncCanvasData();
      this.hideAllDropdowns();
    });
    const createItem = section.createDiv("canvas-grid-menu-item");
    createItem.innerHTML = `
			<svg class="menu-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
				<polyline points="14,2 14,8 20,8"/>
				<line x1="12" y1="18" x2="12" y2="12"/>
				<line x1="9" y1="15" x2="15" y2="15"/>
			</svg>
			<span class="menu-text">\u65B0\u5EFACanvas\u6587\u4EF6</span>
		`;
    createItem.addEventListener("click", () => {
      this.createNewCanvasFile();
      this.hideAllDropdowns();
    });
  }
  // 创建排序和筛选部分
  createSortFilterSection(container) {
    const section = container.createDiv("canvas-grid-menu-section");
    i18n.setLanguage(this.settings.language);
    const sortItem = section.createDiv("canvas-grid-menu-item canvas-grid-submenu-item");
    sortItem.innerHTML = `
			<svg class="menu-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<path d="M3 6h18"/>
				<path d="M7 12h10"/>
				<path d="M10 18h4"/>
			</svg>
			<span class="menu-text">${i18n.t("sortBy")}</span>
			<svg class="menu-arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<polyline points="9,18 15,12 9,6"/>
			</svg>
		`;
    const filterItem = section.createDiv("canvas-grid-menu-item canvas-grid-submenu-item");
    filterItem.innerHTML = `
			<svg class="menu-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<polyline points="22,12 18,12 15,21 9,3 6,12 2,12"/>
			</svg>
			<span class="menu-text">\u7B5B\u9009\u6761\u4EF6</span>
			<svg class="menu-arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<polyline points="9,18 15,12 9,6"/>
			</svg>
		`;
    this.addSubmenuEvents(sortItem, "sort");
    this.addSubmenuEvents(filterItem, "filter");
  }
  // 添加子菜单事件
  addSubmenuEvents(menuItem, type) {
    menuItem.addEventListener("click", (e) => {
      e.stopPropagation();
      const existingSubmenu = document.querySelector(`.canvas-grid-submenu[data-submenu-type="${type}"]`);
      if (existingSubmenu) {
        this.closeAllSubmenus();
      } else {
        this.showSubmenu(menuItem, type);
      }
    });
  }
  // 显示子菜单
  showSubmenu(parentItem, type) {
    this.closeAllSubmenus();
    const submenu = document.createElement("div");
    submenu.className = "canvas-grid-submenu";
    submenu.dataset.submenuType = type;
    switch (type) {
      case "sort":
        this.createSortSubmenu(submenu);
        break;
      case "filter":
        this.createFilterSubmenu(submenu);
        break;
    }
    const rect = parentItem.getBoundingClientRect();
    submenu.style.position = "fixed";
    submenu.style.left = `${rect.right + 8}px`;
    submenu.style.top = `${rect.top}px`;
    submenu.style.zIndex = "1001";
    document.body.appendChild(submenu);
    const closeSubmenu = (e) => {
      if (!submenu.contains(e.target) && !parentItem.contains(e.target)) {
        submenu.remove();
        document.removeEventListener("click", closeSubmenu);
        const index = this.globalEventListeners.findIndex(
          (listener) => listener.element === document && listener.event === "click" && listener.handler === closeSubmenu
        );
        if (index > -1) {
          this.globalEventListeners.splice(index, 1);
        }
      }
    };
    this.safeSetTimeout(() => {
      this.addGlobalEventListener(document, "click", closeSubmenu);
    }, 0);
  }
  // 关闭所有子菜单
  closeAllSubmenus() {
    const existingSubmenus = document.querySelectorAll(".canvas-grid-submenu");
    existingSubmenus.forEach((submenu) => {
      submenu.remove();
    });
  }
  // 创建合并排序子菜单（排序方式+顺序）
  createSortSubmenu(container) {
    i18n.setLanguage(this.settings.language);
    const sortOptions = [
      { key: "created", label: i18n.t("sortByCreated") },
      { key: "modified", label: i18n.t("sortByModified") },
      { key: "title", label: i18n.t("sortByTitle") }
    ];
    console.log(`\u{1F39B}\uFE0F Creating sort submenu with current sort: ${this.sortBy} (${this.sortOrder})`);
    sortOptions.forEach((option) => {
      const item = container.createDiv("canvas-grid-menu-item");
      const isActive = this.sortBy === option.key;
      const isAsc = this.sortOrder === "asc";
      let statusIcon = "";
      if (isActive) {
        statusIcon = isAsc ? "\u2191" : "\u2193";
      }
      item.innerHTML = `
				<span class="menu-text">${option.label}</span>
				<span class="menu-status">${statusIcon}</span>
			`;
      if (isActive) {
        item.style.backgroundColor = "var(--background-modifier-hover)";
        item.style.fontWeight = "600";
      }
      item.addEventListener("click", () => {
        console.log(`\u{1F504} Sort option clicked: ${option.key} (current: ${this.sortBy})`);
        if (this.sortBy === option.key) {
          this.sortOrder = this.sortOrder === "asc" ? "desc" : "asc";
          console.log(`\u{1F504} Toggled sort order to: ${this.sortOrder}`);
        } else {
          this.sortBy = option.key;
          this.sortOrder = "desc";
          console.log(`\u{1F504} Changed sort to: ${this.sortBy} (${this.sortOrder})`);
        }
        this.applySortAndFilter();
        this.hideAllDropdowns();
        container.parentElement?.remove();
      });
    });
  }
  // 创建筛选子菜单
  createFilterSubmenu(container) {
    const filterOptions = [
      { key: "all", label: "\u663E\u793A\u5168\u90E8" },
      { key: "text", label: "\u4EC5\u6587\u672C\u5361\u7247" },
      { key: "file", label: "\u4EC5\u6587\u4EF6\u5361\u7247" },
      { key: "link", label: "\u4EC5\u94FE\u63A5\u5361\u7247" }
    ];
    filterOptions.forEach((option) => {
      const item = container.createDiv("canvas-grid-menu-item");
      item.innerHTML = `<span class="menu-text">${option.label}</span>`;
      item.addEventListener("click", () => {
        this.applyTypeFilter(option.key);
        this.hideAllDropdowns();
        container.parentElement?.remove();
      });
    });
  }
  // 创建导航部分
  createNavigationSection(container) {
    const section = container.createDiv("canvas-grid-menu-section");
    const backItem = section.createDiv("canvas-grid-menu-item canvas-grid-menu-back");
    backItem.innerHTML = `
			<svg class="menu-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<line x1="19" y1="12" x2="5" y2="12"/>
				<polyline points="12,19 5,12 12,5"/>
			</svg>
			<span class="menu-text">\u8FD4\u56DECanvas\u767D\u677F</span>
		`;
    backItem.addEventListener("click", () => {
      this.returnToCanvas();
      this.hideAllDropdowns();
    });
  }
  // 卡片大小相关方法已移除
  // 创建新Canvas文件
  async createNewCanvasFile() {
    try {
      const fileName = `Canvas-${Date.now()}.canvas`;
      const newFile = await this.app.vault.create(fileName, JSON.stringify({
        nodes: [],
        edges: []
      }));
      await this.setLinkedCanvas(newFile);
      new import_obsidian.Notice(`\u5DF2\u521B\u5EFA\u5E76\u5173\u8054\u65B0Canvas\u6587\u4EF6: ${newFile.basename}`);
    } catch (error) {
      console.error("Failed to create new canvas file:", error);
      new import_obsidian.Notice("\u521B\u5EFACanvas\u6587\u4EF6\u5931\u8D25");
    }
  }
  // 同步Canvas数据（合并刷新和同步功能）
  async syncCanvasData() {
    try {
      if (this.linkedCanvasFile) {
        await this.loadCanvasDataFromFile(this.linkedCanvasFile);
        this.notifyCanvasViewRefresh();
        new import_obsidian.Notice("Canvas\u6570\u636E\u5DF2\u540C\u6B65");
      } else {
        await this.loadActiveCanvas();
        new import_obsidian.Notice("Canvas\u6570\u636E\u5DF2\u5237\u65B0");
      }
    } catch (error) {
      console.error("Failed to sync canvas data:", error);
      const errorMessage = error instanceof Error ? error.message : "\u672A\u77E5\u9519\u8BEF";
      new import_obsidian.Notice(`\u540C\u6B65\u6570\u636E\u5931\u8D25: ${errorMessage}`);
      this.showErrorState(`\u540C\u6B65\u5931\u8D25: ${errorMessage}`);
    }
  }
  // 导出网格数据
  async exportGridData() {
    if (!this.canvasData) {
      new import_obsidian.Notice("\u6CA1\u6709\u53EF\u5BFC\u51FA\u7684\u6570\u636E");
      return;
    }
    try {
      const exportData = {
        timestamp: Date.now(),
        source: this.linkedCanvasFile?.path || "unknown",
        nodes: this.canvasData.nodes,
        edges: this.canvasData.edges
      };
      const fileName = `grid-export-${Date.now()}.json`;
      await this.app.vault.create(fileName, JSON.stringify(exportData, null, 2));
      new import_obsidian.Notice(`\u6570\u636E\u5DF2\u5BFC\u51FA\u5230: ${fileName}`);
    } catch (error) {
      console.error("Failed to export data:", error);
      new import_obsidian.Notice("\u5BFC\u51FA\u6570\u636E\u5931\u8D25");
    }
  }
  // 返回Canvas白板
  returnToCanvas() {
    if (this.linkedCanvasFile) {
      this.app.workspace.openLinkText(this.linkedCanvasFile.path, "", false);
    } else {
      const canvasLeaves = this.app.workspace.getLeavesOfType("canvas");
      if (canvasLeaves.length > 0) {
        this.app.workspace.setActiveLeaf(canvasLeaves[0]);
      } else {
        new import_obsidian.Notice("\u6CA1\u6709\u627E\u5230\u53EF\u8FD4\u56DE\u7684Canvas\u6587\u4EF6");
      }
    }
  }
  // 创建操作按钮 (已整合到主菜单，保留以防兼容性问题)
  createActionButtons(container) {
    return;
    const actionsEl = container.createDiv("canvas-grid-toolbar-actions");
    const officialLinkBtn = actionsEl.createEl("button", {
      cls: "canvas-grid-action-btn canvas-grid-official-link-btn",
      title: "\u4F7F\u7528\u5B98\u65B9\u5173\u8054\u6807\u7B7E\u9875\u529F\u80FD"
    });
    officialLinkBtn.innerHTML = `
			<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<path d="M9 12l2 2 4-4"/>
				<path d="M21 12c-1 0-3-1-3-3s2-3 3-3 3 1 3 3-2 3-3 3"/>
				<path d="M3 12c1 0 3-1 3-3s-2-3-3-3-3 1-3 3 2 3 3 3"/>
				<path d="M13 12h3"/>
				<path d="M8 12h3"/>
			</svg>
		`;
    officialLinkBtn.onclick = () => {
      new import_obsidian.Notice("\u5B98\u65B9\u5173\u8054\u529F\u80FD\u5DF2\u6574\u5408\u5230\u81EA\u52A8\u5173\u8054\u4E2D");
    };
    const linkBtn = actionsEl.createEl("button", {
      cls: "canvas-grid-action-btn",
      title: "\u81EA\u5B9A\u4E49\u5173\u8054Canvas\u6587\u4EF6"
    });
    linkBtn.innerHTML = `
			<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
				<path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
			</svg>
		`;
    linkBtn.onclick = () => this.showCanvasSelectionDialog();
    const unlinkBtn = actionsEl.createEl("button", {
      cls: "canvas-grid-action-btn canvas-grid-unlink-btn",
      title: "\u89E3\u9664\u5173\u8054"
    });
    unlinkBtn.innerHTML = `
			<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<path d="M18 6L6 18M6 6l12 12"/>
			</svg>
		`;
    unlinkBtn.onclick = () => this.unlinkCanvas();
    this.updateActionButtonsVisibility();
  }
  // 创建搜索框
  createSearchBox(container) {
    const searchContainer = container.createDiv("canvas-grid-search-container");
    this.searchInputEl = searchContainer.createEl("input", {
      cls: "canvas-grid-search-input",
      type: "text",
      placeholder: this.settings.language === "zh" ? "\u641C\u7D22\u5361\u7247\u5185\u5BB9..." : "Search card content..."
    });
    const clearBtn = searchContainer.createDiv("canvas-grid-search-clear");
    clearBtn.innerHTML = `
			<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<line x1="18" y1="6" x2="6" y2="18"/>
				<line x1="6" y1="6" x2="18" y2="18"/>
			</svg>
		`;
    clearBtn.style.display = "none";
    this.searchInputEl.addEventListener("input", (e) => {
      const target = e.target;
      this.searchQuery = target.value.trim();
      if (this.searchQuery) {
        clearBtn.style.display = "flex";
      } else {
        clearBtn.style.display = "none";
      }
      this.performSearch();
    });
    clearBtn.addEventListener("click", () => {
      this.searchInputEl.value = "";
      this.searchQuery = "";
      clearBtn.style.display = "none";
      this.performSearch();
      this.searchInputEl.focus();
    });
    this.searchInputEl.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        this.searchInputEl.blur();
      }
    });
  }
  // 创建时间胶囊按钮
  createTimeCapsuleButton(container) {
    const buttonContainer = container.createDiv("canvas-grid-time-capsule-container");
    this.timeCapsuleButton = buttonContainer.createEl("button", {
      cls: "canvas-grid-time-capsule-btn",
      title: "\u65F6\u95F4\u80F6\u56CA - \u70B9\u51FB\u5F00\u59CB\u6536\u96C6"
    });
    this.updateTimeCapsuleButton();
    this.timeCapsuleButton.addEventListener("click", () => {
      this.toggleTimeCapsuleInternal();
    });
    let longPressTimer = null;
    this.timeCapsuleButton.addEventListener("mousedown", () => {
      longPressTimer = setTimeout(() => {
        this.showDurationMenu();
      }, 800);
    });
    this.timeCapsuleButton.addEventListener("mouseup", () => {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    });
    this.timeCapsuleButton.addEventListener("mouseleave", () => {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    });
  }
  // 创建颜色筛选器
  createColorFilter(container) {
    this.colorFilterContainer = container.createDiv("canvas-grid-color-filter");
    const allBtn = this.colorFilterContainer.createDiv("canvas-grid-color-dot all-colors");
    allBtn.title = "\u663E\u793A\u5168\u90E8\u989C\u8272";
    allBtn.classList.add("active");
    allBtn.style.background = "conic-gradient(from 0deg, #ff6b6b 0deg 51.4deg, #ffa726 51.4deg 102.8deg, #ffeb3b 102.8deg 154.2deg, #66bb6a 154.2deg 205.6deg, #26c6da 205.6deg 257deg, #42a5f5 257deg 308.4deg, #ab47bc 308.4deg 360deg)";
    allBtn.addEventListener("click", () => {
      this.setColorFilter(null);
    });
    this.settings.colorFilterColors.forEach((colorValue) => {
      const colorDot = this.colorFilterContainer.createDiv("canvas-grid-color-dot");
      colorDot.dataset.color = colorValue;
      const colorMap = {
        "1": "#ff6b6b",
        // 红色
        "2": "#ffa726",
        // 橙色
        "3": "#ffeb3b",
        // 黄色
        "4": "#66bb6a",
        // 绿色
        "5": "#26c6da",
        // 青色
        "6": "#42a5f5",
        // 蓝色
        "7": "#ab47bc"
        // 紫色
      };
      const color = colorMap[colorValue];
      if (color) {
        colorDot.style.backgroundColor = color;
        colorDot.style.borderColor = color;
      }
      const colorCategory = this.settings.colorCategories.find((cat) => cat.color === colorValue);
      if (colorCategory) {
        colorDot.title = this.settings.language === "zh" ? `\u7B5B\u9009${colorCategory.name}\u5361\u7247` : `Filter ${colorCategory.name} cards`;
      } else {
        const colorNames = this.settings.language === "zh" ? ["\u7EA2", "\u6A59", "\u9EC4", "\u7EFF", "\u9752", "\u84DD", "\u7D2B"] : ["Red", "Orange", "Yellow", "Green", "Cyan", "Blue", "Purple"];
        const index = parseInt(colorValue) - 1;
        if (index >= 0 && index < colorNames.length) {
          colorDot.title = this.settings.language === "zh" ? `\u7B5B\u9009${colorNames[index]}\u8272\u5361\u7247` : `Filter ${colorNames[index]} cards`;
        }
      }
      colorDot.addEventListener("click", () => {
        this.setColorFilter(colorValue);
      });
    });
  }
  // 设置颜色筛选器（互斥选择）
  setColorFilter(color) {
    console.log("\u8BBE\u7F6E\u989C\u8272\u7B5B\u9009\u5668:", color);
    if (this.activeColorFilter === color) {
      this.activeColorFilter = null;
      color = null;
      console.log("\u53D6\u6D88\u5F53\u524D\u989C\u8272\u7B5B\u9009\uFF0C\u56DE\u5230\u663E\u793A\u5168\u90E8");
    } else {
      this.activeColorFilter = color;
    }
    if (this.colorFilterContainer) {
      const dots = this.colorFilterContainer.querySelectorAll(".canvas-grid-color-dot");
      console.log("\u627E\u5230\u989C\u8272\u5706\u70B9\u6570\u91CF:", dots.length);
      dots.forEach((dot) => {
        dot.classList.remove("active");
      });
      if (color === null) {
        const allBtn = this.colorFilterContainer.querySelector(".all-colors");
        if (allBtn) {
          allBtn.classList.add("active");
          console.log('\u6FC0\u6D3B"\u5168\u90E8"\u6309\u94AE');
        }
      } else {
        const targetDot = this.colorFilterContainer.querySelector(`[data-color="${color}"]`);
        if (targetDot) {
          targetDot.classList.add("active");
          console.log("\u6FC0\u6D3B\u989C\u8272\u5706\u70B9:", color);
        }
      }
    }
    console.log("\u6267\u884C\u989C\u8272\u7B5B\u9009\uFF0C\u5F53\u524D\u7B5B\u9009\u989C\u8272:", this.activeColorFilter);
    this.performSearch();
  }
  // ==================== 时间胶囊功能方法 ====================
  // 更新时间胶囊按钮显示
  updateTimeCapsuleButton() {
    if (!this.timeCapsuleButton)
      return;
    const state = this.timeCapsuleState;
    if (state.isActive) {
      const minutes = Math.floor(state.remainingTime / 6e4);
      const seconds = Math.floor(state.remainingTime % 6e4 / 1e3);
      const timeText = `${minutes}:${seconds.toString().padStart(2, "0")}`;
      let colorClass = "active";
      if (state.remainingTime < 6e4) {
        colorClass = "warning";
      }
      this.timeCapsuleButton.className = `canvas-grid-time-capsule-btn ${colorClass}`;
      this.timeCapsuleButton.innerHTML = `
				<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
					<path d="M6 2v6h.01L6 8.01 10 12l-4 4-.01.01V22h12v-5.99-.01L18 16l-4-4 4-3.99.01-.01V2H6z"/>
				</svg>
				<span class="time-display">${timeText}</span>
			`;
      this.timeCapsuleButton.title = `\u65F6\u95F4\u80F6\u56CA\u6536\u96C6\u4E2D - \u5269\u4F59 ${timeText}`;
    } else {
      this.timeCapsuleButton.className = "canvas-grid-time-capsule-btn";
      this.timeCapsuleButton.innerHTML = `
				<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
					<path d="M6 2v6h.01L6 8.01 10 12l-4 4-.01.01V22h12v-5.99-.01L18 16l-4-4 4-3.99.01-.01V2H6z"/>
				</svg>
			`;
      this.timeCapsuleButton.title = "\u65F6\u95F4\u80F6\u56CA - \u70B9\u51FB\u5F00\u59CB\u6536\u96C6";
    }
  }
  // 切换时间胶囊状态（私有方法，供按钮点击使用）
  toggleTimeCapsuleInternal() {
    if (this.timeCapsuleState.isActive) {
      this.stopTimeCapsule();
    } else {
      this.startTimeCapsule();
    }
  }
  // 开始时间胶囊
  startTimeCapsule() {
    const duration = this.timeCapsuleState.duration;
    const now = Date.now();
    const groupName = `\u65F6\u95F4\u80F6\u56CA ${(/* @__PURE__ */ new Date()).toLocaleString("zh-CN", {
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit"
    })}`;
    this.timeCapsuleState = {
      isActive: true,
      startTime: now,
      duration,
      remainingTime: duration,
      groupId: null,
      // 稍后创建分组时设置
      collectedItems: [],
      groupName
    };
    this.createTimeCapsuleGroup();
    this.startTimeCapsuleTimer();
    this.renderGrid();
    new import_obsidian.Notice(`\u65F6\u95F4\u80F6\u56CA\u5DF2\u542F\u52A8\uFF01\u6536\u96C6\u65F6\u957F\uFF1A${Math.floor(duration / 6e4)}\u5206\u949F`);
    console.log("\u65F6\u95F4\u80F6\u56CA\u5DF2\u542F\u52A8\uFF0C\u7F51\u683C\u89C6\u56FE\u5DF2\u5237\u65B0:", this.timeCapsuleState);
  }
  // 停止时间胶囊
  stopTimeCapsule() {
    if (this.timeCapsuleTimer) {
      clearTimeout(this.timeCapsuleTimer);
      this.timeCapsuleTimer = null;
    }
    if (this.timeCapsuleUpdateInterval) {
      clearInterval(this.timeCapsuleUpdateInterval);
      this.timeCapsuleUpdateInterval = null;
    }
    const collectedCount = this.timeCapsuleState.collectedItems.length;
    this.timeCapsuleState = {
      isActive: false,
      startTime: 0,
      duration: 15 * 60 * 1e3,
      remainingTime: 0,
      groupId: null,
      collectedItems: [],
      groupName: ""
    };
    this.updateTimeCapsuleButton();
    this.renderGrid();
    new import_obsidian.Notice(`\u65F6\u95F4\u80F6\u56CA\u5DF2\u7ED3\u675F\uFF01\u5171\u6536\u96C6\u4E86 ${collectedCount} \u4E2A\u9879\u76EE`);
    console.log("\u65F6\u95F4\u80F6\u56CA\u5DF2\u505C\u6B62\uFF0C\u7F51\u683C\u89C6\u56FE\u5DF2\u5237\u65B0");
  }
  // 开始倒计时定时器
  startTimeCapsuleTimer() {
    this.timeCapsuleTimer = setTimeout(() => {
      this.stopTimeCapsule();
    }, this.timeCapsuleState.duration);
    this.timeCapsuleUpdateInterval = setInterval(() => {
      const elapsed = Date.now() - this.timeCapsuleState.startTime;
      this.timeCapsuleState.remainingTime = Math.max(0, this.timeCapsuleState.duration - elapsed);
      this.updateTimeCapsuleButton();
      this.updateTimeCapsuleGroupDisplay();
      if (this.timeCapsuleState.remainingTime <= 0) {
        this.stopTimeCapsule();
      }
    }, 1e3);
  }
  // 创建时间胶囊分组
  createTimeCapsuleGroup() {
    if (!this.canvasData) {
      console.warn("\u65E0\u6CD5\u521B\u5EFA\u65F6\u95F4\u80F6\u56CA\u5206\u7EC4\uFF1ACanvas\u6570\u636E\u4E0D\u5B58\u5728");
      return;
    }
    const groupId = `time-capsule-${Date.now()}`;
    const timeCapsuleSize = { width: 400, height: 300 };
    const position = this.findSafePositionForTimeCapsule(timeCapsuleSize);
    console.log(`\u{1F3AF} \u65F6\u95F4\u80F6\u56CA\u5206\u7EC4\u4F4D\u7F6E\u8BA1\u7B97\u5B8C\u6210: (${position.x}, ${position.y})`);
    const groupNode = {
      id: groupId,
      type: "group",
      x: position.x,
      y: position.y,
      width: timeCapsuleSize.width,
      height: timeCapsuleSize.height,
      color: "5",
      // 青色 - 时间胶囊主题色
      label: this.timeCapsuleState.groupName
    };
    this.canvasData.nodes.push(groupNode);
    this.timeCapsuleState.groupId = groupId;
    this.saveCanvasData();
    console.log("\u65F6\u95F4\u80F6\u56CA\u5206\u7EC4\u5DF2\u521B\u5EFA:", groupId, "\u4F4D\u7F6E:", position);
  }
  // 为时间胶囊分组寻找安全位置，避免与现有分组重叠
  findSafePositionForTimeCapsule(size) {
    if (!this.canvasData) {
      return { x: 100, y: 100 };
    }
    const existingGroups = this.canvasData.nodes.filter((node) => node.type === "group");
    console.log(`\u{1F4CA} \u68C0\u6D4B\u5230 ${existingGroups.length} \u4E2A\u73B0\u6709\u5206\u7EC4`);
    const candidatePositions = [
      { x: 50, y: 50 },
      // 左上角
      { x: 500, y: 50 },
      // 右上角
      { x: 50, y: 400 },
      // 左下角
      { x: 500, y: 400 },
      // 右下角
      { x: 250, y: 50 },
      // 顶部中央
      { x: 50, y: 225 },
      // 左侧中央
      { x: 500, y: 225 },
      // 右侧中央
      { x: 250, y: 400 },
      // 底部中央
      { x: 800, y: 50 },
      // 更右上角
      { x: 800, y: 400 }
      // 更右下角
    ];
    for (const candidate of candidatePositions) {
      if (this.isPositionSafe(candidate, size, existingGroups)) {
        console.log(`\u2705 \u627E\u5230\u5B89\u5168\u4F4D\u7F6E: (${candidate.x}, ${candidate.y})`);
        return candidate;
      }
    }
    const dynamicPosition = this.findDynamicSafePosition(size, existingGroups);
    if (dynamicPosition) {
      console.log(`\u{1F50D} \u52A8\u6001\u627E\u5230\u5B89\u5168\u4F4D\u7F6E: (${dynamicPosition.x}, ${dynamicPosition.y})`);
      return dynamicPosition;
    }
    const fallbackPosition = { x: 1e3, y: 50 };
    console.log(`\u26A0\uFE0F \u4F7F\u7528\u5907\u7528\u4F4D\u7F6E: (${fallbackPosition.x}, ${fallbackPosition.y})`);
    return fallbackPosition;
  }
  // 检查指定位置是否安全（不与现有分组重叠）
  isPositionSafe(position, size, existingGroups) {
    const newGroupBounds = {
      left: position.x,
      top: position.y,
      right: position.x + size.width,
      bottom: position.y + size.height
    };
    for (const group of existingGroups) {
      const groupBounds = {
        left: group.x,
        top: group.y,
        right: group.x + (group.width || 200),
        bottom: group.y + (group.height || 200)
      };
      const isOverlapping = !(newGroupBounds.right < groupBounds.left || newGroupBounds.left > groupBounds.right || newGroupBounds.bottom < groupBounds.top || newGroupBounds.top > groupBounds.bottom);
      if (isOverlapping) {
        console.log(`\u274C \u4F4D\u7F6E (${position.x}, ${position.y}) \u4E0E\u5206\u7EC4 ${group.id} \u91CD\u53E0`);
        return false;
      }
    }
    return true;
  }
  // 动态寻找安全位置
  findDynamicSafePosition(size, existingGroups) {
    const canvasBounds = this.calculateCanvasBounds(existingGroups);
    const rightSideX = canvasBounds.maxX + 100;
    const testPosition = { x: rightSideX, y: 50 };
    if (this.isPositionSafe(testPosition, size, existingGroups)) {
      return testPosition;
    }
    const bottomY = canvasBounds.maxY + 100;
    const bottomPosition = { x: 50, y: bottomY };
    if (this.isPositionSafe(bottomPosition, size, existingGroups)) {
      return bottomPosition;
    }
    const gridStep = 50;
    for (let x = 50; x <= 1200; x += gridStep) {
      for (let y = 50; y <= 800; y += gridStep) {
        const gridPosition = { x, y };
        if (this.isPositionSafe(gridPosition, size, existingGroups)) {
          return gridPosition;
        }
      }
    }
    return null;
  }
  // 计算Canvas的使用边界
  calculateCanvasBounds(existingGroups) {
    if (existingGroups.length === 0) {
      return { minX: 0, minY: 0, maxX: 0, maxY: 0 };
    }
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    existingGroups.forEach((group) => {
      const left = group.x;
      const top = group.y;
      const right = group.x + (group.width || 200);
      const bottom = group.y + (group.height || 200);
      minX = Math.min(minX, left);
      minY = Math.min(minY, top);
      maxX = Math.max(maxX, right);
      maxY = Math.max(maxY, bottom);
    });
    console.log(`\u{1F4D0} Canvas\u4F7F\u7528\u8FB9\u754C: (${minX}, ${minY}) \u5230 (${maxX}, ${maxY})`);
    return { minX, minY, maxX, maxY };
  }
  // 更新时间胶囊分组显示
  updateTimeCapsuleGroupDisplay() {
    if (!this.timeCapsuleState.isActive || !this.timeCapsuleState.groupId)
      return;
    const groupCard = this.gridContainer.querySelector(`[data-node-id="${this.timeCapsuleState.groupId}"]`);
    if (!groupCard)
      return;
    const countDiv = groupCard.querySelector(".group-member-count");
    if (countDiv) {
      const minutes = Math.floor(this.timeCapsuleState.remainingTime / 6e4);
      const seconds = Math.floor(this.timeCapsuleState.remainingTime % 6e4 / 1e3);
      const timeText = `${minutes}:${seconds.toString().padStart(2, "0")}`;
      const collectedCount = this.timeCapsuleState.collectedItems.length;
      countDiv.innerHTML = `
				<div class="time-capsule-status">
					<span class="collecting-text">\u6536\u96C6\u4E2D</span>
					<span class="countdown-text">${timeText}</span>
				</div>
				<div class="member-count">${collectedCount} \u4E2A\u9879\u76EE</div>
			`;
    }
    if (this.timeCapsuleState.remainingTime < 6e4) {
      groupCard.classList.add("time-capsule-urgent");
    }
  }
  // 获取时间胶囊最大收集数量（基于时长）
  getMaxCollectionCount() {
    const durationMinutes = Math.floor(this.timeCapsuleState.duration / 6e4);
    return Math.max(10, durationMinutes * 2);
  }
  // 显示时长选择菜单
  showDurationMenu() {
    const menu = document.createElement("div");
    menu.className = "canvas-grid-duration-menu";
    const durations = [
      { label: "5\u5206\u949F", value: 5 * 60 * 1e3 },
      { label: "15\u5206\u949F", value: 15 * 60 * 1e3 },
      { label: "30\u5206\u949F", value: 30 * 60 * 1e3 },
      { label: "1\u5C0F\u65F6", value: 60 * 60 * 1e3 }
    ];
    durations.forEach((duration) => {
      const item = menu.createDiv("duration-menu-item");
      item.textContent = duration.label;
      item.onclick = () => {
        this.timeCapsuleState.duration = duration.value;
        menu.remove();
        new import_obsidian.Notice(`\u65F6\u95F4\u80F6\u56CA\u65F6\u957F\u8BBE\u7F6E\u4E3A\uFF1A${duration.label}`);
      };
    });
    const buttonRect = this.timeCapsuleButton.getBoundingClientRect();
    menu.style.position = "fixed";
    menu.style.top = `${buttonRect.bottom + 5}px`;
    menu.style.left = `${buttonRect.left}px`;
    menu.style.zIndex = "1000";
    document.body.appendChild(menu);
    const closeMenu = (e) => {
      if (!menu.contains(e.target)) {
        menu.remove();
        document.removeEventListener("click", closeMenu);
      }
    };
    setTimeout(() => document.addEventListener("click", closeMenu), 100);
  }
  // 检查时间胶囊是否激活
  isTimeCapsuleActive() {
    return this.timeCapsuleState.isActive;
  }
  // 收集内容到时间胶囊
  collectToTimeCapsule(content, sourceInfo) {
    if (!this.timeCapsuleState.isActive || !this.timeCapsuleState.groupId) {
      console.warn("\u65F6\u95F4\u80F6\u56CA\u672A\u6FC0\u6D3B\u6216\u5206\u7EC4\u4E0D\u5B58\u5728");
      return;
    }
    const nodeId = `collected-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
    const timestamp = (/* @__PURE__ */ new Date()).toLocaleTimeString();
    let nodeText = content;
    if (sourceInfo.sourcePath && sourceInfo.sourcePath !== "\u526A\u8D34\u677F") {
      const fileName = sourceInfo.sourcePath.split("/").pop()?.replace(".md", "") || sourceInfo.sourcePath;
      nodeText += `

---
\u{1F4CD} \u6765\u6E90: [[${fileName}]]`;
      if (sourceInfo.sourcePosition) {
        nodeText += ` (\u884C ${sourceInfo.sourcePosition.line + 1})`;
      }
    }
    nodeText += `
\u23F0 \u6536\u96C6\u65F6\u95F4: ${timestamp}`;
    const groupNode = this.canvasData?.nodes.find((n) => n.id === this.timeCapsuleState.groupId);
    if (!groupNode) {
      console.warn("\u627E\u4E0D\u5230\u65F6\u95F4\u80F6\u56CA\u5206\u7EC4");
      return;
    }
    const itemIndex = this.timeCapsuleState.collectedItems.length;
    const nodeX = groupNode.x + 20 + itemIndex % 2 * 180;
    const nodeY = groupNode.y + 50 + Math.floor(itemIndex / 2) * 120;
    const newNode = {
      id: nodeId,
      type: "text",
      x: nodeX,
      y: nodeY,
      width: 160,
      height: 100,
      color: "5",
      // 青色标记为收集的内容
      text: nodeText
    };
    if (this.canvasData) {
      this.canvasData.nodes.push(newNode);
      this.timeCapsuleState.collectedItems.push(nodeId);
      this.saveCanvasData();
      this.renderGrid();
      this.updateTimeCapsuleGroupDisplay();
      new import_obsidian.Notice(`\u5DF2\u6536\u96C6\u5230\u65F6\u95F4\u80F6\u56CA (${this.timeCapsuleState.collectedItems.length}/${this.getMaxCollectionCount()})`);
      console.log("\u5185\u5BB9\u5DF2\u6536\u96C6\u5230\u65F6\u95F4\u80F6\u56CA:", nodeId);
    }
  }
  // 公开切换时间胶囊方法
  toggleTimeCapsule() {
    if (this.timeCapsuleState.isActive) {
      this.stopTimeCapsule();
    } else {
      this.startTimeCapsule();
    }
  }
  // 更新颜色筛选器（公共方法）
  updateColorFilter() {
    if (this.colorFilterContainer) {
      this.colorFilterContainer.remove();
      this.colorFilterContainer = null;
    }
    const container = this.containerEl.children[1];
    if (!container) {
      console.error("Canvasgrid Transit: Container element not found");
      return;
    }
    const colorRow = container.querySelector(".canvas-grid-toolbar-color-row");
    if (colorRow) {
      this.createColorFilter(colorRow);
    } else {
      console.warn("Canvasgrid Transit: Color row not found, recreating toolbar");
      const toolbar = container.querySelector(".canvas-grid-toolbar");
      if (toolbar) {
        toolbar.remove();
      }
      this.createToolbar(container);
    }
  }
  // 视图选项方法已移除，功能已整合到主菜单
  // ==================== 搜索和排序功能实现 ====================
  // 执行搜索（优化版本，减少不必要的重新渲染）
  performSearch() {
    if (!this.canvasData) {
      this.filteredNodes = [];
      this.applySortAndFilter();
      return;
    }
    console.log(`\u{1F50D} Performing search with query: "${this.searchQuery}"`);
    const previousFilteredNodes = [...this.filteredNodes];
    let searchResults;
    if (!this.searchQuery || this.searchQuery.trim() === "") {
      searchResults = [...this.canvasData.nodes];
      console.log("\u65E0\u641C\u7D22\u67E5\u8BE2\uFF0C\u4F7F\u7528\u6240\u6709\u8282\u70B9:", searchResults.length);
    } else {
      const query = this.searchQuery.toLowerCase().trim();
      searchResults = this.canvasData.nodes.filter((node) => {
        if (node.text && node.text.toLowerCase().includes(query)) {
          return true;
        }
        if (node.file && node.file.toLowerCase().includes(query)) {
          return true;
        }
        if (node.url && node.url.toLowerCase().includes(query)) {
          return true;
        }
        return false;
      });
      console.log(`\u641C\u7D22 "${query}" \u627E\u5230 ${searchResults.length} \u4E2A\u7ED3\u679C`);
    }
    console.log("\u5E94\u7528\u989C\u8272\u7B5B\u9009\uFF0C\u5F53\u524D\u7B5B\u9009\u989C\u8272:", this.activeColorFilter);
    if (this.activeColorFilter && this.activeColorFilter !== "all") {
      this.filteredNodes = searchResults.filter((node) => {
        const matches = node.color === this.activeColorFilter;
        return matches;
      });
      console.log("\u989C\u8272\u7B5B\u9009\u540E\u8282\u70B9\u6570\u91CF:", this.filteredNodes.length);
    } else {
      this.filteredNodes = searchResults;
      console.log("\u65E0\u989C\u8272\u7B5B\u9009\uFF0C\u4F7F\u7528\u6240\u6709\u641C\u7D22\u7ED3\u679C:", this.filteredNodes.length);
    }
    console.log(`\u{1F4CA} Final filtered nodes: ${this.filteredNodes.length}, applying sort...`);
    this.applySortAndFilter();
  }
  // 比较两个数组是否相等（基于节点ID）
  arraysEqual(arr1, arr2) {
    if (arr1.length !== arr2.length)
      return false;
    const ids1 = arr1.map((node) => node.id).sort();
    const ids2 = arr2.map((node) => node.id).sort();
    return ids1.every((id, index) => id === ids2[index]);
  }
  // 应用排序和筛选
  applySortAndFilter() {
    if (!this.filteredNodes || this.filteredNodes.length === 0) {
      this.renderGrid();
      return;
    }
    console.log(`\u{1F504} Applying sort: ${this.sortBy} (${this.sortOrder}) to ${this.filteredNodes.length} nodes`);
    this.filteredNodes.sort((a, b) => {
      let comparison = 0;
      try {
        switch (this.sortBy) {
          case "created":
            const timeA = this.extractTimestamp(a.id);
            const timeB = this.extractTimestamp(b.id);
            comparison = timeA - timeB;
            break;
          case "modified":
            const modA = a.modified || this.extractTimestamp(a.id);
            const modB = b.modified || this.extractTimestamp(b.id);
            comparison = modA - modB;
            break;
          case "title":
            const titleA = this.getNodeTitle(a).toLowerCase();
            const titleB = this.getNodeTitle(b).toLowerCase();
            comparison = titleA.localeCompare(titleB);
            break;
          default:
            const defaultTimeA = this.extractTimestamp(a.id);
            const defaultTimeB = this.extractTimestamp(b.id);
            comparison = defaultTimeA - defaultTimeB;
            break;
        }
      } catch (error) {
        console.error("\u6392\u5E8F\u8FC7\u7A0B\u4E2D\u51FA\u9519:", error);
        comparison = a.id.localeCompare(b.id);
      }
      const result = this.sortOrder === "asc" ? comparison : -comparison;
      return result;
    });
    console.log(`\u2705 Sort completed. First node: ${this.getNodeTitle(this.filteredNodes[0])}`);
    this.renderGrid();
  }
  // 提取时间戳
  extractTimestamp(nodeId) {
    const match = nodeId.match(/(\d{13})/);
    return match ? parseInt(match[1]) : 0;
  }
  // 获取节点标题
  getNodeTitle(node) {
    if (node.text) {
      return node.text.split("\n")[0].substring(0, 50);
    }
    if (node.file) {
      return node.file;
    }
    if (node.url) {
      return node.url;
    }
    return "Untitled";
  }
  // 强制刷新排序（用于数据更新后）
  refreshSort() {
    console.log("\u{1F504} Refreshing sort...");
    if (!this.canvasData) {
      return;
    }
    this.filteredNodes = [...this.canvasData.nodes];
    this.performSearch();
  }
  // 应用类型筛选
  applyTypeFilter(filterType) {
    if (!this.canvasData)
      return;
    if (filterType === "all") {
      this.filteredNodes = [...this.canvasData.nodes];
    } else {
      this.filteredNodes = this.canvasData.nodes.filter((node) => {
        return node.type === filterType;
      });
    }
    if (this.searchQuery) {
      this.performSearch();
    } else {
      this.applySortAndFilter();
    }
  }
  // 卡片大小调整方法已移除
  // 隐藏所有下拉菜单
  hideAllDropdowns() {
    const mainDropdowns = this.containerEl.querySelectorAll(".canvas-grid-main-dropdown");
    mainDropdowns.forEach((dropdown) => {
      dropdown.style.display = "none";
    });
    const buttons = this.containerEl.querySelectorAll(".canvas-grid-main-btn");
    buttons.forEach((btn) => {
      btn.classList.remove("active");
    });
    this.closeAllSubmenus();
  }
  // 隐藏下拉菜单
  hideDropdownMenu(dropdownMenu) {
    dropdownMenu.style.display = "none";
  }
  // 切换下拉菜单
  toggleDropdownMenu(dropdownMenu) {
    const isVisible = dropdownMenu.style.display !== "none";
    if (isVisible) {
      dropdownMenu.style.display = "none";
    } else {
      dropdownMenu.style.display = "block";
    }
  }
  // 显示空状态
  showEmptyState() {
    const emptyEl = this.gridContainer.createDiv("canvas-grid-empty-state");
    emptyEl.innerHTML = `
			<div class="empty-icon">\u{1F4C4}</div>
			<div class="empty-title">\u6CA1\u6709Canvas\u8282\u70B9</div>
			<div class="empty-desc">\u5F53\u524DCanvas\u6587\u4EF6\u4E2D\u6CA1\u6709\u8282\u70B9\uFF0C\u8BF7\u5148\u5728Canvas\u4E2D\u6DFB\u52A0\u4E00\u4E9B\u5185\u5BB9</div>
		`;
  }
  // 创建菜单区域 (已整合到主菜单，保留以防兼容性问题)
  createMenuSection(container) {
    return;
    const menuSection = container.createDiv("canvas-grid-toolbar-menu");
    const menuBtn = menuSection.createDiv("canvas-grid-menu-btn");
    menuBtn.innerHTML = `
			<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<circle cx="12" cy="12" r="1"/>
				<circle cx="12" cy="5" r="1"/>
				<circle cx="12" cy="19" r="1"/>
			</svg>
		`;
    menuBtn.title = "\u66F4\u591A\u9009\u9879";
    const dropdownMenu = menuSection.createDiv("canvas-grid-dropdown-menu");
    dropdownMenu.style.display = "none";
    const backMenuItem = dropdownMenu.createDiv("canvas-grid-menu-item");
    backMenuItem.innerHTML = `
			<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<path d="m12 19-7-7 7-7"/>
				<path d="m19 12H5"/>
			</svg>
			<span>\u8FD4\u56DECanvas</span>
		`;
    backMenuItem.onclick = () => {
      this.switchToCanvasView();
      this.hideDropdownMenu(dropdownMenu);
    };
    const refreshMenuItem = dropdownMenu.createDiv("canvas-grid-menu-item");
    refreshMenuItem.innerHTML = `
			<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/>
				<path d="M21 3v5h-5"/>
				<path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/>
				<path d="M3 21v-5h5"/>
			</svg>
			<span>\u5237\u65B0</span>
		`;
    refreshMenuItem.onclick = () => {
      this.refreshCanvasData();
      this.hideDropdownMenu(dropdownMenu);
    };
    const settingsMenuItem = dropdownMenu.createDiv("canvas-grid-menu-item");
    settingsMenuItem.innerHTML = `
			<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<circle cx="12" cy="12" r="3"/>
				<path d="m12 1 1.27 2.22 2.22 1.27-1.27 2.22L12 8.5l-1.27-2.22L8.5 5.23l1.27-2.22L12 1"/>
				<path d="m12 15.5 1.27 2.22 2.22 1.27-1.27 2.22L12 22.5l-1.27-2.22L8.5 18.77l1.27-2.22L12 15.5"/>
			</svg>
			<span>\u7F51\u683C\u8BBE\u7F6E</span>
		`;
    settingsMenuItem.onclick = () => {
      this.openGridSettings();
      this.hideDropdownMenu(dropdownMenu);
    };
    menuBtn.onclick = (e) => {
      e.stopPropagation();
      this.toggleDropdownMenu(dropdownMenu);
    };
    document.addEventListener("click", () => {
      this.hideDropdownMenu(dropdownMenu);
    });
  }
  // 设置网格样式 - 使用CSS Grid自动布局
  setupGridStyles() {
    this.gridContainer.style.setProperty("--grid-card-spacing", `${CARD_CONSTANTS.spacing}px`);
    this.gridContainer.style.setProperty("--grid-card-min-width", `${CARD_CONSTANTS.width}px`);
    this.gridContainer.style.setProperty("--grid-card-height", `${CARD_CONSTANTS.height}px`);
    this.gridContainer.style.removeProperty("grid-template-columns");
  }
  // 设置事件委托，提升性能
  setupEventDelegation() {
    this.gridContainer.addEventListener("click", this.handleGridClick);
    this.gridContainer.addEventListener("dblclick", this.handleCardDoubleClick);
    this.gridContainer.addEventListener("contextmenu", this.handleCardContextMenu);
    this.gridContainer.addEventListener("keydown", this.handleKeyDown);
    document.addEventListener("click", this.handleDocumentClick);
    this.setupScrollListener();
    this.setupGridCardDragEvents();
  }
  // 设置网格卡片拖拽事件 - 使用HTML5 Drag & Drop API
  setupGridCardDragEvents() {
    this.setupCardDragAttributes();
    this.registerDomEvent(this.gridContainer, "dragstart", this.handleCardDragStart.bind(this));
    this.registerDomEvent(this.gridContainer, "dragend", this.handleCardDragEnd.bind(this));
  }
  // 为卡片设置拖拽属性
  setupCardDragAttributes() {
    const cards = this.gridContainer.querySelectorAll(".canvas-grid-card");
    cards.forEach((card) => {
      card.draggable = false;
      card.style.cursor = "grab";
      this.setupCardLongPress(card);
    });
  }
  // 设置卡片长按检测
  setupCardLongPress(cardElement) {
    let longPressTimer = null;
    let longPressStartTime = 0;
    const handleMouseDown = (e) => {
      if (e.target.closest(".canvas-card-toolbar")) {
        return;
      }
      longPressStartTime = Date.now();
      longPressTimer = setTimeout(() => {
        cardElement.draggable = true;
        cardElement.style.cursor = "grabbing";
        console.log("\u{1F525} Long press detected, drag enabled");
        cardElement.classList.add("long-press-active");
      }, 500);
    };
    const handleMouseUp = () => {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
      setTimeout(() => {
        cardElement.draggable = false;
        cardElement.style.cursor = "grab";
        cardElement.classList.remove("long-press-active");
      }, 100);
    };
    const handleMouseLeave = () => {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    };
    cardElement.addEventListener("mousedown", handleMouseDown);
    cardElement.addEventListener("mouseup", handleMouseUp);
    cardElement.addEventListener("mouseleave", handleMouseLeave);
  }
  // 设置滚动监听，实现功能栏自动隐藏/显示
  setupScrollListener() {
    let lastScrollTop = 0;
    let isToolbarHidden = false;
    let scrollTimeout = null;
    const getContainer = () => {
      return this.containerEl.children[1];
    };
    const getToolbar = () => {
      const container = getContainer();
      return container?.querySelector(".canvas-grid-toolbar");
    };
    const showToolbar = () => {
      const toolbar2 = getToolbar();
      const container = getContainer();
      if (toolbar2 && container && isToolbarHidden) {
        toolbar2.style.position = "relative";
        toolbar2.style.transform = "translateY(0)";
        toolbar2.style.opacity = "1";
        toolbar2.style.zIndex = "100";
        this.gridContainer.classList.remove("toolbar-hidden");
        const viewContent = this.containerEl.querySelector(".view-content");
        if (viewContent) {
          viewContent.classList.remove("toolbar-hidden-parent");
        }
        this.gridContainer.style.removeProperty("margin-top");
        this.gridContainer.style.removeProperty("height");
        isToolbarHidden = false;
      }
    };
    const hideToolbar = () => {
      const toolbar2 = getToolbar();
      const container = getContainer();
      if (toolbar2 && container && !isToolbarHidden) {
        const toolbarHeight = toolbar2.offsetHeight;
        toolbar2.style.position = "fixed";
        toolbar2.style.top = "0";
        toolbar2.style.left = "0";
        toolbar2.style.right = "0";
        toolbar2.style.transform = "translateY(-100%)";
        toolbar2.style.opacity = "0";
        toolbar2.style.zIndex = "100";
        this.gridContainer.classList.add("toolbar-hidden");
        const viewContent = this.containerEl.querySelector(".view-content");
        if (viewContent) {
          viewContent.classList.add("toolbar-hidden-parent");
        }
        this.gridContainer.style.marginTop = `-${toolbarHeight}px`;
        isToolbarHidden = true;
      }
    };
    const handleScroll = () => {
      const currentScrollTop = this.gridContainer.scrollTop;
      const scrollDelta = currentScrollTop - lastScrollTop;
      if (scrollTimeout) {
        clearTimeout(scrollTimeout);
      }
      if (Math.abs(scrollDelta) < 5) {
        return;
      }
      if (currentScrollTop < 50) {
        showToolbar();
      } else {
        if (scrollDelta > 0 && !isToolbarHidden) {
          hideToolbar();
        } else if (scrollDelta < 0 && isToolbarHidden) {
          showToolbar();
        }
      }
      scrollTimeout = setTimeout(() => {
        showToolbar();
      }, 2e3);
      lastScrollTop = currentScrollTop;
    };
    this.gridContainer.addEventListener("scroll", handleScroll, { passive: true });
    const toolbar = getToolbar();
    if (toolbar) {
      toolbar.style.transition = "transform 0.3s ease, opacity 0.3s ease";
      toolbar.style.zIndex = "100";
    }
  }
  // 加载当前活动的Canvas文件 - 优化版本
  async loadActiveCanvas() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile || activeFile.extension !== "canvas") {
      this.showMessage("\u8BF7\u5148\u6253\u5F00\u4E00\u4E2ACanvas\u6587\u4EF6");
      return;
    }
    this.showLoadingState();
    try {
      const content = await this.app.vault.read(activeFile);
      let parsedData;
      try {
        parsedData = JSON.parse(content);
      } catch (parseError) {
        throw new Error("Canvas\u6587\u4EF6\u683C\u5F0F\u65E0\u6548");
      }
      if (!parsedData.nodes || !Array.isArray(parsedData.nodes)) {
        throw new Error("Canvas\u6587\u4EF6\u7F3A\u5C11\u6709\u6548\u7684\u8282\u70B9\u6570\u636E");
      }
      this.canvasData = parsedData;
      this.initializeSearchAndSort();
      console.log("\u2705 Canvas loaded and sort applied");
    } catch (error) {
      console.error("Canvas\u52A0\u8F7D\u9519\u8BEF:", error);
      this.showErrorState(error instanceof Error ? error.message : "\u672A\u77E5\u9519\u8BEF");
    }
  }
  // 渲染网格视图 - 优化版本（支持批量渲染和分组显示）
  renderGrid() {
    if (!this.gridContainer)
      return;
    this.gridContainer.empty();
    if (this.currentGroupView) {
      this.renderGroupMembers();
      return;
    }
    this.analyzeGroups();
    const nodesToRender = this.searchQuery || this.activeColorFilter ? this.filteredNodes : this.canvasData?.nodes || [];
    console.log("\u6E32\u67D3\u8282\u70B9\u51B3\u7B56:", {
      searchQuery: this.searchQuery,
      activeColorFilter: this.activeColorFilter,
      filteredNodesLength: this.filteredNodes.length,
      nodesToRenderLength: nodesToRender.length,
      groupCount: this.groupAnalysis.size
    });
    if (nodesToRender.length === 0) {
      if (this.searchQuery) {
        this.showNoSearchResults();
      } else {
        this.showEmptyState();
      }
      return;
    }
    const groupNodes = nodesToRender.filter((node) => node.type === "group");
    const regularNodes = nodesToRender.filter((node) => node.type !== "group");
    const itemsToRender = [];
    const sortedGroups = this.getGroupsForGridView();
    sortedGroups.forEach((groupInfo) => {
      if (groupNodes.some((node) => node.id === groupInfo.group.id)) {
        itemsToRender.push({ type: "group", data: groupInfo });
      }
    });
    const ungroupedNodes = this.getUngroupedNodes(regularNodes);
    ungroupedNodes.forEach((node) => {
      itemsToRender.push({ type: "node", data: node });
    });
    this.renderGridItems(itemsToRender);
    this.setupCardDragAttributes();
  }
  // 立即渲染（小量数据）
  renderGridImmediate(nodes) {
    const fragment = document.createDocumentFragment();
    nodes.forEach((node) => {
      const card = this.createCard(node);
      if (this.searchQuery) {
        this.highlightSearchResults(card, this.searchQuery);
      }
      fragment.appendChild(card);
    });
    this.gridContainer.appendChild(fragment);
  }
  // 批量渲染（大量数据）
  async renderGridBatched(nodes) {
    const batchSize = 20;
    let currentIndex = 0;
    this.showLoadingState();
    const renderBatch = () => {
      const fragment = document.createDocumentFragment();
      const endIndex = Math.min(currentIndex + batchSize, nodes.length);
      for (let i = currentIndex; i < endIndex; i++) {
        const node = nodes[i];
        const card = this.createCard(node);
        if (this.searchQuery) {
          this.highlightSearchResults(card, this.searchQuery);
        }
        fragment.appendChild(card);
      }
      this.gridContainer.appendChild(fragment);
      currentIndex = endIndex;
      if (currentIndex < nodes.length) {
        requestAnimationFrame(renderBatch);
      } else {
        this.hideLoadingState();
      }
    };
    requestAnimationFrame(renderBatch);
  }
  // 显示无搜索结果状态
  showNoSearchResults() {
    const emptyEl = this.gridContainer.createDiv("canvas-grid-empty-state");
    emptyEl.innerHTML = `
			<div class="empty-icon">\u{1F50D}</div>
			<div class="empty-title">\u672A\u627E\u5230\u5339\u914D\u7684\u5361\u7247</div>
			<div class="empty-desc">\u5C1D\u8BD5\u4F7F\u7528\u4E0D\u540C\u7684\u5173\u952E\u8BCD\u641C\u7D22</div>
			<button class="empty-action" onclick="this.closest('.canvas-grid-view').querySelector('.canvas-grid-search-input').value = ''; this.closest('.canvas-grid-view').querySelector('.canvas-grid-search-input').dispatchEvent(new Event('input'));">\u6E05\u7A7A\u641C\u7D22</button>
		`;
  }
  // 高亮搜索结果
  highlightSearchResults(cardEl, query) {
    const textElements = cardEl.querySelectorAll(".canvas-grid-card-content, .canvas-grid-card-title");
    const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")})`, "gi");
    textElements.forEach((el) => {
      const element = el;
      if (element.textContent) {
        element.innerHTML = element.textContent.replace(regex, '<mark class="search-highlight">$1</mark>');
      }
    });
  }
  // 保存设置
  async saveSettings() {
    console.log("Settings saved:", this.settings);
  }
  // 创建单个卡片 - 响应式版本（带缓存优化）
  createCard(node) {
    const cacheKey = this.generateCardCacheKey(node);
    const cachedCard = this.getRenderCacheItem(cacheKey);
    if (cachedCard) {
      const clonedCard = cachedCard.cloneNode(true);
      this.updateCardEventHandlers(clonedCard, node);
      return clonedCard;
    }
    const card = this.createCardInternal(node);
    this.setRenderCacheItem(cacheKey, card.cloneNode(true));
    return card;
  }
  // 内部创建卡片方法
  createCardInternal(node) {
    const card = document.createElement("div");
    card.className = "canvas-grid-card";
    card.style.minHeight = `${CARD_CONSTANTS.height}px`;
    card.dataset.nodeId = node.id;
    card.dataset.nodeType = node.type;
    if (node.color) {
      const normalizedColor = this.normalizeColorValue(node.color);
      if (normalizedColor) {
        const colorStyles = this.getColorStyles(normalizedColor);
        card.dataset.color = normalizedColor;
        card.style.backgroundColor = colorStyles.backgroundColor;
        card.style.borderColor = colorStyles.borderColor;
        card.style.borderWidth = "2px";
      }
    }
    if (node.flag) {
      card.dataset.flag = node.flag.toString();
    }
    card.setAttribute("role", "button");
    card.setAttribute("tabindex", "0");
    card.setAttribute("aria-label", `${node.type}\u8282\u70B9`);
    this.renderCardContent(card, node);
    this.createCardToolbar(card, node);
    return card;
  }
  // 生成卡片缓存键
  generateCardCacheKey(node) {
    const keyData = {
      id: node.id,
      type: node.type,
      color: node.color,
      flag: node.flag,
      // 对于文本节点，包含文本内容的哈希
      textHash: node.text ? this.simpleHash(node.text) : null,
      // 对于文件节点，包含文件路径
      file: node.file,
      // 对于链接节点，包含URL
      url: node.url,
      // 设置相关
      cardHeight: CARD_CONSTANTS.height
    };
    return JSON.stringify(keyData);
  }
  // 简单哈希函数
  simpleHash(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return hash;
  }
  // 获取渲染缓存项
  getRenderCacheItem(key) {
    const item = this.renderCache.get(key);
    if (item) {
      const currentCount = this.renderCacheAccessCount.get(key) || 0;
      this.renderCacheAccessCount.set(key, currentCount + 1);
      return item;
    }
    return null;
  }
  // 设置渲染缓存项
  setRenderCacheItem(key, element) {
    if (this.renderCache.size >= this.MAX_RENDER_CACHE_SIZE) {
      this.cleanupRenderCache();
    }
    this.renderCache.set(key, element);
    this.renderCacheAccessCount.set(key, 1);
  }
  // 清理渲染缓存
  cleanupRenderCache() {
    let minAccess = Infinity;
    let keyToDelete = "";
    for (const [key, count] of this.renderCacheAccessCount.entries()) {
      if (count < minAccess) {
        minAccess = count;
        keyToDelete = key;
      }
    }
    if (keyToDelete) {
      this.renderCache.delete(keyToDelete);
      this.renderCacheAccessCount.delete(keyToDelete);
    }
  }
  // 更新卡片事件处理器（用于缓存的卡片）
  updateCardEventHandlers(card, node) {
    card.dataset.nodeId = node.id;
    card.dataset.nodeType = node.type;
  }
  // 清空渲染缓存
  clearRenderCache() {
    this.renderCache.clear();
    this.renderCacheAccessCount.clear();
  }
  // 创建卡片工具栏
  createCardToolbar(card, node) {
    const toolbar = document.createElement("div");
    toolbar.className = "canvas-card-toolbar";
    const deleteBtn = this.createToolbarButton("delete", "\u5220\u9664");
    const colorBtn = this.createToolbarButton("color", "\u8BBE\u7F6E\u989C\u8272");
    toolbar.appendChild(deleteBtn);
    toolbar.appendChild(colorBtn);
    card.appendChild(toolbar);
  }
  // 创建工具栏按钮（使用事件委托，不直接绑定onclick）
  createToolbarButton(type, title, onClick) {
    const button = document.createElement("div");
    button.className = `canvas-card-toolbar-btn canvas-card-toolbar-${type}`;
    button.title = title;
    button.setAttribute("role", "button");
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-label", title);
    const icon = document.createElement("div");
    icon.className = `canvas-card-toolbar-icon canvas-card-toolbar-icon-${type}`;
    button.appendChild(icon);
    return button;
  }
  // 从工具栏删除卡片
  async deleteCardFromToolbar(card) {
    const nodeId = card.dataset.nodeId;
    if (!nodeId)
      return;
    const confirmed = confirm("\u786E\u5B9A\u8981\u5220\u9664\u8FD9\u4E2A\u8282\u70B9\u5417\uFF1F");
    if (!confirmed)
      return;
    try {
      await this.deleteNodeFromCanvas(nodeId);
      card.remove();
      console.log("\u5361\u7247\u5220\u9664\u5B8C\u6210\uFF0CUI\u5DF2\u66F4\u65B0");
    } catch (error) {
      console.error("\u5220\u9664\u5361\u7247\u5931\u8D25:", error);
      new import_obsidian.Notice("\u5220\u9664\u5361\u7247\u5931\u8D25");
    }
  }
  // 显示颜色选择器
  showColorPicker(card, node) {
    const colorPicker = document.createElement("div");
    colorPicker.className = "canvas-color-picker";
    const colors = [
      { name: "\u9ED8\u8BA4", value: "", bgColor: "var(--background-primary)", textColor: "var(--text-normal)" },
      { name: "\u7EA2\u8272", value: "1" },
      { name: "\u6A59\u8272", value: "2" },
      { name: "\u9EC4\u8272", value: "3" },
      { name: "\u7EFF\u8272", value: "4" },
      { name: "\u9752\u8272", value: "5" },
      { name: "\u84DD\u8272", value: "6" },
      { name: "\u7D2B\u8272", value: "7" }
    ];
    colors.forEach((colorOption) => {
      const colorItem = document.createElement("div");
      colorItem.className = "canvas-color-item";
      if (colorOption.value) {
        const pureColorMap = {
          "1": "#ff6b6b",
          // 红色
          "2": "#ffa726",
          // 橙色
          "3": "#ffeb3b",
          // 黄色
          "4": "#66bb6a",
          // 绿色
          "5": "#26c6da",
          // 青色
          "6": "#42a5f5",
          // 蓝色
          "7": "#ab47bc"
          // 紫色
        };
        const pureColor = pureColorMap[colorOption.value];
        colorItem.style.backgroundColor = pureColor;
        colorItem.style.border = `2px solid ${pureColor}`;
      } else {
        colorItem.style.backgroundColor = "var(--background-secondary)";
        colorItem.style.border = "2px solid var(--background-modifier-border)";
      }
      colorItem.style.borderRadius = "50%";
      colorItem.style.width = "24px";
      colorItem.style.height = "24px";
      colorItem.style.cursor = "pointer";
      colorItem.style.transition = "all 0.2s ease";
      colorItem.addEventListener("mouseenter", () => {
        colorItem.style.transform = "scale(1.1)";
        colorItem.style.boxShadow = "0 2px 8px rgba(0, 0, 0, 0.2)";
      });
      colorItem.addEventListener("mouseleave", () => {
        colorItem.style.transform = "scale(1)";
        colorItem.style.boxShadow = "none";
      });
      colorItem.title = colorOption.name;
      if (node.color === colorOption.value || !node.color && !colorOption.value) {
        colorItem.classList.add("selected");
        colorItem.style.boxShadow = "0 0 0 2px var(--interactive-accent)";
      }
      colorItem.onclick = () => {
        this.setCardColor(card, node, colorOption.value);
        colorPicker.remove();
      };
      colorPicker.appendChild(colorItem);
    });
    const rect = card.getBoundingClientRect();
    colorPicker.style.position = "fixed";
    colorPicker.style.top = `${rect.top - 40}px`;
    colorPicker.style.left = `${rect.left}px`;
    colorPicker.style.zIndex = "10000";
    document.body.appendChild(colorPicker);
    const closeHandler = (e) => {
      const mouseEvent = e;
      if (!colorPicker.contains(mouseEvent.target)) {
        colorPicker.remove();
        document.removeEventListener("click", closeHandler);
        const index = this.globalEventListeners.findIndex(
          (listener) => listener.element === document && listener.event === "click" && listener.handler === closeHandler
        );
        if (index > -1) {
          this.globalEventListeners.splice(index, 1);
        }
      }
    };
    this.safeSetTimeout(() => {
      this.addGlobalEventListener(document, "click", closeHandler);
    }, 0);
  }
  // 设置卡片颜色 - 设置背景色、文字色和边框色
  async setCardColor(card, node, color) {
    const normalizedColor = color ? this.normalizeColorValue(color) : null;
    node.color = normalizedColor || void 0;
    if (normalizedColor) {
      const colorStyles = this.getColorStyles(normalizedColor);
      card.dataset.color = normalizedColor;
      card.style.backgroundColor = colorStyles.backgroundColor;
      card.style.borderColor = colorStyles.borderColor;
      card.style.borderWidth = "2px";
      const contentDiv = card.querySelector(".card-content");
      if (contentDiv) {
        contentDiv.style.color = colorStyles.textColor;
      }
    } else {
      delete card.dataset.color;
      card.style.backgroundColor = "";
      card.style.borderColor = "";
      card.style.borderWidth = "";
      const contentDiv = card.querySelector(".card-content");
      if (contentDiv) {
        contentDiv.style.color = "";
      }
    }
    await this.saveNodeToCanvas(node);
  }
  // 渲染卡片内容
  renderCardContent(card, node) {
    switch (node.type) {
      case "text":
        this.renderTextNode(card, node);
        break;
      case "file":
        this.renderFileNode(card, node);
        break;
      case "link":
        this.renderLinkNode(card, node);
        break;
      default:
        card.createDiv().textContent = `\u672A\u652F\u6301\u7684\u8282\u70B9\u7C7B\u578B: ${node.type}`;
    }
    if (node.color) {
      const normalizedColor = this.normalizeColorValue(node.color);
      if (normalizedColor) {
        const colorStyles = this.getColorStyles(normalizedColor);
        const contentDiv = card.querySelector(".card-content");
        if (contentDiv) {
          contentDiv.style.color = colorStyles.textColor;
        }
      }
    }
  }
  // 渲染文本节点
  renderTextNode(card, node) {
    const content = card.createDiv("card-content");
    content.style.lineHeight = "1.5";
    this.renderTextNodeContent(content, node);
  }
  // 渲染文件节点
  renderFileNode(card, node) {
    const content = card.createDiv("card-content");
    if (node.file) {
      const fileName = node.file.split("/").pop() || node.file;
      const fileIcon = content.createSpan("file-icon");
      fileIcon.textContent = "\u{1F4C4} ";
      content.createSpan().textContent = fileName;
      if (node.file.includes("#")) {
        const subpath = node.file.split("#")[1];
        const subpathEl = content.createDiv("file-subpath");
        subpathEl.textContent = `#${subpath}`;
        subpathEl.style.color = "var(--text-muted)";
        subpathEl.style.fontSize = "12px";
        subpathEl.style.marginTop = "4px";
      }
    } else {
      content.textContent = "\u65E0\u6548\u7684\u6587\u4EF6\u5F15\u7528";
      content.style.color = "var(--text-error)";
    }
  }
  // 渲染链接节点
  renderLinkNode(card, node) {
    const content = card.createDiv("card-content link-card-content");
    this.renderLinkNodeWithPreview(content, node);
  }
  // 简单的Markdown渲染
  simpleMarkdownRender(text) {
    return text.replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>").replace(/\*(.*?)\*/g, "<em>$1</em>").replace(/`(.*?)`/g, "<code>$1</code>").replace(/\n/g, "<br>");
  }
  // 获取节点颜色
  getNodeColor(color) {
    const colorMap = {
      "1": "#ff6b6b",
      // red
      "2": "#ffa726",
      // orange
      "3": "#ffeb3b",
      // yellow
      "4": "#66bb6a",
      // green
      "5": "#26c6da",
      // cyan
      "6": "#42a5f5",
      // blue
      "7": "#ab47bc"
      // purple
    };
    return colorMap[color] || color;
  }
  // 获取颜色的背景色和文字色（考虑对比度）
  getColorStyles(color) {
    const colorMap = {
      "1": { backgroundColor: "#ffebee", textColor: "#c62828", borderColor: "#ff6b6b" },
      // red - 浅红背景，深红文字
      "2": { backgroundColor: "#fff3e0", textColor: "#e65100", borderColor: "#ffa726" },
      // orange - 浅橙背景，深橙文字
      "3": { backgroundColor: "#fffde7", textColor: "#f57f17", borderColor: "#ffeb3b" },
      // yellow - 浅黄背景，深黄文字
      "4": { backgroundColor: "#e8f5e8", textColor: "#2e7d32", borderColor: "#66bb6a" },
      // green - 浅绿背景，深绿文字
      "5": { backgroundColor: "#e0f2f1", textColor: "#00695c", borderColor: "#26c6da" },
      // cyan - 浅青背景，深青文字
      "6": { backgroundColor: "#e3f2fd", textColor: "#1565c0", borderColor: "#42a5f5" },
      // blue - 浅蓝背景，深蓝文字
      "7": { backgroundColor: "#f3e5f5", textColor: "#7b1fa2", borderColor: "#ab47bc" }
      // purple - 浅紫背景，深紫文字
    };
    const isDarkTheme = document.body.classList.contains("theme-dark");
    if (isDarkTheme) {
      const darkColorMap = {
        "1": { backgroundColor: "#4a1a1a", textColor: "#ff8a80", borderColor: "#ff6b6b" },
        // red
        "2": { backgroundColor: "#4a2c1a", textColor: "#ffcc80", borderColor: "#ffa726" },
        // orange
        "3": { backgroundColor: "#4a4a1a", textColor: "#fff176", borderColor: "#ffeb3b" },
        // yellow
        "4": { backgroundColor: "#1a4a1a", textColor: "#a5d6a7", borderColor: "#66bb6a" },
        // green
        "5": { backgroundColor: "#1a3a3a", textColor: "#80deea", borderColor: "#26c6da" },
        // cyan
        "6": { backgroundColor: "#1a2a4a", textColor: "#90caf9", borderColor: "#42a5f5" },
        // blue
        "7": { backgroundColor: "#3a1a4a", textColor: "#ce93d8", borderColor: "#ab47bc" }
        // purple
      };
      return darkColorMap[color] || { backgroundColor: "", textColor: "", borderColor: "" };
    }
    return colorMap[color] || { backgroundColor: "", textColor: "", borderColor: "" };
  }
  // 标准化颜色值 - 处理不同的颜色值格式
  normalizeColorValue(color) {
    if (!color)
      return null;
    if (/^[1-7]$/.test(color)) {
      return color;
    }
    const colorNameMap = {
      "red": "1",
      "orange": "2",
      "yellow": "3",
      "green": "4",
      "cyan": "5",
      "blue": "6",
      "purple": "7"
    };
    const normalizedName = color.toLowerCase();
    return colorNameMap[normalizedName] || null;
  }
  // 卡片点击事件
  onCardClick(node, cardElement) {
    if (this.currentEditingCard && this.currentEditingNode) {
      const clickedCard = cardElement || this.gridContainer.querySelector(`[data-node-id="${node.id}"]`);
      if (clickedCard !== this.currentEditingCard) {
        console.log("\u70B9\u51FB\u5176\u4ED6\u5361\u7247\uFF0C\u9000\u51FA\u7F16\u8F91\u72B6\u6001\u5E76\u4FDD\u5B58");
        this.exitCurrentEditingState(true);
      }
    }
    console.log("Card clicked:", node);
  }
  // 卡片双击事件 - 进入编辑模式
  onCardDoubleClick(node, cardElement) {
    if (node.type === "text") {
      this.startTextEditing(node, cardElement);
    } else if (node.type === "link") {
      this.startLinkEditing(node, cardElement);
    }
  }
  // 开始文本编辑
  startTextEditing(node, cardElement) {
    if (this.currentEditingCard && this.currentEditingCard !== cardElement) {
      this.exitCurrentEditingState(true);
    }
    const contentDiv = cardElement.querySelector(".card-content");
    if (!contentDiv)
      return;
    this.currentEditingCard = cardElement;
    this.currentEditingNode = node;
    this.autoSaveEnabled = false;
    const originalContent = contentDiv.innerHTML;
    const originalText = node.text || "";
    const editor = this.createTextEditor(originalText, (newText) => {
      this.saveTextNode(node, newText);
      this.exitEditMode(cardElement, contentDiv, newText);
      this.clearEditingState();
    }, () => {
      this.exitEditMode(cardElement, contentDiv, originalText);
      this.clearEditingState();
    }, false);
    this.enterEditMode(cardElement, contentDiv, editor);
  }
  // 创建文本编辑器 - 使用卡片边框尺寸
  createTextEditor(text, onSave, onCancel, enableAutoSave = true) {
    const editorContainer = document.createElement("div");
    editorContainer.className = "card-editor-container";
    const textarea = document.createElement("textarea");
    textarea.className = "card-editor-textarea";
    textarea.value = text;
    textarea.style.width = "100%";
    textarea.style.height = "100%";
    textarea.style.minHeight = "calc(100% - 8px)";
    textarea.style.border = "none";
    textarea.style.outline = "none";
    textarea.style.resize = "none";
    textarea.style.padding = "12px";
    textarea.style.margin = "0";
    textarea.style.boxSizing = "border-box";
    textarea.style.fontFamily = "var(--font-text)";
    textarea.style.fontSize = "var(--font-text-size)";
    textarea.style.lineHeight = "1.5";
    textarea.style.background = "transparent";
    textarea.style.color = "var(--text-normal)";
    textarea.style.borderRadius = "inherit";
    let autoSaveTimeout = null;
    const autoSave = () => {
      if (!enableAutoSave)
        return;
      if (autoSaveTimeout) {
        this.safeClearTimeout(autoSaveTimeout);
      }
      autoSaveTimeout = this.safeSetTimeout(() => {
        onSave(textarea.value);
        autoSaveTimeout = null;
      }, 1e3);
    };
    if (enableAutoSave) {
      textarea.addEventListener("input", autoSave);
    }
    textarea.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        e.preventDefault();
        if (autoSaveTimeout) {
          this.safeClearTimeout(autoSaveTimeout);
          autoSaveTimeout = null;
        }
        onSave(textarea.value);
      } else if (e.key === "Enter" && (e.ctrlKey || e.metaKey)) {
        e.preventDefault();
        if (autoSaveTimeout) {
          this.safeClearTimeout(autoSaveTimeout);
          autoSaveTimeout = null;
        }
        onSave(textarea.value);
      }
    });
    textarea.addEventListener("blur", () => {
      if (enableAutoSave) {
        if (autoSaveTimeout) {
          this.safeClearTimeout(autoSaveTimeout);
          autoSaveTimeout = null;
        }
        onSave(textarea.value);
      }
    });
    editorContainer.appendChild(textarea);
    this.safeSetTimeout(() => {
      textarea.focus();
      textarea.select();
    }, 0);
    return editorContainer;
  }
  // 清除编辑状态
  clearEditingState() {
    this.currentEditingCard = null;
    this.currentEditingNode = null;
    this.autoSaveEnabled = true;
  }
  // 退出当前编辑状态
  exitCurrentEditingState(save = false) {
    if (!this.currentEditingCard || !this.currentEditingNode)
      return;
    const contentDiv = this.currentEditingCard.querySelector(".card-content");
    if (!contentDiv)
      return;
    const editorContainer = this.currentEditingCard.querySelector(".card-editor-container");
    if (!editorContainer)
      return;
    if (save) {
      const textarea = editorContainer.querySelector("textarea");
      const input = editorContainer.querySelector("input");
      if (textarea && this.currentEditingNode.type === "text") {
        this.saveTextNode(this.currentEditingNode, textarea.value);
        this.exitEditMode(this.currentEditingCard, contentDiv, textarea.value);
      } else if (input && this.currentEditingNode.type === "link") {
        this.saveLinkNodeAndRefresh(this.currentEditingNode, input.value, this.currentEditingCard, contentDiv);
      }
    } else {
      if (this.currentEditingNode.type === "text") {
        this.exitEditMode(this.currentEditingCard, contentDiv, this.currentEditingNode.text || "");
      } else if (this.currentEditingNode.type === "link") {
        this.exitEditModeAndRefresh(this.currentEditingCard, contentDiv, this.currentEditingNode);
      }
    }
    this.clearEditingState();
  }
  // ==================== 分组功能相关方法 ====================
  // 分析Canvas中的分组和成员关系
  analyzeGroups() {
    if (!this.canvasData)
      return;
    this.groupAnalysis.clear();
    const groupNodes = this.canvasData.nodes.filter((node) => node.type === "group");
    groupNodes.forEach((group) => {
      const members = this.findGroupMembers(group);
      const groupInfo = {
        group,
        members,
        memberCount: members.length,
        bounds: this.calculateGroupBounds(group)
      };
      this.groupAnalysis.set(group.id, groupInfo);
    });
    console.log("\u5206\u7EC4\u5206\u6790\u5B8C\u6210:", this.groupAnalysis);
  }
  // 查找分组内的成员节点
  findGroupMembers(group) {
    if (!this.canvasData)
      return [];
    const groupBounds = this.calculateGroupBounds(group);
    const members = [];
    this.canvasData.nodes.forEach((node) => {
      if (node.type !== "group" && node.id !== group.id) {
        if (this.isNodeInsideGroup(node, groupBounds)) {
          members.push(node);
        }
      }
    });
    return members;
  }
  // 计算分组的边界框
  calculateGroupBounds(group) {
    return {
      minX: group.x,
      minY: group.y,
      maxX: group.x + group.width,
      maxY: group.y + group.height
    };
  }
  // 判断节点是否在分组内
  isNodeInsideGroup(node, groupBounds) {
    const nodeCenter = {
      x: node.x + node.width / 2,
      y: node.y + node.height / 2
    };
    return nodeCenter.x >= groupBounds.minX && nodeCenter.x <= groupBounds.maxX && nodeCenter.y >= groupBounds.minY && nodeCenter.y <= groupBounds.maxY;
  }
  // 获取所有分组信息 - 支持时间胶囊分组置顶
  getGroupsForGridView() {
    const groups = Array.from(this.groupAnalysis.values());
    const sortedGroups = groups.sort((a, b) => {
      const aIsActive = this.isActiveTimeCapsuleGroup(a.group.id);
      const bIsActive = this.isActiveTimeCapsuleGroup(b.group.id);
      const aIsHistorical = this.isHistoricalTimeCapsuleGroup(a.group.id);
      const bIsHistorical = this.isHistoricalTimeCapsuleGroup(b.group.id);
      if (aIsActive && !bIsActive)
        return -1;
      if (!aIsActive && bIsActive)
        return 1;
      if (aIsHistorical && !bIsHistorical && !bIsActive)
        return -1;
      if (!aIsHistorical && bIsHistorical && !aIsActive)
        return 1;
      return b.group.id.localeCompare(a.group.id);
    });
    console.log("\u{1F504} Group sorting result:");
    sortedGroups.forEach((group, index) => {
      const isActive = this.isActiveTimeCapsuleGroup(group.group.id);
      const isHistorical = this.isHistoricalTimeCapsuleGroup(group.group.id);
      const type = isActive ? "ACTIVE" : isHistorical ? "HISTORICAL" : "NORMAL";
      console.log(`  ${index + 1}. [${type}] ${group.group.id}`);
    });
    return sortedGroups;
  }
  // 判断是否为时间胶囊分组（包括历史时间胶囊）
  isTimeCapsuleGroup(groupId) {
    return groupId.startsWith("time-capsule-");
  }
  // 判断是否为当前激活的时间胶囊分组
  isActiveTimeCapsuleGroup(groupId) {
    return this.timeCapsuleState.isActive && groupId === this.timeCapsuleState.groupId;
  }
  // 判断是否为历史时间胶囊分组
  isHistoricalTimeCapsuleGroup(groupId) {
    return this.isTimeCapsuleGroup(groupId) && !this.isActiveTimeCapsuleGroup(groupId);
  }
  // 进入分组视图
  enterGroupView(groupId) {
    const groupInfo = this.groupAnalysis.get(groupId);
    if (!groupInfo)
      return;
    this.currentGroupView = groupId;
    this.filteredNodes = groupInfo.members;
    this.renderGrid();
    this.updateToolbarForGroupView(groupInfo);
  }
  // 退出分组视图，返回主视图
  exitGroupView() {
    this.currentGroupView = null;
    if (this.canvasData) {
      this.filteredNodes = this.canvasData.nodes.filter((node) => node.type !== "group");
    }
    this.renderGrid();
    this.updateToolbarForMainView();
  }
  // 更新工具栏显示分组视图信息
  updateToolbarForGroupView(groupInfo) {
    this.addGroupViewBackButtonToColorRow();
  }
  // 在颜色行中添加返回按钮
  addGroupViewBackButtonToColorRow() {
    const toolbar = this.containerEl.querySelector(".canvas-grid-toolbar");
    if (!toolbar)
      return;
    const colorRow = toolbar.querySelector(".canvas-grid-toolbar-color-row");
    if (!colorRow)
      return;
    const existingBackButton = toolbar.querySelector(".group-back-button-toolbar");
    if (existingBackButton) {
      existingBackButton.remove();
    }
    const backButton = document.createElement("button");
    backButton.className = "group-back-button-toolbar";
    backButton.title = this.settings.language === "zh" ? "\u8FD4\u56DE\u4E3B\u89C6\u56FE" : "Back to main view";
    backButton.setAttribute("aria-label", this.settings.language === "zh" ? "\u8FD4\u56DE\u4E3B\u89C6\u56FE" : "Back to main view");
    backButton.innerHTML = `
			<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<polyline points="15,18 9,12 15,6"/>
			</svg>
		`;
    backButton.onclick = () => this.exitGroupView();
    const colorFilter = colorRow.querySelector(".canvas-grid-color-filter");
    if (colorFilter) {
      colorRow.insertBefore(backButton, colorFilter);
    } else {
      colorRow.appendChild(backButton);
    }
  }
  // 恢复主视图工具栏
  updateToolbarForMainView() {
    const toolbar = this.containerEl.querySelector(".canvas-grid-toolbar");
    if (!toolbar)
      return;
    const existingBackButton = toolbar.querySelector(".group-back-button-toolbar");
    if (existingBackButton) {
      existingBackButton.remove();
    }
  }
  // 渲染分组成员（在分组视图中）
  renderGroupMembers() {
    if (!this.currentGroupView)
      return;
    const groupInfo = this.groupAnalysis.get(this.currentGroupView);
    if (!groupInfo)
      return;
    if (groupInfo.members.length > 50) {
      this.renderGridBatched(groupInfo.members);
    } else {
      this.renderGridImmediate(groupInfo.members);
    }
    this.setupCardDragAttributes();
    console.log(`\u2705 Group members rendered with drag support: ${groupInfo.members.length} cards`);
  }
  // 获取未分组的节点
  getUngroupedNodes(nodes) {
    const ungroupedNodes = [];
    nodes.forEach((node) => {
      let isInGroup = false;
      for (const groupInfo of this.groupAnalysis.values()) {
        if (groupInfo.members.some((member) => member.id === node.id)) {
          isInGroup = true;
          break;
        }
      }
      if (!isInGroup) {
        ungroupedNodes.push(node);
      }
    });
    return ungroupedNodes;
  }
  // 渲染网格项目（分组卡片和普通节点）
  renderGridItems(items) {
    const fragment = document.createDocumentFragment();
    items.forEach((item) => {
      let card;
      if (item.type === "group") {
        card = this.createGroupCard(item.data);
      } else {
        card = this.createCard(item.data);
        if (this.searchQuery) {
          this.highlightSearchResults(card, this.searchQuery);
        }
      }
      fragment.appendChild(card);
    });
    this.gridContainer.appendChild(fragment);
  }
  // 创建分组卡片
  createGroupCard(groupInfo) {
    const card = document.createElement("div");
    const isTimeCapsule = this.isTimeCapsuleGroup(groupInfo.group.id);
    const isActiveTimeCapsule = this.isActiveTimeCapsuleGroup(groupInfo.group.id);
    const isHistoricalTimeCapsule = this.isHistoricalTimeCapsuleGroup(groupInfo.group.id);
    if (isActiveTimeCapsule) {
      card.className = "canvas-grid-card group-card time-capsule-group time-capsule-collecting";
    } else if (isHistoricalTimeCapsule) {
      card.className = "canvas-grid-card group-card time-capsule-group time-capsule-historical";
    } else {
      card.className = "canvas-grid-card group-card";
    }
    card.dataset.nodeId = groupInfo.group.id;
    card.dataset.nodeType = "group";
    card.style.minHeight = `${CARD_CONSTANTS.height}px`;
    if (groupInfo.group.color) {
      const normalizedColor = this.normalizeColorValue(groupInfo.group.color);
      if (normalizedColor) {
        const colorStyles = this.getColorStyles(normalizedColor);
        card.style.backgroundColor = colorStyles.backgroundColor;
        card.style.borderColor = colorStyles.borderColor;
        card.style.color = colorStyles.textColor;
      }
    }
    const contentDiv = card.createDiv("group-card-content");
    const iconDiv = contentDiv.createDiv("group-icon");
    if (isActiveTimeCapsule) {
      iconDiv.innerHTML = `
				<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
					<path d="M6 2v6h.01L6 8.01 10 12l-4 4-.01.01V22h12v-5.99-.01L18 16l-4-4 4-3.99.01-.01V2H6z"/>
				</svg>
			`;
      iconDiv.classList.add("time-capsule-icon", "time-capsule-active");
    } else if (isHistoricalTimeCapsule) {
      iconDiv.innerHTML = `
				<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
					<path d="M6 2v6h.01L6 8.01 10 12l-4 4-.01.01V22h12v-5.99-.01L18 16l-4-4 4-3.99.01-.01V2H6z"/>
				</svg>
			`;
      iconDiv.classList.add("time-capsule-icon", "time-capsule-historical");
    } else {
      iconDiv.innerHTML = `
				<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
					<rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
					<path d="M9 9h6v6H9z"/>
				</svg>
			`;
    }
    const titleDiv = contentDiv.createDiv("group-title");
    titleDiv.textContent = groupInfo.group.label || "\u672A\u547D\u540D\u5206\u7EC4";
    const countDiv = contentDiv.createDiv("group-member-count");
    if (isActiveTimeCapsule) {
      const minutes = Math.floor(this.timeCapsuleState.remainingTime / 6e4);
      const seconds = Math.floor(this.timeCapsuleState.remainingTime % 6e4 / 1e3);
      const timeText = `${minutes}:${seconds.toString().padStart(2, "0")}`;
      countDiv.innerHTML = `
				<div class="time-capsule-status">
					<span class="collecting-text">\u6536\u96C6\u4E2D</span>
					<span class="countdown-text">${timeText}</span>
				</div>
				<div class="member-count">${groupInfo.memberCount} \u4E2A\u9879\u76EE</div>
			`;
    } else if (isHistoricalTimeCapsule) {
      countDiv.innerHTML = `
				<div class="time-capsule-status">
					<span class="completed-text">\u5DF2\u5B8C\u6210</span>
				</div>
				<div class="member-count">${groupInfo.memberCount} \u4E2A\u9879\u76EE</div>
			`;
    } else {
      countDiv.textContent = `${groupInfo.memberCount} \u4E2A\u9879\u76EE`;
    }
    if (groupInfo.members.length > 0) {
      const previewDiv = contentDiv.createDiv("group-members-preview");
      const maxPreview = Math.min(4, groupInfo.members.length);
      for (let i = 0; i < maxPreview; i++) {
        const member = groupInfo.members[i];
        const memberIcon = previewDiv.createDiv("member-icon");
        memberIcon.className = `member-icon ${member.type}-icon`;
        switch (member.type) {
          case "text":
            memberIcon.innerHTML = `<svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>`;
            break;
          case "file":
            memberIcon.innerHTML = `<svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/></svg>`;
            break;
          case "link":
            memberIcon.innerHTML = `<svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/></svg>`;
            break;
        }
      }
      if (groupInfo.members.length > maxPreview) {
        const moreIcon = previewDiv.createDiv("member-icon more-icon");
        moreIcon.textContent = `+${groupInfo.members.length - maxPreview}`;
      }
    }
    const enterButton = contentDiv.createDiv("group-enter-button");
    enterButton.innerHTML = `
			<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<polyline points="9,18 15,12 9,6"/>
			</svg>
		`;
    enterButton.title = "\u67E5\u770B\u5206\u7EC4\u5185\u5BB9";
    card.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.enterGroupView(groupInfo.group.id);
    });
    card.addEventListener("mouseenter", () => {
      card.style.transform = "translateY(-2px)";
      card.style.boxShadow = "0 4px 12px rgba(0, 0, 0, 0.15)";
    });
    card.addEventListener("mouseleave", () => {
      card.style.transform = "translateY(0)";
      card.style.boxShadow = "";
    });
    return card;
  }
  // 开始链接编辑
  startLinkEditing(node, cardElement) {
    if (this.currentEditingCard && this.currentEditingCard !== cardElement) {
      this.exitCurrentEditingState(true);
    }
    const contentDiv = cardElement.querySelector(".card-content");
    if (!contentDiv)
      return;
    this.currentEditingCard = cardElement;
    this.currentEditingNode = node;
    this.autoSaveEnabled = false;
    const originalUrl = node.url || "";
    const editor = this.createLinkEditor(originalUrl, (newUrl) => {
      this.saveLinkNodeAndRefresh(node, newUrl, cardElement, contentDiv);
      this.clearEditingState();
    }, () => {
      this.exitEditModeAndRefresh(cardElement, contentDiv, node);
      this.clearEditingState();
    }, false);
    this.enterEditMode(cardElement, contentDiv, editor);
  }
  // 保存链接节点并刷新显示
  async saveLinkNodeAndRefresh(node, newUrl, cardElement, contentDiv) {
    node.url = newUrl;
    await this.saveCanvasData();
    this.exitEditModeAndRefresh(cardElement, contentDiv, node);
  }
  // 退出编辑模式并刷新内容
  exitEditModeAndRefresh(cardElement, contentDiv, node) {
    cardElement.classList.remove("editing");
    cardElement.style.zIndex = "";
    cardElement.style.boxShadow = "";
    if (node.url) {
      this.linkPreviewCache.delete(node.url);
    }
    contentDiv.empty();
    contentDiv.removeClass("link-card-content");
    contentDiv.addClass("link-card-content");
    this.renderLinkNodeWithPreview(contentDiv, node);
  }
  // 创建链接编辑器
  createLinkEditor(url, onSave, onCancel, enableAutoSave = true) {
    const editorContainer = document.createElement("div");
    editorContainer.className = "card-editor-container";
    const input = document.createElement("input");
    input.type = "url";
    input.className = "card-editor-input";
    input.value = url;
    input.placeholder = "\u8F93\u5165URL\u5730\u5740...";
    input.style.width = "100%";
    input.style.padding = "8px";
    input.style.border = "1px solid var(--background-modifier-border)";
    input.style.borderRadius = "4px";
    input.style.background = "var(--background-primary)";
    input.style.color = "var(--text-normal)";
    input.style.fontSize = "var(--font-text-size)";
    let saveTimeout = null;
    const autoSave = () => {
      if (!enableAutoSave)
        return;
      if (saveTimeout) {
        this.safeClearTimeout(saveTimeout);
      }
      saveTimeout = this.safeSetTimeout(() => {
        onSave(input.value);
        saveTimeout = null;
      }, 500);
    };
    if (enableAutoSave) {
      input.addEventListener("input", autoSave);
      input.addEventListener("blur", () => {
        if (saveTimeout) {
          this.safeClearTimeout(saveTimeout);
          saveTimeout = null;
        }
        onSave(input.value);
      });
    }
    input.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        e.preventDefault();
        onCancel();
      } else if (e.key === "Enter") {
        e.preventDefault();
        if (saveTimeout) {
          this.safeClearTimeout(saveTimeout);
          saveTimeout = null;
        }
        onSave(input.value);
      }
    });
    editorContainer.appendChild(input);
    this.safeSetTimeout(() => {
      input.focus();
      input.select();
    }, 0);
    return editorContainer;
  }
  // 进入编辑模式
  enterEditMode(cardElement, contentDiv, editor) {
    cardElement.classList.add("editing");
    cardElement.style.zIndex = "1000";
    cardElement.style.boxShadow = "0 8px 24px rgba(0,0,0,0.2)";
    cardElement.style.position = "relative";
    contentDiv.style.display = "none";
    const editorContainer = editor.querySelector(".card-editor-container");
    if (editorContainer) {
      editorContainer.style.position = "absolute";
      editorContainer.style.top = "0";
      editorContainer.style.left = "0";
      editorContainer.style.right = "0";
      editorContainer.style.bottom = "0";
      editorContainer.style.width = "100%";
      editorContainer.style.height = "100%";
      editorContainer.style.borderRadius = "inherit";
      editorContainer.style.overflow = "hidden";
    }
    cardElement.appendChild(editor);
  }
  // 退出编辑模式
  exitEditMode(cardElement, contentDiv, newContent) {
    cardElement.classList.remove("editing");
    cardElement.style.zIndex = "";
    cardElement.style.boxShadow = "";
    cardElement.style.position = "";
    const editor = cardElement.querySelector(".card-editor-container");
    if (editor) {
      editor.remove();
    }
    if (newContent !== void 0) {
      contentDiv.innerHTML = this.formatTextContent(newContent);
    }
    contentDiv.style.display = "";
  }
  // 格式化文本内容
  formatTextContent(text) {
    return text.replace(/\n/g, "<br>");
  }
  // 保存文本节点
  async saveTextNode(node, newText) {
    if (!this.canvasData)
      return;
    node.text = newText;
    await this.saveCanvasData();
    this.refreshCard(node);
    new import_obsidian.Notice("\u6587\u672C\u5DF2\u4FDD\u5B58");
  }
  // 保存链接节点
  async saveLinkNode(node, newUrl) {
    if (!this.canvasData)
      return;
    node.url = newUrl;
    await this.saveCanvasData();
    this.refreshCard(node);
    new import_obsidian.Notice("\u94FE\u63A5\u5DF2\u4FDD\u5B58");
  }
  // 刷新单个卡片
  refreshCard(node) {
    const cardElement = this.gridContainer.querySelector(`[data-node-id="${node.id}"]`);
    if (!cardElement)
      return;
    const contentDiv = cardElement.querySelector(".card-content");
    if (!contentDiv)
      return;
    contentDiv.innerHTML = "";
    if (node.type === "text") {
      this.renderTextNodeContent(contentDiv, node);
    } else if (node.type === "link") {
      this.renderLinkNodeContent(contentDiv, node);
    }
  }
  // 渲染文本节点内容（提取的方法）
  renderTextNodeContent(contentDiv, node) {
    if (node.text) {
      const rendered = this.simpleMarkdownRender(node.text);
      contentDiv.innerHTML = rendered;
    } else {
      contentDiv.textContent = "\u7A7A\u6587\u672C\u8282\u70B9";
      contentDiv.style.color = "var(--text-muted)";
      contentDiv.style.fontStyle = "italic";
    }
  }
  // 渲染带预览的链接节点
  async renderLinkNodeWithPreview(contentDiv, node) {
    if (!node.url) {
      contentDiv.textContent = "\u65E0\u6548\u7684\u94FE\u63A5";
      contentDiv.style.color = "var(--text-error)";
      contentDiv.style.fontStyle = "italic";
      return;
    }
    this.renderLinkLoadingState(contentDiv, node.url);
    try {
      const preview = await this.fetchLinkPreview(node.url);
      contentDiv.empty();
      this.renderLinkPreview(contentDiv, preview);
    } catch (error) {
      console.error("Failed to render link preview:", error);
      contentDiv.empty();
      this.renderSimpleLinkFallback(contentDiv, node.url);
    }
  }
  // 渲染链接加载状态
  renderLinkLoadingState(contentDiv, url) {
    contentDiv.empty();
    contentDiv.addClass("link-preview-loading");
    const skeleton = contentDiv.createDiv("link-preview-skeleton");
    const titleSkeleton = skeleton.createDiv("skeleton-title");
    const descSkeleton = skeleton.createDiv("skeleton-description");
    const urlDiv = skeleton.createDiv("skeleton-url");
    urlDiv.textContent = this.formatUrlForDisplay(url);
  }
  // 渲染链接预览
  renderLinkPreview(contentDiv, preview) {
    contentDiv.addClass("link-bookmark-card");
    contentDiv.dataset.nodeUrl = preview.url;
    const bookmarkContainer = contentDiv.createDiv("link-bookmark-container");
    const contentArea = bookmarkContainer.createDiv("link-bookmark-content");
    const titleEl = contentArea.createDiv("link-bookmark-title");
    titleEl.textContent = preview.title || this.extractDomainFromUrl(preview.url);
    if (preview.description) {
      const descEl = contentArea.createDiv("link-bookmark-description");
      descEl.textContent = preview.description;
    }
    const footerEl = contentArea.createDiv("link-bookmark-footer");
    const siteInfo = footerEl.createDiv("link-bookmark-site-info");
    if (preview.favicon) {
      const faviconEl = siteInfo.createEl("img", {
        cls: "link-bookmark-favicon",
        attr: {
          src: preview.favicon,
          alt: "Site icon"
        }
      });
      faviconEl.addEventListener("error", () => {
        faviconEl.style.display = "none";
      });
    }
    const siteNameEl = siteInfo.createSpan("link-bookmark-site-name");
    siteNameEl.textContent = preview.siteName || this.extractDomainFromUrl(preview.url);
    const urlEl = footerEl.createDiv("link-bookmark-url");
    urlEl.textContent = this.formatUrlForDisplay(preview.url);
    if (preview.image) {
      const imageContainer = bookmarkContainer.createDiv("link-bookmark-image-container");
      const img = imageContainer.createEl("img", {
        cls: "link-bookmark-image",
        attr: {
          src: preview.image,
          alt: preview.title || "Link preview image"
        }
      });
      img.addEventListener("error", () => {
        imageContainer.style.display = "none";
        bookmarkContainer.classList.add("no-image");
      });
    } else {
      bookmarkContainer.classList.add("no-image");
    }
    bookmarkContainer.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      window.open(preview.url, "_blank");
    });
    bookmarkContainer.style.cursor = "pointer";
    bookmarkContainer.title = `\u6253\u5F00\u94FE\u63A5: ${preview.url}`;
  }
  // 简单链接回退显示
  renderSimpleLinkFallback(contentDiv, url) {
    const linkElement = contentDiv.createEl("a", {
      cls: "external-link simple-link",
      href: url
    });
    const displayText = this.extractDomainFromUrl(url);
    linkElement.textContent = displayText;
    const linkIcon = linkElement.createSpan("external-link-icon");
    linkIcon.innerHTML = `
			<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/>
				<polyline points="15,3 21,3 21,9"/>
				<line x1="10" y1="14" x2="21" y2="3"/>
			</svg>
		`;
    linkElement.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      window.open(url, "_blank");
    });
  }
  // 渲染链接节点内容（编辑时使用的简化版本）
  renderLinkNodeContent(contentDiv, node) {
    if (node.url) {
      this.renderSimpleLinkFallback(contentDiv, node.url);
    } else {
      contentDiv.textContent = "\u65E0\u6548\u7684\u94FE\u63A5";
      contentDiv.style.color = "var(--text-error)";
      contentDiv.style.fontStyle = "italic";
    }
  }
  // 格式化URL用于显示
  formatUrlForDisplay(url) {
    try {
      const urlObj = new URL(url);
      const domain = urlObj.hostname;
      const path = urlObj.pathname;
      if (url.length > 50) {
        if (path.length > 20) {
          return `${domain}${path.substring(0, 15)}...`;
        } else {
          return `${domain}${path}`;
        }
      }
      return url;
    } catch {
      return url.length > 50 ? url.substring(0, 47) + "..." : url;
    }
  }
  // 获取链接预览数据
  async fetchLinkPreview(url) {
    const cachedItem = this.getCacheItem(url);
    if (cachedItem) {
      return cachedItem;
    }
    if (this.previewLoadingUrls.has(url)) {
      return { url, isLoading: true };
    }
    this.previewLoadingUrls.add(url);
    try {
      const preview = await this.extractLinkMetadata(url);
      this.setCacheItem(url, preview);
      this.previewLoadingUrls.delete(url);
      return preview;
    } catch (error) {
      console.error("Failed to fetch link preview:", error);
      const errorPreview = {
        url,
        error: "Failed to load preview",
        title: this.extractDomainFromUrl(url)
      };
      this.setCacheItem(url, errorPreview);
      this.previewLoadingUrls.delete(url);
      return errorPreview;
    }
  }
  // 提取链接元数据（优化版本 - 快速书签解析）
  async extractLinkMetadata(url) {
    try {
      const urlObj = new URL(url);
      const basicPreview = {
        url,
        title: this.extractTitleFromUrl(url),
        siteName: this.extractDomainFromUrl(url),
        favicon: `https://www.google.com/s2/favicons?domain=${urlObj.hostname}`,
        isBasic: true
        // 标记为基础信息
      };
      this.fetchDetailedMetadata(url, basicPreview);
      return basicPreview;
    } catch (urlError) {
      return {
        url,
        title: "\u65E0\u6548\u94FE\u63A5",
        siteName: "\u672A\u77E5",
        error: "URL\u683C\u5F0F\u65E0\u6548"
      };
    }
  }
  // 从URL提取智能标题
  extractTitleFromUrl(url) {
    try {
      const urlObj = new URL(url);
      const domain = urlObj.hostname;
      const path = urlObj.pathname;
      if (path && path !== "/") {
        const pathParts = path.split("/").filter((part) => part.length > 0);
        if (pathParts.length > 0) {
          const lastPart = pathParts[pathParts.length - 1];
          const cleanTitle = lastPart.replace(/\.(html|htm|php|asp|jsp)$/i, "").replace(/[-_]/g, " ").replace(/\b\w/g, (l) => l.toUpperCase());
          if (cleanTitle.length > 3) {
            return cleanTitle;
          }
        }
      }
      return this.extractDomainFromUrl(url);
    } catch {
      return this.extractDomainFromUrl(url);
    }
  }
  // 异步获取详细元数据（不阻塞UI）
  async fetchDetailedMetadata(url, basicPreview) {
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 3e3);
      const apiServices = [
        `https://api.microlink.io/?url=${encodeURIComponent(url)}&timeout=2000`,
        `https://jsonlink.io/api/extract?url=${encodeURIComponent(url)}`
      ];
      let detailedData = null;
      for (const apiUrl of apiServices) {
        try {
          const response = await Promise.race([
            fetch(apiUrl, {
              signal: controller.signal,
              headers: {
                "Accept": "application/json",
                "User-Agent": "Obsidian Canvasgrid Transit Plugin"
              }
            }),
            new Promise(
              (_, reject) => setTimeout(() => reject(new Error("Service timeout")), 2e3)
            )
          ]);
          if (response.ok) {
            const data = await response.json();
            if (this.isValidMetadata(data)) {
              detailedData = data;
              break;
            }
          }
        } catch (serviceError) {
          console.log(`API service failed: ${apiUrl}`, serviceError);
          continue;
        }
      }
      clearTimeout(timeoutId);
      if (detailedData) {
        const enhancedPreview = this.parseMetadataResponse(url, detailedData);
        this.setCacheItem(url, enhancedPreview);
        this.updateBookmarkCard(url, enhancedPreview);
      }
    } catch (error) {
      console.log("\u8BE6\u7EC6\u5143\u6570\u636E\u83B7\u53D6\u5931\u8D25\uFF0C\u4F7F\u7528\u57FA\u7840\u4FE1\u606F:", error);
    }
  }
  // 验证元数据响应是否有效
  isValidMetadata(data) {
    if (!data)
      return false;
    if (data.status === "success" && data.data) {
      return true;
    }
    if (data.title || data.description) {
      return true;
    }
    return false;
  }
  // 解析不同API服务的响应格式
  parseMetadataResponse(url, data) {
    let title = "";
    let description = "";
    let image = "";
    let siteName = "";
    let favicon = "";
    if (data.status === "success" && data.data) {
      title = data.data.title || "";
      description = data.data.description || "";
      image = data.data.image?.url || "";
      siteName = data.data.publisher || "";
      favicon = data.data.logo?.url || "";
    } else if (data.title || data.description) {
      title = data.title || "";
      description = data.description || "";
      image = data.image || "";
      siteName = data.site_name || "";
      favicon = data.favicon || "";
    }
    if (!favicon) {
      try {
        const urlObj = new URL(url);
        favicon = `https://www.google.com/s2/favicons?domain=${urlObj.hostname}`;
      } catch {
        favicon = "";
      }
    }
    return {
      url,
      title: title || this.extractTitleFromUrl(url),
      description: description || "",
      image: image || "",
      siteName: siteName || this.extractDomainFromUrl(url),
      favicon
    };
  }
  // 更新书签卡片显示（当获取到详细信息时）
  updateBookmarkCard(url, enhancedPreview) {
    const cards = this.gridContainer.querySelectorAll(`[data-node-url="${url}"]`);
    cards.forEach((card) => {
      const bookmarkContainer = card.querySelector(".link-bookmark-container");
      if (bookmarkContainer) {
        const titleEl = bookmarkContainer.querySelector(".link-bookmark-title");
        if (titleEl && enhancedPreview.title) {
          titleEl.textContent = enhancedPreview.title;
        }
        let descEl = bookmarkContainer.querySelector(".link-bookmark-description");
        if (enhancedPreview.description) {
          if (!descEl) {
            const contentArea = bookmarkContainer.querySelector(".link-bookmark-content");
            if (contentArea) {
              descEl = contentArea.createDiv("link-bookmark-description");
            }
          }
          if (descEl) {
            descEl.textContent = enhancedPreview.description;
          }
        }
        const imageArea = bookmarkContainer.querySelector(".link-bookmark-image");
        if (imageArea && enhancedPreview.image) {
          const img = imageArea.querySelector("img");
          if (img) {
            img.src = enhancedPreview.image;
          }
        }
        const faviconEl = bookmarkContainer.querySelector(".link-bookmark-favicon");
        if (faviconEl && enhancedPreview.favicon) {
          const img = faviconEl.querySelector("img");
          if (img) {
            img.src = enhancedPreview.favicon;
          }
        }
      }
    });
  }
  // 从URL提取域名
  extractDomainFromUrl(url) {
    try {
      const urlObj = new URL(url);
      return urlObj.hostname.replace("www.", "");
    } catch {
      return url;
    }
  }
  // 显示消息
  showMessage(message) {
    this.gridContainer.empty();
    const messageEl = this.gridContainer.createDiv("grid-message");
    messageEl.textContent = message;
    messageEl.style.textAlign = "center";
    messageEl.style.color = "var(--text-muted)";
    messageEl.style.marginTop = "50px";
  }
  // 显示加载状态
  showLoadingState() {
    this.gridContainer.empty();
    const loadingEl = this.gridContainer.createDiv("canvas-grid-loading");
    loadingEl.textContent = "\u6B63\u5728\u52A0\u8F7DCanvas\u6570\u636E...";
  }
  // 隐藏加载状态
  hideLoadingState() {
    const loadingEl = this.gridContainer.querySelector(".canvas-grid-loading");
    if (loadingEl) {
      loadingEl.remove();
    }
  }
  // 显示错误状态
  showErrorState(errorMessage) {
    this.gridContainer.empty();
    const errorEl = this.gridContainer.createDiv("canvas-grid-error");
    const titleEl = errorEl.createEl("h3");
    titleEl.textContent = "\u52A0\u8F7D\u5931\u8D25";
    titleEl.style.color = "var(--text-error)";
    const messageEl = errorEl.createEl("p");
    messageEl.textContent = errorMessage;
    messageEl.style.color = "var(--text-muted)";
    const retryBtn = errorEl.createEl("button", {
      text: "\u91CD\u8BD5",
      cls: "mod-cta"
    });
    retryBtn.onclick = () => this.loadActiveCanvas();
    errorEl.style.textAlign = "center";
    errorEl.style.marginTop = "50px";
  }
  // 打开网格设置
  openGridSettings() {
    console.log("Open grid settings");
  }
  // 切换到Canvas视图
  async switchToCanvasView() {
    let targetFile = this.app.workspace.getActiveFile();
    if (!targetFile || targetFile.extension !== "canvas") {
      if (this.linkedCanvasFile) {
        targetFile = this.linkedCanvasFile;
        console.log("Using linked canvas file:", targetFile.path);
      } else {
        new import_obsidian.Notice("\u6CA1\u6709\u5173\u8054\u7684Canvas\u6587\u4EF6\uFF0C\u8BF7\u5148\u5173\u8054\u4E00\u4E2ACanvas\u6587\u4EF6");
        return;
      }
    }
    const targetLeaf = this.findExistingCanvasLeaf(targetFile);
    if (targetLeaf) {
      this.app.workspace.setActiveLeaf(targetLeaf);
      console.log("Activated existing canvas view");
    } else {
      try {
        await this.openCanvasInMainWorkspace(targetFile);
      } catch (error) {
        console.error("Failed to open canvas file:", error);
        new import_obsidian.Notice("\u65E0\u6CD5\u6253\u5F00Canvas\u6587\u4EF6");
      }
    }
  }
  // 查找现有的Canvas叶子（避免重复打开）
  findExistingCanvasLeaf(targetFile) {
    const canvasLeaves = this.app.workspace.getLeavesOfType("canvas");
    for (const leaf of canvasLeaves) {
      const view = leaf.view;
      if (view && view.file && view.file.path === targetFile.path) {
        if (this.isLeafInMainWorkspace(leaf)) {
          console.log("Found existing canvas leaf in main workspace");
          return leaf;
        }
      }
    }
    return null;
  }
  // 检查叶子是否在主工作区
  isLeafInMainWorkspace(leaf) {
    let parent = leaf.parent;
    while (parent) {
      if (parent === this.app.workspace.leftSplit || parent === this.app.workspace.rightSplit) {
        return false;
      }
      parent = parent.parent;
    }
    return true;
  }
  // 在主工作区打开Canvas文件
  async openCanvasInMainWorkspace(targetFile) {
    try {
      const newLeaf = this.app.workspace.getLeaf("tab");
      if (newLeaf && this.isLeafInMainWorkspace(newLeaf)) {
        await newLeaf.openFile(targetFile);
        this.app.workspace.setActiveLeaf(newLeaf);
        console.log("Opened canvas file in new tab in main workspace");
        return;
      }
      const rootLeaf = this.app.workspace.getLeaf(true);
      if (rootLeaf) {
        await rootLeaf.openFile(targetFile);
        this.app.workspace.setActiveLeaf(rootLeaf);
        console.log("Opened canvas file in new leaf in main workspace");
        return;
      }
      throw new Error("\u65E0\u6CD5\u521B\u5EFA\u65B0\u7684\u5DE5\u4F5C\u533A\u53F6\u5B50");
    } catch (error) {
      console.error("Failed to open canvas in main workspace:", error);
      throw error;
    }
  }
  async onClose() {
    if (this.gridContainer) {
      this.gridContainer.removeEventListener("click", this.handleCardClick);
      this.gridContainer.removeEventListener("dblclick", this.handleCardDoubleClick);
      this.gridContainer.removeEventListener("contextmenu", this.handleCardContextMenu);
      this.gridContainer.removeEventListener("keydown", this.handleKeyDown);
    }
    document.removeEventListener("click", this.handleDocumentClick);
    this.removeGlobalMouseListeners();
    this.globalEventListeners.forEach(({ element, event, handler, options }) => {
      try {
        element.removeEventListener(event, handler, options);
      } catch (error) {
        console.warn("Failed to remove event listener:", error);
      }
    });
    this.globalEventListeners.length = 0;
    this.activeTimeouts.forEach((timeoutId) => {
      try {
        clearTimeout(timeoutId);
      } catch (error) {
        console.warn("Failed to clear timeout:", error);
      }
    });
    this.activeTimeouts.clear();
    this.activeIntervals.forEach((intervalId) => {
      try {
        clearInterval(intervalId);
      } catch (error) {
        console.warn("Failed to clear interval:", error);
      }
    });
    this.activeIntervals.clear();
    if (this.refreshTimer) {
      this.safeClearInterval(this.refreshTimer);
      this.refreshTimer = null;
    }
    if (this.cacheCleanupInterval) {
      this.safeClearInterval(this.cacheCleanupInterval);
      this.cacheCleanupInterval = null;
    }
    this.hideContextMenu();
    this.linkPreviewCache.clear();
    this.previewLoadingUrls.clear();
    this.clearRenderCache();
    this.canvasData = null;
    this.searchInputEl = null;
    this.colorFilterContainer = null;
    this.dropIndicator = null;
    this.cleanupWidthControl();
    this.linkedCanvasFile = null;
  }
  // 显示右键菜单
  showContextMenu(card, x, y) {
    this.hideContextMenu();
    const nodeId = card.dataset.nodeId;
    const nodeType = card.dataset.nodeType;
    if (!nodeId)
      return;
    const menu = document.createElement("div");
    menu.className = "canvas-grid-context-menu";
    if (nodeType === "group") {
      const renameItem = this.createMenuItem("\u91CD\u547D\u540D\u5206\u7EC4", "lucide-edit-3", () => {
        this.renameGroup(nodeId);
        this.hideContextMenu();
      });
      const focusItem = this.createMenuItem("\u805A\u7126\u5206\u7EC4", "lucide-target", () => {
        this.focusNodeInCanvas(nodeId);
        this.hideContextMenu();
      });
      const deleteItem = this.createMenuItem("\u5220\u9664\u5206\u7EC4", "lucide-trash-2", () => {
        this.deleteCard(card);
        this.hideContextMenu();
      });
      menu.appendChild(renameItem);
      menu.appendChild(focusItem);
      menu.appendChild(deleteItem);
    } else {
      const focusItem = this.createMenuItem("\u805A\u7126\u8282\u70B9", "lucide-target", () => {
        this.focusNodeInCanvas(nodeId);
        this.hideContextMenu();
      });
      const editItem = this.createMenuItem("\u7F16\u8F91", "lucide-edit", () => {
        this.editCard(card);
        this.hideContextMenu();
      });
      const deleteItem = this.createMenuItem("\u5220\u9664", "lucide-trash-2", () => {
        this.deleteCard(card);
        this.hideContextMenu();
      });
      menu.appendChild(focusItem);
      menu.appendChild(editItem);
      const node = this.canvasData?.nodes.find((n) => n.id === nodeId);
      if (node) {
        const backlinkItem = this.createMenuItem("\u56DE\u94FE", "lucide-arrow-left", () => {
          this.handleBacklinkNavigation(node);
          this.hideContextMenu();
        });
        menu.appendChild(backlinkItem);
        console.log("Added backlink menu item for node:", nodeId);
      }
      menu.appendChild(deleteItem);
    }
    menu.style.left = `${x}px`;
    menu.style.top = `${y}px`;
    document.body.appendChild(menu);
    this.adjustMenuPosition(menu, x, y);
  }
  // 创建菜单项
  createMenuItem(text, iconClass, onClick) {
    const item = document.createElement("div");
    item.className = "canvas-grid-context-menu-item";
    const icon = document.createElement("div");
    icon.className = `canvas-grid-context-menu-icon ${iconClass}`;
    const label = document.createElement("span");
    label.textContent = text;
    item.appendChild(icon);
    item.appendChild(label);
    item.addEventListener("click", onClick);
    return item;
  }
  // 调整菜单位置
  adjustMenuPosition(menu, x, y) {
    const rect = menu.getBoundingClientRect();
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    let adjustedX = x;
    let adjustedY = y;
    if (x + rect.width > viewportWidth) {
      adjustedX = viewportWidth - rect.width - 10;
    }
    if (y + rect.height > viewportHeight) {
      adjustedY = viewportHeight - rect.height - 10;
    }
    menu.style.left = `${adjustedX}px`;
    menu.style.top = `${adjustedY}px`;
  }
  // 隐藏右键菜单
  hideContextMenu() {
    const existingMenu = document.querySelector(".canvas-grid-context-menu");
    if (existingMenu) {
      existingMenu.remove();
    }
  }
  // 处理回链功能（旧版本，保留兼容性）
  async handleBacklink(nodeId) {
    try {
      console.log("Handling backlink for node:", nodeId);
      new import_obsidian.Notice(`\u56DE\u94FE\u529F\u80FD\u5DF2\u89E6\u53D1\uFF0C\u8282\u70B9ID: ${nodeId}`);
    } catch (error) {
      console.error("Failed to handle backlink:", error);
      new import_obsidian.Notice("\u56DE\u94FE\u529F\u80FD\u6267\u884C\u5931\u8D25");
    }
  }
  // 智能处理回链导航（新版本）
  async handleBacklinkNavigation(node) {
    try {
      console.log("=== Backlink Navigation ===");
      console.log("Node:", node);
      if (this.hasBacklink(node)) {
        console.log("\u2705 Found backlink in node, using navigateToBacklink");
        await this.navigateToBacklink(node);
      } else {
        console.log("\u274C No backlink found, showing alternative options");
        await this.showBacklinkAlternatives(node);
      }
    } catch (error) {
      console.error("Failed to handle backlink navigation:", error);
      new import_obsidian.Notice("\u56DE\u94FE\u5BFC\u822A\u5931\u8D25");
    }
  }
  // 显示回链替代选项
  async showBacklinkAlternatives(node) {
    const modal = new import_obsidian.Modal(this.app);
    modal.titleEl.setText("\u56DE\u94FE\u9009\u9879");
    const content = modal.contentEl;
    content.empty();
    content.createEl("p", { text: "\u8BE5\u8282\u70B9\u6CA1\u6709\u68C0\u6D4B\u5230\u56DE\u94FE\u4FE1\u606F\uFF0C\u8BF7\u9009\u62E9\u64CD\u4F5C\uFF1A" });
    const buttonContainer = content.createDiv("backlink-options-container");
    buttonContainer.style.cssText = `
			display: flex;
			gap: 10px;
			margin-top: 20px;
			justify-content: center;
		`;
    const searchButton = buttonContainer.createEl("button", { text: "\u67E5\u627E\u6E90\u6587\u4EF6" });
    searchButton.onclick = () => {
      modal.close();
      this.searchForSourceFile(node);
    };
    const infoButton = buttonContainer.createEl("button", { text: "\u8282\u70B9\u4FE1\u606F" });
    infoButton.onclick = () => {
      modal.close();
      this.showNodeInfo(node);
    };
    const cancelButton = buttonContainer.createEl("button", { text: "\u53D6\u6D88" });
    cancelButton.onclick = () => {
      modal.close();
    };
    modal.open();
  }
  // 搜索可能的源文件
  async searchForSourceFile(node) {
    if (node.type !== "text" || !node.text) {
      new import_obsidian.Notice("\u53EA\u80FD\u4E3A\u6587\u672C\u8282\u70B9\u641C\u7D22\u6E90\u6587\u4EF6");
      return;
    }
    const searchText = node.text.split("\n")[0].substring(0, 50);
    new import_obsidian.Notice(`\u6B63\u5728\u641C\u7D22\u5305\u542B "${searchText}" \u7684\u6587\u4EF6...`);
    try {
      this.app.internalPlugins?.getPluginById("global-search")?.instance?.openGlobalSearch?.(searchText);
    } catch (error) {
      console.log("Global search not available, showing manual search notice");
      new import_obsidian.Notice(`\u8BF7\u624B\u52A8\u641C\u7D22: "${searchText}"`);
    }
  }
  // 显示节点详细信息
  showNodeInfo(node) {
    const info = [
      `\u8282\u70B9ID: ${node.id}`,
      `\u8282\u70B9\u7C7B\u578B: ${node.type}`,
      `\u4F4D\u7F6E: (${node.x}, ${node.y})`,
      `\u5C3A\u5BF8: ${node.width} \xD7 ${node.height}`,
      node.text ? `\u6587\u672C\u957F\u5EA6: ${node.text.length} \u5B57\u7B26` : "\u65E0\u6587\u672C\u5185\u5BB9"
    ];
    new import_obsidian.Notice(info.join("\n"), 5e3);
    console.log("Node Info:", node);
    return Promise.resolve();
  }
  // 重命名分组
  async renameGroup(groupId) {
    if (!this.canvasData)
      return;
    const groupNode = this.canvasData.nodes.find((n) => n.id === groupId && n.type === "group");
    if (!groupNode) {
      new import_obsidian.Notice("\u672A\u627E\u5230\u5206\u7EC4\u8282\u70B9");
      return;
    }
    const currentName = groupNode.label || "\u672A\u547D\u540D\u5206\u7EC4";
    const modal = new GroupRenameModal(this.app, currentName, async (newName) => {
      try {
        groupNode.label = newName;
        await this.saveCanvasData();
        const groupInfo = this.groupAnalysis.get(groupId);
        if (groupInfo) {
          groupInfo.group.label = newName;
        }
        this.renderGrid();
        this.notifyCanvasViewRefresh();
        new import_obsidian.Notice(`\u5206\u7EC4\u5DF2\u91CD\u547D\u540D\u4E3A: ${newName}`);
        console.log(`Group ${groupId} renamed to: ${newName}`);
      } catch (error) {
        console.error("Failed to rename group:", error);
        new import_obsidian.Notice("\u91CD\u547D\u540D\u5206\u7EC4\u5931\u8D25");
      }
    });
    modal.open();
  }
  // 编辑卡片
  editCard(card) {
    const nodeId = card.dataset.nodeId;
    if (!nodeId)
      return;
    const node = this.canvasData?.nodes.find((n) => n.id === nodeId);
    if (node && !card.classList.contains("editing")) {
      this.onCardDoubleClick(node, card);
    }
  }
  // 删除卡片
  async deleteCard(card) {
    const nodeId = card.dataset.nodeId;
    if (!nodeId)
      return;
    const confirmed = confirm("\u786E\u5B9A\u8981\u5220\u9664\u8FD9\u4E2A\u8282\u70B9\u5417\uFF1F");
    if (!confirmed)
      return;
    try {
      await this.deleteNodeFromCanvas(nodeId);
      card.remove();
      console.log("\u5361\u7247\u5220\u9664\u5B8C\u6210\uFF0CUI\u5DF2\u66F4\u65B0");
    } catch (error) {
      console.error("\u5220\u9664\u5361\u7247\u5931\u8D25:", error);
      new import_obsidian.Notice("\u5220\u9664\u5361\u7247\u5931\u8D25");
    }
  }
  // 从Canvas数据中删除节点
  async deleteNodeFromCanvas(nodeId) {
    let targetFile = null;
    if (this.linkedCanvasFile) {
      targetFile = this.linkedCanvasFile;
    } else {
      const activeFile = this.app.workspace.getActiveFile();
      if (activeFile && activeFile.extension === "canvas") {
        targetFile = activeFile;
      }
    }
    if (!targetFile) {
      console.error("\u65E0\u6CD5\u786E\u5B9A\u76EE\u6807Canvas\u6587\u4EF6");
      new import_obsidian.Notice("\u5220\u9664\u5931\u8D25\uFF1A\u65E0\u6CD5\u786E\u5B9A\u76EE\u6807Canvas\u6587\u4EF6");
      return;
    }
    try {
      this.disableFileWatcher();
      const content = await this.app.vault.read(targetFile);
      const canvasData = JSON.parse(content);
      const nodeExists = canvasData.nodes.some((node) => node.id === nodeId);
      if (!nodeExists) {
        console.warn("\u8282\u70B9\u4E0D\u5B58\u5728\uFF0C\u53EF\u80FD\u5DF2\u88AB\u5220\u9664:", nodeId);
        return;
      }
      canvasData.nodes = canvasData.nodes.filter((node) => node.id !== nodeId);
      canvasData.edges = canvasData.edges.filter(
        (edge) => edge.fromNode !== nodeId && edge.toNode !== nodeId
      );
      await this.app.vault.modify(targetFile, JSON.stringify(canvasData, null, 2));
      this.canvasData = canvasData;
      this.filteredNodes = this.filteredNodes.filter((node) => node.id !== nodeId);
      console.log("\u8282\u70B9\u5220\u9664\u5B8C\u6210\uFF0C\u66F4\u65B0\u7B5B\u9009\u7ED3\u679C:", {
        deletedNodeId: nodeId,
        remainingFilteredNodes: this.filteredNodes.length
      });
      this.safeSetTimeout(() => {
        this.enableFileWatcher();
      }, 1e3);
      console.log("\u8282\u70B9\u5220\u9664\u6210\u529F:", nodeId);
      new import_obsidian.Notice("\u8282\u70B9\u5220\u9664\u6210\u529F");
    } catch (error) {
      console.error("\u5220\u9664\u8282\u70B9\u5931\u8D25:", error);
      new import_obsidian.Notice("\u5220\u9664\u8282\u70B9\u5931\u8D25");
      this.enableFileWatcher();
    }
  }
  // 禁用文件监听器
  disableFileWatcher() {
    this.fileWatcherDisabled = true;
  }
  // 启用文件监听器
  enableFileWatcher() {
    this.fileWatcherDisabled = false;
  }
  // 保存单个节点到Canvas文件
  async saveNodeToCanvas(node) {
    if (!node || !node.id) {
      throw new Error("\u8282\u70B9\u6570\u636E\u65E0\u6548");
    }
    const canvasFile = this.linkedCanvasFile;
    if (!canvasFile) {
      throw new Error("\u6CA1\u6709\u5173\u8054\u7684Canvas\u6587\u4EF6");
    }
    try {
      console.log("Saving node to canvas:", node.id);
      const content = await this.app.vault.read(canvasFile);
      let canvasData;
      try {
        canvasData = JSON.parse(content);
      } catch (parseError) {
        throw new Error("Canvas\u6587\u4EF6\u683C\u5F0F\u65E0\u6548");
      }
      if (!Array.isArray(canvasData.nodes)) {
        throw new Error("Canvas\u6587\u4EF6\u7F3A\u5C11\u6709\u6548\u7684\u8282\u70B9\u6570\u636E");
      }
      const nodeIndex = canvasData.nodes.findIndex((n) => n.id === node.id);
      if (nodeIndex === -1) {
        throw new Error(`\u8282\u70B9\u4E0D\u5B58\u5728: ${node.id}`);
      }
      canvasData.nodes[nodeIndex] = { ...canvasData.nodes[nodeIndex], ...node };
      const updatedNode = canvasData.nodes[nodeIndex];
      if (!updatedNode.id || !updatedNode.type) {
        throw new Error("\u66F4\u65B0\u540E\u7684\u8282\u70B9\u6570\u636E\u65E0\u6548");
      }
      const jsonContent = JSON.stringify(canvasData, null, 2);
      await this.app.vault.modify(canvasFile, jsonContent);
      console.log("Node saved successfully:", node.id);
    } catch (error) {
      console.error("\u4FDD\u5B58\u8282\u70B9\u5931\u8D25:", error);
      const errorMessage = error instanceof Error ? error.message : "\u672A\u77E5\u9519\u8BEF";
      throw new Error(`\u4FDD\u5B58\u8282\u70B9\u5931\u8D25: ${errorMessage}`);
    }
  }
  // ==================== 聚焦功能实现 ====================
  // 聚焦到Canvas中的指定节点
  async focusNodeInCanvas(nodeId) {
    try {
      console.log("=== Starting focus operation for node:", nodeId);
      new import_obsidian.Notice("\u6B63\u5728\u5B9A\u4F4D\u8282\u70B9...", 2e3);
      await this.ensureCanvasView();
      await this.waitForCanvasLoad();
      const canvasView = this.getActiveCanvasView();
      if (!canvasView) {
        new import_obsidian.Notice("\u65E0\u6CD5\u83B7\u53D6Canvas\u89C6\u56FE");
        return false;
      }
      console.log("Canvas view obtained, detecting API...");
      const canvasAPI = this.detectCanvasAPI(canvasView);
      if (!canvasAPI) {
        console.log("Canvas API not available, falling back to simulation");
        return this.focusNodeBySimulation(nodeId);
      }
      const nodeData = this.canvasData?.nodes.find((n) => n.id === nodeId);
      if (!nodeData) {
        new import_obsidian.Notice("\u627E\u4E0D\u5230\u76EE\u6807\u8282\u70B9");
        return false;
      }
      console.log("Node data found:", nodeData);
      console.log("Executing focus operations...");
      const success = await this.executeCanvasFocus(canvasAPI, nodeId, nodeData);
      if (success) {
        new import_obsidian.Notice("\u5DF2\u805A\u7126\u5230\u76EE\u6807\u8282\u70B9", 3e3);
        return true;
      } else {
        console.log("Canvas API focus failed, falling back to simulation");
        return this.focusNodeBySimulation(nodeId);
      }
    } catch (error) {
      console.error("\u805A\u7126\u8282\u70B9\u5931\u8D25:", error);
      new import_obsidian.Notice("\u805A\u7126\u5931\u8D25\uFF0C\u8BF7\u624B\u52A8\u5B9A\u4F4D");
      return false;
    }
  }
  // 确保切换到Canvas视图
  async ensureCanvasView() {
    console.log("Ensuring canvas view...");
    if (!this.linkedCanvasFile) {
      new import_obsidian.Notice("\u6CA1\u6709\u5173\u8054\u7684Canvas\u6587\u4EF6\uFF0C\u8BF7\u5148\u5173\u8054\u4E00\u4E2ACanvas\u6587\u4EF6");
      throw new Error("No linked canvas file");
    }
    const targetLeaf = this.findExistingCanvasLeaf(this.linkedCanvasFile);
    if (targetLeaf) {
      console.log("Found existing canvas view, activating...");
      this.app.workspace.setActiveLeaf(targetLeaf);
      await new Promise((resolve) => {
        this.safeSetTimeout(() => resolve(void 0), 300);
      });
      return;
    }
    const activeLeaf = this.app.workspace.activeLeaf;
    if (activeLeaf && activeLeaf.view.getViewType() === "canvas") {
      const canvasView = activeLeaf.view;
      if (canvasView && canvasView.file && canvasView.file.path === this.linkedCanvasFile.path) {
        console.log("Already in correct canvas view");
        return;
      }
    }
    console.log("Creating new canvas view...");
    await this.openCanvasInMainWorkspace(this.linkedCanvasFile);
    await new Promise((resolve) => {
      this.safeSetTimeout(() => resolve(void 0), 800);
    });
    const newActiveLeaf = this.app.workspace.activeLeaf;
    if (newActiveLeaf && newActiveLeaf.view.getViewType() === "canvas") {
      console.log("Successfully switched to canvas view");
    } else {
      console.warn("Failed to switch to canvas view");
      throw new Error("\u65E0\u6CD5\u5207\u6362\u5230Canvas\u89C6\u56FE");
    }
  }
  // 探测Canvas视图的可用API
  detectCanvasAPI(canvasView) {
    try {
      console.log("Canvas view object:", canvasView);
      if (!canvasView || typeof canvasView !== "object") {
        console.warn("Invalid canvas view object");
        return null;
      }
      console.log("Canvas view properties:", Object.keys(canvasView));
      if (!hasProperty(canvasView, "canvas")) {
        console.warn("Canvas view does not have canvas property");
        return null;
      }
      const canvas = canvasView.canvas;
      console.log("Canvas object:", canvas);
      if (!canvas) {
        console.warn("Canvas object not found in view");
        return null;
      }
      console.log("Canvas properties:", Object.keys(canvas));
      console.log("Canvas methods:", Object.getOwnPropertyNames(Object.getPrototypeOf(canvas)));
      this.exploreCanvasAPI(canvas);
      const apiMethods = this.findCanvasAPIMethods(canvas);
      if (!apiMethods) {
        console.log("No suitable Canvas API methods found");
        return null;
      }
      console.log("Found Canvas API methods:", apiMethods);
      return apiMethods;
    } catch (error) {
      console.error("Failed to detect Canvas API:", error);
      return null;
    }
  }
  // 查找Canvas API的实际方法
  findCanvasAPIMethods(canvas) {
    const allMethods = this.getAllMethods(canvas);
    console.log("All canvas methods:", allMethods);
    const zoomMethods = allMethods.filter(
      (method) => method.toLowerCase().includes("zoom") || method.toLowerCase().includes("scale") || method.toLowerCase().includes("fit")
    );
    console.log("Zoom methods:", zoomMethods);
    const selectMethods = allMethods.filter(
      (method) => method.toLowerCase().includes("select") || method.toLowerCase().includes("focus") || method.toLowerCase().includes("highlight")
    );
    console.log("Select methods:", selectMethods);
    const nodeMethods = allMethods.filter(
      (method) => method.toLowerCase().includes("node") || method.toLowerCase().includes("element") || method.toLowerCase().includes("item")
    );
    console.log("Node methods:", nodeMethods);
    const panMethods = allMethods.filter(
      (method) => method.toLowerCase().includes("pan") || method.toLowerCase().includes("move") || method.toLowerCase().includes("translate")
    );
    console.log("Pan methods:", panMethods);
    const api = {};
    const zoomToBboxMethod = this.findMethod(canvas, [
      "zoomToBbox",
      "zoomToRect",
      "zoomToArea",
      "fitToRect",
      "focusRect"
    ]);
    if (zoomToBboxMethod) {
      api.zoomToBbox = zoomToBboxMethod;
    }
    const selectMethod = this.findMethod(canvas, [
      "selectNode",
      "selectElement",
      "select",
      "setSelection",
      "addSelection"
    ]);
    if (selectMethod) {
      api.selectNode = selectMethod;
    }
    const deselectMethod = this.findMethod(canvas, [
      "deselectAll",
      "clearSelection",
      "deselect",
      "unselectAll"
    ]);
    if (deselectMethod) {
      api.deselectAll = deselectMethod;
    }
    const getNodeMethod = this.findMethod(canvas, [
      "getNode",
      "getElement",
      "getElementById",
      "findNode"
    ]);
    if (getNodeMethod) {
      api.getNode = getNodeMethod;
    }
    const panMethod = this.findMethod(canvas, [
      "panTo",
      "moveTo",
      "translateTo",
      "setViewport"
    ]);
    if (panMethod) {
      api.panTo = panMethod;
    }
    if (api.zoomToBbox || api.selectNode && api.panMethod) {
      return api;
    }
    return null;
  }
  // 查找指定名称的方法
  findMethod(obj, methodNames) {
    if (!obj || typeof obj !== "object") {
      return null;
    }
    for (const name of methodNames) {
      if (hasProperty(obj, name) && typeof obj[name] === "function") {
        console.log(`Found method: ${name}`);
        return obj[name].bind(obj);
      }
    }
    return null;
  }
  // 获取对象的所有方法
  getAllMethods(obj) {
    const methods = /* @__PURE__ */ new Set();
    let current = obj;
    while (current && current !== Object.prototype) {
      Object.getOwnPropertyNames(current).forEach((name) => {
        if (typeof obj[name] === "function") {
          methods.add(name);
        }
      });
      current = Object.getPrototypeOf(current);
    }
    return Array.from(methods);
  }
  // 执行Canvas聚焦操作
  async executeCanvasFocus(canvasAPI, nodeId, nodeData) {
    try {
      if (canvasAPI.deselectAll) {
        console.log("Clearing selection...");
        canvasAPI.deselectAll();
      }
      if (canvasAPI.selectNode) {
        console.log("Selecting node:", nodeId);
        try {
          canvasAPI.selectNode(nodeId);
        } catch (error) {
          console.warn("selectNode failed:", error);
        }
      }
      if (canvasAPI.zoomToBbox) {
        console.log("Zooming to bbox...");
        const bbox = this.calculateOptimalBbox(nodeData);
        console.log("Calculated bbox:", bbox);
        try {
          canvasAPI.zoomToBbox(bbox);
          return true;
        } catch (error) {
          console.warn("zoomToBbox failed:", error);
        }
      }
      if (canvasAPI.panTo) {
        console.log("Using panTo as fallback...");
        const centerX = nodeData.x + nodeData.width / 2;
        const centerY = nodeData.y + nodeData.height / 2;
        try {
          canvasAPI.panTo(centerX, centerY);
          return true;
        } catch (error) {
          console.warn("panTo failed:", error);
        }
      }
      return false;
    } catch (error) {
      console.error("executeCanvasFocus failed:", error);
      return false;
    }
  }
  // 探索Canvas API的可用方法
  exploreCanvasAPI(canvas) {
    console.log("=== Canvas API Exploration ===");
    const allProps = [];
    let obj = canvas;
    while (obj && obj !== Object.prototype) {
      allProps.push(...Object.getOwnPropertyNames(obj));
      obj = Object.getPrototypeOf(obj);
    }
    const uniqueProps = [...new Set(allProps)];
    const methods = uniqueProps.filter((prop) => {
      try {
        return typeof canvas[prop] === "function";
      } catch {
        return false;
      }
    });
    console.log("All available methods:", methods);
    const focusMethods = methods.filter(
      (method) => method.toLowerCase().includes("zoom") || method.toLowerCase().includes("focus") || method.toLowerCase().includes("select") || method.toLowerCase().includes("center") || method.toLowerCase().includes("pan")
    );
    console.log("Potential focus-related methods:", focusMethods);
  }
  // 获取当前活动的Canvas视图
  getActiveCanvasView() {
    console.log("=== Getting Canvas View ===");
    const activeLeaf = this.app.workspace.activeLeaf;
    console.log("Active leaf:", activeLeaf);
    console.log("Active leaf view type:", activeLeaf?.view?.getViewType());
    if (activeLeaf && activeLeaf.view.getViewType() === "canvas") {
      console.log("Found active canvas view");
      return activeLeaf.view;
    }
    const canvasLeaves = this.app.workspace.getLeavesOfType("canvas");
    console.log("Canvas leaves found:", canvasLeaves.length);
    const activeFile = this.app.workspace.getActiveFile();
    console.log("Active file:", activeFile?.path);
    for (const leaf of canvasLeaves) {
      const view = leaf.view;
      console.log("Checking canvas leaf:", view?.file?.path);
      if (view && view.file && activeFile && view.file.path === activeFile.path) {
        console.log("Found matching canvas view");
        return view;
      }
    }
    console.log("No canvas view found");
    return null;
  }
  // 等待Canvas视图加载完成
  async waitForCanvasLoad() {
    return new Promise((resolve) => {
      this.safeSetTimeout(() => resolve(void 0), 300);
    });
  }
  // 计算最佳聚焦边界框
  calculateOptimalBbox(node) {
    const padding = 100;
    return {
      minX: node.x - padding,
      minY: node.y - padding,
      maxX: node.x + node.width + padding,
      maxY: node.y + node.height + padding
    };
  }
  // 模拟操作聚焦节点（回退方案）
  async focusNodeBySimulation(nodeId) {
    try {
      console.log("=== Starting simulation focus ===");
      const nodeData = this.canvasData?.nodes.find((n) => n.id === nodeId);
      if (!nodeData) {
        new import_obsidian.Notice("\u627E\u4E0D\u5230\u76EE\u6807\u8282\u70B9");
        return false;
      }
      console.log("Node data for simulation:", nodeData);
      const canvasView = this.getActiveCanvasView();
      if (!canvasView || !canvasView.containerEl) {
        console.log("Canvas view or container not found");
        return false;
      }
      const canvasSelectors = [
        ".canvas-wrapper",
        ".canvas-container",
        ".canvas-viewport",
        ".canvas",
        '[data-type="canvas"]',
        '.workspace-leaf-content[data-type="canvas"]'
      ];
      let canvasElement = null;
      for (const selector of canvasSelectors) {
        canvasElement = canvasView.containerEl.querySelector(selector);
        if (canvasElement) {
          console.log(`Found canvas element with selector: ${selector}`);
          break;
        }
      }
      if (!canvasElement) {
        console.log("Canvas element not found, trying direct approach");
        canvasElement = canvasView.containerEl;
      }
      if (canvasView.canvas) {
        console.log("Trying direct canvas manipulation...");
        const success = await this.tryDirectCanvasManipulation(canvasView.canvas, nodeId, nodeData);
        if (success) {
          new import_obsidian.Notice("\u5DF2\u805A\u7126\u5230\u76EE\u6807\u8282\u70B9\uFF08\u76F4\u63A5\u64CD\u4F5C\uFF09", 3e3);
          return true;
        }
      }
      const nodeElement = this.findNodeElement(canvasView.containerEl, nodeId);
      if (nodeElement) {
        console.log("Found node element, simulating click...");
        nodeElement.scrollIntoView({ behavior: "smooth", block: "center" });
        nodeElement.click();
        new import_obsidian.Notice("\u5DF2\u805A\u7126\u5230\u76EE\u6807\u8282\u70B9\uFF08\u5143\u7D20\u70B9\u51FB\uFF09", 3e3);
        return true;
      }
      new import_obsidian.Notice("\u805A\u7126\u529F\u80FD\u6682\u4E0D\u53EF\u7528\uFF0C\u8BF7\u624B\u52A8\u5B9A\u4F4D", 3e3);
      return false;
    } catch (error) {
      console.error("\u6A21\u62DF\u805A\u7126\u5931\u8D25:", error);
      new import_obsidian.Notice("\u805A\u7126\u5931\u8D25\uFF0C\u8BF7\u624B\u52A8\u5B9A\u4F4D");
      return false;
    }
  }
  // 尝试直接操作Canvas对象
  async tryDirectCanvasManipulation(canvas, nodeId, nodeData) {
    try {
      console.log("Trying direct canvas manipulation...");
      console.log("Canvas object:", canvas);
      if (canvas.nodes && canvas.nodes.has && canvas.nodes.has(nodeId)) {
        console.log("Found node in canvas.nodes");
        const node = canvas.nodes.get(nodeId);
        console.log("Canvas node object:", node);
        if (canvas.selection) {
          console.log("Setting canvas selection...");
          canvas.selection.clear();
          canvas.selection.add(node);
        }
      }
      if (canvas.viewport || canvas.view) {
        const viewport = canvas.viewport || canvas.view;
        console.log("Found viewport:", viewport);
        const centerX = nodeData.x + nodeData.width / 2;
        const centerY = nodeData.y + nodeData.height / 2;
        if (viewport.setCenter) {
          viewport.setCenter(centerX, centerY);
          return true;
        } else if (viewport.panTo) {
          viewport.panTo(centerX, centerY);
          return true;
        } else if (viewport.x !== void 0 && viewport.y !== void 0) {
          viewport.x = -centerX + viewport.width / 2;
          viewport.y = -centerY + viewport.height / 2;
          return true;
        }
      }
      return false;
    } catch (error) {
      console.error("Direct canvas manipulation failed:", error);
      return false;
    }
  }
  // 查找节点对应的DOM元素
  findNodeElement(container, nodeId) {
    const selectors = [
      `[data-node-id="${nodeId}"]`,
      `[data-id="${nodeId}"]`,
      `#${nodeId}`,
      `.canvas-node[data-id="${nodeId}"]`,
      `.canvas-card[data-id="${nodeId}"]`
    ];
    for (const selector of selectors) {
      const element = container.querySelector(selector);
      if (element) {
        console.log(`Found node element with selector: ${selector}`);
        return element;
      }
    }
    console.log("Node element not found");
    return null;
  }
  // ==================== 拖拽功能实现 ====================
  // 设置拖拽处理器
  setupDragDropHandlers() {
    console.log("Setting up drag and drop handlers...");
    this.setupEditorDragSource();
    this.setupGridDropTarget();
    this.setupCanvasDropTarget();
  }
  // ==================== 网格卡片拖拽到Canvas功能 (HTML5 Drag & Drop API) ====================
  /*
   * 旧的鼠标事件处理代码已被HTML5 Drag & Drop API替代
   * 保留注释以防需要回退
   */
  // 处理卡片拖拽开始事件
  handleCardDragStart(e) {
    const cardElement = e.target.closest(".canvas-grid-card");
    if (!cardElement || !cardElement.dataset.nodeId) {
      e.preventDefault();
      return;
    }
    if (e.target.closest(".canvas-card-toolbar")) {
      e.preventDefault();
      return;
    }
    const nodeId = cardElement.dataset.nodeId;
    const node = this.canvasData?.nodes.find((n) => n.id === nodeId);
    if (!node) {
      e.preventDefault();
      return;
    }
    console.log("\u{1F680} Starting card drag with HTML5 API:", node);
    if (e.dataTransfer) {
      e.dataTransfer.setData("text/plain", node.text || "");
      e.dataTransfer.setData("application/json", JSON.stringify({
        type: "canvas-node",
        nodeData: node,
        source: "canvas-grid-view",
        isCtrlDrag: e.ctrlKey
        // 记录是否按住Ctrl键
      }));
      e.dataTransfer.effectAllowed = e.ctrlKey ? "copy" : "move";
      this.setCardDragPreview(e, cardElement);
    }
    cardElement.classList.add("dragging-from-grid");
    cardElement.style.cursor = "grabbing";
    this.isDragFromGrid = true;
    this.currentDragCard = cardElement;
    console.log("\u2705 Card drag started successfully");
  }
  // 处理卡片拖拽结束事件
  handleCardDragEnd(e) {
    console.log("\u{1F3C1} Card drag ended");
    if (this.currentDragCard) {
      this.currentDragCard.classList.remove("dragging-from-grid");
      this.currentDragCard.style.cursor = "grab";
    }
    this.isDragFromGrid = false;
    this.currentDragCard = null;
    console.log("\u2705 Card drag cleanup completed");
  }
  // 设置卡片拖拽预览
  setCardDragPreview(e, cardElement) {
    try {
      const preview = cardElement.cloneNode(true);
      preview.style.cssText = `
				position: absolute;
				top: -1000px;
				left: -1000px;
				width: ${cardElement.offsetWidth}px;
				height: ${cardElement.offsetHeight}px;
				opacity: 0.8;
				transform: rotate(3deg);
				box-shadow: 0 5px 15px rgba(0,0,0,0.3);
				pointer-events: none;
				z-index: 10000;
			`;
      document.body.appendChild(preview);
      if (e.dataTransfer) {
        e.dataTransfer.setDragImage(preview, cardElement.offsetWidth / 2, cardElement.offsetHeight / 2);
      }
      setTimeout(() => {
        if (document.body.contains(preview)) {
          document.body.removeChild(preview);
        }
      }, 0);
    } catch (error) {
      console.error("Failed to set card drag preview:", error);
    }
  }
  // 设置Canvas拖拽目标
  setupCanvasDropTarget() {
    console.log("Setting up Canvas drop target for grid cards...");
    this.registerDomEvent(document, "dragover", (e) => {
      if (this.isDragFromGrid && e.dataTransfer?.types.includes("application/json")) {
        const canvasElement = this.findCanvasElementUnderCursor(e);
        if (canvasElement) {
          e.preventDefault();
          e.dataTransfer.dropEffect = e.ctrlKey ? "copy" : "move";
        }
      }
    });
    this.registerDomEvent(document, "drop", (e) => {
      if (this.isDragFromGrid && e.dataTransfer?.types.includes("application/json")) {
        const canvasView = this.findCanvasViewUnderCursor(e);
        if (canvasView) {
          e.preventDefault();
          this.handleCanvasDropFromGrid(e, canvasView);
        }
      }
    });
  }
  // 查找鼠标下的Canvas元素
  findCanvasElementUnderCursor(e) {
    const element = document.elementFromPoint(e.clientX, e.clientY);
    if (!element)
      return null;
    const canvasContainer = element.closest('.workspace-leaf-content[data-type="canvas"]');
    return canvasContainer;
  }
  // 处理Canvas接收网格卡片的拖拽
  async handleCanvasDropFromGrid(e, canvasView) {
    try {
      console.log("\u{1F3AF} Handling Canvas drop from grid...");
      const dragDataStr = e.dataTransfer?.getData("application/json");
      if (!dragDataStr) {
        console.error("No drag data found");
        return;
      }
      const dragData = JSON.parse(dragDataStr);
      if (dragData.type !== "canvas-node" || dragData.source !== "canvas-grid-view") {
        console.log("Not a grid card drag, ignoring");
        return;
      }
      const node = dragData.nodeData;
      const isCtrlDrag = dragData.isCtrlDrag || e.ctrlKey;
      console.log("Processing grid card drop:", node, "Ctrl pressed:", isCtrlDrag);
      const canvasCoords = this.getCanvasCoordinatesFromDrop(e, canvasView);
      console.log("Canvas coordinates:", canvasCoords);
      const newNode = this.createCanvasNodeFromGridCard(node, canvasCoords);
      await this.addNodeToCanvas(newNode, canvasView);
      if (isCtrlDrag) {
        new import_obsidian.Notice("\u5361\u7247\u5DF2\u590D\u5236\u5230Canvas");
        console.log("\u2705 Card copied to Canvas (Ctrl+drag)");
      } else {
        await this.removeNodeFromGrid(node.id);
        new import_obsidian.Notice("\u5361\u7247\u5DF2\u79FB\u52A8\u5230Canvas");
        console.log("\u2705 Card moved to Canvas (normal drag)");
      }
      console.log("\u2705 Canvas drop completed successfully");
    } catch (error) {
      console.error("Failed to handle Canvas drop:", error);
      new import_obsidian.Notice("\u62D6\u62FD\u5230Canvas\u5931\u8D25");
    }
  }
  // 从拖拽事件获取Canvas坐标 - 使用Obsidian内置方法
  getCanvasCoordinatesFromDrop(e, canvasView) {
    console.log("\u{1F3AF} Getting Canvas coordinates from drop event...");
    try {
      if (canvasView.canvas && typeof canvasView.canvas.posFromEvt === "function") {
        const pos = canvasView.canvas.posFromEvt(e);
        console.log("\u2705 Using Canvas.posFromEvt:", pos);
        return { x: pos.x, y: pos.y };
      }
      console.log("\u26A0\uFE0F Canvas.posFromEvt not available, using manual calculation");
      return this.getCanvasCoordinatesManual(e, canvasView);
    } catch (error) {
      console.error("Error getting Canvas coordinates:", error);
      return { x: e.clientX, y: e.clientY };
    }
  }
  // 手动计算Canvas坐标（备用方法）
  getCanvasCoordinatesManual(e, canvasView) {
    const canvasContainer = canvasView.containerEl.querySelector(".canvas-wrapper") || canvasView.containerEl.querySelector(".canvas-container") || canvasView.containerEl;
    if (!canvasContainer) {
      console.warn("Canvas container not found, using event coordinates");
      return { x: e.clientX, y: e.clientY };
    }
    const rect = canvasContainer.getBoundingClientRect();
    const relativeX = e.clientX - rect.left;
    const relativeY = e.clientY - rect.top;
    const canvas = canvasView.canvas;
    if (canvas && canvas.tx !== void 0 && canvas.ty !== void 0 && canvas.tZoom !== void 0) {
      return {
        x: (relativeX - canvas.tx) / canvas.tZoom,
        y: (relativeY - canvas.ty) / canvas.tZoom
      };
    }
    return { x: relativeX, y: relativeY };
  }
  // 处理卡片鼠标按下事件 (已废弃 - 使用HTML5 Drag & Drop API)
  handleCardMouseDown_DEPRECATED(e) {
    const cardElement = e.target.closest(".canvas-grid-card");
    if (!cardElement || !cardElement.dataset.nodeId)
      return;
    if (e.target.closest(".canvas-card-toolbar"))
      return;
    this.longPressStartTime = Date.now();
    this.dragStartPosition = { x: e.clientX, y: e.clientY };
    this.currentDragCard = cardElement;
    this.addGlobalMouseListeners();
    this.longPressTimer = setTimeout(() => {
      this.startCardDrag(cardElement, e);
    }, this.longPressThreshold);
    e.preventDefault();
  }
  // 处理卡片鼠标移动事件 (已废弃 - 使用HTML5 Drag & Drop API)
  handleCardMouseMove_DEPRECATED(e) {
    if (!this.isDragFromGrid && this.longPressTimer) {
      const deltaX = Math.abs(e.clientX - this.dragStartPosition.x);
      const deltaY = Math.abs(e.clientY - this.dragStartPosition.y);
      const moveDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      if (moveDistance > 10) {
        this.clearLongPressTimer();
      }
    }
    if (this.isDragFromGrid && this.dragPreviewElement) {
      this.dragPreviewElement.style.top = `${e.clientY - 20}px`;
      this.dragPreviewElement.style.left = `${e.clientX - 20}px`;
    }
  }
  // 处理卡片鼠标抬起事件 (已废弃 - 使用HTML5 Drag & Drop API)
  handleCardMouseUp_DEPRECATED(e) {
    this.clearLongPressTimer();
    if (this.isDragFromGrid) {
      this.endCardDrag(e);
    } else {
      this.resetCardDragState();
    }
  }
  // 处理鼠标离开网格容器事件
  handleCardMouseLeave(e) {
    this.clearLongPressTimer();
    if (!this.isDragFromGrid) {
      this.resetCardDragState();
    }
  }
  // 清理长按定时器
  clearLongPressTimer() {
    if (this.longPressTimer) {
      clearTimeout(this.longPressTimer);
      this.longPressTimer = null;
    }
  }
  // 重置卡片拖拽状态
  resetCardDragState() {
    console.log("Resetting card drag state...");
    this.forceCleanupDragPreview();
    this.hideDragHint();
    if (this.currentDragCard) {
      this.currentDragCard.classList.remove("dragging-from-grid");
    }
    this.currentDragCard = null;
    this.isDragFromGrid = false;
    this.longPressStartTime = 0;
    this.dragStartPosition = { x: 0, y: 0 };
    this.removeGlobalMouseListeners();
    console.log("Card drag state reset complete");
  }
  // 添加全局鼠标事件监听器
  addGlobalMouseListeners() {
    this.removeGlobalMouseListeners();
    console.log("Adding global mouse listeners...");
    this.globalMouseMoveHandler = (e) => {
      this.handleCardMouseMove_DEPRECATED(e);
    };
    this.globalMouseUpHandler = (e) => {
      this.handleCardMouseUp_DEPRECATED(e);
    };
    document.addEventListener("mousemove", this.globalMouseMoveHandler, { passive: true });
    document.addEventListener("mouseup", this.globalMouseUpHandler);
    document.addEventListener("keydown", this.handleDragEscape);
    setTimeout(() => {
      if (this.isDragFromGrid) {
        window.addEventListener("blur", this.handleWindowBlur);
      }
    }, 200);
    console.log("Global mouse listeners added");
  }
  // 取消拖拽操作
  cancelDrag() {
    console.log("Canceling drag operation...");
    this.resetCardDragState();
  }
  // 移除全局鼠标事件监听器
  removeGlobalMouseListeners() {
    console.log("Removing global mouse listeners...");
    if (this.globalMouseMoveHandler) {
      document.removeEventListener("mousemove", this.globalMouseMoveHandler);
      this.globalMouseMoveHandler = null;
    }
    if (this.globalMouseUpHandler) {
      document.removeEventListener("mouseup", this.globalMouseUpHandler);
      this.globalMouseUpHandler = null;
    }
    window.removeEventListener("blur", this.handleWindowBlur);
    document.removeEventListener("keydown", this.handleDragEscape);
    console.log("Global mouse listeners removed");
  }
  // 开始卡片拖拽
  startCardDrag(cardElement, e) {
    const nodeId = cardElement.dataset.nodeId;
    if (!nodeId || !this.canvasData)
      return;
    const node = this.canvasData.nodes.find((n) => n.id === nodeId);
    if (!node)
      return;
    console.log("Starting card drag from grid:", node);
    this.isDragFromGrid = true;
    this.createDragPreview(cardElement, e);
    cardElement.classList.add("dragging-from-grid");
    this.showDragHint(e.ctrlKey);
  }
  // 结束卡片拖拽
  endCardDrag(e) {
    console.log("\u{1F3C1} Ending card drag at:", e.clientX, e.clientY);
    if (!this.currentDragCard || !this.isDragFromGrid) {
      console.log("\u274C Invalid drag state - currentDragCard:", !!this.currentDragCard, "isDragFromGrid:", this.isDragFromGrid);
      return;
    }
    const nodeId = this.currentDragCard.dataset.nodeId;
    if (!nodeId || !this.canvasData) {
      console.log("\u274C Missing nodeId or canvasData - nodeId:", nodeId, "canvasData:", !!this.canvasData);
      return;
    }
    const node = this.canvasData.nodes.find((n) => n.id === nodeId);
    if (!node) {
      console.log("\u274C Node not found for nodeId:", nodeId);
      return;
    }
    console.log("\u2705 Found node for drag:", node);
    const canvasView = this.findCanvasViewUnderCursor(e);
    if (canvasView) {
      console.log("\u{1F3AF} Canvas view found, handling drop...");
      this.handleDropToCanvas(node, e, canvasView);
    } else {
      console.log("\u274C No Canvas view found under cursor");
      new import_obsidian.Notice("\u8BF7\u62D6\u62FD\u5230Canvas\u533A\u57DF");
    }
    console.log("\u{1F9F9} Cleaning up drag state...");
    this.resetCardDragState();
  }
  // 创建拖拽预览
  createDragPreview(cardElement, e) {
    this.forceCleanupDragPreview();
    console.log("Creating drag preview...");
    this.dragPreviewElement = cardElement.cloneNode(true);
    this.dragPreviewElement.classList.add("drag-preview");
    this.dragPreviewElement.style.cssText = `
			position: fixed !important;
			top: ${e.clientY - 20}px !important;
			left: ${e.clientX - 20}px !important;
			width: ${cardElement.offsetWidth}px !important;
			height: ${cardElement.offsetHeight}px !important;
			opacity: 0.8 !important;
			pointer-events: none !important;
			z-index: 10000 !important;
			transform: rotate(5deg) !important;
			box-shadow: 0 5px 15px rgba(0,0,0,0.3) !important;
		`;
    document.body.appendChild(this.dragPreviewElement);
    console.log("Drag preview created and attached");
  }
  // 强制清理拖拽预览
  forceCleanupDragPreview() {
    console.log("Force cleaning up drag preview...");
    if (this.dragPreviewElement) {
      try {
        if (this.dragPreviewElement.parentNode) {
          this.dragPreviewElement.parentNode.removeChild(this.dragPreviewElement);
        }
      } catch (error) {
        console.warn("Error removing drag preview element:", error);
      }
      this.dragPreviewElement = null;
    }
    this.cleanupDragPreview = () => {
    };
    console.log("Drag preview cleanup complete");
  }
  // 显示拖拽提示
  showDragHint(isCtrlPressed) {
    const hint = document.createElement("div");
    hint.className = "drag-hint";
    hint.textContent = isCtrlPressed ? "\u79FB\u52A8\u5230Canvas\uFF08\u5220\u9664\u539F\u5361\u7247\uFF09" : "\u590D\u5236\u5230Canvas\uFF08\u4FDD\u6301\u539F\u5361\u7247\uFF09";
    hint.style.cssText = `
			position: fixed;
			top: 20px;
			left: 50%;
			transform: translateX(-50%);
			background: var(--background-primary);
			border: 1px solid var(--background-modifier-border);
			border-radius: 6px;
			padding: 8px 16px;
			font-size: 12px;
			color: var(--text-normal);
			z-index: 10001;
			box-shadow: 0 2px 8px rgba(0,0,0,0.15);
		`;
    document.body.appendChild(hint);
    this.dragHintElement = hint;
  }
  // 隐藏拖拽提示
  hideDragHint() {
    if (this.dragHintElement) {
      this.dragHintElement.remove();
      this.dragHintElement = null;
    }
  }
  // 查找鼠标位置下的Canvas视图
  findCanvasViewUnderCursor(e) {
    console.log("\u{1F50D} Finding Canvas view under cursor at:", e.clientX, e.clientY);
    const originalDisplay = this.dragPreviewElement?.style.display;
    if (this.dragPreviewElement) {
      this.dragPreviewElement.style.display = "none";
    }
    const elementUnderCursor = document.elementFromPoint(e.clientX, e.clientY);
    console.log("\u{1F3AF} Element under cursor:", elementUnderCursor);
    if (this.dragPreviewElement && originalDisplay !== void 0) {
      this.dragPreviewElement.style.display = originalDisplay;
    }
    if (!elementUnderCursor) {
      console.log("\u274C No element found under cursor");
      return null;
    }
    const canvasSelectors = [
      '.workspace-leaf-content[data-type="canvas"]',
      '[data-type="canvas"]',
      ".canvas-wrapper",
      ".canvas-container",
      '.view-content[data-type="canvas"]'
    ];
    let canvasContainer = null;
    for (const selector of canvasSelectors) {
      canvasContainer = elementUnderCursor.closest(selector);
      if (canvasContainer) {
        console.log("\u2705 Found Canvas container with selector:", selector, canvasContainer);
        break;
      }
    }
    if (!canvasContainer) {
      console.log("\u274C No Canvas container found. Element classes:", elementUnderCursor.className);
      console.log("\u274C Element parents:", this.getElementPath(elementUnderCursor));
      return null;
    }
    const canvasLeaves = this.app.workspace.getLeavesOfType("canvas");
    console.log("\u{1F4CB} Available Canvas leaves:", canvasLeaves.length);
    const leaf = canvasLeaves.find((leaf2) => {
      const containerEl = leaf2.view?.containerEl;
      if (containerEl && containerEl.contains(canvasContainer)) {
        console.log("\u2705 Found matching Canvas leaf:", leaf2);
        return true;
      }
      return false;
    });
    if (!leaf) {
      console.log("\u274C No matching Canvas leaf found");
      return null;
    }
    console.log("\u{1F389} Successfully found Canvas view:", leaf.view);
    return leaf.view;
  }
  // 获取元素路径用于调试
  getElementPath(element) {
    const path = [];
    let current = element;
    for (let i = 0; i < 5 && current; i++) {
      const tag = current.tagName.toLowerCase();
      const className = current.className ? `.${current.className.split(" ").join(".")}` : "";
      const id = current.id ? `#${current.id}` : "";
      path.push(`${tag}${id}${className}`);
      current = current.parentElement;
    }
    return path.join(" > ");
  }
  // 处理拖拽到Canvas的操作
  async handleDropToCanvas(node, e, canvasView) {
    try {
      console.log("Dropping card to Canvas:", node);
      const rawCoords = this.getCanvasCoordinates(e, canvasView);
      const canvasCoords = this.calibrateCanvasCoordinates(rawCoords, canvasView);
      this.showCoordinateDebugInfo(e, canvasView, canvasCoords);
      const newNode = this.createCanvasNodeFromGridCard(node, canvasCoords);
      await this.addNodeToCanvas(newNode, canvasView);
      if (e.ctrlKey) {
        await this.removeNodeFromGrid(node.id);
        new import_obsidian.Notice("\u5361\u7247\u5DF2\u79FB\u52A8\u5230Canvas");
      } else {
        new import_obsidian.Notice("\u5361\u7247\u5DF2\u590D\u5236\u5230Canvas");
      }
    } catch (error) {
      console.error("Failed to drop card to Canvas:", error);
      new import_obsidian.Notice("\u62D6\u62FD\u5230Canvas\u5931\u8D25");
    }
  }
  // 获取Canvas坐标 - 改进版本，支持多种坐标转换方法
  getCanvasCoordinates(e, canvasView) {
    console.log("\u{1F3AF} Converting mouse coordinates to Canvas coordinates...");
    console.log("Mouse position:", { x: e.clientX, y: e.clientY });
    const containerSelectors = [
      ".canvas-wrapper",
      ".canvas-container",
      ".canvas-viewport",
      ".view-content"
    ];
    let canvasContainer = null;
    for (const selector of containerSelectors) {
      canvasContainer = canvasView.containerEl.querySelector(selector);
      if (canvasContainer) {
        console.log("\u2705 Found Canvas container with selector:", selector);
        break;
      }
    }
    if (!canvasContainer) {
      console.log("\u274C No Canvas container found, using containerEl directly");
      canvasContainer = canvasView.containerEl;
    }
    const rect = canvasContainer.getBoundingClientRect();
    console.log("Canvas container rect:", {
      left: rect.left,
      top: rect.top,
      width: rect.width,
      height: rect.height
    });
    const relativeX = e.clientX - rect.left;
    const relativeY = e.clientY - rect.top;
    console.log("Relative coordinates:", { x: relativeX, y: relativeY });
    const canvas = canvasView.canvas;
    console.log("Canvas transform info:", {
      tx: canvas?.tx,
      ty: canvas?.ty,
      tZoom: canvas?.tZoom
    });
    if (canvas && canvas.tx !== void 0 && canvas.ty !== void 0 && canvas.tZoom !== void 0) {
      const canvasX = (relativeX - canvas.tx) / canvas.tZoom;
      const canvasY = (relativeY - canvas.ty) / canvas.tZoom;
      console.log("\u2705 Canvas coordinates calculated:", { x: canvasX, y: canvasY });
      const adjustedX = canvasX - 10;
      const adjustedY = canvasY - 10;
      console.log("\u{1F527} Adjusted coordinates:", { x: adjustedX, y: adjustedY });
      return { x: adjustedX, y: adjustedY };
    }
    console.log("\u26A0\uFE0F No transform info, trying alternative method...");
    const canvasElement = canvasContainer.querySelector("canvas");
    if (canvasElement) {
      const canvasRect = canvasElement.getBoundingClientRect();
      const canvasRelativeX = e.clientX - canvasRect.left;
      const canvasRelativeY = e.clientY - canvasRect.top;
      console.log("Canvas element coordinates:", { x: canvasRelativeX, y: canvasRelativeY });
      return { x: canvasRelativeX, y: canvasRelativeY };
    }
    console.log("\u{1F4CD} Using relative coordinates as final fallback:", { x: relativeX, y: relativeY });
    return { x: relativeX, y: relativeY };
  }
  // 坐标校准方法 - 根据Canvas状态进行精确校准
  calibrateCanvasCoordinates(coords, canvasView) {
    const canvas = canvasView.canvas;
    let offsetX = 0;
    let offsetY = 0;
    if (canvas?.tZoom) {
      if (canvas.tZoom < 0.5) {
        offsetX = -20;
        offsetY = -20;
      } else if (canvas.tZoom > 1.5) {
        offsetX = -5;
        offsetY = -5;
      } else {
        offsetX = -10;
        offsetY = -10;
      }
    }
    const toolbarElement = canvasView.containerEl.querySelector(".canvas-controls");
    const toolbarHeight = toolbarElement ? toolbarElement.offsetHeight : 0;
    const sidebarWidth = 0;
    const calibratedX = coords.x + offsetX - sidebarWidth;
    const calibratedY = coords.y + offsetY - toolbarHeight;
    console.log("\u{1F3AF} Coordinate calibration:", {
      original: coords,
      offset: { x: offsetX, y: offsetY },
      toolbar: toolbarHeight,
      calibrated: { x: calibratedX, y: calibratedY }
    });
    return { x: calibratedX, y: calibratedY };
  }
  // 实时坐标测试 - 在Canvas上显示坐标信息（调试用）
  showCoordinateDebugInfo(e, canvasView, coords) {
    let debugElement = document.getElementById("canvas-coord-debug");
    if (!debugElement) {
      debugElement = document.createElement("div");
      debugElement.id = "canvas-coord-debug";
      debugElement.style.cssText = `
				position: fixed;
				top: 10px;
				right: 10px;
				background: rgba(0, 0, 0, 0.8);
				color: white;
				padding: 10px;
				border-radius: 5px;
				font-family: monospace;
				font-size: 12px;
				z-index: 10001;
				pointer-events: none;
			`;
      document.body.appendChild(debugElement);
    }
    const canvas = canvasView.canvas;
    debugElement.innerHTML = `
			<div><strong>\u5750\u6807\u8C03\u8BD5\u4FE1\u606F</strong></div>
			<div>\u9F20\u6807\u4F4D\u7F6E: ${e.clientX}, ${e.clientY}</div>
			<div>Canvas\u5750\u6807: ${coords.x.toFixed(1)}, ${coords.y.toFixed(1)}</div>
			<div>\u7F29\u653E: ${canvas?.tZoom?.toFixed(2) || "N/A"}</div>
			<div>\u5E73\u79FB: ${canvas?.tx?.toFixed(1) || "N/A"}, ${canvas?.ty?.toFixed(1) || "N/A"}</div>
		`;
    setTimeout(() => {
      if (debugElement && debugElement.parentNode) {
        debugElement.parentNode.removeChild(debugElement);
      }
    }, 3e3);
  }
  // 从网格卡片创建Canvas节点
  createCanvasNodeFromGridCard(gridNode, coords) {
    const timestamp = Date.now();
    return {
      ...gridNode,
      id: `node-${timestamp}-from-grid`,
      x: coords.x,
      y: coords.y,
      // 保持原有的宽高，或使用默认值
      width: gridNode.width || 250,
      height: gridNode.height || 100
    };
  }
  // 添加节点到Canvas
  async addNodeToCanvas(node, canvasView) {
    if (!canvasView.canvas || !canvasView.file) {
      throw new Error("Canvas view not available");
    }
    const content = await this.app.vault.read(canvasView.file);
    const canvasData = JSON.parse(content);
    canvasData.nodes.push(node);
    await this.app.vault.modify(canvasView.file, JSON.stringify(canvasData, null, 2));
    if (canvasView.canvas.requestSave) {
      canvasView.canvas.requestSave();
    }
  }
  // 从网格中移除节点
  async removeNodeFromGrid(nodeId) {
    if (!this.canvasData || !this.linkedCanvasFile)
      return;
    console.log(`\u{1F5D1}\uFE0F Removing node from grid: ${nodeId}`);
    this.canvasData.nodes = this.canvasData.nodes.filter((node) => node.id !== nodeId);
    await this.saveCanvasData();
    if (this.currentGroupView) {
      this.analyzeGroups();
      const groupInfo = this.groupAnalysis.get(this.currentGroupView);
      if (!groupInfo || groupInfo.members.length === 0) {
        console.log("\u{1F4E4} Group is empty, returning to main view");
        this.exitGroupView();
        new import_obsidian.Notice("\u5206\u7EC4\u5DF2\u7A7A\uFF0C\u5DF2\u8FD4\u56DE\u4E3B\u89C6\u56FE");
        return;
      } else {
        this.filteredNodes = groupInfo.members;
        console.log(`\u{1F4CA} Group view updated, ${groupInfo.members.length} members remaining`);
      }
    }
    this.renderGrid();
    console.log("\u2705 Node removed and view refreshed");
  }
  // 设置编辑器拖拽源
  setupEditorDragSource() {
    this.registerDomEvent(document, "dragstart", (e) => {
      const target = e.target;
      if (this.isInEditor(target)) {
        const selectedText = this.getSelectedText();
        if (selectedText && selectedText.trim()) {
          this.handleEditorDragStart(e, selectedText);
        }
      }
    });
    this.registerDomEvent(document, "dragend", (e) => {
      this.resetDragState();
    });
  }
  // 检查是否在编辑器中
  isInEditor(element) {
    if (!element || typeof element.closest !== "function") {
      return false;
    }
    try {
      return element.closest(".cm-editor") !== null || element.closest(".markdown-source-view") !== null || element.closest(".markdown-preview-view") !== null;
    } catch (error) {
      console.error("Error checking if element is in editor:", error);
      return false;
    }
  }
  // 获取选中文本（使用Obsidian API）
  getSelectedText() {
    try {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (!activeView)
        return null;
      const editor = activeView.editor;
      const selection = editor.getSelection();
      return selection.trim() || null;
    } catch (error) {
      console.error("Failed to get selected text:", error);
      return null;
    }
  }
  // 获取源文件信息（用于创建回链）
  getSourceFileInfo() {
    try {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (!activeView) {
        return { file: null, path: "", position: null, context: "" };
      }
      const file = activeView.file;
      const editor = activeView.editor;
      const selections = editor.listSelections();
      const cursor = editor.getCursor();
      const currentLine = editor.getLine(cursor.line);
      let position = {
        line: cursor.line,
        ch: cursor.ch,
        selection: selections.length > 0 ? selections[0] : null
      };
      if (selections.length > 0 && selections[0]) {
        position.line = selections[0].anchor.line;
        position.ch = selections[0].anchor.ch;
      }
      return {
        file,
        path: file ? file.path : "",
        position,
        context: currentLine
      };
    } catch (error) {
      console.error("Failed to get source file info:", error);
      return { file: null, path: "", position: null, context: "" };
    }
  }
  // 处理编辑器拖拽开始
  handleEditorDragStart(e, selectedText) {
    if (!e.dataTransfer)
      return;
    console.log("Drag started from editor:", selectedText);
    const sourceInfo = this.getSourceFileInfo();
    e.dataTransfer.setData("text/plain", selectedText);
    e.dataTransfer.setData("application/obsidian-text", selectedText);
    e.dataTransfer.effectAllowed = "copy";
    this.isDragging = true;
    this.dragData = {
      text: selectedText,
      source: "editor",
      timestamp: Date.now(),
      sourceFile: sourceInfo.file,
      sourcePath: sourceInfo.path,
      sourcePosition: sourceInfo.position,
      sourceContext: sourceInfo.context
    };
    console.log("Drag data with backlink info:", this.dragData);
    this.setDragPreview(e, selectedText);
  }
  // 设置拖拽预览
  setDragPreview(e, text) {
    try {
      const preview = document.createElement("div");
      preview.style.cssText = `
				position: absolute;
				top: -1000px;
				left: -1000px;
				background: var(--background-primary);
				border: 1px solid var(--background-modifier-border);
				border-radius: 6px;
				padding: 8px 12px;
				font-size: 12px;
				color: var(--text-normal);
				max-width: 200px;
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
				box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
			`;
      preview.textContent = text.length > 50 ? text.substring(0, 50) + "..." : text;
      document.body.appendChild(preview);
      if (e.dataTransfer) {
        e.dataTransfer.setDragImage(preview, 10, 10);
      }
      this.safeSetTimeout(() => {
        if (document.body.contains(preview)) {
          document.body.removeChild(preview);
        }
      }, 0);
    } catch (error) {
      console.error("Failed to set drag preview:", error);
    }
  }
  // 设置网格视图拖拽目标
  setupGridDropTarget() {
    if (!this.gridContainer)
      return;
    console.log("Setting up grid drop target...");
    this.registerDomEvent(this.gridContainer, "dragover", (e) => {
      e.preventDefault();
      if (this.isDragging && this.dragData) {
        e.dataTransfer.dropEffect = "copy";
        this.showDropIndicator(e);
      }
    });
    this.registerDomEvent(this.gridContainer, "dragenter", (e) => {
      e.preventDefault();
      if (this.isDragging) {
        this.gridContainer.classList.add("drag-over");
        console.log("Drag entered grid container");
      }
    });
    this.registerDomEvent(this.gridContainer, "dragleave", (e) => {
      if (!this.gridContainer.contains(e.relatedTarget)) {
        this.gridContainer.classList.remove("drag-over");
        this.hideDropIndicator();
        console.log("Drag left grid container");
      }
    });
    this.registerDomEvent(this.gridContainer, "drop", (e) => {
      e.preventDefault();
      console.log("Drop event received");
      this.handleGridDrop(e);
    });
  }
  // 显示拖拽指示器
  showDropIndicator(e) {
    if (!this.dropIndicator) {
      this.dropIndicator = document.createElement("div");
      this.dropIndicator.className = "drop-indicator";
      this.gridContainer.appendChild(this.dropIndicator);
    }
    const rect = this.gridContainer.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const cols = Math.floor(this.gridContainer.clientWidth / (CARD_CONSTANTS.width + CARD_CONSTANTS.spacing));
    const col = Math.floor(x / (CARD_CONSTANTS.width + CARD_CONSTANTS.spacing));
    const row = Math.floor(y / (CARD_CONSTANTS.height + CARD_CONSTANTS.spacing));
    this.dropIndicator.style.left = `${col * (CARD_CONSTANTS.width + CARD_CONSTANTS.spacing)}px`;
    this.dropIndicator.style.top = `${row * (CARD_CONSTANTS.height + CARD_CONSTANTS.spacing)}px`;
    this.dropIndicator.style.width = `${CARD_CONSTANTS.width}px`;
    this.dropIndicator.style.height = `${CARD_CONSTANTS.height}px`;
    this.dropIndicator.style.display = "block";
  }
  // 隐藏拖拽指示器
  hideDropIndicator() {
    if (this.dropIndicator) {
      this.dropIndicator.style.display = "none";
    }
  }
  // 重置拖拽状态
  resetDragState() {
    this.isDragging = false;
    this.dragData = null;
    this.gridContainer?.classList.remove("drag-over");
    this.hideDropIndicator();
    console.log("Drag state reset");
  }
  // 处理网格拖拽放下
  async handleGridDrop(e) {
    try {
      this.gridContainer.classList.remove("drag-over");
      this.hideDropIndicator();
      const droppedText = e.dataTransfer?.getData("application/obsidian-text") || e.dataTransfer?.getData("text/plain");
      if (!droppedText || !droppedText.trim()) {
        new import_obsidian.Notice("\u6CA1\u6709\u68C0\u6D4B\u5230\u6709\u6548\u7684\u6587\u672C\u5185\u5BB9");
        return;
      }
      if (!this.linkedCanvasFile) {
        new import_obsidian.Notice("\u8BF7\u5148\u5173\u8054\u4E00\u4E2ACanvas\u6587\u4EF6");
        this.showCanvasSelectionDialog();
        return;
      }
      console.log("Processing drop with linked canvas:", this.linkedCanvasFile.path);
      new import_obsidian.Notice("\u6B63\u5728\u521B\u5EFA\u65B0\u5361\u7247...", 2e3);
      this.disableFileWatcher();
      const newNode = await this.createNodeFromText(droppedText, e);
      if (newNode) {
        await this.saveCanvasDataToLinkedFile();
        this.renderGrid();
        this.notifyCanvasViewRefresh();
        this.scrollToNewCard(newNode.id);
        new import_obsidian.Notice("\u65B0\u5361\u7247\u521B\u5EFA\u6210\u529F\uFF01", 3e3);
      }
      this.safeSetTimeout(() => {
        this.enableFileWatcher();
      }, 1e3);
      this.resetDragState();
    } catch (error) {
      console.error("\u62D6\u62FD\u521B\u5EFA\u5361\u7247\u5931\u8D25:", error);
      new import_obsidian.Notice("\u521B\u5EFA\u5361\u7247\u5931\u8D25\uFF0C\u8BF7\u91CD\u8BD5");
      this.enableFileWatcher();
      this.resetDragState();
    }
  }
  // 从文本创建Canvas节点
  async createNodeFromText(text, dropEvent) {
    try {
      const contentType = await this.analyzeTextContent(text);
      const dropTarget = this.analyzeDropTarget(dropEvent);
      let newNode;
      if (dropTarget.type === "existing-group") {
        newNode = await this.addToExistingGroup(dropTarget.groupId, contentType, dropTarget.position);
        console.log("Added to existing group:", dropTarget.groupId);
      } else {
        const { groupNode, contentNode } = this.createGroupedNodes(text, contentType, dropTarget.position);
        if (!this.canvasData) {
          this.canvasData = { nodes: [], edges: [] };
        }
        this.canvasData.nodes.push(groupNode);
        this.canvasData.nodes.push(contentNode);
        newNode = contentNode;
        console.log("Created new group with content");
      }
      await this.saveCanvasData();
      return newNode;
    } catch (error) {
      console.error("\u521B\u5EFA\u8282\u70B9\u5931\u8D25:", error);
      return null;
    }
  }
  // 分析文本内容类型（异步版本）
  async analyzeTextContent(text) {
    const trimmedText = text.trim();
    if (this.isURL(trimmedText)) {
      return {
        type: "link",
        content: { url: trimmedText },
        width: 300,
        height: 100
      };
    }
    if (this.isFileLink(trimmedText)) {
      return {
        type: "file",
        content: { file: trimmedText },
        width: 300,
        height: 200
      };
    }
    const textWithBacklink = await this.addBacklinkToText(trimmedText);
    const lines = textWithBacklink.split("\n").length;
    const estimatedWidth = Math.min(400, Math.max(200, textWithBacklink.length * 8));
    const estimatedHeight = Math.min(300, Math.max(100, lines * 25 + 40));
    return {
      type: "text",
      content: { text: textWithBacklink },
      width: estimatedWidth,
      height: estimatedHeight
    };
  }
  // 检测是否为URL
  isURL(text) {
    try {
      new URL(text);
      return true;
    } catch {
      return /^https?:\/\//.test(text);
    }
  }
  // 检测是否为文件链接
  isFileLink(text) {
    return /^\[\[.*\]\]$/.test(text) || text.includes(".md") || text.includes(".pdf");
  }
  // 分析拖拽目标
  analyzeDropTarget(dropEvent) {
    if (this.currentGroupView) {
      console.log("Drop in group view:", this.currentGroupView);
      return {
        type: "existing-group",
        groupId: this.currentGroupView,
        position: this.calculatePositionInGroup(this.currentGroupView, dropEvent)
      };
    }
    const targetGroupId = this.findGroupUnderCursor(dropEvent);
    if (targetGroupId) {
      console.log("Drop on group card:", targetGroupId);
      return {
        type: "existing-group",
        groupId: targetGroupId,
        position: this.calculatePositionInGroup(targetGroupId, dropEvent)
      };
    }
    console.log("Drop in empty area, creating new group");
    return {
      type: "new-group",
      position: this.calculateDropPosition(dropEvent)
    };
  }
  // 查找鼠标下的分组
  findGroupUnderCursor(dropEvent) {
    const rect = this.gridContainer.getBoundingClientRect();
    const x = dropEvent.clientX - rect.left;
    const y = dropEvent.clientY - rect.top;
    const elementUnderCursor = document.elementFromPoint(dropEvent.clientX, dropEvent.clientY);
    if (elementUnderCursor) {
      const groupCard = elementUnderCursor.closest('[data-node-type="group"]');
      if (groupCard) {
        return groupCard.dataset.nodeId || null;
      }
    }
    return null;
  }
  // 计算在分组内的位置
  calculatePositionInGroup(groupId, dropEvent) {
    if (!this.canvasData) {
      return { x: 100, y: 100 };
    }
    const groupNode = this.canvasData.nodes.find((n) => n.id === groupId && n.type === "group");
    if (!groupNode) {
      return { x: 100, y: 100 };
    }
    const groupMembers = this.canvasData.nodes.filter(
      (n) => n.type !== "group" && n.x >= groupNode.x && n.y >= groupNode.y && n.x + n.width <= groupNode.x + groupNode.width && n.y + n.height <= groupNode.y + groupNode.height
    );
    const padding = 20;
    if (groupMembers.length === 0) {
      return {
        x: groupNode.x + padding,
        y: groupNode.y + padding + 30
        // 为分组标题留空间
      };
    }
    const maxX = Math.max(...groupMembers.map((n) => n.x + n.width));
    const maxY = Math.max(...groupMembers.map((n) => n.y + n.height));
    const newX = maxX + padding;
    if (newX + 300 <= groupNode.x + groupNode.width - padding) {
      return { x: newX, y: groupMembers[0].y };
    }
    return {
      x: groupNode.x + padding,
      y: maxY + padding
    };
  }
  // 添加到现有分组
  async addToExistingGroup(groupId, contentType, position) {
    const timestamp = Date.now();
    const contentId = `node-${timestamp}-content`;
    const contentNode = {
      id: contentId,
      type: contentType.type,
      x: position.x,
      y: position.y,
      width: contentType.width,
      height: contentType.height,
      ...contentType.content
    };
    if (!this.canvasData) {
      this.canvasData = { nodes: [], edges: [] };
    }
    this.canvasData.nodes.push(contentNode);
    this.expandGroupIfNeeded(groupId, contentNode);
    this.updateGroupAnalysisAfterAdd(groupId, contentNode);
    if (this.currentGroupView === groupId) {
      this.refreshGroupView(groupId);
    }
    return contentNode;
  }
  // 扩展分组大小以容纳新内容
  expandGroupIfNeeded(groupId, newNode) {
    if (!this.canvasData)
      return;
    const groupNode = this.canvasData.nodes.find((n) => n.id === groupId && n.type === "group");
    if (!groupNode)
      return;
    const padding = 20;
    const requiredWidth = newNode.x + newNode.width - groupNode.x + padding;
    const requiredHeight = newNode.y + newNode.height - groupNode.y + padding;
    if (requiredWidth > groupNode.width) {
      groupNode.width = requiredWidth;
    }
    if (requiredHeight > groupNode.height) {
      groupNode.height = requiredHeight;
    }
  }
  // 更新分组分析数据（添加新节点后）
  updateGroupAnalysisAfterAdd(groupId, newNode) {
    const groupInfo = this.groupAnalysis.get(groupId);
    if (groupInfo) {
      groupInfo.members.push(newNode);
      groupInfo.memberCount = groupInfo.members.length;
      this.updateGroupBounds(groupInfo);
      console.log(`Updated group ${groupId} analysis, new member count: ${groupInfo.memberCount}`);
    } else {
      console.log(`Group ${groupId} not found in analysis, re-analyzing all groups`);
      this.analyzeGroups();
    }
  }
  // 更新分组边界
  updateGroupBounds(groupInfo) {
    if (groupInfo.members.length === 0)
      return;
    const allNodes = [groupInfo.group, ...groupInfo.members];
    const minX = Math.min(...allNodes.map((n) => n.x));
    const minY = Math.min(...allNodes.map((n) => n.y));
    const maxX = Math.max(...allNodes.map((n) => n.x + n.width));
    const maxY = Math.max(...allNodes.map((n) => n.y + n.height));
    groupInfo.bounds = { minX, minY, maxX, maxY };
  }
  // 刷新分组视图
  refreshGroupView(groupId) {
    console.log(`Refreshing group view for: ${groupId}`);
    this.analyzeGroups();
    const groupInfo = this.groupAnalysis.get(groupId);
    if (!groupInfo) {
      console.error(`Group ${groupId} not found after analysis`);
      return;
    }
    this.filteredNodes = [...groupInfo.members];
    this.renderGroupMembers();
    console.log(`Group view refreshed, showing ${groupInfo.members.length} members`);
  }
  // 创建分组和内容节点
  createGroupedNodes(text, contentType, position) {
    const timestamp = Date.now();
    const groupId = `group-${timestamp}`;
    const contentId = `node-${timestamp}-content`;
    const groupPadding = 40;
    const groupWidth = contentType.width + groupPadding * 2;
    const groupHeight = contentType.height + groupPadding * 2 + 60;
    const groupNode = {
      id: groupId,
      type: "group",
      x: position.x,
      y: position.y,
      width: groupWidth,
      height: groupHeight,
      label: "\u6536\u96C6",
      // 分组标题
      color: "1"
      // 使用红色作为默认分组颜色
    };
    const contentNode = {
      id: contentId,
      type: contentType.type,
      x: position.x + groupPadding,
      y: position.y + groupPadding + 30,
      // 为分组标题留出空间
      width: contentType.width,
      height: contentType.height,
      ...contentType.content
    };
    return { groupNode, contentNode };
  }
  // 计算拖拽放置位置
  calculateDropPosition(dropEvent) {
    if (this.canvasData && this.canvasData.nodes.length > 0) {
      const maxX = Math.max(...this.canvasData.nodes.map((n) => n.x + n.width));
      const maxY = Math.max(...this.canvasData.nodes.map((n) => n.y + n.height));
      const groupSpacing = 50;
      const newX = maxX + groupSpacing;
      const newY = 100;
      const estimatedCanvasWidth = 1200;
      const groupWidth = CARD_CONSTANTS.width + 80;
      if (newX + groupWidth > estimatedCanvasWidth) {
        return {
          x: 100,
          // 从左边开始
          y: maxY + groupSpacing
        };
      }
      return { x: newX, y: newY };
    }
    return { x: 100, y: 100 };
  }
  // 生成唯一节点ID
  generateNodeId() {
    return "node-" + Date.now() + "-" + Math.random().toString(36).substr(2, 9);
  }
  // 生成唯一的块引用ID
  generateBlockId() {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substr(2, 6);
    return `canvas-${timestamp}-${random}`;
  }
  // 🔧 修复：创建 dragData 的安全快照，避免竞态条件
  createDragDataSnapshot() {
    try {
      if (!this.dragData) {
        console.log("No dragData to snapshot");
        return null;
      }
      if (!this.dragData.sourceFile) {
        console.log("No sourceFile in dragData");
        return null;
      }
      if (!this.dragData.sourcePosition) {
        console.log("No sourcePosition in dragData");
        return null;
      }
      const snapshot = {
        sourceFile: this.dragData.sourceFile,
        sourcePosition: {
          line: this.dragData.sourcePosition.line,
          ch: this.dragData.sourcePosition.ch
        },
        sourcePath: this.dragData.sourcePath || "",
        sourceContext: this.dragData.sourceContext || ""
      };
      console.log("\u2705 Created dragData snapshot:", snapshot);
      return snapshot;
    } catch (error) {
      console.error("Failed to create dragData snapshot:", error);
      return null;
    }
  }
  // 在源文件中插入块引用（修复版本：添加文件锁保护）
  async insertBlockReference(file, position, blockId) {
    const filePath = file.path;
    try {
      console.log("=== Inserting Block Reference (Protected) ===");
      console.log("File:", filePath);
      console.log("Position:", position);
      console.log("Block ID:", blockId);
      if (this.fileModificationLocks.has(filePath)) {
        console.log("\u274C File is currently being modified, skipping");
        new import_obsidian.Notice("\u6E90\u6587\u4EF6\u6B63\u5728\u88AB\u4FEE\u6539\uFF0C\u8BF7\u7A0D\u540E\u91CD\u8BD5");
        return false;
      }
      this.fileModificationLocks.add(filePath);
      if (!file || !position || typeof position.line !== "number") {
        console.error("Invalid input parameters");
        return false;
      }
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      if (position.line < 0 || position.line >= lines.length) {
        console.error("Line number out of range:", position.line, "max:", lines.length - 1);
        return false;
      }
      const targetLine = lines[position.line];
      if (this.hasExistingBlockReference(targetLine)) {
        console.log("Line already has block reference, skipping");
        return false;
      }
      lines[position.line] = `${targetLine} ^${blockId}`;
      const newContent = lines.join("\n");
      await this.app.vault.modify(file, newContent);
      console.log("\u2705 Block reference inserted successfully");
      new import_obsidian.Notice("\u5DF2\u5728\u6E90\u6587\u4EF6\u4E2D\u6DFB\u52A0\u5757\u5F15\u7528");
      return true;
    } catch (error) {
      console.error("Failed to insert block reference:", error);
      const errorMessage = error instanceof Error ? error.message : "\u672A\u77E5\u9519\u8BEF";
      new import_obsidian.Notice("\u63D2\u5165\u5757\u5F15\u7528\u5931\u8D25\uFF1A" + errorMessage);
      return false;
    } finally {
      this.fileModificationLocks.delete(filePath);
      console.log("Released file lock for:", filePath);
    }
  }
  // 🔧 修复：改进的块引用检测方法
  hasExistingBlockReference(line) {
    if (!line || typeof line !== "string") {
      return false;
    }
    const blockRefPattern = /\s\^[a-zA-Z0-9\-_]+$/;
    return blockRefPattern.test(line);
  }
  // 🔧 修复：用户确认机制
  async confirmBlockReferenceInsertion(file) {
    return new Promise((resolve) => {
      const modal = new import_obsidian.Modal(this.app);
      modal.titleEl.setText("\u786E\u8BA4\u4FEE\u6539\u6E90\u6587\u4EF6");
      const content = modal.contentEl;
      content.empty();
      content.createEl("p", {
        text: "\u4E3A\u4E86\u521B\u5EFA\u7CBE\u786E\u7684\u56DE\u94FE\uFF0C\u9700\u8981\u5728\u6E90\u6587\u4EF6\u4E2D\u6DFB\u52A0\u5757\u5F15\u7528\u6807\u8BB0\u3002"
      });
      content.createEl("p", {
        text: `\u6587\u4EF6\uFF1A${file.basename}`,
        cls: "canvas-grid-file-info"
      });
      content.createEl("p", {
        text: "\u8FD9\u5C06\u5728\u62D6\u62FD\u7684\u6587\u672C\u884C\u672B\u5C3E\u6DFB\u52A0\u4E00\u4E2A\u5757\u5F15\u7528ID\uFF08\u5982\uFF1A^canvas-123456\uFF09",
        cls: "canvas-grid-detail-info"
      });
      const buttonContainer = content.createDiv("canvas-grid-confirm-buttons");
      buttonContainer.style.cssText = `
				display: flex;
				gap: 10px;
				margin-top: 20px;
				justify-content: center;
			`;
      const confirmButton = buttonContainer.createEl("button", { text: "\u786E\u8BA4\u4FEE\u6539" });
      confirmButton.style.cssText = `
				background-color: var(--interactive-accent);
				color: var(--text-on-accent);
				border: none;
				padding: 8px 16px;
				border-radius: 4px;
				cursor: pointer;
			`;
      confirmButton.onclick = () => {
        modal.close();
        resolve(true);
      };
      const cancelButton = buttonContainer.createEl("button", { text: "\u53D6\u6D88\uFF08\u4F7F\u7528\u884C\u53F7\uFF09" });
      cancelButton.style.cssText = `
				background-color: var(--background-modifier-border);
				color: var(--text-normal);
				border: none;
				padding: 8px 16px;
				border-radius: 4px;
				cursor: pointer;
			`;
      cancelButton.onclick = () => {
        modal.close();
        resolve(false);
      };
      confirmButton.focus();
      modal.open();
    });
  }
  // 在文本中添加回链（修复版本：解决竞态条件）
  async addBacklinkToText(originalText) {
    console.log("=== addBacklinkToText called (Fixed Version) ===");
    console.log("Original text:", originalText);
    console.log("Drag data:", this.dragData);
    const dragDataSnapshot = this.createDragDataSnapshot();
    if (!dragDataSnapshot) {
      console.log("\u274C No valid dragData snapshot available");
      return originalText;
    }
    try {
      const blockId = this.generateBlockId();
      console.log("Generated block ID:", blockId);
      const userConfirmed = await this.confirmBlockReferenceInsertion(dragDataSnapshot.sourceFile);
      if (!userConfirmed) {
        console.log("User declined block reference insertion, using fallback");
        const sourceFileName2 = dragDataSnapshot.sourceFile.basename;
        const lineNumber = dragDataSnapshot.sourcePosition.line + 1;
        const backlink2 = `[[${sourceFileName2}#^L${lineNumber}]]`;
        return `${originalText}

---
\u6765\u6E90\uFF1A${backlink2}`;
      }
      const insertSuccess = await this.insertBlockReference(
        dragDataSnapshot.sourceFile,
        dragDataSnapshot.sourcePosition,
        blockId
      );
      if (!insertSuccess) {
        console.log("\u274C Failed to insert block reference, using fallback");
        const sourceFileName2 = dragDataSnapshot.sourceFile.basename;
        const lineNumber = dragDataSnapshot.sourcePosition.line + 1;
        const backlink2 = `[[${sourceFileName2}#^L${lineNumber}]]`;
        return `${originalText}

---
\u6765\u6E90\uFF1A${backlink2}`;
      }
      const sourceFileName = dragDataSnapshot.sourceFile.basename;
      const backlink = `[[${sourceFileName}#^${blockId}]]`;
      const textWithBacklink = `${originalText}

---
\u6765\u6E90\uFF1A${backlink}`;
      console.log("\u2705 Successfully added block reference backlink:", backlink);
      console.log("Final text with backlink:", textWithBacklink);
      return textWithBacklink;
    } catch (error) {
      console.error("Error in addBacklinkToText:", error);
      new import_obsidian.Notice("\u521B\u5EFA\u56DE\u94FE\u65F6\u53D1\u751F\u9519\u8BEF\uFF0C\u5DF2\u4F7F\u7528\u539F\u59CB\u6587\u672C");
      return originalText;
    }
  }
  // 检查节点是否包含回链（支持块引用和行号格式）
  hasBacklink(node) {
    if (node.type !== "text" || !node.text) {
      return false;
    }
    return /---\n来源：\[\[.*#\^(canvas-\d+-\w+|L\d+)\]\]/.test(node.text);
  }
  // 从节点回链跳转到源位置（支持块引用）
  async navigateToBacklink(node) {
    if (node.type !== "text" || !node.text) {
      new import_obsidian.Notice("\u8282\u70B9\u4E0D\u5305\u542B\u6587\u672C\u5185\u5BB9");
      return;
    }
    try {
      console.log("=== Navigating to Backlink ===");
      console.log("Node text:", node.text);
      const backlinkMatch = node.text.match(/来源：\[\[(.*)#\^(canvas-\d+-\w+|L\d+)\]\]/);
      if (!backlinkMatch) {
        new import_obsidian.Notice("\u672A\u627E\u5230\u6709\u6548\u7684\u56DE\u94FE\u4FE1\u606F");
        return;
      }
      const fileName = backlinkMatch[1];
      const reference = backlinkMatch[2];
      console.log("Parsed backlink:", fileName, "reference:", reference);
      const files = this.app.vault.getMarkdownFiles();
      const sourceFile = files.find((f) => f.basename === fileName);
      if (!sourceFile) {
        new import_obsidian.Notice(`\u6E90\u6587\u4EF6\u4E0D\u5B58\u5728: ${fileName}`);
        return;
      }
      if (reference.startsWith("canvas-")) {
        await this.openFileAndNavigateToBlock(sourceFile, reference);
      } else if (reference.startsWith("L")) {
        const lineNumber = parseInt(reference.substring(1)) - 1;
        await this.openFileAndNavigate(sourceFile, lineNumber);
      } else {
        new import_obsidian.Notice("\u4E0D\u652F\u6301\u7684\u56DE\u94FE\u683C\u5F0F");
      }
    } catch (error) {
      console.error("Failed to navigate to backlink:", error);
      new import_obsidian.Notice("\u8DF3\u8F6C\u5230\u6E90\u6587\u4EF6\u5931\u8D25");
    }
  }
  // 打开文件并导航到指定位置
  async openFileAndNavigate(file, lineNumber) {
    try {
      const leaf = this.app.workspace.getUnpinnedLeaf();
      await leaf.openFile(file);
      await new Promise((resolve) => setTimeout(resolve, 100));
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (activeView && activeView.editor) {
        const editor = activeView.editor;
        const targetPos = { line: lineNumber, ch: 0 };
        editor.setCursor(targetPos);
        editor.scrollIntoView({ from: targetPos, to: targetPos }, true);
        const lineText = editor.getLine(lineNumber);
        const lineEnd = { line: lineNumber, ch: lineText.length };
        editor.setSelection(targetPos, lineEnd);
        setTimeout(() => {
          try {
            const cursor = editor.getCursor();
            editor.setCursor(cursor);
          } catch (e) {
          }
        }, 3e3);
        new import_obsidian.Notice(`\u5DF2\u8DF3\u8F6C\u5230\u6E90\u6587\u4EF6: ${file.basename} (\u7B2C${lineNumber + 1}\u884C)`);
        console.log("Successfully navigated to backlink position");
      } else {
        new import_obsidian.Notice("\u65E0\u6CD5\u83B7\u53D6\u7F16\u8F91\u5668\u89C6\u56FE");
      }
    } catch (error) {
      console.error("Failed to open file and navigate:", error);
      new import_obsidian.Notice("\u6253\u5F00\u6587\u4EF6\u5931\u8D25");
    }
  }
  // 打开文件并导航到指定的块引用
  async openFileAndNavigateToBlock(file, blockId) {
    try {
      console.log("=== Opening file and navigating to block ===");
      console.log("File:", file.path);
      console.log("Block ID:", blockId);
      const leaf = this.app.workspace.getUnpinnedLeaf();
      await leaf.openFile(file);
      await new Promise((resolve) => setTimeout(resolve, 100));
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (activeView && activeView.editor) {
        const editor = activeView.editor;
        const content = editor.getValue();
        const lines = content.split("\n");
        let targetLine = -1;
        for (let i = 0; i < lines.length; i++) {
          if (lines[i].includes(`^${blockId}`)) {
            targetLine = i;
            break;
          }
        }
        if (targetLine >= 0) {
          const targetPos = { line: targetLine, ch: 0 };
          editor.setCursor(targetPos);
          editor.scrollIntoView({ from: targetPos, to: targetPos }, true);
          const lineText = lines[targetLine];
          const lineEnd = { line: targetLine, ch: lineText.length };
          editor.setSelection(targetPos, lineEnd);
          setTimeout(() => {
            try {
              const cursor = editor.getCursor();
              editor.setCursor(cursor);
            } catch (e) {
            }
          }, 3e3);
          new import_obsidian.Notice(`\u5DF2\u8DF3\u8F6C\u5230\u5757\u5F15\u7528: ${file.basename}`);
          console.log("Successfully navigated to block reference");
        } else {
          new import_obsidian.Notice(`\u672A\u627E\u5230\u5757\u5F15\u7528: ^${blockId}`);
          console.log("Block reference not found:", blockId);
        }
      } else {
        new import_obsidian.Notice("\u65E0\u6CD5\u83B7\u53D6\u7F16\u8F91\u5668\u89C6\u56FE");
      }
    } catch (error) {
      console.error("Failed to open file and navigate to block:", error);
      new import_obsidian.Notice("\u8DF3\u8F6C\u5230\u5757\u5F15\u7528\u5931\u8D25");
    }
  }
  // 保存Canvas数据
  async saveCanvasData() {
    if (!this.canvasData)
      return;
    if (this.linkedCanvasFile) {
      await this.saveCanvasDataToLinkedFile();
      return;
    }
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile || activeFile.extension !== "canvas") {
      throw new Error("\u6CA1\u6709\u6D3B\u52A8\u7684Canvas\u6587\u4EF6\u6216\u5173\u8054\u6587\u4EF6");
    }
    try {
      const canvasContent = JSON.stringify(this.canvasData, null, 2);
      await this.app.vault.modify(activeFile, canvasContent);
      console.log("Canvas data saved to active file successfully");
    } catch (error) {
      console.error("Failed to save canvas data:", error);
      throw error;
    }
  }
  // 滚动到新创建的卡片
  scrollToNewCard(nodeId) {
    this.safeSetTimeout(() => {
      const cardElement = this.gridContainer?.querySelector(`[data-node-id="${nodeId}"]`);
      if (cardElement) {
        cardElement.scrollIntoView({
          behavior: "smooth",
          block: "center"
        });
        cardElement.classList.add("newly-created");
        this.safeSetTimeout(() => {
          if (cardElement.classList.contains("newly-created")) {
            cardElement.classList.remove("newly-created");
          }
        }, 2e3);
      }
    }, 100);
  }
  // ==================== 关联标签页功能实现 ====================
  // 设置关联Canvas文件
  async setLinkedCanvas(canvasFile) {
    try {
      console.log("Setting linked canvas file:", canvasFile.path);
      this.linkedCanvasFile = canvasFile;
      this.linkedTabManager.linkCanvasFile(canvasFile, this);
      this.showLoadingState();
      await this.loadCanvasDataFromFile(canvasFile);
      this.initializeSearchAndSort();
      this.updateLinkedCanvasDisplay(canvasFile);
      this.updateActionButtonsVisibility();
      this.renderGrid();
      new import_obsidian.Notice(`\u5DF2\u5173\u8054Canvas\u6587\u4EF6: ${canvasFile.basename}`, 3e3);
      console.log("Canvas file linked and data loaded:", canvasFile.path);
    } catch (error) {
      console.error("Failed to link canvas file:", error);
      new import_obsidian.Notice("\u5173\u8054Canvas\u6587\u4EF6\u5931\u8D25");
      this.showErrorState(error instanceof Error ? error.message : "\u672A\u77E5\u9519\u8BEF");
    }
  }
  // 获取关联的Canvas文件
  getLinkedCanvas() {
    return this.linkedCanvasFile;
  }
  // 解除关联
  unlinkCanvas() {
    if (this.linkedCanvasFile) {
      const fileName = this.linkedCanvasFile.basename;
      this.linkedCanvasFile = null;
      this.linkedTabManager.unlinkCanvas();
      this.canvasData = null;
      this.renderGrid();
      this.updateLinkedCanvasDisplay(null);
      this.updateActionButtonsVisibility();
      new import_obsidian.Notice(`\u5DF2\u89E3\u9664\u4E0E ${fileName} \u7684\u5173\u8054`, 3e3);
      console.log("Canvas link removed");
    }
  }
  // 从指定文件加载Canvas数据
  async loadCanvasDataFromFile(file) {
    if (!file) {
      throw new Error("\u6587\u4EF6\u53C2\u6570\u65E0\u6548");
    }
    const fileExists = this.app.vault.getAbstractFileByPath(file.path);
    if (!fileExists) {
      throw new Error(`\u6587\u4EF6\u4E0D\u5B58\u5728: ${file.path}`);
    }
    try {
      console.log("Loading canvas data from file:", file.path);
      const content = await this.app.vault.read(file);
      if (!content || content.trim() === "") {
        console.log("Canvas file is empty, creating empty data structure");
        this.canvasData = { nodes: [], edges: [] };
        this.clearRenderCache();
        this.renderGrid();
        return;
      }
      let parsedData;
      try {
        parsedData = JSON.parse(content);
      } catch (parseError) {
        throw new Error(`JSON\u683C\u5F0F\u65E0\u6548: ${parseError instanceof Error ? parseError.message : "\u89E3\u6790\u9519\u8BEF"}`);
      }
      if (!parsedData || typeof parsedData !== "object") {
        throw new Error("Canvas\u6570\u636E\u683C\u5F0F\u65E0\u6548");
      }
      if (!Array.isArray(parsedData.nodes)) {
        throw new Error("Canvas\u6587\u4EF6\u7F3A\u5C11\u6709\u6548\u7684\u8282\u70B9\u6570\u636E");
      }
      if (!Array.isArray(parsedData.edges)) {
        parsedData.edges = [];
      }
      this.canvasData = parsedData;
      this.clearRenderCache();
      this.filteredNodes = [...parsedData.nodes];
      this.searchQuery = "";
      if (this.searchInputEl) {
        this.searchInputEl.value = "";
      }
      this.activeColorFilter = null;
      console.log("Canvas\u6570\u636E\u52A0\u8F7D\u6210\u529F\uFF0C\u8282\u70B9\u6570\u91CF:", parsedData.nodes.length);
      parsedData.nodes.forEach((node) => {
        if (node.color) {
          console.log("\u8282\u70B9\u989C\u8272\u503C:", node.id, "color:", node.color, "type:", typeof node.color);
        }
      });
      this.renderGrid();
      console.log("Canvas data loaded and rendered successfully from file:", file.path);
    } catch (error) {
      console.error("Failed to load canvas data from file:", error);
      const errorMessage = error instanceof Error ? error.message : "\u672A\u77E5\u9519\u8BEF";
      throw new Error(`\u52A0\u8F7DCanvas\u6587\u4EF6\u5931\u8D25: ${errorMessage}`);
    }
  }
  // 保存到关联的Canvas文件
  async saveCanvasDataToLinkedFile() {
    if (!this.canvasData) {
      throw new Error("\u6CA1\u6709Canvas\u6570\u636E\u53EF\u4FDD\u5B58");
    }
    if (!this.linkedCanvasFile) {
      throw new Error("\u6CA1\u6709\u5173\u8054\u7684Canvas\u6587\u4EF6");
    }
    const fileExists = this.app.vault.getAbstractFileByPath(this.linkedCanvasFile.path);
    if (!fileExists) {
      throw new Error(`\u5173\u8054\u7684Canvas\u6587\u4EF6\u4E0D\u5B58\u5728: ${this.linkedCanvasFile.path}`);
    }
    try {
      if (!Array.isArray(this.canvasData.nodes)) {
        throw new Error("Canvas\u8282\u70B9\u6570\u636E\u65E0\u6548");
      }
      if (!Array.isArray(this.canvasData.edges)) {
        this.canvasData.edges = [];
      }
      console.log("Saving canvas data to linked file:", this.linkedCanvasFile.path);
      const backupData = JSON.parse(JSON.stringify(this.canvasData));
      const canvasContent = JSON.stringify(this.canvasData, null, 2);
      try {
        JSON.parse(canvasContent);
      } catch (jsonError) {
        throw new Error("\u751F\u6210\u7684JSON\u683C\u5F0F\u65E0\u6548");
      }
      await this.app.vault.modify(this.linkedCanvasFile, canvasContent);
      console.log("Canvas data saved successfully to linked file:", this.linkedCanvasFile.path);
    } catch (error) {
      console.error("Failed to save to linked canvas file:", error);
      const errorMessage = error instanceof Error ? error.message : "\u672A\u77E5\u9519\u8BEF";
      throw new Error(`\u4FDD\u5B58Canvas\u6587\u4EF6\u5931\u8D25: ${errorMessage}`);
    }
  }
  // 显示Canvas文件选择对话框
  showCanvasSelectionDialog() {
    const modal = new CanvasSelectionModal(
      this.app,
      this,
      (file) => {
        this.setLinkedCanvas(file);
      }
    );
    modal.open();
  }
  // 更新关联Canvas显示
  updateLinkedCanvasDisplay(file) {
    if (!this.linkedIndicatorEl)
      return;
    if (file) {
      this.linkedIndicatorEl.textContent = file.basename;
      this.linkedIndicatorEl.removeClass("not-linked");
      this.linkedIndicatorEl.title = `\u5173\u8054\u6587\u4EF6: ${file.path}`;
    } else {
      this.linkedIndicatorEl.textContent = "\u672A\u5173\u8054";
      this.linkedIndicatorEl.addClass("not-linked");
      this.linkedIndicatorEl.title = "\u70B9\u51FB\u5173\u8054Canvas\u6587\u4EF6";
    }
    const mainBtn = this.containerEl.querySelector(".canvas-grid-main-btn");
    if (mainBtn) {
      if (file) {
        mainBtn.title = `\u7F51\u683C\u89C6\u56FE\u83DC\u5355 - \u5DF2\u5173\u8054: ${file.basename}`;
      } else {
        mainBtn.title = "\u7F51\u683C\u89C6\u56FE\u83DC\u5355 - \u672A\u5173\u8054Canvas\u6587\u4EF6";
      }
    }
  }
  // 更新操作按钮可见性
  updateActionButtonsVisibility() {
    const linkBtn = this.containerEl.querySelector(".canvas-grid-action-btn:not(.canvas-grid-unlink-btn)");
    const unlinkBtn = this.containerEl.querySelector(".canvas-grid-unlink-btn");
    if (linkBtn && unlinkBtn) {
      if (this.linkedCanvasFile) {
        linkBtn.style.display = "none";
        unlinkBtn.style.display = "flex";
      } else {
        linkBtn.style.display = "flex";
        unlinkBtn.style.display = "none";
      }
    }
  }
  // 刷新Canvas数据
  async refreshCanvasData() {
    try {
      if (this.linkedCanvasFile) {
        await this.loadCanvasDataFromFile(this.linkedCanvasFile);
        new import_obsidian.Notice("Canvas\u6570\u636E\u5DF2\u5237\u65B0", 2e3);
      } else {
        await this.loadActiveCanvas();
      }
      this.initializeSearchAndSort();
      console.log("\u2705 Canvas data refreshed and sort reapplied");
    } catch (error) {
      console.error("Failed to refresh canvas data:", error);
      new import_obsidian.Notice("\u5237\u65B0\u6570\u636E\u5931\u8D25", 2e3);
    }
  }
  // 自动关联当前Canvas文件
  async autoLinkCurrentCanvas() {
    try {
      const activeFile = this.app.workspace.getActiveFile();
      if (!activeFile || activeFile.extension !== "canvas") {
        new import_obsidian.Notice("\u8BF7\u5148\u6253\u5F00\u4E00\u4E2ACanvas\u6587\u4EF6");
        return;
      }
      await this.setLinkedCanvas(activeFile);
      new import_obsidian.Notice(`\u5DF2\u81EA\u52A8\u5173\u8054Canvas\u6587\u4EF6: ${activeFile.basename}`, 3e3);
      console.log("Auto-linked canvas file:", activeFile.path);
    } catch (error) {
      console.error("Failed to auto-link canvas file:", error);
      new import_obsidian.Notice("\u81EA\u52A8\u5173\u8054Canvas\u6587\u4EF6\u5931\u8D25");
    }
  }
  // ==================== 文件监听事件处理 ====================
  // 关联文件被修改
  onLinkedFileModified(file) {
    console.log("Linked canvas file modified:", file.path);
    if (this.fileWatcherDisabled) {
      console.log("File watcher disabled, skipping update");
      return;
    }
    if (this.updateTimeout) {
      this.safeClearTimeout(this.updateTimeout);
    }
    this.updateTimeout = this.safeSetTimeout(async () => {
      try {
        if (this.fileWatcherDisabled) {
          console.log("File watcher disabled during timeout, skipping update");
          return;
        }
        await this.loadCanvasDataFromFile(file);
        new import_obsidian.Notice("Canvas\u6570\u636E\u5DF2\u540C\u6B65\u66F4\u65B0", 2e3);
      } catch (error) {
        console.error("Failed to sync canvas data:", error);
        new import_obsidian.Notice("\u540C\u6B65Canvas\u6570\u636E\u5931\u8D25");
      }
    }, 500);
  }
  // 关联文件被删除
  onLinkedFileDeleted() {
    console.log("Linked canvas file deleted");
    this.linkedCanvasFile = null;
    this.canvasData = null;
    this.renderGrid();
    this.showMessage("\u5173\u8054\u7684Canvas\u6587\u4EF6\u5DF2\u88AB\u5220\u9664\uFF0C\u8BF7\u91CD\u65B0\u5173\u8054");
    this.updateLinkedCanvasDisplay(null);
    this.updateActionButtonsVisibility();
  }
  // 关联文件被重命名
  onLinkedFileRenamed(file) {
    console.log("Linked canvas file renamed:", file.path);
    this.linkedCanvasFile = file;
    this.updateLinkedCanvasDisplay(file);
    new import_obsidian.Notice(`\u5173\u8054\u6587\u4EF6\u5DF2\u91CD\u547D\u540D\u4E3A: ${file.basename}`, 3e3);
  }
  // 通知Canvas视图刷新
  notifyCanvasViewRefresh() {
    if (!this.linkedCanvasFile)
      return;
    const canvasLeaves = this.app.workspace.getLeavesOfType("canvas");
    const targetLeaf = canvasLeaves.find((leaf) => {
      const view = leaf.view;
      return view.file?.path === this.linkedCanvasFile?.path;
    });
    if (targetLeaf) {
      console.log("Notifying canvas view to refresh");
      const canvasView = targetLeaf.view;
      if (canvasView.requestSave) {
        canvasView.requestSave();
      }
      if (canvasView.requestParse) {
        canvasView.requestParse();
      }
      if (canvasView.load && this.linkedCanvasFile) {
        canvasView.load(this.linkedCanvasFile);
      }
    }
  }
  // ==================== 宽度控制功能 ====================
  // 初始化宽度控制
  initializeWidthControl() {
    const sidebarContainer = this.containerEl.closest(".workspace-leaf");
    if (!sidebarContainer)
      return;
    this.resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        this.handleWidthChange(entry.contentRect.width);
      }
    });
    this.resizeObserver.observe(sidebarContainer);
    const currentWidth = sidebarContainer.getBoundingClientRect().width;
    this.handleWidthChange(currentWidth);
  }
  // 处理宽度变化
  handleWidthChange(width) {
    const sidebarContainer = this.containerEl.closest(".workspace-leaf");
    if (!sidebarContainer)
      return;
    if (width < this.minWidth) {
      if (!this.isWidthLimited) {
        this.setCompactMode(sidebarContainer);
        this.isWidthLimited = true;
      }
    } else {
      if (this.isWidthLimited) {
        this.removeCompactMode(sidebarContainer);
        this.isWidthLimited = false;
      }
    }
  }
  // 设置紧凑模式（不强制固定宽度）
  setCompactMode(container) {
    container.classList.add("canvas-grid-compact-mode");
  }
  // 移除紧凑模式
  removeCompactMode(container) {
    container.classList.remove("canvas-grid-compact-mode");
  }
  // 移除了自动隐藏侧边栏的功能
  // 现在让用户自己决定是否需要隐藏侧边栏
  // 清理宽度控制
  cleanupWidthControl() {
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
      this.resizeObserver = null;
    }
    const sidebarContainer = this.containerEl.closest(".workspace-leaf");
    if (sidebarContainer) {
      this.removeCompactMode(sidebarContainer);
    }
    this.isWidthLimited = false;
  }
};
var CanvasGridPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.canvasViewButtons = /* @__PURE__ */ new Map();
  }
  async onload() {
    await this.loadSettings();
    i18n.setLanguage(this.settings.language);
    this.registerView(
      CANVAS_GRID_VIEW_TYPE,
      (leaf) => new CanvasGridView(leaf, this)
    );
    let ribbonIconEl;
    try {
      ribbonIconEl = this.addRibbonIcon("grid", "Canvas\u7F51\u683C\u89C6\u56FE", (evt) => {
        this.activateView();
      });
    } catch (error) {
      try {
        ribbonIconEl = this.addRibbonIcon("layout", "Canvas\u7F51\u683C\u89C6\u56FE", (evt) => {
          this.activateView();
        });
      } catch (error2) {
        try {
          ribbonIconEl = this.addRibbonIcon("table", "Canvas\u7F51\u683C\u89C6\u56FE", (evt) => {
            this.activateView();
          });
        } catch (error3) {
          ribbonIconEl = this.addRibbonIcon("", "Canvas\u7F51\u683C\u89C6\u56FE", (evt) => {
            this.activateView();
          });
          ribbonIconEl.innerHTML = `
						<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
							<rect x="3" y="3" width="7" height="7"/>
							<rect x="14" y="3" width="7" height="7"/>
							<rect x="3" y="14" width="7" height="7"/>
							<rect x="14" y="14" width="7" height="7"/>
						</svg>
					`;
        }
      }
    }
    this.addCommand({
      id: "open-canvas-grid-view",
      name: "\u6253\u5F00Canvas\u7F51\u683C\u89C6\u56FE",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "time-capsule-collect",
      name: "\u65F6\u95F4\u80F6\u56CA\u6536\u96C6\u5185\u5BB9",
      hotkeys: [{ modifiers: ["Ctrl", "Shift"], key: "c" }],
      callback: () => {
        this.collectToTimeCapsule();
      }
    });
    this.addCommand({
      id: "toggle-time-capsule",
      name: "\u5207\u6362\u65F6\u95F4\u80F6\u56CA\u72B6\u6001",
      hotkeys: [{ modifiers: ["Ctrl", "Shift"], key: "t" }],
      callback: () => {
        this.toggleTimeCapsule();
      }
    });
    this.addSettingTab(new CanvasGridSettingTab(this.app, this));
    this.registerEvent(
      this.app.workspace.on("layout-change", () => {
        this.addCanvasViewButtons();
      })
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.addCanvasViewButtons();
      })
    );
    this.addCanvasViewButtons();
    console.log("\u{1F3A8} Canvasgrid Transit Plugin loaded - \u70ED\u91CD\u8F7D\u6D4B\u8BD5\u6210\u529F!");
  }
  onunload() {
    this.removeAllCanvasViewButtons();
  }
  // 获取活动的网格视图
  getActiveGridView() {
    const leaves = this.app.workspace.getLeavesOfType(CANVAS_GRID_VIEW_TYPE);
    if (leaves.length > 0) {
      return leaves[0].view;
    }
    return null;
  }
  // 为所有Canvas视图添加切换按钮
  addCanvasViewButtons() {
    const leaves = this.app.workspace.getLeavesOfType("canvas");
    leaves.forEach((leaf) => {
      const canvasView = leaf.view;
      if (canvasView && canvasView.canvas && canvasView.containerEl) {
        this.addButtonToCanvasView(canvasView);
      }
    });
  }
  // 为单个Canvas视图添加按钮
  addButtonToCanvasView(canvasView) {
    const containerEl = canvasView.containerEl;
    if (this.canvasViewButtons.has(containerEl)) {
      return;
    }
    console.log("Adding button to Canvas view");
    console.log("Container element:", containerEl);
    this.analyzeCanvasDOM(containerEl);
    const menuContainer = this.findCanvasMenuContainer(containerEl);
    if (menuContainer) {
      console.log("Found Canvas menu container:", menuContainer);
      this.addButtonToCanvasMenu(menuContainer, containerEl);
    } else {
      console.log("Canvas menu container not found, using fallback");
      this.addButtonToCanvasViewFallback(canvasView);
    }
  }
  // 分析Canvas DOM结构
  analyzeCanvasDOM(containerEl) {
    console.log("=== Canvas DOM Structure Analysis ===");
    const toolbarSelectors = [
      ".canvas-controls",
      // Canvas控制区域
      ".canvas-toolbar",
      // Canvas工具栏
      ".canvas-menu",
      // Canvas菜单
      ".canvas-control-bar",
      // Canvas控制栏
      ".canvas-actions",
      // Canvas操作区域
      ".canvas-buttons",
      // Canvas按钮区域
      ".canvas-tools",
      // Canvas工具区域
      ".canvas-ui",
      // Canvas UI区域
      ".canvas-interface",
      // Canvas界面区域
      '[class*="canvas"][class*="control"]',
      // 包含canvas和control的类
      '[class*="canvas"][class*="toolbar"]',
      // 包含canvas和toolbar的类
      '[class*="canvas"][class*="menu"]'
      // 包含canvas和menu的类
    ];
    toolbarSelectors.forEach((selector) => {
      const elements = containerEl.querySelectorAll(selector);
      if (elements.length > 0) {
        console.log(`Found ${elements.length} elements with selector: ${selector}`);
        elements.forEach((el, index) => {
          console.log(`  [${index}]:`, el.className, el.getAttribute("aria-label"));
          const children = el.children;
          console.log(`    Children count: ${children.length}`);
          for (let i = 0; i < Math.min(children.length, 5); i++) {
            console.log(`    Child[${i}]:`, children[i].className, children[i].getAttribute("aria-label"));
          }
        });
      }
    });
    const iconElements = containerEl.querySelectorAll('.clickable-icon, [class*="icon"], [aria-label*="help"], [aria-label*="Help"], [aria-label*="\u5E2E\u52A9"]');
    console.log(`Found ${iconElements.length} icon elements:`);
    iconElements.forEach((el, index) => {
      console.log(`  Icon[${index}]:`, el.className, el.getAttribute("aria-label"), el.parentElement?.className);
    });
    const canvasSelectors = [
      ".canvas-wrapper",
      ".canvas-container",
      ".canvas-viewport"
    ];
    canvasSelectors.forEach((selector) => {
      const element = containerEl.querySelector(selector);
      if (element) {
        console.log(`Found Canvas element: ${selector}`, element);
      }
    });
  }
  // 查找Canvas菜单容器
  findCanvasMenuContainer(containerEl) {
    const toolbarSelectors = [
      ".canvas-controls",
      // Canvas控制区域
      ".canvas-toolbar",
      // Canvas工具栏
      ".canvas-menu",
      // Canvas菜单
      ".canvas-control-bar",
      // Canvas控制栏
      ".canvas-actions",
      // Canvas操作区域
      '[class*="canvas"][class*="control"]',
      // 包含canvas和control的类
      '[class*="canvas"][class*="toolbar"]'
      // 包含canvas和toolbar的类
    ];
    for (const selector of toolbarSelectors) {
      const toolbar = containerEl.querySelector(selector);
      if (toolbar) {
        console.log(`Found Canvas toolbar with selector: ${selector}`);
        return toolbar;
      }
    }
    const helpButtons = containerEl.querySelectorAll('[aria-label*="help"], [aria-label*="Help"], [aria-label*="\u5E2E\u52A9"], [title*="help"], [title*="Help"], [title*="\u5E2E\u52A9"]');
    for (let i = 0; i < helpButtons.length; i++) {
      const helpButton = helpButtons[i];
      const parent = helpButton.parentElement;
      if (parent && this.isValidToolbarContainer(parent)) {
        console.log("Found toolbar container via help button:", parent);
        return parent;
      }
    }
    const fallbackSelectors = [
      ".view-actions",
      ".view-header-nav-buttons",
      ".workspace-leaf-header .view-actions",
      ".view-header"
    ];
    for (const selector of fallbackSelectors) {
      const container = containerEl.querySelector(selector);
      if (container) {
        console.log(`Found fallback menu container with selector: ${selector}`);
        return container;
      }
    }
    return null;
  }
  // 验证是否为有效的工具栏容器
  isValidToolbarContainer(element) {
    const icons = element.querySelectorAll('.clickable-icon, [class*="icon"]');
    return icons.length >= 2;
  }
  // 将按钮添加到Canvas原生菜单中
  addButtonToCanvasMenu(menuContainer, containerEl) {
    const helpButton = this.findHelpButton(menuContainer);
    const gridButton = document.createElement("div");
    gridButton.className = "clickable-icon";
    gridButton.setAttribute("aria-label", "\u5207\u6362\u5230\u7F51\u683C\u89C6\u56FE");
    gridButton.setAttribute("data-tooltip-position", "left");
    gridButton.style.cssText = `
			border: 1px solid var(--background-modifier-border) !important;
			background: var(--background-secondary) !important;
			border-radius: 4px !important;
			box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1) !important;
		`;
    gridButton.innerHTML = `
			<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<rect x="3" y="3" width="7" height="7"/>
				<rect x="14" y="3" width="7" height="7"/>
				<rect x="3" y="14" width="7" height="7"/>
				<rect x="14" y="14" width="7" height="7"/>
			</svg>
		`;
    gridButton.onclick = () => {
      console.log("Grid button clicked from Canvas toolbar");
      this.activateViewWithAutoLink(containerEl);
    };
    if (helpButton && helpButton.parentElement === menuContainer) {
      const nextSibling = helpButton.nextSibling;
      if (nextSibling) {
        menuContainer.insertBefore(gridButton, nextSibling);
      } else {
        menuContainer.appendChild(gridButton);
      }
      console.log("Button inserted after help button");
    } else {
      menuContainer.appendChild(gridButton);
      console.log("Button appended to toolbar end");
    }
    console.log("Button added to Canvas toolbar successfully");
    this.canvasViewButtons.set(containerEl, gridButton);
  }
  // 查找帮助按钮
  findHelpButton(container) {
    const helpSelectors = [
      '[aria-label*="help"]',
      '[aria-label*="Help"]',
      '[aria-label*="\u5E2E\u52A9"]',
      '[title*="help"]',
      '[title*="Help"]',
      '[title*="\u5E2E\u52A9"]'
    ];
    for (const selector of helpSelectors) {
      const helpButton = container.querySelector(selector);
      if (helpButton) {
        console.log("Found help button:", helpButton);
        return helpButton;
      }
    }
    return null;
  }
  // 判断是否为垂直工具栏
  isVerticalToolbar(container) {
    const rect = container.getBoundingClientRect();
    return rect.height > rect.width;
  }
  // 回退方案：添加到右上角独立位置
  addButtonToCanvasViewFallback(canvasView) {
    const containerEl = canvasView.containerEl;
    const canvasContainer = containerEl.querySelector(".canvas-wrapper") || containerEl.querySelector(".canvas-container") || containerEl.querySelector(".view-content") || containerEl;
    if (!canvasContainer) {
      console.log("Canvas container not found for fallback");
      return;
    }
    const buttonContainer = document.createElement("div");
    buttonContainer.style.cssText = `
			position: absolute;
			top: 10px;
			right: 10px;
			z-index: 1000;
		`;
    const gridButton = document.createElement("div");
    gridButton.className = "clickable-icon";
    gridButton.setAttribute("aria-label", "\u5207\u6362\u5230\u7F51\u683C\u89C6\u56FE");
    gridButton.setAttribute("data-tooltip-position", "left");
    gridButton.style.cssText = `
			background: var(--background-secondary) !important;
			border: 1px solid var(--background-modifier-border) !important;
			border-radius: 4px !important;
			box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1) !important;
		`;
    gridButton.innerHTML = `
			<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
				<rect x="3" y="3" width="7" height="7"/>
				<rect x="14" y="3" width="7" height="7"/>
				<rect x="3" y="14" width="7" height="7"/>
				<rect x="14" y="14" width="7" height="7"/>
			</svg>
		`;
    gridButton.onclick = () => {
      console.log("Grid button clicked from fallback position");
      this.activateViewWithAutoLink(containerEl);
    };
    buttonContainer.appendChild(gridButton);
    canvasContainer.appendChild(buttonContainer);
    console.log("Fallback button added successfully");
    this.canvasViewButtons.set(containerEl, buttonContainer);
  }
  // 移除所有Canvas视图按钮
  removeAllCanvasViewButtons() {
    this.canvasViewButtons.forEach((button, container) => {
      if (button.parentNode) {
        button.parentNode.removeChild(button);
      }
    });
    this.canvasViewButtons.clear();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // ==================== 时间胶囊功能方法 ====================
  // 收集内容到时间胶囊
  collectToTimeCapsule() {
    const gridView = this.getActiveGridView();
    if (!gridView) {
      new import_obsidian.Notice("\u8BF7\u5148\u6253\u5F00Canvas\u7F51\u683C\u89C6\u56FE");
      return;
    }
    if (!gridView.isTimeCapsuleActive()) {
      new import_obsidian.Notice("\u65F6\u95F4\u80F6\u56CA\u672A\u6FC0\u6D3B\uFF0C\u8BF7\u5148\u542F\u52A8\u65F6\u95F4\u80F6\u56CA");
      return;
    }
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (activeView) {
      const editor = activeView.editor;
      const selectedText = editor.getSelection();
      if (selectedText) {
        gridView.collectToTimeCapsule(selectedText, {
          sourceFile: activeView.file,
          sourcePath: activeView.file?.path || "",
          sourcePosition: {
            line: editor.getCursor("from").line,
            ch: editor.getCursor("from").ch
          }
        });
        new import_obsidian.Notice("\u5185\u5BB9\u5DF2\u6536\u96C6\u5230\u65F6\u95F4\u80F6\u56CA");
      } else {
        new import_obsidian.Notice("\u8BF7\u5148\u9009\u62E9\u8981\u6536\u96C6\u7684\u5185\u5BB9");
      }
    } else {
      navigator.clipboard.readText().then((text) => {
        if (text && text.trim()) {
          gridView.collectToTimeCapsule(text.trim(), {
            sourceFile: null,
            sourcePath: "\u526A\u8D34\u677F",
            sourcePosition: null
          });
          new import_obsidian.Notice("\u526A\u8D34\u677F\u5185\u5BB9\u5DF2\u6536\u96C6\u5230\u65F6\u95F4\u80F6\u56CA");
        } else {
          new import_obsidian.Notice("\u526A\u8D34\u677F\u4E3A\u7A7A\u6216\u65E0\u53EF\u6536\u96C6\u5185\u5BB9");
        }
      }).catch(() => {
        new import_obsidian.Notice("\u65E0\u6CD5\u8BBF\u95EE\u526A\u8D34\u677F");
      });
    }
  }
  // 切换时间胶囊状态
  toggleTimeCapsule() {
    const gridView = this.getActiveGridView();
    if (!gridView) {
      new import_obsidian.Notice("\u8BF7\u5148\u6253\u5F00Canvas\u7F51\u683C\u89C6\u56FE");
      return;
    }
    gridView.toggleTimeCapsule();
  }
  async activateView() {
    const { workspace } = this.app;
    const activeFile = workspace.getActiveFile();
    let leaf = null;
    const leaves = workspace.getLeavesOfType(CANVAS_GRID_VIEW_TYPE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({ type: CANVAS_GRID_VIEW_TYPE, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
      if (activeFile && activeFile.extension === "canvas") {
        const gridView = leaf.view;
        if (gridView && gridView.setLinkedCanvas) {
          try {
            await gridView.setLinkedCanvas(activeFile);
            console.log("Auto-linked canvas file:", activeFile.path);
          } catch (error) {
            console.error("Failed to auto-link canvas file:", error);
          }
        }
      }
    }
  }
  // 激活视图并自动关联Canvas文件
  async activateViewWithAutoLink(canvasContainer) {
    const { workspace } = this.app;
    let canvasFile = null;
    const activeFile = workspace.getActiveFile();
    if (activeFile && activeFile.extension === "canvas") {
      canvasFile = activeFile;
    }
    if (!canvasFile) {
      const canvasLeaves = workspace.getLeavesOfType("canvas");
      for (const leaf2 of canvasLeaves) {
        const canvasView = leaf2.view;
        if (canvasView && canvasView.file) {
          canvasFile = canvasView.file;
          break;
        }
      }
    }
    let leaf = null;
    const leaves = workspace.getLeavesOfType(CANVAS_GRID_VIEW_TYPE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({ type: CANVAS_GRID_VIEW_TYPE, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
      if (canvasFile) {
        const gridView = leaf.view;
        if (gridView && gridView.setLinkedCanvas) {
          try {
            await gridView.setLinkedCanvas(canvasFile);
            console.log("Auto-linked canvas file from button:", canvasFile.path);
          } catch (error) {
            console.error("Failed to auto-link canvas file from button:", error);
          }
        }
      }
    }
  }
};
var CanvasGridSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    i18n.setLanguage(this.plugin.settings.language);
    containerEl.createEl("h3", { text: i18n.t("gridLayoutSettings") });
    containerEl.createEl("p", {
      text: this.plugin.settings.language === "zh" ? "\u7F51\u683C\u5E03\u5C40\u4F7F\u7528\u56FA\u5B9A\u7684\u5361\u7247\u5C3A\u5BF8\u548C\u95F4\u8DDD\uFF0C\u81EA\u52A8\u9002\u5E94\u5C4F\u5E55\u5BBD\u5EA6\u3002" : "Grid layout uses fixed card dimensions and spacing, automatically adapting to screen width.",
      cls: "setting-item-description"
    });
    new import_obsidian.Setting(containerEl).setName(i18n.t("enableAutoLayout")).setDesc(this.plugin.settings.language === "zh" ? "\u81EA\u52A8\u8C03\u6574\u5361\u7247\u5E03\u5C40\u4EE5\u9002\u5E94\u5C4F\u5E55\uFF08\u63A8\u8350\u5F00\u542F\uFF09" : "Automatically adjust card layout to fit screen (recommended)").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableAutoLayout).onChange(async (value) => {
      this.plugin.settings.enableAutoLayout = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "\u{1F310} " + i18n.t("interfaceLanguage") });
    new import_obsidian.Setting(containerEl).setName(i18n.t("interfaceLanguage")).setDesc(this.plugin.settings.language === "zh" ? "\u9009\u62E9\u63D2\u4EF6\u754C\u9762\u663E\u793A\u8BED\u8A00" : "Select plugin interface display language").addDropdown((dropdown) => dropdown.addOption("zh", "\u4E2D\u6587 (\u7B80\u4F53)").addOption("en", "English").setValue(this.plugin.settings.language).onChange(async (value) => {
      this.plugin.settings.language = value;
      await this.plugin.saveSettings();
      this.display();
      this.updateAllGridViews();
    }));
    this.createUnifiedColorSection(containerEl);
    this.createAboutSection(containerEl);
  }
  // 创建统一的颜色管理设置部分
  createUnifiedColorSection(containerEl) {
    containerEl.createEl("h3", {
      text: "\u{1F3A8} " + (this.plugin.settings.language === "zh" ? "\u989C\u8272\u7BA1\u7406" : "Color Management")
    });
    const descContainer = containerEl.createDiv("unified-color-desc");
    descContainer.style.cssText = `
			background: var(--background-secondary);
			border-radius: 6px;
			padding: 12px;
			margin-bottom: 20px;
			border-left: 3px solid var(--interactive-accent);
		`;
    const descText = descContainer.createEl("p", {
      text: this.plugin.settings.language === "zh" ? "\u9009\u62E9\u8981\u5728\u989C\u8272\u7B5B\u9009\u5668\u4E2D\u663E\u793A\u7684\u989C\u8272\uFF08\u6700\u591A5\u4E2A\uFF09\u3002\u8FD9\u4E9B\u989C\u8272\u5C06\u663E\u793A\u4E3A\u641C\u7D22\u6846\u4E0B\u65B9\u7684\u7B5B\u9009\u5706\u70B9\u3002\u5728\u4E0B\u65B9\u9884\u89C8\u533A\u57DF\u53EF\u4EE5\u62D6\u62FD\u8C03\u6574\u989C\u8272\u663E\u793A\u987A\u5E8F\u3002" : "Select colors to display in the color filter (up to 5). These colors will appear as filter dots below the search box. Drag colors in the preview area to reorder them.",
      cls: "setting-item-description"
    });
    descText.style.cssText = `
			margin: 0;
			color: var(--text-muted);
			font-size: 13px;
			line-height: 1.4;
		`;
    this.createSelectableColorGrid(containerEl);
    this.createSelectedColorsPreview(containerEl);
  }
  // 创建可选颜色网格
  createSelectableColorGrid(containerEl) {
    const gridContainer = containerEl.createDiv("selectable-color-grid-container");
    gridContainer.style.cssText = `
			background: var(--background-primary);
			border: 1px solid var(--background-modifier-border);
			border-radius: 8px;
			padding: 20px;
			margin-bottom: 20px;
		`;
    const gridTitle = gridContainer.createEl("h4", {
      text: this.plugin.settings.language === "zh" ? "\u53EF\u9009\u989C\u8272" : "Available Colors",
      cls: "color-grid-title"
    });
    gridTitle.style.cssText = `
			margin: 0 0 16px 0;
			color: var(--text-normal);
			font-size: 14px;
			font-weight: 600;
		`;
    const colorGrid = gridContainer.createDiv("selectable-color-grid");
    colorGrid.style.cssText = `
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
			gap: 16px;
		`;
    const availableColors = [
      { value: "1", color: "#ff6b6b" },
      { value: "2", color: "#ffa726" },
      { value: "3", color: "#ffeb3b" },
      { value: "4", color: "#66bb6a" },
      { value: "5", color: "#26c6da" },
      { value: "6", color: "#42a5f5" },
      { value: "7", color: "#ab47bc" }
    ];
    availableColors.forEach((colorOption) => {
      this.createSelectableColorCard(colorGrid, colorOption);
    });
  }
  // 创建可选择的颜色卡片
  createSelectableColorCard(container, colorOption) {
    const isSelected = this.plugin.settings.colorFilterColors.includes(colorOption.value);
    const category = this.plugin.settings.colorCategories.find((cat) => cat.color === colorOption.value);
    const colorCard = container.createDiv("selectable-color-card");
    colorCard.style.cssText = `
			display: flex;
			flex-direction: column;
			align-items: center;
			padding: 20px 16px;
			border: 2px solid ${isSelected ? colorOption.color : "var(--background-modifier-border)"};
			border-radius: 8px;
			cursor: pointer;
			transition: all 0.2s ease;
			background: var(--background-secondary);
			position: relative;
			min-height: 140px;
		`;
    if (isSelected) {
      const checkmark = colorCard.createDiv("color-card-checkmark");
      checkmark.innerHTML = "\u2713";
      checkmark.style.cssText = `
				position: absolute;
				top: 8px;
				right: 8px;
				width: 20px;
				height: 20px;
				background: ${colorOption.color};
				color: white;
				border-radius: 50%;
				display: flex;
				align-items: center;
				justify-content: center;
				font-size: 12px;
				font-weight: bold;
				box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
			`;
    }
    const colorDot = colorCard.createDiv("color-dot");
    colorDot.style.cssText = `
			width: 40px;
			height: 40px;
			border-radius: 50%;
			background: ${colorOption.color};
			margin-bottom: 16px;
			box-shadow: 0 2px 8px ${colorOption.color}40;
			border: 3px solid white;
		`;
    const nameContainer = colorCard.createDiv("color-name-container");
    nameContainer.style.cssText = `
			width: 100%;
			text-align: center;
			margin-bottom: 8px;
		`;
    const nameDisplay = nameContainer.createEl("div", {
      text: category ? category.name : this.getDefaultColorName(colorOption.value),
      cls: "color-name-display"
    });
    nameDisplay.style.cssText = `
			font-size: 14px;
			font-weight: 600;
			color: var(--text-normal);
			cursor: text;
			padding: 4px 8px;
			border-radius: 4px;
			transition: background 0.2s ease;
		`;
    const descContainer = colorCard.createDiv("color-desc-container");
    descContainer.style.cssText = `
			width: 100%;
			text-align: center;
		`;
    const descDisplay = descContainer.createEl("div", {
      text: category ? category.description : "",
      cls: "color-desc-display"
    });
    descDisplay.style.cssText = `
			font-size: 11px;
			color: var(--text-muted);
			cursor: text;
			padding: 4px 8px;
			border-radius: 4px;
			transition: background 0.2s ease;
			min-height: 16px;
			line-height: 1.3;
		`;
    this.addInlineEditingToColorCard(nameDisplay, descDisplay, colorOption.value);
    colorCard.addEventListener("click", (e) => {
      if (e.target.classList.contains("color-name-display") || e.target.classList.contains("color-desc-display")) {
        return;
      }
      this.toggleColorSelection(colorOption.value);
    });
    colorCard.addEventListener("mouseenter", () => {
      if (!isSelected) {
        colorCard.style.borderColor = colorOption.color;
        colorCard.style.transform = "translateY(-2px)";
      }
    });
    colorCard.addEventListener("mouseleave", () => {
      if (!isSelected) {
        colorCard.style.borderColor = "var(--background-modifier-border)";
        colorCard.style.transform = "translateY(0)";
      }
    });
  }
  // 添加内联编辑功能到颜色卡片
  addInlineEditingToColorCard(nameDisplay, descDisplay, colorValue) {
    nameDisplay.addEventListener("dblclick", () => {
      this.startInlineEdit(nameDisplay, colorValue, "name");
    });
    descDisplay.addEventListener("dblclick", () => {
      this.startInlineEdit(descDisplay, colorValue, "description");
    });
    nameDisplay.addEventListener("mouseenter", () => {
      nameDisplay.style.background = "var(--background-modifier-hover)";
      nameDisplay.title = this.plugin.settings.language === "zh" ? "\u53CC\u51FB\u7F16\u8F91\u540D\u79F0" : "Double-click to edit name";
    });
    nameDisplay.addEventListener("mouseleave", () => {
      nameDisplay.style.background = "transparent";
    });
    descDisplay.addEventListener("mouseenter", () => {
      descDisplay.style.background = "var(--background-modifier-hover)";
      descDisplay.title = this.plugin.settings.language === "zh" ? "\u53CC\u51FB\u7F16\u8F91\u63CF\u8FF0" : "Double-click to edit description";
    });
    descDisplay.addEventListener("mouseleave", () => {
      descDisplay.style.background = "transparent";
    });
  }
  // 开始内联编辑
  startInlineEdit(element, colorValue, field) {
    const currentText = element.textContent || "";
    const input = document.createElement(field === "description" ? "textarea" : "input");
    input.value = currentText;
    input.style.cssText = `
			width: 100%;
			background: var(--background-primary);
			border: 1px solid var(--interactive-accent);
			border-radius: 4px;
			padding: 4px 8px;
			font-size: ${field === "name" ? "14px" : "11px"};
			font-weight: ${field === "name" ? "600" : "normal"};
			color: var(--text-normal);
			text-align: center;
			resize: none;
			${field === "description" ? "min-height: 32px; line-height: 1.3;" : ""}
		`;
    element.style.display = "none";
    element.parentElement?.insertBefore(input, element);
    input.focus();
    input.select();
    const saveEdit = async () => {
      const newValue = input.value.trim();
      element.textContent = newValue;
      element.style.display = "block";
      input.remove();
      await this.updateColorCategory(colorValue, field, newValue);
    };
    const cancelEdit = () => {
      element.style.display = "block";
      input.remove();
    };
    input.addEventListener("blur", saveEdit);
    input.addEventListener("keydown", (e) => {
      const keyEvent = e;
      if (keyEvent.key === "Enter" && !keyEvent.shiftKey) {
        e.preventDefault();
        saveEdit();
      } else if (keyEvent.key === "Escape") {
        e.preventDefault();
        cancelEdit();
      }
    });
  }
  // 更新颜色分类
  async updateColorCategory(colorValue, field, newValue) {
    let category = this.plugin.settings.colorCategories.find((cat) => cat.color === colorValue);
    if (!category) {
      const defaultName = this.getDefaultColorName(colorValue);
      category = {
        id: `color-${colorValue}`,
        name: field === "name" ? newValue : defaultName,
        description: field === "description" ? newValue : "",
        color: colorValue
      };
      this.plugin.settings.colorCategories.push(category);
    } else {
      if (field === "name") {
        category.name = newValue;
      } else {
        category.description = newValue;
      }
    }
    await this.plugin.saveSettings();
    this.updateAllGridViews();
  }
  // 切换颜色选择状态
  async toggleColorSelection(colorValue) {
    const currentColors = [...this.plugin.settings.colorFilterColors];
    const isCurrentlySelected = currentColors.includes(colorValue);
    if (isCurrentlySelected) {
      const index = currentColors.indexOf(colorValue);
      if (index > -1) {
        currentColors.splice(index, 1);
      }
    } else {
      if (currentColors.length < 5) {
        currentColors.push(colorValue);
      } else {
        new import_obsidian.Notice(this.plugin.settings.language === "zh" ? "\u6700\u591A\u53EA\u80FD\u9009\u62E95\u4E2A\u989C\u8272" : "Maximum 5 colors can be selected");
        return;
      }
    }
    this.plugin.settings.colorFilterColors = currentColors;
    await this.plugin.saveSettings();
    this.updateAllGridViews();
    this.display();
  }
  // 创建已选择颜色预览
  createSelectedColorsPreview(containerEl) {
    const previewContainer = containerEl.createDiv("selected-colors-preview");
    previewContainer.style.cssText = `
			background: var(--background-secondary);
			border-radius: 6px;
			padding: 16px;
			margin-bottom: 20px;
		`;
    const previewHeader = previewContainer.createDiv("preview-header");
    previewHeader.style.cssText = `
			display: flex;
			align-items: center;
			justify-content: space-between;
			margin-bottom: 12px;
		`;
    const statusText = previewHeader.createEl("span", {
      text: this.plugin.settings.language === "zh" ? `\u5DF2\u9009\u62E9 ${this.plugin.settings.colorFilterColors.length}/5 \u4E2A\u989C\u8272` : `Selected ${this.plugin.settings.colorFilterColors.length}/5 colors`,
      cls: "selected-colors-status"
    });
    statusText.style.cssText = `
			color: var(--text-muted);
			font-size: 13px;
		`;
    const sortHint = previewHeader.createEl("span", {
      text: this.plugin.settings.language === "zh" ? "\u62D6\u62FD\u8C03\u6574\u987A\u5E8F" : "Drag to reorder",
      cls: "sort-hint"
    });
    sortHint.style.cssText = `
			color: var(--text-muted);
			font-size: 11px;
			font-style: italic;
		`;
    const sortableContainer = previewContainer.createDiv("sortable-preview-container");
    sortableContainer.style.cssText = `
			display: flex;
			gap: 8px;
			flex-wrap: wrap;
			min-height: 40px;
			padding: 8px;
			border: 1px dashed var(--background-modifier-border);
			border-radius: 4px;
			background: var(--background-primary);
		`;
    this.renderSortableColorDots(sortableContainer);
  }
  // 创建颜色选择网格
  createColorSelectionGrid(container) {
    const colorGridContainer = container.createDiv("color-filter-grid-container");
    colorGridContainer.style.cssText = `
			background: var(--background-primary);
			border: 1px solid var(--background-modifier-border);
			border-radius: 8px;
			padding: 20px;
			margin-bottom: 16px;
		`;
    const gridTitle = colorGridContainer.createEl("h4", {
      text: this.plugin.settings.language === "zh" ? "\u53EF\u9009\u989C\u8272" : "Available Colors",
      cls: "color-grid-title"
    });
    gridTitle.style.cssText = `
			margin: 0 0 16px 0;
			color: var(--text-normal);
			font-size: 14px;
			font-weight: 600;
		`;
    const colorGrid = colorGridContainer.createDiv("color-filter-grid");
    colorGrid.style.cssText = `
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
			gap: 12px;
		`;
    const availableColors = [
      { value: "1", color: "#ff6b6b", emoji: "\u{1F534}" },
      { value: "2", color: "#ffa726", emoji: "\u{1F7E0}" },
      { value: "3", color: "#ffeb3b", emoji: "\u{1F7E1}" },
      { value: "4", color: "#66bb6a", emoji: "\u{1F7E2}" },
      { value: "5", color: "#26c6da", emoji: "\u{1F535}" },
      { value: "6", color: "#42a5f5", emoji: "\u{1F535}" },
      { value: "7", color: "#ab47bc", emoji: "\u{1F7E3}" }
    ];
    availableColors.forEach((colorOption) => {
      const colorCard = colorGrid.createDiv("color-filter-card");
      const isSelected = this.plugin.settings.colorFilterColors.includes(colorOption.value);
      const category = this.plugin.settings.colorCategories.find((cat) => cat.color === colorOption.value);
      const displayName = category ? category.name : this.getDefaultColorName(colorOption.value);
      const description = category ? category.description : "";
      colorCard.style.cssText = `
				display: flex;
				flex-direction: column;
				align-items: center;
				padding: 16px 12px;
				border: 2px solid ${isSelected ? colorOption.color : "var(--background-modifier-border)"};
				border-radius: 8px;
				cursor: pointer;
				transition: all 0.2s ease;
				background: ${isSelected ? colorOption.color + "10" : "var(--background-secondary)"};
				position: relative;
				min-height: 120px;
			`;
      const colorPreview = colorCard.createDiv("color-preview-large");
      colorPreview.style.cssText = `
				width: 36px;
				height: 36px;
				border-radius: 50%;
				background: ${colorOption.color};
				margin-bottom: 12px;
				box-shadow: 0 2px 8px ${colorOption.color}40;
				border: 2px solid white;
			`;
      const colorName = colorCard.createEl("div", {
        text: displayName,
        cls: "color-card-name"
      });
      colorName.style.cssText = `
				font-size: 13px;
				font-weight: 600;
				color: var(--text-normal);
				text-align: center;
				margin-bottom: 4px;
			`;
      if (description) {
        const colorDesc = colorCard.createEl("div", {
          text: description,
          cls: "color-card-desc"
        });
        colorDesc.style.cssText = `
					font-size: 11px;
					color: var(--text-muted);
					text-align: center;
					line-height: 1.3;
					margin-bottom: 8px;
				`;
      }
      if (isSelected) {
        const checkmark = colorCard.createDiv("color-card-checkmark");
        checkmark.innerHTML = "\u2713";
        checkmark.style.cssText = `
					position: absolute;
					top: 6px;
					right: 6px;
					width: 18px;
					height: 18px;
					background: ${colorOption.color};
					color: white;
					border-radius: 50%;
					display: flex;
					align-items: center;
					justify-content: center;
					font-size: 11px;
					font-weight: bold;
					box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
				`;
      }
      colorCard.addEventListener("click", async () => {
        const currentColors = [...this.plugin.settings.colorFilterColors];
        const isCurrentlySelected = currentColors.includes(colorOption.value);
        if (isCurrentlySelected) {
          const index = currentColors.indexOf(colorOption.value);
          if (index > -1) {
            currentColors.splice(index, 1);
          }
        } else {
          if (currentColors.length < 5) {
            currentColors.push(colorOption.value);
          } else {
            new import_obsidian.Notice(this.plugin.settings.language === "zh" ? "\u6700\u591A\u53EA\u80FD\u9009\u62E95\u4E2A\u989C\u8272" : "Maximum 5 colors can be selected");
            return;
          }
        }
        this.plugin.settings.colorFilterColors = currentColors;
        await this.plugin.saveSettings();
        this.updateAllGridViews();
        this.display();
      });
      colorCard.addEventListener("mouseenter", () => {
        if (!isSelected) {
          colorCard.style.borderColor = colorOption.color;
          colorCard.style.background = colorOption.color + "08";
          colorCard.style.transform = "translateY(-2px)";
        }
      });
      colorCard.addEventListener("mouseleave", () => {
        if (!isSelected) {
          colorCard.style.borderColor = "var(--background-modifier-border)";
          colorCard.style.background = "var(--background-secondary)";
          colorCard.style.transform = "translateY(0)";
        }
      });
    });
  }
  // 创建可排序的颜色预览
  createSortableColorPreview(container) {
    const statusContainer = container.createDiv("color-filter-status");
    statusContainer.style.cssText = `
			background: var(--background-secondary);
			border-radius: 6px;
			margin-bottom: 20px;
			padding: 16px;
		`;
    const statusHeader = statusContainer.createDiv("status-header");
    statusHeader.style.cssText = `
			display: flex;
			align-items: center;
			justify-content: space-between;
			margin-bottom: 12px;
		`;
    const statusText = statusHeader.createEl("span", {
      text: this.plugin.settings.language === "zh" ? `\u5DF2\u9009\u62E9 ${this.plugin.settings.colorFilterColors.length}/5 \u4E2A\u989C\u8272` : `Selected ${this.plugin.settings.colorFilterColors.length}/5 colors`,
      cls: "color-filter-status-text"
    });
    statusText.style.cssText = `
			color: var(--text-muted);
			font-size: 13px;
		`;
    const sortHint = statusHeader.createEl("span", {
      text: this.plugin.settings.language === "zh" ? "\u62D6\u62FD\u8C03\u6574\u987A\u5E8F" : "Drag to reorder",
      cls: "sort-hint"
    });
    sortHint.style.cssText = `
			color: var(--text-muted);
			font-size: 11px;
			font-style: italic;
		`;
    const sortableContainer = statusContainer.createDiv("sortable-color-container");
    sortableContainer.style.cssText = `
			display: flex;
			gap: 8px;
			flex-wrap: wrap;
			min-height: 40px;
			padding: 8px;
			border: 1px dashed var(--background-modifier-border);
			border-radius: 4px;
			background: var(--background-primary);
		`;
    this.renderSortableColorDots(sortableContainer);
  }
  // 获取默认颜色名称
  getDefaultColorName(colorValue) {
    const colorNames = {
      "1": this.plugin.settings.language === "zh" ? "\u7EA2\u8272" : "Red",
      "2": this.plugin.settings.language === "zh" ? "\u6A59\u8272" : "Orange",
      "3": this.plugin.settings.language === "zh" ? "\u9EC4\u8272" : "Yellow",
      "4": this.plugin.settings.language === "zh" ? "\u7EFF\u8272" : "Green",
      "5": this.plugin.settings.language === "zh" ? "\u9752\u8272" : "Cyan",
      "6": this.plugin.settings.language === "zh" ? "\u84DD\u8272" : "Blue",
      "7": this.plugin.settings.language === "zh" ? "\u7D2B\u8272" : "Purple"
    };
    return colorNames[colorValue] || colorValue;
  }
  // 创建颜色分类列表
  createColorCategoryList(containerEl) {
    const categoryContainer = containerEl.createDiv("color-category-list");
    categoryContainer.style.cssText = `
			background: var(--background-primary);
			border: 1px solid var(--background-modifier-border);
			border-radius: 8px;
			padding: 20px;
			margin-bottom: 16px;
		`;
    const listTitle = categoryContainer.createEl("h4", {
      text: this.plugin.settings.language === "zh" ? "\u989C\u8272\u5206\u7C7B\u914D\u7F6E" : "Color Category Configuration",
      cls: "color-category-title"
    });
    listTitle.style.cssText = `
			margin: 0 0 16px 0;
			color: var(--text-normal);
			font-size: 14px;
			font-weight: 600;
		`;
    this.plugin.settings.colorCategories.forEach((category, index) => {
      this.createColorCategoryItem(categoryContainer, category, index);
    });
  }
  // 创建单个颜色分类项
  createColorCategoryItem(container, category, index) {
    const itemContainer = container.createDiv("color-category-item");
    itemContainer.style.cssText = `
			display: flex;
			align-items: center;
			gap: 12px;
			padding: 12px;
			border: 1px solid var(--background-modifier-border);
			border-radius: 6px;
			margin-bottom: 8px;
			background: var(--background-secondary);
		`;
    const colorDot = itemContainer.createDiv("color-category-dot");
    colorDot.style.cssText = `
			width: 24px;
			height: 24px;
			border-radius: 50%;
			background: ${this.getColorValue(category.color)};
			border: 2px solid var(--background-modifier-border);
			flex-shrink: 0;
		`;
    const infoContainer = itemContainer.createDiv("color-category-info");
    infoContainer.style.cssText = `
			flex: 1;
			min-width: 0;
		`;
    const nameEl = infoContainer.createEl("div", {
      text: category.name,
      cls: "color-category-name"
    });
    nameEl.style.cssText = `
			font-weight: 600;
			color: var(--text-normal);
			margin-bottom: 4px;
		`;
    const descEl = infoContainer.createEl("div", {
      text: category.description,
      cls: "color-category-desc"
    });
    descEl.style.cssText = `
			font-size: 12px;
			color: var(--text-muted);
			line-height: 1.3;
		`;
    const editBtn = itemContainer.createEl("button", {
      text: this.plugin.settings.language === "zh" ? "\u7F16\u8F91" : "Edit",
      cls: "mod-cta"
    });
    editBtn.style.cssText = `
			padding: 4px 12px;
			font-size: 12px;
		`;
    editBtn.onclick = () => {
      this.openColorCategoryEditor(category, index);
    };
  }
  // 获取颜色值
  getColorValue(colorId) {
    const colorMap = {
      "1": "#ff6b6b",
      // 红色
      "2": "#ffa726",
      // 橙色
      "3": "#ffeb3b",
      // 黄色
      "4": "#66bb6a",
      // 绿色
      "5": "#26c6da",
      // 青色
      "6": "#42a5f5",
      // 蓝色
      "7": "#ab47bc"
      // 紫色
    };
    return colorMap[colorId] || "#999999";
  }
  // 打开颜色分类编辑器
  openColorCategoryEditor(category, index) {
    new ColorCategoryEditModal(this.app, this.plugin, category, index, () => {
      this.display();
    }).open();
  }
  // 渲染可排序的颜色圆点
  renderSortableColorDots(container) {
    container.empty();
    const colorMap = {
      "1": "#ff6b6b",
      "2": "#ffa726",
      "3": "#ffeb3b",
      "4": "#66bb6a",
      "5": "#26c6da",
      "6": "#42a5f5",
      "7": "#ab47bc"
    };
    const colorNames = {
      "1": this.plugin.settings.language === "zh" ? "\u7EA2\u8272" : "Red",
      "2": this.plugin.settings.language === "zh" ? "\u6A59\u8272" : "Orange",
      "3": this.plugin.settings.language === "zh" ? "\u9EC4\u8272" : "Yellow",
      "4": this.plugin.settings.language === "zh" ? "\u7EFF\u8272" : "Green",
      "5": this.plugin.settings.language === "zh" ? "\u9752\u8272" : "Cyan",
      "6": this.plugin.settings.language === "zh" ? "\u84DD\u8272" : "Blue",
      "7": this.plugin.settings.language === "zh" ? "\u7D2B\u8272" : "Purple"
    };
    this.plugin.settings.colorFilterColors.forEach((colorValue, index) => {
      const colorDot = container.createDiv("sortable-color-dot");
      colorDot.draggable = true;
      colorDot.dataset.colorValue = colorValue;
      colorDot.dataset.index = index.toString();
      colorDot.style.cssText = `
				width: 32px;
				height: 32px;
				border-radius: 50%;
				background: ${colorMap[colorValue]};
				border: 2px solid white;
				box-shadow: 0 2px 8px ${colorMap[colorValue]}40;
				cursor: grab;
				transition: all 0.2s ease;
				position: relative;
				display: flex;
				align-items: center;
				justify-content: center;
			`;
      colorDot.title = colorNames[colorValue] || colorValue;
      colorDot.addEventListener("dragstart", (e) => {
        colorDot.style.cursor = "grabbing";
        colorDot.style.opacity = "0.5";
        e.dataTransfer.setData("text/plain", index.toString());
        e.dataTransfer.effectAllowed = "move";
      });
      colorDot.addEventListener("dragend", () => {
        colorDot.style.cursor = "grab";
        colorDot.style.opacity = "1";
      });
      colorDot.addEventListener("dragover", (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = "move";
      });
      colorDot.addEventListener("drop", async (e) => {
        e.preventDefault();
        const draggedIndex = parseInt(e.dataTransfer.getData("text/plain"));
        const targetIndex = index;
        if (draggedIndex !== targetIndex) {
          const newColors = [...this.plugin.settings.colorFilterColors];
          const draggedColor = newColors.splice(draggedIndex, 1)[0];
          newColors.splice(targetIndex, 0, draggedColor);
          this.plugin.settings.colorFilterColors = newColors;
          await this.plugin.saveSettings();
          this.updateAllGridViews();
          this.renderSortableColorDots(container);
        }
      });
      colorDot.addEventListener("mouseenter", () => {
        colorDot.style.transform = "scale(1.1)";
      });
      colorDot.addEventListener("mouseleave", () => {
        colorDot.style.transform = "scale(1)";
      });
    });
    if (this.plugin.settings.colorFilterColors.length === 0) {
      const emptyHint = container.createDiv("empty-hint");
      emptyHint.textContent = this.plugin.settings.language === "zh" ? "\u8BF7\u5728\u4E0A\u65B9\u9009\u62E9\u989C\u8272" : "Please select colors above";
      emptyHint.style.cssText = `
				color: var(--text-muted);
				font-size: 12px;
				font-style: italic;
				text-align: center;
				padding: 8px;
			`;
    }
  }
  // 创建关于插件部分
  createAboutSection(containerEl) {
    const separator = containerEl.createEl("hr");
    separator.style.cssText = `
			border: none;
			border-top: 1px solid var(--background-modifier-border);
			margin: 32px 0 24px 0;
		`;
    const titleEl = containerEl.createEl("h2", {
      text: this.plugin.settings.language === "zh" ? "\u{1F3A8} \u5173\u4E8E Canvasgrid Transit" : "\u{1F3A8} About Canvasgrid Transit",
      cls: "plugin-intro-title"
    });
    titleEl.style.cssText = `
			color: var(--interactive-accent);
			margin-bottom: 8px;
			font-size: 24px;
			font-weight: 600;
		`;
    const versionEl = containerEl.createEl("div", {
      text: "v0.5.1",
      cls: "plugin-intro-version"
    });
    versionEl.style.cssText = `
			color: var(--text-muted);
			font-size: 12px;
			margin-bottom: 16px;
			font-weight: 500;
		`;
    const descEl = containerEl.createEl("p", {
      text: this.plugin.settings.language === "zh" ? "\u4E3A Obsidian Canvas \u63D0\u4F9B\u5F3A\u5927\u7684\u7F51\u683C\u5361\u7247\u89C6\u56FE\uFF0C\u96C6\u6210\u667A\u80FD\u641C\u7D22\u3001\u989C\u8272\u7B5B\u9009\u3001\u5206\u7EC4\u7BA1\u7406\u3001\u65F6\u95F4\u80F6\u56CA\u6536\u96C6\u3001\u5FEB\u901F\u4E66\u7B7E\u89E3\u6790\u7B49\u521B\u65B0\u529F\u80FD\uFF0C\u8BA9\u60A8\u7684\u77E5\u8BC6\u7BA1\u7406\u66F4\u52A0\u9AD8\u6548\u4FBF\u6377\u3002" : "Powerful grid card view for Obsidian Canvas with intelligent search, color filtering, group management, time capsule collection, fast bookmark parsing and other innovative features for efficient knowledge management.",
      cls: "plugin-intro-desc"
    });
    descEl.style.cssText = `
			color: var(--text-normal);
			font-size: 14px;
			line-height: 1.5;
			margin-bottom: 20px;
		`;
    const featuresContainer = containerEl.createDiv("plugin-intro-features");
    featuresContainer.style.cssText = `
			background: var(--background-secondary);
			border-radius: 8px;
			padding: 16px;
			margin-bottom: 24px;
			border: 1px solid var(--background-modifier-border);
		`;
    const featuresTitle = featuresContainer.createEl("h4", {
      text: "\u2728 " + i18n.t("mainFeatures"),
      cls: "plugin-intro-features-title"
    });
    featuresTitle.style.cssText = `
			color: var(--text-normal);
			margin-bottom: 12px;
			font-size: 14px;
			font-weight: 600;
		`;
    const featuresList = this.plugin.settings.language === "zh" ? [
      "\u{1F50D} \u667A\u80FD\u641C\u7D22 - \u652F\u6301\u5185\u5BB9\u3001\u6587\u4EF6\u540D\u3001URL\u5168\u6587\u641C\u7D22",
      "\u{1F3A8} \u989C\u8272\u7B5B\u9009 - \u53EF\u914D\u7F6E\u989C\u8272\u5206\u7C7B\u548C\u4E00\u952E\u7B5B\u9009",
      "\u{1F4F1} \u54CD\u5E94\u5F0F\u5E03\u5C40 - \u81EA\u9002\u5E94\u5C4F\u5E55\u5BBD\u5EA6\u7684\u7F51\u683C\u5E03\u5C40",
      "\u{1F5C2}\uFE0F \u5206\u7EC4\u7BA1\u7406 - Canvas\u5206\u7EC4\u7684\u5361\u7247\u5316\u663E\u793A\u548C\u7F16\u8F91",
      "\u23F0 \u65F6\u95F4\u80F6\u56CA - \u521B\u65B0\u7684\u5185\u5BB9\u6536\u96C6\u548C\u65F6\u95F4\u7BA1\u7406\u529F\u80FD",
      "\u{1F517} \u5FEB\u901F\u4E66\u7B7E - \u7F51\u9875\u94FE\u63A5\u7684\u77AC\u95F4\u89E3\u6790\u548C\u7F8E\u89C2\u5C55\u793A",
      "\u270F\uFE0F \u5B9E\u65F6\u7F16\u8F91 - \u76F4\u63A5\u5728\u7F51\u683C\u89C6\u56FE\u4E2D\u7F16\u8F91\u5361\u7247\u5185\u5BB9",
      "\u{1F3AF} \u7CBE\u51C6\u5B9A\u4F4D - \u4E00\u952E\u805A\u7126\u5230Canvas\u4E2D\u7684\u5177\u4F53\u8282\u70B9",
      "\u{1F504} \u53CC\u5411\u540C\u6B65 - \u4E0ECanvas\u767D\u677F\u7684\u5B9E\u65F6\u6570\u636E\u540C\u6B65",
      "\u{1F310} \u591A\u8BED\u8A00 - \u652F\u6301\u4E2D\u6587\u548C\u82F1\u6587\u754C\u9762\u5207\u6362"
    ] : [
      "\u{1F50D} Smart Search - Full-text search for content, filenames, and URLs",
      "\u{1F3A8} Color Filtering - Configurable color categories and one-click filtering",
      "\u{1F4F1} Responsive Layout - Grid layout that adapts to screen width",
      "\u{1F5C2}\uFE0F Group Management - Card-based display and editing of Canvas groups",
      "\u23F0 Time Capsule - Innovative content collection and time management",
      "\u{1F517} Fast Bookmarks - Instant parsing and beautiful display of web links",
      "\u270F\uFE0F Real-time Editing - Direct card content editing in grid view",
      "\u{1F3AF} Precise Navigation - One-click focus to specific Canvas nodes",
      "\u{1F504} Bidirectional Sync - Real-time data sync with Canvas whiteboard",
      "\u{1F310} Multi-language - Support for Chinese and English interface"
    ];
    featuresList.forEach((feature) => {
      const featureItem = featuresContainer.createEl("div", {
        text: feature,
        cls: "plugin-intro-feature-item"
      });
      featureItem.style.cssText = `
				color: var(--text-muted);
				font-size: 13px;
				margin-bottom: 6px;
				padding-left: 8px;
			`;
    });
    this.createSupportSection(containerEl);
  }
  // 创建感谢和支持部分
  createSupportSection(containerEl) {
    const thanksContainer = containerEl.createDiv("plugin-thanks-section");
    thanksContainer.style.cssText = `
			background: linear-gradient(135deg, var(--interactive-accent)20, var(--interactive-accent)10);
			border-radius: 12px;
			padding: 20px;
			margin-bottom: 20px;
			border: 1px solid var(--interactive-accent)40;
		`;
    const thanksTitle = thanksContainer.createEl("h4", {
      text: "\u{1F49D} " + i18n.t("thanks"),
      cls: "plugin-thanks-title"
    });
    thanksTitle.style.cssText = `
			color: var(--interactive-accent);
			margin-bottom: 12px;
			font-size: 16px;
			font-weight: 600;
		`;
    const thanksText = thanksContainer.createEl("p", {
      text: this.plugin.settings.language === "zh" ? "\u611F\u8C22\u60A8\u9009\u62E9 Canvasgrid Transit\uFF01\u8FD9\u4E2A\u63D2\u4EF6\u878D\u5408\u4E86\u521B\u65B0\u7684\u65F6\u95F4\u80F6\u56CA\u3001\u667A\u80FD\u4E66\u7B7E\u89E3\u6790\u3001\u5206\u7EC4\u7BA1\u7406\u7B49\u529F\u80FD\uFF0C\u81F4\u529B\u4E8E\u63D0\u5347\u60A8\u7684\u77E5\u8BC6\u7BA1\u7406\u4F53\u9A8C\u3002\u60A8\u7684\u6BCF\u4E00\u4E2A\u53CD\u9988\u90FD\u662F\u6211\u4EEC\u524D\u8FDB\u7684\u52A8\u529B\uFF01" : "Thank you for choosing Canvasgrid Transit! This plugin integrates innovative features like time capsule, intelligent bookmark parsing, and group management to enhance your knowledge management experience. Every feedback from you is our driving force!",
      cls: "plugin-thanks-text"
    });
    const specialThanks = thanksContainer.createEl("div", {
      cls: "plugin-special-thanks"
    });
    specialThanks.style.cssText = `
			margin-top: 16px;
			padding: 12px;
			background: var(--background-secondary);
			border-radius: 6px;
			border-left: 3px solid var(--interactive-accent);
		`;
    const obsidianThanks = specialThanks.createEl("p", {
      text: this.plugin.settings.language === "zh" ? "\u{1F64F} \u7279\u522B\u611F\u8C22 Obsidian \u56E2\u961F\u521B\u9020\u4E86\u5982\u6B64\u4F18\u79C0\u7684\u77E5\u8BC6\u7BA1\u7406\u5E73\u53F0\uFF0C\u4E3A\u6211\u4EEC\u7684\u521B\u65B0\u63D0\u4F9B\u4E86\u65E0\u9650\u53EF\u80FD\u3002" : "\u{1F64F} Special thanks to the Obsidian team for creating such an excellent knowledge management platform, providing infinite possibilities for our innovation.",
      cls: "plugin-obsidian-thanks"
    });
    obsidianThanks.style.cssText = `
			color: var(--text-muted);
			font-size: 12px;
			margin-bottom: 8px;
			font-style: italic;
		`;
    const designInspiration = specialThanks.createEl("p", {
      text: this.plugin.settings.language === "zh" ? "\u23F0 \u65F6\u95F4\u80F6\u56CA\u529F\u80FD\u7684\u8BBE\u8BA1\u7075\u611F\u6765\u6E90\u4E8E\u9524\u5B50\u79D1\u6280 Smartisan \u7684\u65F6\u95F4\u80F6\u56CA\uFF0C\u81F4\u656C\u7ECF\u5178\u7684\u521B\u65B0\u8BBE\u8BA1\u7406\u5FF5\u3002" : "\u23F0 The time capsule feature design is inspired by Smartisan's time capsule from Hammer Technology, paying tribute to classic innovative design concepts.",
      cls: "plugin-design-inspiration"
    });
    designInspiration.style.cssText = `
			color: var(--text-muted);
			font-size: 12px;
			margin: 0;
			font-style: italic;
		`;
    thanksText.style.cssText = `
			color: var(--text-normal);
			font-size: 14px;
			line-height: 1.5;
			margin-bottom: 16px;
		`;
    const supportButtons = thanksContainer.createDiv("plugin-support-buttons");
    supportButtons.style.cssText = `
			display: flex;
			gap: 12px;
			flex-wrap: wrap;
		`;
    const feedbackBtn = supportButtons.createEl("button", {
      text: "\u{1F4AC} " + i18n.t("feedback"),
      cls: "plugin-support-btn"
    });
    feedbackBtn.style.cssText = `
			background: var(--interactive-accent);
			color: white;
			border: none;
			padding: 8px 16px;
			border-radius: 6px;
			font-size: 13px;
			cursor: pointer;
			transition: all 0.2s ease;
			font-weight: 500;
		`;
    feedbackBtn.onmouseover = () => {
      feedbackBtn.style.background = "var(--interactive-accent-hover)";
      feedbackBtn.style.transform = "translateY(-1px)";
    };
    feedbackBtn.onmouseout = () => {
      feedbackBtn.style.background = "var(--interactive-accent)";
      feedbackBtn.style.transform = "translateY(0)";
    };
    feedbackBtn.onclick = () => {
      window.open("https://github.com/zhuzhige123/Canvasgrid-Transit", "_blank");
    };
    const contactBtn = supportButtons.createEl("button", {
      text: "\u{1F4E7} " + i18n.t("contact"),
      cls: "plugin-support-btn"
    });
    contactBtn.style.cssText = `
			background: var(--background-modifier-border);
			color: var(--text-normal);
			border: 1px solid var(--background-modifier-border);
			padding: 8px 16px;
			border-radius: 6px;
			font-size: 13px;
			cursor: pointer;
			transition: all 0.2s ease;
			font-weight: 500;
		`;
    contactBtn.onmouseover = () => {
      contactBtn.style.background = "var(--background-modifier-hover)";
      contactBtn.style.transform = "translateY(-1px)";
    };
    contactBtn.onmouseout = () => {
      contactBtn.style.background = "var(--background-modifier-border)";
      contactBtn.style.transform = "translateY(0)";
    };
    contactBtn.onclick = () => {
      window.open("mailto:tutaoyuan8@outlook.com", "_blank");
    };
    const coffeeBtn = supportButtons.createEl("button", {
      text: "\u2615 " + i18n.t("buyCoffee"),
      cls: "plugin-support-btn"
    });
    coffeeBtn.style.cssText = `
			background: linear-gradient(135deg, #ff6b6b, #ffa726);
			color: white;
			border: none;
			padding: 8px 16px;
			border-radius: 6px;
			font-size: 13px;
			cursor: pointer;
			transition: all 0.2s ease;
			font-weight: 500;
		`;
    coffeeBtn.onmouseover = () => {
      coffeeBtn.style.transform = "translateY(-1px) scale(1.05)";
      coffeeBtn.style.boxShadow = "0 4px 12px rgba(255, 107, 107, 0.3)";
    };
    coffeeBtn.onmouseout = () => {
      coffeeBtn.style.transform = "translateY(0) scale(1)";
      coffeeBtn.style.boxShadow = "none";
    };
    coffeeBtn.onclick = () => {
      window.open("https://buymeacoffee.com/canvasgrid", "_blank");
    };
    const alipayBtn = supportButtons.createEl("button", {
      text: "\u{1F499} " + i18n.t("alipaySupport"),
      cls: "plugin-support-btn"
    });
    alipayBtn.style.cssText = `
			background: linear-gradient(135deg, #1677ff, #00a6fb);
			color: white;
			border: none;
			padding: 8px 16px;
			border-radius: 6px;
			font-size: 13px;
			cursor: pointer;
			transition: all 0.2s ease;
			font-weight: 500;
		`;
    alipayBtn.onmouseover = () => {
      alipayBtn.style.transform = "translateY(-1px) scale(1.05)";
      alipayBtn.style.boxShadow = "0 4px 12px rgba(22, 119, 255, 0.3)";
    };
    alipayBtn.onmouseout = () => {
      alipayBtn.style.transform = "translateY(0) scale(1)";
      alipayBtn.style.boxShadow = "none";
    };
    alipayBtn.onclick = () => {
      window.open("https://github.com/zhuzhige123/Canvasgrid-Transit/blob/main/SUPPORT.md#-\u652F\u4ED8\u5B9D", "_blank");
    };
    const sponsorBtn = supportButtons.createEl("button", {
      text: "\u2B50 " + i18n.t("githubSponsor"),
      cls: "plugin-support-btn"
    });
    sponsorBtn.style.cssText = `
			background: linear-gradient(135deg, #6366f1, #8b5cf6);
			color: white;
			border: none;
			padding: 8px 16px;
			border-radius: 6px;
			font-size: 13px;
			cursor: pointer;
			transition: all 0.2s ease;
			font-weight: 500;
		`;
    sponsorBtn.onmouseover = () => {
      sponsorBtn.style.transform = "translateY(-1px) scale(1.05)";
      sponsorBtn.style.boxShadow = "0 4px 12px rgba(99, 102, 241, 0.3)";
    };
    sponsorBtn.onmouseout = () => {
      sponsorBtn.style.transform = "translateY(0) scale(1)";
      sponsorBtn.style.boxShadow = "none";
    };
    sponsorBtn.onclick = () => {
      window.open("https://github.com/zhuzhige123/Canvasgrid-Transit", "_blank");
    };
    const projectInfo = containerEl.createDiv("plugin-project-info");
    projectInfo.style.cssText = `
			background: var(--background-secondary);
			border-radius: 8px;
			padding: 16px;
			margin-bottom: 20px;
			border: 1px solid var(--background-modifier-border);
		`;
    const projectTitle = projectInfo.createEl("h4", {
      text: "\u{1F517} " + i18n.t("projectLinks"),
      cls: "plugin-project-title"
    });
    projectTitle.style.cssText = `
			color: var(--text-normal);
			margin-bottom: 12px;
			font-size: 14px;
			font-weight: 600;
		`;
    const projectLinks = this.plugin.settings.language === "zh" ? [
      { text: "\u{1F4DA} \u4F7F\u7528\u6587\u6863", url: "https://github.com/zhuzhige123/Canvasgrid-Transit/blob/main/README.md" },
      { text: "\u{1F41B} \u95EE\u9898\u62A5\u544A", url: "https://github.com/zhuzhige123/Canvasgrid-Transit/issues" },
      { text: "\u2B50 GitHub \u4ED3\u5E93", url: "https://github.com/zhuzhige123/Canvasgrid-Transit" },
      { text: "\u{1F3A8} \u66F4\u65B0\u65E5\u5FD7", url: "https://github.com/zhuzhige123/Canvasgrid-Transit/releases" }
    ] : [
      { text: "\u{1F4DA} Documentation", url: "https://github.com/zhuzhige123/Canvasgrid-Transit/blob/main/README.md" },
      { text: "\u{1F41B} Bug Reports", url: "https://github.com/zhuzhige123/Canvasgrid-Transit/issues" },
      { text: "\u2B50 GitHub Repository", url: "https://github.com/zhuzhige123/Canvasgrid-Transit" },
      { text: "\u{1F3A8} Changelog", url: "https://github.com/zhuzhige123/Canvasgrid-Transit/releases" }
    ];
    projectLinks.forEach((link) => {
      const linkItem = projectInfo.createEl("div", {
        cls: "plugin-project-link"
      });
      linkItem.style.cssText = `
				display: flex;
				align-items: center;
				padding: 6px 0;
				cursor: pointer;
				transition: color 0.2s ease;
				color: var(--text-muted);
				font-size: 13px;
			`;
      linkItem.textContent = link.text;
      linkItem.onmouseover = () => {
        linkItem.style.color = "var(--interactive-accent)";
      };
      linkItem.onmouseout = () => {
        linkItem.style.color = "var(--text-muted)";
      };
      linkItem.onclick = () => {
        window.open(link.url, "_blank");
      };
    });
    const copyrightEl = containerEl.createEl("div", {
      text: this.plugin.settings.language === "zh" ? "\xA9 2025 Canvasgrid Transit v0.5.1 - \u7528 \u2764\uFE0F \u4E3A Obsidian \u77E5\u8BC6\u7BA1\u7406\u793E\u533A\u7CBE\u5FC3\u6253\u9020" : "\xA9 2025 Canvasgrid Transit v0.5.1 - Crafted with \u2764\uFE0F for Obsidian knowledge management community",
      cls: "plugin-copyright"
    });
    copyrightEl.style.cssText = `
			text-align: center;
			color: var(--text-muted);
			font-size: 12px;
			margin-top: 20px;
			padding-top: 16px;
			border-top: 1px solid var(--background-modifier-border);
		`;
  }
  // 更新所有网格视图的样式
  updateAllGridViews() {
    const gridLeaves = this.plugin.app.workspace.getLeavesOfType(CANVAS_GRID_VIEW_TYPE);
    gridLeaves.forEach((leaf) => {
      const view = leaf.view;
      if (view) {
        if (view.setupGridStyles) {
          view.setupGridStyles();
        }
        view.updateColorFilter();
      }
    });
  }
};
var ColorCategoryEditModal = class extends import_obsidian.Modal {
  constructor(app, plugin, category, index, onSave) {
    super(app);
    this.plugin = plugin;
    this.category = category;
    this.index = index;
    this.onSave = onSave;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", {
      text: this.plugin.settings.language === "zh" ? "\u7F16\u8F91\u989C\u8272\u5206\u7C7B" : "Edit Color Category",
      cls: "modal-title"
    });
    const formContainer = contentEl.createDiv("color-category-form");
    formContainer.style.cssText = `
			display: flex;
			flex-direction: column;
			gap: 16px;
			margin: 20px 0;
		`;
    const colorPreview = formContainer.createDiv("color-preview-container");
    colorPreview.style.cssText = `
			display: flex;
			align-items: center;
			gap: 12px;
			padding: 12px;
			background: var(--background-secondary);
			border-radius: 6px;
		`;
    const colorDot = colorPreview.createDiv("color-preview-dot");
    colorDot.style.cssText = `
			width: 32px;
			height: 32px;
			border-radius: 50%;
			background: ${this.getColorValue(this.category.color)};
			border: 2px solid var(--background-modifier-border);
			flex-shrink: 0;
		`;
    const colorInfo = colorPreview.createDiv("color-info");
    colorInfo.innerHTML = `
			<div style="font-weight: 600; color: var(--text-normal);">
				${this.plugin.settings.language === "zh" ? "\u989C\u8272" : "Color"}: ${this.getColorName(this.category.color)}
			</div>
			<div style="font-size: 12px; color: var(--text-muted);">
				${this.plugin.settings.language === "zh" ? "\u989C\u8272ID" : "Color ID"}: ${this.category.color}
			</div>
		`;
    const nameContainer = formContainer.createDiv("input-container");
    const nameLabel = nameContainer.createEl("label", {
      text: this.plugin.settings.language === "zh" ? "\u5206\u7C7B\u540D\u79F0:" : "Category Name:",
      cls: "setting-item-name"
    });
    nameLabel.style.cssText = `
			display: block;
			margin-bottom: 6px;
			font-weight: 600;
			color: var(--text-normal);
		`;
    this.nameInput = nameContainer.createEl("input", {
      type: "text",
      value: this.category.name,
      cls: "color-category-name-input"
    });
    this.nameInput.style.cssText = `
			width: 100%;
			padding: 8px 12px;
			border: 1px solid var(--background-modifier-border);
			border-radius: 4px;
			background: var(--background-primary);
			color: var(--text-normal);
			font-size: 14px;
		`;
    const descContainer = formContainer.createDiv("input-container");
    const descLabel = descContainer.createEl("label", {
      text: this.plugin.settings.language === "zh" ? "\u5206\u7C7B\u63CF\u8FF0:" : "Category Description:",
      cls: "setting-item-name"
    });
    descLabel.style.cssText = `
			display: block;
			margin-bottom: 6px;
			font-weight: 600;
			color: var(--text-normal);
		`;
    this.descInput = descContainer.createEl("textarea", {
      value: this.category.description,
      cls: "color-category-desc-input"
    });
    this.descInput.style.cssText = `
			width: 100%;
			min-height: 80px;
			padding: 8px 12px;
			border: 1px solid var(--background-modifier-border);
			border-radius: 4px;
			background: var(--background-primary);
			color: var(--text-normal);
			font-size: 14px;
			resize: vertical;
			font-family: inherit;
		`;
    const buttonContainer = contentEl.createDiv("modal-button-container");
    buttonContainer.style.cssText = `
			display: flex;
			justify-content: flex-end;
			gap: 12px;
			margin-top: 20px;
			padding-top: 16px;
			border-top: 1px solid var(--background-modifier-border);
		`;
    const cancelBtn = buttonContainer.createEl("button", {
      text: this.plugin.settings.language === "zh" ? "\u53D6\u6D88" : "Cancel",
      cls: "mod-cancel"
    });
    cancelBtn.onclick = () => this.close();
    const saveBtn = buttonContainer.createEl("button", {
      text: this.plugin.settings.language === "zh" ? "\u4FDD\u5B58" : "Save",
      cls: "mod-cta"
    });
    saveBtn.onclick = () => this.saveChanges();
    setTimeout(() => {
      this.nameInput.focus();
      this.nameInput.select();
    }, 100);
  }
  getColorValue(colorId) {
    const colorMap = {
      "1": "#ff6b6b",
      // 红色
      "2": "#ffa726",
      // 橙色
      "3": "#ffeb3b",
      // 黄色
      "4": "#66bb6a",
      // 绿色
      "5": "#26c6da",
      // 青色
      "6": "#42a5f5",
      // 蓝色
      "7": "#ab47bc"
      // 紫色
    };
    return colorMap[colorId] || "#999999";
  }
  getColorName(colorId) {
    const colorNames = {
      "1": this.plugin.settings.language === "zh" ? "\u7EA2\u8272" : "Red",
      "2": this.plugin.settings.language === "zh" ? "\u6A59\u8272" : "Orange",
      "3": this.plugin.settings.language === "zh" ? "\u9EC4\u8272" : "Yellow",
      "4": this.plugin.settings.language === "zh" ? "\u7EFF\u8272" : "Green",
      "5": this.plugin.settings.language === "zh" ? "\u9752\u8272" : "Cyan",
      "6": this.plugin.settings.language === "zh" ? "\u84DD\u8272" : "Blue",
      "7": this.plugin.settings.language === "zh" ? "\u7D2B\u8272" : "Purple"
    };
    return colorNames[colorId] || colorId;
  }
  saveChanges() {
    const newName = this.nameInput.value.trim();
    const newDesc = this.descInput.value.trim();
    if (!newName) {
      new import_obsidian.Notice(this.plugin.settings.language === "zh" ? "\u5206\u7C7B\u540D\u79F0\u4E0D\u80FD\u4E3A\u7A7A" : "Category name cannot be empty");
      this.nameInput.focus();
      return;
    }
    this.plugin.settings.colorCategories[this.index] = {
      ...this.category,
      name: newName,
      description: newDesc
    };
    this.plugin.saveSettings();
    new import_obsidian.Notice(this.plugin.settings.language === "zh" ? "\u989C\u8272\u5206\u7C7B\u5DF2\u66F4\u65B0" : "Color category updated");
    this.close();
    this.onSave();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
